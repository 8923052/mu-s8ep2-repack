; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	C:\muserver_dev\development\MU-S8EP2-Repack\GameServer\Source\QueueTimer.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?_EEM_DS@?$deque@HV?$allocator@H@std@@@std@@2HB	; std::deque<int,std::allocator<int> >::_EEM_DS
;	COMDAT ?_EEM_DS@?$deque@HV?$allocator@H@std@@@std@@2HB
CONST	SEGMENT
?_EEM_DS@?$deque@HV?$allocator@H@std@@@std@@2HB DD 04H	; std::deque<int,std::allocator<int> >::_EEM_DS
CONST	ENDS
PUBLIC	?RegCallBack@CQueueTimer@@QAEXP6GXPAXE@Z@Z	; CQueueTimer::RegCallBack
; Function compile flags: /Ogtp
; File c:\muserver_dev\development\mu-s8ep2-repack\gameserver\source\queuetimer.cpp
;	COMDAT ?RegCallBack@CQueueTimer@@QAEXP6GXPAXE@Z@Z
_TEXT	SEGMENT
_callback$ = 8						; size = 4
?RegCallBack@CQueueTimer@@QAEXP6GXPAXE@Z@Z PROC		; CQueueTimer::RegCallBack, COMDAT
; _this$ = ecx

; 17   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 18   : 	this->m_callback = callback;

  00003	8b 45 08	 mov	 eax, DWORD PTR _callback$[ebp]
  00006	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 19   : }

  00009	5d		 pop	 ebp
  0000a	c2 04 00	 ret	 4
?RegCallBack@CQueueTimer@@QAEXP6GXPAXE@Z@Z ENDP		; CQueueTimer::RegCallBack
_TEXT	ENDS
PUBLIC	?QueueTimerInit@CQueueTimer@@QAEXXZ		; CQueueTimer::QueueTimerInit
EXTRN	__imp__CreateTimerQueue@0:PROC
; Function compile flags: /Ogtp
;	COMDAT ?QueueTimerInit@CQueueTimer@@QAEXXZ
_TEXT	SEGMENT
?QueueTimerInit@CQueueTimer@@QAEXXZ PROC		; CQueueTimer::QueueTimerInit, COMDAT
; _this$ = ecx

; 33   : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 34   : 	this->m_timerqueue = CreateTimerQueue();

  00003	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateTimerQueue@0
  00009	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0000c	5e		 pop	 esi

; 35   : }

  0000d	c3		 ret	 0
?QueueTimerInit@CQueueTimer@@QAEXXZ ENDP		; CQueueTimer::QueueTimerInit
_TEXT	ENDS
PUBLIC	??2@YAPAXIPAX@Z					; operator new
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\new.h
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 81   :         {return (_Where); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]
  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
PUBLIC	?DeleteQueueTimer@CQueueTimer@@QAEXXZ		; CQueueTimer::DeleteQueueTimer
EXTRN	__imp__DeleteTimerQueue@4:PROC
; Function compile flags: /Ogtp
; File c:\muserver_dev\development\mu-s8ep2-repack\gameserver\source\queuetimer.cpp
;	COMDAT ?DeleteQueueTimer@CQueueTimer@@QAEXXZ
_TEXT	SEGMENT
?DeleteQueueTimer@CQueueTimer@@QAEXXZ PROC		; CQueueTimer::DeleteQueueTimer, COMDAT
; _this$ = ecx

; 70   : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 71   : 	DeleteTimerQueue(this->m_timerqueue);

  00003	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00006	50		 push	 eax
  00007	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteTimerQueue@4

; 72   : 	this->m_timerqueue = INVALID_HANDLE_VALUE;

  0000d	c7 46 08 ff ff
	ff ff		 mov	 DWORD PTR [esi+8], -1
  00014	5e		 pop	 esi

; 73   : }

  00015	c3		 ret	 0
?DeleteQueueTimer@CQueueTimer@@QAEXXZ ENDP		; CQueueTimer::DeleteQueueTimer
_TEXT	ENDS
PUBLIC	??3@YAXPAX0@Z					; operator delete
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\new.h
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 83   :         {return; }

  00000	c3		 ret	 0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
PUBLIC	?SyncLock@CQueueTimer@@QAEXXZ			; CQueueTimer::SyncLock
EXTRN	?Lock@TSync@@QAEXXZ:PROC			; TSync::Lock
; Function compile flags: /Ogtp
; File c:\muserver_dev\development\mu-s8ep2-repack\gameserver\source\queuetimer.cpp
;	COMDAT ?SyncLock@CQueueTimer@@QAEXXZ
_TEXT	SEGMENT
?SyncLock@CQueueTimer@@QAEXXZ PROC			; CQueueTimer::SyncLock, COMDAT
; _this$ = ecx

; 77   : 	this->m_sync.Lock();

  00000	83 c1 24	 add	 ecx, 36			; 00000024H
  00003	e9 00 00 00 00	 jmp	 ?Lock@TSync@@QAEXXZ	; TSync::Lock
?SyncLock@CQueueTimer@@QAEXXZ ENDP			; CQueueTimer::SyncLock
_TEXT	ENDS
PUBLIC	?SyncUnlock@CQueueTimer@@QAEXXZ			; CQueueTimer::SyncUnlock
EXTRN	?Unlock@TSync@@QAEXXZ:PROC			; TSync::Unlock
; Function compile flags: /Ogtp
;	COMDAT ?SyncUnlock@CQueueTimer@@QAEXXZ
_TEXT	SEGMENT
?SyncUnlock@CQueueTimer@@QAEXXZ PROC			; CQueueTimer::SyncUnlock, COMDAT
; _this$ = ecx

; 82   : 	this->m_sync.Unlock();

  00000	83 c1 24	 add	 ecx, 36			; 00000024H
  00003	e9 00 00 00 00	 jmp	 ?Unlock@TSync@@QAEXXZ	; TSync::Unlock
?SyncUnlock@CQueueTimer@@QAEXXZ ENDP			; CQueueTimer::SyncUnlock
_TEXT	ENDS
PUBLIC	?empty@?$deque@HV?$allocator@H@std@@@std@@QBE_NXZ ; std::deque<int,std::allocator<int> >::empty
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\deque
;	COMDAT ?empty@?$deque@HV?$allocator@H@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$deque@HV?$allocator@H@std@@@std@@QBE_NXZ PROC	; std::deque<int,std::allocator<int> >::empty, COMDAT
; _this$ = ecx

; 1160 : 		return (this->_Mysize == 0);

  00000	33 c0		 xor	 eax, eax
  00002	39 41 10	 cmp	 DWORD PTR [ecx+16], eax
  00005	0f 94 c0	 sete	 al

; 1161 : 		}

  00008	c3		 ret	 0
?empty@?$deque@HV?$allocator@H@std@@@std@@QBE_NXZ ENDP	; std::deque<int,std::allocator<int> >::empty
_TEXT	ENDS
PUBLIC	??0?$allocator@H@std@@QAE@XZ			; std::allocator<int>::allocator<int>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??0?$allocator@H@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@H@std@@QAE@XZ PROC			; std::allocator<int>::allocator<int>, COMDAT
; _this$ = ecx

; 161  : 	_ALLOCATOR() _THROW0()

  00000	8b c1		 mov	 eax, ecx

; 162  : 		{	// construct default allocator (do nothing)
; 163  : 		}

  00002	c3		 ret	 0
??0?$allocator@H@std@@QAE@XZ ENDP			; std::allocator<int>::allocator<int>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@H@std@@QAEXPAHI@Z	; std::allocator<int>::deallocate
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Ogtp
;	COMDAT ?deallocate@?$allocator@H@std@@QAEXPAHI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@H@std@@QAEXPAHI@Z PROC		; std::allocator<int>::deallocate, COMDAT
; _this$ = ecx

; 181  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 182  : 		::operator delete(_Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000c	83 c4 04	 add	 esp, 4

; 183  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 08 00	 ret	 8
?deallocate@?$allocator@H@std@@QAEXPAHI@Z ENDP		; std::allocator<int>::deallocate
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@PAH@std@@QAEXPAPAHI@Z	; std::allocator<int *>::deallocate
; Function compile flags: /Ogtp
;	COMDAT ?deallocate@?$allocator@PAH@std@@QAEXPAPAHI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAH@std@@QAEXPAPAHI@Z PROC	; std::allocator<int *>::deallocate, COMDAT
; _this$ = ecx

; 181  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 182  : 		::operator delete(_Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000c	83 c4 04	 add	 esp, 4

; 183  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 08 00	 ret	 8
?deallocate@?$allocator@PAH@std@@QAEXPAPAHI@Z ENDP	; std::allocator<int *>::deallocate
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::deallocate
; Function compile flags: /Ogtp
;	COMDAT ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z PROC ; std::allocator<std::_Container_proxy>::deallocate, COMDAT
; _this$ = ecx

; 181  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 182  : 		::operator delete(_Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000c	83 c4 04	 add	 esp, 4

; 183  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 08 00	 ret	 8
?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ENDP ; std::allocator<std::_Container_proxy>::deallocate
_TEXT	ENDS
PUBLIC	??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?_Xlen@?$deque@HV?$allocator@H@std@@@std@@IBEXXZ ; std::deque<int,std::allocator<int> >::_Xlen
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
;	COMDAT ??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long?$AA@
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\deque
CONST	SEGMENT
??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long?$AA@ DB 'deque<T> too long', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?_Xlen@?$deque@HV?$allocator@H@std@@@std@@IBEXXZ
_TEXT	SEGMENT
?_Xlen@?$deque@HV?$allocator@H@std@@@std@@IBEXXZ PROC	; std::deque<int,std::allocator<int> >::_Xlen, COMDAT
; _this$ = ecx

; 1580 : 		_Xlength_error("deque<T> too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long?$AA@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN4@Xlen:
$LN3@Xlen:
  0000a	cc		 int	 3
?_Xlen@?$deque@HV?$allocator@H@std@@@std@@IBEXXZ ENDP	; std::deque<int,std::allocator<int> >::_Xlen
_TEXT	ENDS
PUBLIC	??0?$allocator@H@std@@QAE@ABV01@@Z		; std::allocator<int>::allocator<int>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??0?$allocator@H@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@H@std@@QAE@ABV01@@Z PROC			; std::allocator<int>::allocator<int>, COMDAT
; _this$ = ecx

; 165  : 	_ALLOCATOR(const _ALLOCATOR<_Ty>&) _THROW0()

  00000	8b c1		 mov	 eax, ecx

; 166  : 		{	// construct by copying (do nothing)
; 167  : 		}

  00002	c2 04 00	 ret	 4
??0?$allocator@H@std@@QAE@ABV01@@Z ENDP			; std::allocator<int>::allocator<int>
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@H@std@@QBEIXZ		; std::allocator<int>::max_size
; Function compile flags: /Ogtp
;	COMDAT ?max_size@?$allocator@H@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@H@std@@QBEIXZ PROC		; std::allocator<int>::max_size, COMDAT
; _this$ = ecx

; 218  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 219  : 		return (0 < _Count ? _Count : 1);

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 220  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@H@std@@QBEIXZ ENDP		; std::allocator<int>::max_size
_TEXT	ENDS
PUBLIC	??Y?$_Deque_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z ; std::_Deque_iterator<int,std::allocator<int> >::operator+=
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\deque
;	COMDAT ??Y?$_Deque_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Deque_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z PROC ; std::_Deque_iterator<int,std::allocator<int> >::operator+=, COMDAT
; _this$ = ecx

; 654  : 		{	// increment by integer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx

; 655  : 		this->_Myoff += _Off;

  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Off$[ebp]
  00008	01 48 08	 add	 DWORD PTR [eax+8], ecx

; 656  : 		return (*this);
; 657  : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
??Y?$_Deque_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Deque_iterator<int,std::allocator<int> >::operator+=
_TEXT	ENDS
PUBLIC	??$?0H@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@H@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><int>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$?0H@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@H@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$?0H@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@H@1@@Z PROC ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><int>, COMDAT
; _this$ = ecx

; 170  : 		_ALLOCATOR(const _ALLOCATOR<_Other>&) _THROW0()

  00000	8b c1		 mov	 eax, ecx

; 171  : 		{	// construct from a related allocator (do nothing)
; 172  : 		}

  00002	c2 04 00	 ret	 4
??$?0H@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@H@1@@Z ENDP ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><int>
_TEXT	ENDS
PUBLIC	??$?0H@?$allocator@PAH@std@@QAE@ABV?$allocator@H@1@@Z ; std::allocator<int *>::allocator<int *><int>
; Function compile flags: /Ogtp
;	COMDAT ??$?0H@?$allocator@PAH@std@@QAE@ABV?$allocator@H@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$?0H@?$allocator@PAH@std@@QAE@ABV?$allocator@H@1@@Z PROC ; std::allocator<int *>::allocator<int *><int>, COMDAT
; _this$ = ecx

; 170  : 		_ALLOCATOR(const _ALLOCATOR<_Other>&) _THROW0()

  00000	8b c1		 mov	 eax, ecx

; 171  : 		{	// construct from a related allocator (do nothing)
; 172  : 		}

  00002	c2 04 00	 ret	 4
??$?0H@?$allocator@PAH@std@@QAE@ABV?$allocator@H@1@@Z ENDP ; std::allocator<int *>::allocator<int *><int>
_TEXT	ENDS
PUBLIC	??$forward@ABH@std@@YAABHABH@Z			; std::forward<int const &>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$forward@ABH@std@@YAABHABH@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABH@std@@YAABHABH@Z PROC			; std::forward<int const &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@ABH@std@@YAABHABH@Z ENDP			; std::forward<int const &>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@PAHPAH@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAH0@Z ; std::_Ptr_cat<int *,int *>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PAHPAH@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAH0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAHPAH@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAH0@Z PROC ; std::_Ptr_cat<int *,int *>, COMDAT

; 516  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 517  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::_Type _Cat;
; 518  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 519  : 	}

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??$_Ptr_cat@PAHPAH@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAH0@Z ENDP ; std::_Ptr_cat<int *,int *>
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAHPAH@std@@YAPAPAHPAPAH00AAV?$allocator@PAH@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<int *,int *>
EXTRN	_memmove:PROC
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\memory
;	COMDAT ??$_Uninit_copy@PAHPAH@std@@YAPAPAHPAPAH00AAV?$allocator@PAH@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
??$_Uninit_copy@PAHPAH@std@@YAPAPAHPAPAH00AAV?$allocator@PAH@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_copy<int *,int *>, COMDAT

; 399  : 	{	// copy [_First, _Last) to raw _Dest, scalar type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 400  : 	_DEBUG_RANGE(_First, _Last);
; 401  : 	_DEBUG_POINTER(_Dest);
; 402  : 	size_t _Count = (size_t)(_Last - _First);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00006	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00009	2b c1		 sub	 eax, ecx
  0000b	56		 push	 esi
  0000c	c1 f8 02	 sar	 eax, 2

; 403  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,
; 404  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  0000f	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]
  00016	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00019	56		 push	 esi
  0001a	51		 push	 ecx
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 _memmove
  00021	83 c4 0c	 add	 esp, 12			; 0000000cH
  00024	03 c6		 add	 eax, esi
  00026	5e		 pop	 esi

; 405  : 	}

  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??$_Uninit_copy@PAHPAH@std@@YAPAPAHPAPAH00AAV?$allocator@PAH@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<int *,int *>
_TEXT	ENDS
PUBLIC	??$_Val_type@PAPAH@std@@YAPAPAHPAPAH@Z		; std::_Val_type<int * *>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??$_Val_type@PAPAH@std@@YAPAPAHPAPAH@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAPAH@std@@YAPAPAHPAPAH@Z PROC		; std::_Val_type<int * *>, COMDAT

; 790  : 	return (0);

  00000	33 c0		 xor	 eax, eax

; 791  : 	}

  00002	c3		 ret	 0
??$_Val_type@PAPAH@std@@YAPAPAHPAPAH@Z ENDP		; std::_Val_type<int * *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAH@std@@@std@@YAXPAPAH0AAV?$allocator@PAH@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<int *> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAH@std@@@std@@YAXPAPAH0AAV?$allocator@PAH@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@PAH@std@@@std@@YAXPAPAH0AAV?$allocator@PAH@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<int *> >, COMDAT

; 105  : 	}

  00000	c3		 ret	 0
??$_Destroy_range@V?$allocator@PAH@std@@@std@@YAXPAPAH0AAV?$allocator@PAH@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<int *> >
_TEXT	ENDS
PUBLIC	??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ; std::forward<std::_Container_proxy>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z PROC ; std::forward<std::_Container_proxy>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ENDP ; std::forward<std::_Container_proxy>
_TEXT	ENDS
PUBLIC	??$_Construct@HABH@std@@YAXPAHABH@Z		; std::_Construct<int,int const &>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Construct@HABH@std@@YAXPAHABH@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@HABH@std@@YAXPAHABH@Z PROC		; std::_Construct<int,int const &>, COMDAT

; 46   : 	{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 	void _FARQ *_Vptr = _Ptr;
; 48   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 07		 je	 SHORT $LN3@Construct
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0000d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000f	89 10		 mov	 DWORD PTR [eax], edx
$LN3@Construct:

; 49   : 	}

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$_Construct@HABH@std@@YAXPAHABH@Z ENDP		; std::_Construct<int,int const &>
_TEXT	ENDS
PUBLIC	??$_Destroy@H@std@@YAXPAH@Z			; std::_Destroy<int>
; Function compile flags: /Ogtp
;	COMDAT ??$_Destroy@H@std@@YAXPAH@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@H@std@@YAXPAH@Z PROC			; std::_Destroy<int>, COMDAT

; 63   : 	_Ptr->~_Ty();
; 64   : 	}

  00000	c3		 ret	 0
??$_Destroy@H@std@@YAXPAH@Z ENDP			; std::_Destroy<int>
_TEXT	ENDS
PUBLIC	??$_Destroy@PAH@std@@YAXPAPAH@Z			; std::_Destroy<int *>
; Function compile flags: /Ogtp
;	COMDAT ??$_Destroy@PAH@std@@YAXPAPAH@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@PAH@std@@YAXPAPAH@Z PROC			; std::_Destroy<int *>, COMDAT

; 63   : 	_Ptr->~_Ty();
; 64   : 	}

  00000	c3		 ret	 0
??$_Destroy@PAH@std@@YAXPAPAH@Z ENDP			; std::_Destroy<int *>
_TEXT	ENDS
PUBLIC	??$_Destroy@U_Container_proxy@std@@@std@@YAXPAU_Container_proxy@0@@Z ; std::_Destroy<std::_Container_proxy>
; Function compile flags: /Ogtp
;	COMDAT ??$_Destroy@U_Container_proxy@std@@@std@@YAXPAU_Container_proxy@0@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@U_Container_proxy@std@@@std@@YAXPAU_Container_proxy@0@@Z PROC ; std::_Destroy<std::_Container_proxy>, COMDAT

; 63   : 	_Ptr->~_Ty();
; 64   : 	}

  00000	c3		 ret	 0
??$_Destroy@U_Container_proxy@std@@@std@@YAXPAU_Container_proxy@0@@Z ENDP ; std::_Destroy<std::_Container_proxy>
_TEXT	ENDS
PUBLIC	??$_Fill_n@PAPAHIPAH@std@@YAXPAPAHIABQAH@Z	; std::_Fill_n<int * *,unsigned int,int *>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??$_Fill_n@PAPAHIPAH@std@@YAXPAPAHIABQAH@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Fill_n@PAPAHIPAH@std@@YAXPAPAHIABQAH@Z PROC		; std::_Fill_n<int * *,unsigned int,int *>, COMDAT

; 2723 : 	{	// copy _Val _Count times through [_Dest, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2724 : 	for (; 0 < _Count; --_Count, ++_Dest)

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 12		 je	 SHORT $LN1@Fill_n
  0000a	8b 55 10	 mov	 edx, DWORD PTR __Val$[ebp]
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __Dest$[ebp]
  00010	56		 push	 esi
$LL3@Fill_n:

; 2725 : 		*_Dest = _Val;

  00011	8b 32		 mov	 esi, DWORD PTR [edx]
  00013	89 31		 mov	 DWORD PTR [ecx], esi
  00015	83 c1 04	 add	 ecx, 4
  00018	48		 dec	 eax
  00019	75 f6		 jne	 SHORT $LL3@Fill_n
  0001b	5e		 pop	 esi
$LN1@Fill_n:

; 2726 : 	}

  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??$_Fill_n@PAPAHIPAH@std@@YAXPAPAHIABQAH@Z ENDP		; std::_Fill_n<int * *,unsigned int,int *>
_TEXT	ENDS
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??0bad_alloc@std@@QAE@PBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
EXTRN	??0exception@std@@QAE@ABQBD@Z:PROC		; std::exception::exception
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R2exception@std@@8
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\exception
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@PBD@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0bad_alloc@std@@QAE@PBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 345  : 		{	// construct from message string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8d 45 08	 lea	 eax, DWORD PTR __Message$[ebp]
  00007	50		 push	 eax
  00008	8b f1		 mov	 esi, ecx
  0000a	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  0000f	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@

; 346  : 		}

  00015	8b c6		 mov	 eax, esi
  00017	5e		 pop	 esi
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@PBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
EXTRN	??1exception@std@@UAE@XZ:PROC			; std::exception::~exception
; Function compile flags: /Ogtp
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 354  : 		{	// destroy the object

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@

; 355  : 		}

  00006	e9 00 00 00 00	 jmp	 ??1exception@std@@UAE@XZ ; std::exception::~exception
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
  0000c	e8 00 00 00 00	 call	 ??1exception@std@@UAE@XZ ; std::exception::~exception
  00011	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00015	74 09		 je	 SHORT $LN6@scalar
  00017	56		 push	 esi
  00018	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0001d	83 c4 04	 add	 esp, 4
$LN6@scalar:
  00020	8b c6		 mov	 eax, esi
  00022	5e		 pop	 esi
  00023	5d		 pop	 ebp
  00024	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??0_Container_proxy@std@@QAE@XZ			; std::_Container_proxy::_Container_proxy
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??0_Container_proxy@std@@QAE@XZ
_TEXT	SEGMENT
??0_Container_proxy@std@@QAE@XZ PROC			; std::_Container_proxy::_Container_proxy, COMDAT
; _this$ = ecx

; 65   : 		{	// construct from pointers

  00000	8b c1		 mov	 eax, ecx
  00002	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00008	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 66   : 		}

  0000f	c3		 ret	 0
??0_Container_proxy@std@@QAE@XZ ENDP			; std::_Container_proxy::_Container_proxy
_TEXT	ENDS
PUBLIC	??0_Container_base12@std@@QAE@XZ		; std::_Container_base12::_Container_base12
; Function compile flags: /Ogtp
;	COMDAT ??0_Container_base12@std@@QAE@XZ
_TEXT	SEGMENT
??0_Container_base12@std@@QAE@XZ PROC			; std::_Container_base12::_Container_base12, COMDAT
; _this$ = ecx

; 77   : 		{	// construct childless container

  00000	8b c1		 mov	 eax, ecx
  00002	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 78   : 		}

  00008	c3		 ret	 0
??0_Container_base12@std@@QAE@XZ ENDP			; std::_Container_base12::_Container_base12
_TEXT	ENDS
PUBLIC	??0_Iterator_base12@std@@QAE@XZ			; std::_Iterator_base12::_Iterator_base12
; Function compile flags: /Ogtp
;	COMDAT ??0_Iterator_base12@std@@QAE@XZ
_TEXT	SEGMENT
??0_Iterator_base12@std@@QAE@XZ PROC			; std::_Iterator_base12::_Iterator_base12, COMDAT
; _this$ = ecx

; 111  : 		{	// construct orphaned iterator

  00000	8b c1		 mov	 eax, ecx
  00002	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00008	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 112  : 		}

  0000f	c3		 ret	 0
??0_Iterator_base12@std@@QAE@XZ ENDP			; std::_Iterator_base12::_Iterator_base12
_TEXT	ENDS
PUBLIC	??1_Iterator_base12@std@@QAE@XZ			; std::_Iterator_base12::~_Iterator_base12
; Function compile flags: /Ogtp
;	COMDAT ??1_Iterator_base12@std@@QAE@XZ
_TEXT	SEGMENT
??1_Iterator_base12@std@@QAE@XZ PROC			; std::_Iterator_base12::~_Iterator_base12, COMDAT
; _this$ = ecx

; 129  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 130  : 		_Lockit _Lock(_LOCK_DEBUG);
; 131  : 		_Orphan_me();
; 132  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 133  : 		}

  00000	c3		 ret	 0
??1_Iterator_base12@std@@QAE@XZ ENDP			; std::_Iterator_base12::~_Iterator_base12
_TEXT	ENDS
PUBLIC	?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt
; Function compile flags: /Ogtp
;	COMDAT ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z
_TEXT	SEGMENT
__Parent$ = 8						; size = 4
?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z PROC ; std::_Iterator_base12::_Adopt, COMDAT
; _this$ = ecx

; 136  : 		{	// adopt this iterator by parent

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 137  : 		if (_Parent != 0)

  00003	8b 45 08	 mov	 eax, DWORD PTR __Parent$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 04		 je	 SHORT $LN1@Adopt

; 138  : 			{	// have a parent, do adoption
; 139  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 140  : 
; 141  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 142  : 			if (_Myproxy != _Parent_proxy)
; 143  : 				{	// change parentage
; 144  : 				_Lockit _Lock(_LOCK_DEBUG);
; 145  : 				_Orphan_me();
; 146  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 147  : 				_Parent_proxy->_Myfirstiter = this;
; 148  : 				_Myproxy = _Parent_proxy;
; 149  : 				}
; 150  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 151  : 			_Myproxy = _Parent_proxy;

  0000a	8b 00		 mov	 eax, DWORD PTR [eax]
  0000c	89 01		 mov	 DWORD PTR [ecx], eax
$LN1@Adopt:

; 152  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 153  : 			}
; 154  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 04 00	 ret	 4
?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z ENDP ; std::_Iterator_base12::_Adopt
_TEXT	ENDS
PUBLIC	?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
; Function compile flags: /Ogtp
;	COMDAT ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ
_TEXT	SEGMENT
?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ PROC ; std::_Iterator_base12::_Getcont, COMDAT
; _this$ = ecx

; 163  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	85 c0		 test	 eax, eax
  00004	75 01		 jne	 SHORT $LN3@Getcont

; 164  : 		}

  00006	c3		 ret	 0
$LN3@Getcont:

; 163  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

  00007	8b 00		 mov	 eax, DWORD PTR [eax]

; 164  : 		}

  00009	c3		 ret	 0
?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ENDP ; std::_Iterator_base12::_Getcont
_TEXT	ENDS
PUBLIC	?_Orphan_all@_Container_base12@std@@QAEXXZ	; std::_Container_base12::_Orphan_all
; Function compile flags: /Ogtp
;	COMDAT ?_Orphan_all@_Container_base12@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@_Container_base12@std@@QAEXXZ PROC		; std::_Container_base12::_Orphan_all, COMDAT
; _this$ = ecx

; 195  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 196  : 	if (_Myproxy != 0)
; 197  : 		{	// proxy allocated, drain it
; 198  : 		_Lockit _Lock(_LOCK_DEBUG);
; 199  : 
; 200  : 		for (_Iterator_base12 **_Pnext = &_Myproxy->_Myfirstiter;
; 201  : 			*_Pnext != 0; *_Pnext = (*_Pnext)->_Mynextiter)
; 202  : 			(*_Pnext)->_Myproxy = 0;
; 203  : 		_Myproxy->_Myfirstiter = 0;
; 204  : 		}
; 205  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 206  : 	}

  00000	c3		 ret	 0
?_Orphan_all@_Container_base12@std@@QAEXXZ ENDP		; std::_Container_base12::_Orphan_all
_TEXT	ENDS
PUBLIC	?empty@?$stack@HV?$deque@HV?$allocator@H@std@@@std@@@std@@QBE_NXZ ; std::stack<int,std::deque<int,std::allocator<int> > >::empty
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\stack
;	COMDAT ?empty@?$stack@HV?$deque@HV?$allocator@H@std@@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$stack@HV?$deque@HV?$allocator@H@std@@@std@@@std@@QBE_NXZ PROC ; std::stack<int,std::deque<int,std::allocator<int> > >::empty, COMDAT
; _this$ = ecx

; 79   : 		return (c.empty());

  00000	33 c0		 xor	 eax, eax
  00002	39 41 10	 cmp	 DWORD PTR [ecx+16], eax
  00005	0f 94 c0	 sete	 al

; 80   : 		}

  00008	c3		 ret	 0
?empty@?$stack@HV?$deque@HV?$allocator@H@std@@@std@@@std@@QBE_NXZ ENDP ; std::stack<int,std::deque<int,std::allocator<int> > >::empty
_TEXT	ENDS
PUBLIC	??1?$_Deque_const_iterator@HV?$allocator@H@std@@@std@@QAE@XZ ; std::_Deque_const_iterator<int,std::allocator<int> >::~_Deque_const_iterator<int,std::allocator<int> >
; Function compile flags: /Ogtp
;	COMDAT ??1?$_Deque_const_iterator@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Deque_const_iterator@HV?$allocator@H@std@@@std@@QAE@XZ PROC ; std::_Deque_const_iterator<int,std::allocator<int> >::~_Deque_const_iterator<int,std::allocator<int> >, COMDAT
; _this$ = ecx
  00000	c3		 ret	 0
??1?$_Deque_const_iterator@HV?$allocator@H@std@@@std@@QAE@XZ ENDP ; std::_Deque_const_iterator<int,std::allocator<int> >::~_Deque_const_iterator<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	?max_size@?$deque@HV?$allocator@H@std@@@std@@QBEIXZ ; std::deque<int,std::allocator<int> >::max_size
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\deque
;	COMDAT ?max_size@?$deque@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$deque@HV?$allocator@H@std@@@std@@QBEIXZ PROC ; std::deque<int,std::allocator<int> >::max_size, COMDAT
; _this$ = ecx

; 1155 : 		return (this->_Alval.max_size());

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 1156 : 		}

  00005	c3		 ret	 0
?max_size@?$deque@HV?$allocator@H@std@@@std@@QBEIXZ ENDP ; std::deque<int,std::allocator<int> >::max_size
_TEXT	ENDS
PUBLIC	??Z?$_Deque_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z ; std::_Deque_iterator<int,std::allocator<int> >::operator-=
; Function compile flags: /Ogtp
;	COMDAT ??Z?$_Deque_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Z?$_Deque_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z PROC ; std::_Deque_iterator<int,std::allocator<int> >::operator-=, COMDAT
; _this$ = ecx

; 666  : 		{	// decrement by integer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx

; 667  : 		return (*this += -_Off);

  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Off$[ebp]
  00008	29 48 08	 sub	 DWORD PTR [eax+8], ecx

; 668  : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
??Z?$_Deque_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Deque_iterator<int,std::allocator<int> >::operator-=
_TEXT	ENDS
PUBLIC	??D?$_Deque_const_iterator@HV?$allocator@H@std@@@std@@QBEABHXZ ; std::_Deque_const_iterator<int,std::allocator<int> >::operator*
; Function compile flags: /Ogtp
;	COMDAT ??D?$_Deque_const_iterator@HV?$allocator@H@std@@@std@@QBEABHXZ
_TEXT	SEGMENT
??D?$_Deque_const_iterator@HV?$allocator@H@std@@@std@@QBEABHXZ PROC ; std::_Deque_const_iterator<int,std::allocator<int> >::operator*, COMDAT
; _this$ = ecx

; 331  : 		_Mydeque *_Mycont = ((_Mydeque *)this->_Getcont());

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	56		 push	 esi
  00003	85 c0		 test	 eax, eax
  00005	75 04		 jne	 SHORT $LN9@operator
  00007	33 f6		 xor	 esi, esi
  00009	eb 02		 jmp	 SHORT $LN10@operator
$LN9@operator:
  0000b	8b 30		 mov	 esi, DWORD PTR [eax]
$LN10@operator:

; 332  : 
; 333  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 334  : 		if (_Mycont == 0
; 335  : 			|| this->_Myoff < _Mycont->_Myoff
; 336  : 			|| _Mycont->_Myoff + _Mycont->_Mysize <= this->_Myoff)
; 337  : 		{	// report error
; 338  : 		_DEBUG_ERROR("deque iterator not dereferencable");
; 339  : 		_SCL_SECURE_OUT_OF_RANGE;
; 340  : 		}
; 341  : 
; 342  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 343  : 		_SCL_SECURE_VALIDATE(_Mycont != 0);
; 344  : 		_SCL_SECURE_VALIDATE_RANGE(_Mycont->_Myoff <= this->_Myoff
; 345  : 			&& this->_Myoff < _Mycont->_Myoff + _Mycont->_Mysize);
; 346  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 347  : 
; 348  : 		__analysis_assume(_Mycont != 0);
; 349  : 
; 350  : 		size_type _Block = _Myoff / _DEQUESIZ;

  0000d	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]

; 351  : 		size_type _Off = _Myoff & (_DEQUESIZ - 1);	// assume power of 2
; 352  : 
; 353  : 		if (_Mycont->_Mapsize <= _Block)

  00010	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00013	8b c8		 mov	 ecx, eax
  00015	c1 e9 02	 shr	 ecx, 2
  00018	83 e0 03	 and	 eax, 3
  0001b	3b d1		 cmp	 edx, ecx
  0001d	77 02		 ja	 SHORT $LN1@operator

; 354  : 			_Block -= _Mycont->_Mapsize;

  0001f	2b ca		 sub	 ecx, edx
$LN1@operator:

; 355  : 		return ((_Mycont->_Map)[_Block][_Off]);

  00021	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00024	8b 0c 8a	 mov	 ecx, DWORD PTR [edx+ecx*4]
  00027	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  0002a	5e		 pop	 esi

; 356  : 		}

  0002b	c3		 ret	 0
??D?$_Deque_const_iterator@HV?$allocator@H@std@@@std@@QBEABHXZ ENDP ; std::_Deque_const_iterator<int,std::allocator<int> >::operator*
_TEXT	ENDS
PUBLIC	?_Setcont@?$_Deque_const_iterator@HV?$allocator@H@std@@@std@@QAEXPBV?$deque@HV?$allocator@H@std@@@2@@Z ; std::_Deque_const_iterator<int,std::allocator<int> >::_Setcont
; Function compile flags: /Ogtp
;	COMDAT ?_Setcont@?$_Deque_const_iterator@HV?$allocator@H@std@@@std@@QAEXPBV?$deque@HV?$allocator@H@std@@@2@@Z
_TEXT	SEGMENT
__Pdeque$ = 8						; size = 4
?_Setcont@?$_Deque_const_iterator@HV?$allocator@H@std@@@std@@QAEXPBV?$deque@HV?$allocator@H@std@@@2@@Z PROC ; std::_Deque_const_iterator<int,std::allocator<int> >::_Setcont, COMDAT
; _this$ = ecx

; 541  : 		{	// set container pointer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 542  : 		this->_Adopt(_Pdeque);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pdeque$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 04		 je	 SHORT $LN3@Setcont
  0000a	8b 00		 mov	 eax, DWORD PTR [eax]
  0000c	89 01		 mov	 DWORD PTR [ecx], eax
$LN3@Setcont:

; 543  : 		}

  0000e	5d		 pop	 ebp
  0000f	c2 04 00	 ret	 4
?_Setcont@?$_Deque_const_iterator@HV?$allocator@H@std@@@std@@QAEXPBV?$deque@HV?$allocator@H@std@@@2@@Z ENDP ; std::_Deque_const_iterator<int,std::allocator<int> >::_Setcont
_TEXT	ENDS
PUBLIC	??$_Uninitialized_copy@PAPAHPAPAHV?$allocator@PAH@std@@@std@@YAPAPAHPAPAH00AAV?$allocator@PAH@0@@Z ; std::_Uninitialized_copy<int * *,int * *,std::allocator<int *> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\memory
;	COMDAT ??$_Uninitialized_copy@PAPAHPAPAHV?$allocator@PAH@std@@@std@@YAPAPAHPAPAH00AAV?$allocator@PAH@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_copy@PAPAHPAPAHV?$allocator@PAH@std@@@std@@YAPAPAHPAPAH00AAV?$allocator@PAH@0@@Z PROC ; std::_Uninitialized_copy<int * *,int * *,std::allocator<int *> >, COMDAT

; 412  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 413  : 	return (_Uninit_copy(_First, _Last, _Dest, _Al,
; 414  : 		_Ptr_cat(_First, _Dest)));

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00006	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00009	2b c1		 sub	 eax, ecx
  0000b	56		 push	 esi
  0000c	c1 f8 02	 sar	 eax, 2
  0000f	8d 34 85 00 00
	00 00		 lea	 esi, DWORD PTR [eax*4]
  00016	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00019	56		 push	 esi
  0001a	51		 push	 ecx
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 _memmove
  00021	83 c4 0c	 add	 esp, 12			; 0000000cH
  00024	03 c6		 add	 eax, esi
  00026	5e		 pop	 esi

; 415  : 	}

  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??$_Uninitialized_copy@PAPAHPAPAHV?$allocator@PAH@std@@@std@@YAPAPAHPAPAH00AAV?$allocator@PAH@0@@Z ENDP ; std::_Uninitialized_copy<int * *,int * *,std::allocator<int *> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAH@std@@@std@@YAXPAPAH0AAV?$allocator@PAH@0@@Z ; std::_Destroy_range<std::allocator<int *> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAH@std@@@std@@YAXPAPAH0AAV?$allocator@PAH@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAH@std@@@std@@YAXPAPAH0AAV?$allocator@PAH@0@@Z PROC ; std::_Destroy_range<std::allocator<int *> >, COMDAT

; 88   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 89   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@V?$allocator@PAH@std@@@std@@YAXPAPAH0AAV?$allocator@PAH@0@@Z ENDP ; std::_Destroy_range<std::allocator<int *> >
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??$_Allocate@H@std@@YAPAHIPAH@Z			; std::_Allocate<int>
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	__CxxThrowException@8:PROC
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\exception
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ??$_Allocate@H@std@@YAPAHIPAH@Z
_TEXT	SEGMENT
$T156251 = -12						; size = 12
$T156256 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@H@std@@YAPAHIPAH@Z PROC			; std::_Allocate<int>, COMDAT

; 30   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 31   : 	void *_Ptr = 0;
; 32   : 
; 33   : 	if (_Count <= 0)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00009	33 c0		 xor	 eax, eax
  0000b	85 c9		 test	 ecx, ecx

; 34   : 		_Count = 0;
; 35   : 	else if (((_SIZT)(-1) / sizeof (_Ty) < _Count)

  0000d	74 44		 je	 SHORT $LN5@Allocate

; 36   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000f	81 f9 ff ff ff
	3f		 cmp	 ecx, 1073741823		; 3fffffffH
  00015	77 14		 ja	 SHORT $LN1@Allocate
  00017	8d 04 8d 00 00
	00 00		 lea	 eax, DWORD PTR [ecx*4]
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00024	83 c4 04	 add	 esp, 4
  00027	85 c0		 test	 eax, eax

; 38   : 
; 39   : 	return ((_Ty _FARQ *)_Ptr);

  00029	75 28		 jne	 SHORT $LN5@Allocate
$LN1@Allocate:

; 37   : 		_THROW_NCEE(bad_alloc, 0);

  0002b	8d 4d 08	 lea	 ecx, DWORD PTR $T156256[ebp]
  0002e	51		 push	 ecx
  0002f	8d 4d f4	 lea	 ecx, DWORD PTR $T156251[ebp]
  00032	c7 45 08 00 00
	00 00		 mov	 DWORD PTR $T156256[ebp], 0
  00039	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  0003e	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00043	8d 55 f4	 lea	 edx, DWORD PTR $T156251[ebp]
  00046	52		 push	 edx
  00047	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T156251[ebp], OFFSET ??_7bad_alloc@std@@6B@
  0004e	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN10@Allocate:
$LN5@Allocate:

; 40   : 	}

  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c3		 ret	 0
$LN9@Allocate:
??$_Allocate@H@std@@YAPAHIPAH@Z ENDP			; std::_Allocate<int>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  00006	56		 push	 esi
  00007	50		 push	 eax
  00008	8b f1		 mov	 esi, ecx
  0000a	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  0000f	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
  00015	8b c6		 mov	 eax, esi
  00017	5e		 pop	 esi
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	??$_Allocate@PAH@std@@YAPAPAHIPAPAH@Z		; std::_Allocate<int *>
; Function compile flags: /Ogtp
;	COMDAT ??$_Allocate@PAH@std@@YAPAPAHIPAPAH@Z
_TEXT	SEGMENT
$T156264 = -12						; size = 12
$T156268 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAH@std@@YAPAPAHIPAPAH@Z PROC		; std::_Allocate<int *>, COMDAT

; 30   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 31   : 	void *_Ptr = 0;
; 32   : 
; 33   : 	if (_Count <= 0)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00009	33 c0		 xor	 eax, eax
  0000b	85 c9		 test	 ecx, ecx

; 34   : 		_Count = 0;
; 35   : 	else if (((_SIZT)(-1) / sizeof (_Ty) < _Count)

  0000d	74 44		 je	 SHORT $LN5@Allocate@2

; 36   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000f	81 f9 ff ff ff
	3f		 cmp	 ecx, 1073741823		; 3fffffffH
  00015	77 14		 ja	 SHORT $LN1@Allocate@2
  00017	8d 04 8d 00 00
	00 00		 lea	 eax, DWORD PTR [ecx*4]
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00024	83 c4 04	 add	 esp, 4
  00027	85 c0		 test	 eax, eax

; 38   : 
; 39   : 	return ((_Ty _FARQ *)_Ptr);

  00029	75 28		 jne	 SHORT $LN5@Allocate@2
$LN1@Allocate@2:

; 37   : 		_THROW_NCEE(bad_alloc, 0);

  0002b	8d 4d 08	 lea	 ecx, DWORD PTR $T156268[ebp]
  0002e	51		 push	 ecx
  0002f	8d 4d f4	 lea	 ecx, DWORD PTR $T156264[ebp]
  00032	c7 45 08 00 00
	00 00		 mov	 DWORD PTR $T156268[ebp], 0
  00039	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  0003e	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00043	8d 55 f4	 lea	 edx, DWORD PTR $T156264[ebp]
  00046	52		 push	 edx
  00047	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T156264[ebp], OFFSET ??_7bad_alloc@std@@6B@
  0004e	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN10@Allocate@2:
$LN5@Allocate@2:

; 40   : 	}

  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c3		 ret	 0
$LN9@Allocate@2:
??$_Allocate@PAH@std@@YAPAPAHIPAPAH@Z ENDP		; std::_Allocate<int *>
_TEXT	ENDS
PUBLIC	??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z ; std::_Allocate<std::_Container_proxy>
; Function compile flags: /Ogtp
;	COMDAT ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z
_TEXT	SEGMENT
$T156273 = -12						; size = 12
$T156277 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z PROC ; std::_Allocate<std::_Container_proxy>, COMDAT

; 30   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 31   : 	void *_Ptr = 0;
; 32   : 
; 33   : 	if (_Count <= 0)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00009	33 c0		 xor	 eax, eax
  0000b	85 c9		 test	 ecx, ecx

; 34   : 		_Count = 0;
; 35   : 	else if (((_SIZT)(-1) / sizeof (_Ty) < _Count)

  0000d	74 44		 je	 SHORT $LN5@Allocate@3

; 36   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000f	81 f9 ff ff ff
	1f		 cmp	 ecx, 536870911		; 1fffffffH
  00015	77 14		 ja	 SHORT $LN1@Allocate@3
  00017	8d 04 cd 00 00
	00 00		 lea	 eax, DWORD PTR [ecx*8]
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00024	83 c4 04	 add	 esp, 4
  00027	85 c0		 test	 eax, eax

; 38   : 
; 39   : 	return ((_Ty _FARQ *)_Ptr);

  00029	75 28		 jne	 SHORT $LN5@Allocate@3
$LN1@Allocate@3:

; 37   : 		_THROW_NCEE(bad_alloc, 0);

  0002b	8d 4d 08	 lea	 ecx, DWORD PTR $T156277[ebp]
  0002e	51		 push	 ecx
  0002f	8d 4d f4	 lea	 ecx, DWORD PTR $T156273[ebp]
  00032	c7 45 08 00 00
	00 00		 mov	 DWORD PTR $T156277[ebp], 0
  00039	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  0003e	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00043	8d 55 f4	 lea	 edx, DWORD PTR $T156273[ebp]
  00046	52		 push	 edx
  00047	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T156273[ebp], OFFSET ??_7bad_alloc@std@@6B@
  0004e	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN10@Allocate@3:
$LN5@Allocate@3:

; 40   : 	}

  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c3		 ret	 0
$LN9@Allocate@3:
??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z ENDP ; std::_Allocate<std::_Container_proxy>
_TEXT	ENDS
PUBLIC	?construct@?$allocator@H@std@@QAEXPAHABH@Z	; std::allocator<int>::construct
; Function compile flags: /Ogtp
;	COMDAT ?construct@?$allocator@H@std@@QAEXPAHABH@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@H@std@@QAEXPAHABH@Z PROC		; std::allocator<int>::construct, COMDAT
; _this$ = ecx

; 196  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 197  : 		_Construct(_Ptr, _Val);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 07		 je	 SHORT $LN5@construct
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0000d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000f	89 10		 mov	 DWORD PTR [eax], edx
$LN5@construct:

; 198  : 		}

  00011	5d		 pop	 ebp
  00012	c2 08 00	 ret	 8
?construct@?$allocator@H@std@@QAEXPAHABH@Z ENDP		; std::allocator<int>::construct
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@H@std@@QAEXPAH@Z		; std::allocator<int>::destroy
; Function compile flags: /Ogtp
;	COMDAT ?destroy@?$allocator@H@std@@QAEXPAH@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@H@std@@QAEXPAH@Z PROC		; std::allocator<int>::destroy, COMDAT
; _this$ = ecx

; 213  : 		_Destroy(_Ptr);
; 214  : 		}

  00000	c2 04 00	 ret	 4
?destroy@?$allocator@H@std@@QAEXPAH@Z ENDP		; std::allocator<int>::destroy
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@PAH@std@@QAEXPAPAH@Z	; std::allocator<int *>::destroy
; Function compile flags: /Ogtp
;	COMDAT ?destroy@?$allocator@PAH@std@@QAEXPAPAH@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@PAH@std@@QAEXPAPAH@Z PROC		; std::allocator<int *>::destroy, COMDAT
; _this$ = ecx

; 213  : 		_Destroy(_Ptr);
; 214  : 		}

  00000	c2 04 00	 ret	 4
?destroy@?$allocator@PAH@std@@QAEXPAPAH@Z ENDP		; std::allocator<int *>::destroy
_TEXT	ENDS
PUBLIC	?construct@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@$$QAU32@@Z ; std::allocator<std::_Container_proxy>::construct
; Function compile flags: /Ogtp
;	COMDAT ?construct@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@$$QAU32@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@$$QAU32@@Z PROC ; std::allocator<std::_Container_proxy>::construct, COMDAT
; _this$ = ecx

; 201  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 202  : 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Ty>(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 0d		 je	 SHORT $LN3@construct@2
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0000d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000f	89 10		 mov	 DWORD PTR [eax], edx
  00011	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00014	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN3@construct@2:

; 203  : 		}

  00017	5d		 pop	 ebp
  00018	c2 08 00	 ret	 8
?construct@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@$$QAU32@@Z ENDP ; std::allocator<std::_Container_proxy>::construct
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@@Z ; std::allocator<std::_Container_proxy>::destroy
; Function compile flags: /Ogtp
;	COMDAT ?destroy@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@@Z PROC ; std::allocator<std::_Container_proxy>::destroy, COMDAT
; _this$ = ecx

; 213  : 		_Destroy(_Ptr);
; 214  : 		}

  00000	c2 04 00	 ret	 4
?destroy@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@@Z ENDP ; std::allocator<std::_Container_proxy>::destroy
_TEXT	ENDS
PUBLIC	??$_Uninit_def_fill_n@PAHIPAHPAH@std@@YAXPAPAHIPBQAHAAV?$allocator@PAH@0@0U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_def_fill_n<int *,unsigned int,int *,int *>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\memory
;	COMDAT ??$_Uninit_def_fill_n@PAHIPAHPAH@std@@YAXPAPAHIPBQAHAAV?$allocator@PAH@0@0U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Uninit_def_fill_n@PAHIPAHPAH@std@@YAXPAPAHIPBQAHAAV?$allocator@PAH@0@0U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_def_fill_n<int *,unsigned int,int *,int *>, COMDAT

; 660  : 	{	// copy _Count * _Valty() to raw _First, using _Al, scalar type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 661  : 	_Fill_n(_First, _Count, (_Valty)0);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 09		 je	 SHORT $LN5@Uninit_def
  0000a	57		 push	 edi
  0000b	8b 7d 08	 mov	 edi, DWORD PTR __First$[ebp]
  0000e	33 c0		 xor	 eax, eax
  00010	f3 ab		 rep stosd
  00012	5f		 pop	 edi
$LN5@Uninit_def:

; 662  : 	}

  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
??$_Uninit_def_fill_n@PAHIPAHPAH@std@@YAXPAPAHIPBQAHAAV?$allocator@PAH@0@0U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_def_fill_n<int *,unsigned int,int *,int *>
_TEXT	ENDS
PUBLIC	??1_Container_base12@std@@QAE@XZ		; std::_Container_base12::~_Container_base12
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??1_Container_base12@std@@QAE@XZ
_TEXT	SEGMENT
??1_Container_base12@std@@QAE@XZ PROC			; std::_Container_base12::~_Container_base12, COMDAT
; _this$ = ecx

; 92   : 		_Orphan_all();
; 93   : 		}

  00000	c3		 ret	 0
??1_Container_base12@std@@QAE@XZ ENDP			; std::_Container_base12::~_Container_base12
_TEXT	ENDS
PUBLIC	??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z	; std::_Iterator_base12::operator=
; Function compile flags: /Ogtp
;	COMDAT ??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z PROC		; std::_Iterator_base12::operator=, COMDAT
; _this$ = ecx

; 121  : 		{	// assign an iterator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx

; 122  : 		if (_Myproxy != _Right._Myproxy)

  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00008	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0000a	39 08		 cmp	 DWORD PTR [eax], ecx
  0000c	74 0a		 je	 SHORT $LN4@operator@2

; 123  : 			_Adopt(_Right._Myproxy->_Mycont);

  0000e	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00010	85 c9		 test	 ecx, ecx
  00012	74 04		 je	 SHORT $LN4@operator@2
  00014	8b 11		 mov	 edx, DWORD PTR [ecx]
  00016	89 10		 mov	 DWORD PTR [eax], edx
$LN4@operator@2:

; 124  : 		return (*this);
; 125  : 		}

  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z ENDP		; std::_Iterator_base12::operator=
_TEXT	ENDS
PUBLIC	??1?$_Deque_iterator@HV?$allocator@H@std@@@std@@QAE@XZ ; std::_Deque_iterator<int,std::allocator<int> >::~_Deque_iterator<int,std::allocator<int> >
; Function compile flags: /Ogtp
;	COMDAT ??1?$_Deque_iterator@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Deque_iterator@HV?$allocator@H@std@@@std@@QAE@XZ PROC ; std::_Deque_iterator<int,std::allocator<int> >::~_Deque_iterator<int,std::allocator<int> >, COMDAT
; _this$ = ecx
  00000	c3		 ret	 0
??1?$_Deque_iterator@HV?$allocator@H@std@@@std@@QAE@XZ ENDP ; std::_Deque_iterator<int,std::allocator<int> >::~_Deque_iterator<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@H@std@@QAEPAHI@Z		; std::allocator<int>::allocate
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@H@std@@QAEPAHI@Z
_TEXT	SEGMENT
$T156382 = -12						; size = 12
$T156374 = 8						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@H@std@@QAEPAHI@Z PROC		; std::allocator<int>::allocate, COMDAT
; _this$ = ecx

; 186  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 187  : 		return (_Allocate(_Count, (pointer)0));

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00009	33 c0		 xor	 eax, eax
  0000b	85 c9		 test	 ecx, ecx
  0000d	74 44		 je	 SHORT $LN1@allocate
  0000f	81 f9 ff ff ff
	3f		 cmp	 ecx, 1073741823		; 3fffffffH
  00015	77 14		 ja	 SHORT $LN3@allocate
  00017	8d 04 8d 00 00
	00 00		 lea	 eax, DWORD PTR [ecx*4]
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00024	83 c4 04	 add	 esp, 4
  00027	85 c0		 test	 eax, eax
  00029	75 28		 jne	 SHORT $LN1@allocate
$LN3@allocate:
  0002b	8d 4d 08	 lea	 ecx, DWORD PTR $T156374[ebp]
  0002e	51		 push	 ecx
  0002f	8d 4d f4	 lea	 ecx, DWORD PTR $T156382[ebp]
  00032	c7 45 08 00 00
	00 00		 mov	 DWORD PTR $T156374[ebp], 0
  00039	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  0003e	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00043	8d 55 f4	 lea	 edx, DWORD PTR $T156382[ebp]
  00046	52		 push	 edx
  00047	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T156382[ebp], OFFSET ??_7bad_alloc@std@@6B@
  0004e	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN13@allocate:
$LN1@allocate:

; 188  : 		}

  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c2 04 00	 ret	 4
$LN12@allocate:
?allocate@?$allocator@H@std@@QAEPAHI@Z ENDP		; std::allocator<int>::allocate
_TEXT	ENDS
PUBLIC	??D?$_Deque_iterator@HV?$allocator@H@std@@@std@@QBEAAHXZ ; std::_Deque_iterator<int,std::allocator<int> >::operator*
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\deque
;	COMDAT ??D?$_Deque_iterator@HV?$allocator@H@std@@@std@@QBEAAHXZ
_TEXT	SEGMENT
??D?$_Deque_iterator@HV?$allocator@H@std@@@std@@QBEAAHXZ PROC ; std::_Deque_iterator<int,std::allocator<int> >::operator*, COMDAT
; _this$ = ecx

; 619  : 		return ((reference)**(_Mybase *)this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	56		 push	 esi
  00003	85 c0		 test	 eax, eax
  00005	75 04		 jne	 SHORT $LN11@operator@3
  00007	33 f6		 xor	 esi, esi
  00009	eb 02		 jmp	 SHORT $LN12@operator@3
$LN11@operator@3:
  0000b	8b 30		 mov	 esi, DWORD PTR [eax]
$LN12@operator@3:
  0000d	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00010	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00013	8b c8		 mov	 ecx, eax
  00015	c1 e9 02	 shr	 ecx, 2
  00018	83 e0 03	 and	 eax, 3
  0001b	3b d1		 cmp	 edx, ecx
  0001d	77 02		 ja	 SHORT $LN3@operator@3
  0001f	2b ca		 sub	 ecx, edx
$LN3@operator@3:
  00021	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00024	8b 0c 8a	 mov	 ecx, DWORD PTR [edx+ecx*4]
  00027	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  0002a	5e		 pop	 esi

; 620  : 		}

  0002b	c3		 ret	 0
??D?$_Deque_iterator@HV?$allocator@H@std@@@std@@QBEAAHXZ ENDP ; std::_Deque_iterator<int,std::allocator<int> >::operator*
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@PAH@std@@QAEPAPAHI@Z	; std::allocator<int *>::allocate
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@PAH@std@@QAEPAPAHI@Z
_TEXT	SEGMENT
$T156429 = -12						; size = 12
$T156421 = 8						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@PAH@std@@QAEPAPAHI@Z PROC		; std::allocator<int *>::allocate, COMDAT
; _this$ = ecx

; 186  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 187  : 		return (_Allocate(_Count, (pointer)0));

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00009	33 c0		 xor	 eax, eax
  0000b	85 c9		 test	 ecx, ecx
  0000d	74 44		 je	 SHORT $LN1@allocate@2
  0000f	81 f9 ff ff ff
	3f		 cmp	 ecx, 1073741823		; 3fffffffH
  00015	77 14		 ja	 SHORT $LN3@allocate@2
  00017	8d 04 8d 00 00
	00 00		 lea	 eax, DWORD PTR [ecx*4]
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00024	83 c4 04	 add	 esp, 4
  00027	85 c0		 test	 eax, eax
  00029	75 28		 jne	 SHORT $LN1@allocate@2
$LN3@allocate@2:
  0002b	8d 4d 08	 lea	 ecx, DWORD PTR $T156421[ebp]
  0002e	51		 push	 ecx
  0002f	8d 4d f4	 lea	 ecx, DWORD PTR $T156429[ebp]
  00032	c7 45 08 00 00
	00 00		 mov	 DWORD PTR $T156421[ebp], 0
  00039	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  0003e	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00043	8d 55 f4	 lea	 edx, DWORD PTR $T156429[ebp]
  00046	52		 push	 edx
  00047	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T156429[ebp], OFFSET ??_7bad_alloc@std@@6B@
  0004e	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN13@allocate@2:
$LN1@allocate@2:

; 188  : 		}

  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c2 04 00	 ret	 4
$LN12@allocate@2:
?allocate@?$allocator@PAH@std@@QAEPAPAHI@Z ENDP		; std::allocator<int *>::allocate
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate
; Function compile flags: /Ogtp
;	COMDAT ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z
_TEXT	SEGMENT
$T156452 = -12						; size = 12
$T156444 = 8						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z PROC ; std::allocator<std::_Container_proxy>::allocate, COMDAT
; _this$ = ecx

; 186  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 187  : 		return (_Allocate(_Count, (pointer)0));

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00009	33 c0		 xor	 eax, eax
  0000b	85 c9		 test	 ecx, ecx
  0000d	74 44		 je	 SHORT $LN1@allocate@3
  0000f	81 f9 ff ff ff
	1f		 cmp	 ecx, 536870911		; 1fffffffH
  00015	77 14		 ja	 SHORT $LN3@allocate@3
  00017	8d 04 cd 00 00
	00 00		 lea	 eax, DWORD PTR [ecx*8]
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00024	83 c4 04	 add	 esp, 4
  00027	85 c0		 test	 eax, eax
  00029	75 28		 jne	 SHORT $LN1@allocate@3
$LN3@allocate@3:
  0002b	8d 4d 08	 lea	 ecx, DWORD PTR $T156444[ebp]
  0002e	51		 push	 ecx
  0002f	8d 4d f4	 lea	 ecx, DWORD PTR $T156452[ebp]
  00032	c7 45 08 00 00
	00 00		 mov	 DWORD PTR $T156444[ebp], 0
  00039	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  0003e	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00043	8d 55 f4	 lea	 edx, DWORD PTR $T156452[ebp]
  00046	52		 push	 edx
  00047	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T156452[ebp], OFFSET ??_7bad_alloc@std@@6B@
  0004e	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN13@allocate@3:
$LN1@allocate@3:

; 188  : 		}

  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c2 04 00	 ret	 4
$LN12@allocate@3:
?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ENDP ; std::allocator<std::_Container_proxy>::allocate
_TEXT	ENDS
PUBLIC	??0?$_Deque_const_iterator@HV?$allocator@H@std@@@std@@QAE@IPBU_Container_base12@1@@Z ; std::_Deque_const_iterator<int,std::allocator<int> >::_Deque_const_iterator<int,std::allocator<int> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\deque
;	COMDAT ??0?$_Deque_const_iterator@HV?$allocator@H@std@@@std@@QAE@IPBU_Container_base12@1@@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
__Pdeque$ = 12						; size = 4
??0?$_Deque_const_iterator@HV?$allocator@H@std@@@std@@QAE@IPBU_Container_base12@1@@Z PROC ; std::_Deque_const_iterator<int,std::allocator<int> >::_Deque_const_iterator<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 310  : 	_Deque_const_iterator(size_type _Off, const _Container_base12 *_Pdeque)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx

; 311  : 		{	// construct with offset _Off in *_Pdeque
; 312  : 		_Setcont((_Mydeque *)_Pdeque);

  00005	8b 4d 0c	 mov	 ecx, DWORD PTR __Pdeque$[ebp]
  00008	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  0000e	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  00015	85 c9		 test	 ecx, ecx
  00017	74 0e		 je	 SHORT $LN10@Deque_cons
  00019	8b 09		 mov	 ecx, DWORD PTR [ecx]

; 313  : 		_Myoff = _Off;

  0001b	8b 55 08	 mov	 edx, DWORD PTR __Off$[ebp]
  0001e	89 08		 mov	 DWORD PTR [eax], ecx
  00020	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 314  : 		}

  00023	5d		 pop	 ebp
  00024	c2 08 00	 ret	 8
$LN10@Deque_cons:

; 313  : 		_Myoff = _Off;

  00027	8b 4d 08	 mov	 ecx, DWORD PTR __Off$[ebp]
  0002a	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 314  : 		}

  0002d	5d		 pop	 ebp
  0002e	c2 08 00	 ret	 8
??0?$_Deque_const_iterator@HV?$allocator@H@std@@@std@@QAE@IPBU_Container_base12@1@@Z ENDP ; std::_Deque_const_iterator<int,std::allocator<int> >::_Deque_const_iterator<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@H@std@@HABH@std@@YAXAAV?$allocator@H@0@PAHABH@Z ; std::_Cons_val<std::allocator<int>,int,int const &>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Cons_val@V?$allocator@H@std@@HABH@std@@YAXAAV?$allocator@H@0@PAHABH@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@H@std@@HABH@std@@YAXAAV?$allocator@H@0@PAHABH@Z PROC ; std::_Cons_val<std::allocator<int>,int,int const &>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Pdest$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 07		 je	 SHORT $LN9@Cons_val
  0000a	8b 4d 10	 mov	 ecx, DWORD PTR __Src$[ebp]
  0000d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000f	89 10		 mov	 DWORD PTR [eax], edx
$LN9@Cons_val:

; 281  : 	}

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$_Cons_val@V?$allocator@H@std@@HABH@std@@YAXAAV?$allocator@H@0@PAHABH@Z ENDP ; std::_Cons_val<std::allocator<int>,int,int const &>
_TEXT	ENDS
PUBLIC	??$_Dest_val@V?$allocator@H@std@@H@std@@YAXAAV?$allocator@H@0@PAH@Z ; std::_Dest_val<std::allocator<int>,int>
; Function compile flags: /Ogtp
;	COMDAT ??$_Dest_val@V?$allocator@H@std@@H@std@@YAXAAV?$allocator@H@0@PAH@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
??$_Dest_val@V?$allocator@H@std@@H@std@@YAXAAV?$allocator@H@0@PAH@Z PROC ; std::_Dest_val<std::allocator<int>,int>, COMDAT

; 287  : 	_Alval.destroy(_Pdest);
; 288  : 	}

  00000	c3		 ret	 0
??$_Dest_val@V?$allocator@H@std@@H@std@@YAXAAV?$allocator@H@0@PAH@Z ENDP ; std::_Dest_val<std::allocator<int>,int>
_TEXT	ENDS
PUBLIC	??$_Dest_val@V?$allocator@PAH@std@@PAH@std@@YAXAAV?$allocator@PAH@0@PAPAH@Z ; std::_Dest_val<std::allocator<int *>,int *>
; Function compile flags: /Ogtp
;	COMDAT ??$_Dest_val@V?$allocator@PAH@std@@PAH@std@@YAXAAV?$allocator@PAH@0@PAPAH@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
??$_Dest_val@V?$allocator@PAH@std@@PAH@std@@YAXAAV?$allocator@PAH@0@PAPAH@Z PROC ; std::_Dest_val<std::allocator<int *>,int *>, COMDAT

; 287  : 	_Alval.destroy(_Pdest);
; 288  : 	}

  00000	c3		 ret	 0
??$_Dest_val@V?$allocator@PAH@std@@PAH@std@@YAXAAV?$allocator@PAH@0@PAPAH@Z ENDP ; std::_Dest_val<std::allocator<int *>,int *>
_TEXT	ENDS
PUBLIC	??$_Dest_val@V?$allocator@U_Container_proxy@std@@@std@@U_Container_proxy@2@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@PAU_Container_proxy@0@@Z ; std::_Dest_val<std::allocator<std::_Container_proxy>,std::_Container_proxy>
; Function compile flags: /Ogtp
;	COMDAT ??$_Dest_val@V?$allocator@U_Container_proxy@std@@@std@@U_Container_proxy@2@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@PAU_Container_proxy@0@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
??$_Dest_val@V?$allocator@U_Container_proxy@std@@@std@@U_Container_proxy@2@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@PAU_Container_proxy@0@@Z PROC ; std::_Dest_val<std::allocator<std::_Container_proxy>,std::_Container_proxy>, COMDAT

; 287  : 	_Alval.destroy(_Pdest);
; 288  : 	}

  00000	c3		 ret	 0
??$_Dest_val@V?$allocator@U_Container_proxy@std@@@std@@U_Container_proxy@2@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@PAU_Container_proxy@0@@Z ENDP ; std::_Dest_val<std::allocator<std::_Container_proxy>,std::_Container_proxy>
_TEXT	ENDS
PUBLIC	??$_Uninitialized_default_fill_n@PAPAHIPAHV?$allocator@PAH@std@@@std@@YAXPAPAHIPBQAHAAV?$allocator@PAH@0@@Z ; std::_Uninitialized_default_fill_n<int * *,unsigned int,int *,std::allocator<int *> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\memory
;	COMDAT ??$_Uninitialized_default_fill_n@PAPAHIPAHV?$allocator@PAH@std@@@std@@YAXPAPAHIPBQAHAAV?$allocator@PAH@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Pval$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_default_fill_n@PAPAHIPAHV?$allocator@PAH@std@@@std@@YAXPAPAHIPBQAHAAV?$allocator@PAH@0@@Z PROC ; std::_Uninitialized_default_fill_n<int * *,unsigned int,int *,std::allocator<int *> >, COMDAT

; 670  : 	{	// copy _Count * _Val_type(_First)() to raw _First, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 671  : 	_Uninit_def_fill_n(_First, _Count, _Pval, _Al,
; 672  : 		_Val_type(_First), _Ptr_cat(_First, _First));

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 09		 je	 SHORT $LN11@Uninitiali
  0000a	57		 push	 edi
  0000b	8b 7d 08	 mov	 edi, DWORD PTR __First$[ebp]
  0000e	33 c0		 xor	 eax, eax
  00010	f3 ab		 rep stosd
  00012	5f		 pop	 edi
$LN11@Uninitiali:

; 673  : 	}

  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
??$_Uninitialized_default_fill_n@PAPAHIPAHV?$allocator@PAH@std@@@std@@YAXPAPAHIPBQAHAAV?$allocator@PAH@0@@Z ENDP ; std::_Uninitialized_default_fill_n<int * *,unsigned int,int *,std::allocator<int *> >
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@U_Container_proxy@std@@@std@@U_Container_proxy@2@U32@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@PAU_Container_proxy@0@$$QAU20@@Z ; std::_Cons_val<std::allocator<std::_Container_proxy>,std::_Container_proxy,std::_Container_proxy>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Cons_val@V?$allocator@U_Container_proxy@std@@@std@@U_Container_proxy@2@U32@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@PAU_Container_proxy@0@$$QAU20@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@U_Container_proxy@std@@@std@@U_Container_proxy@2@U32@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@PAU_Container_proxy@0@$$QAU20@@Z PROC ; std::_Cons_val<std::allocator<std::_Container_proxy>,std::_Container_proxy,std::_Container_proxy>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Pdest$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 0d		 je	 SHORT $LN7@Cons_val@2
  0000a	8b 4d 10	 mov	 ecx, DWORD PTR __Src$[ebp]
  0000d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000f	89 10		 mov	 DWORD PTR [eax], edx
  00011	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00014	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN7@Cons_val@2:

; 281  : 	}

  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
??$_Cons_val@V?$allocator@U_Container_proxy@std@@@std@@U_Container_proxy@2@U32@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@PAU_Container_proxy@0@$$QAU20@@Z ENDP ; std::_Cons_val<std::allocator<std::_Container_proxy>,std::_Container_proxy,std::_Container_proxy>
_TEXT	ENDS
PUBLIC	??0_Iterator_base12@std@@QAE@ABU01@@Z		; std::_Iterator_base12::_Iterator_base12
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??0_Iterator_base12@std@@QAE@ABU01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0_Iterator_base12@std@@QAE@ABU01@@Z PROC		; std::_Iterator_base12::_Iterator_base12, COMDAT
; _this$ = ecx

; 116  : 		{	// copy an iterator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx

; 117  : 		*this = _Right;

  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00008	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  0000e	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  00015	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00017	85 c9		 test	 ecx, ecx
  00019	74 0a		 je	 SHORT $LN6@Iterator_b
  0001b	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0001d	85 c9		 test	 ecx, ecx
  0001f	74 04		 je	 SHORT $LN6@Iterator_b
  00021	8b 11		 mov	 edx, DWORD PTR [ecx]
  00023	89 10		 mov	 DWORD PTR [eax], edx
$LN6@Iterator_b:

; 118  : 		}

  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
??0_Iterator_base12@std@@QAE@ABU01@@Z ENDP		; std::_Iterator_base12::_Iterator_base12
_TEXT	ENDS
PUBLIC	?pop_back@?$deque@HV?$allocator@H@std@@@std@@QAEXXZ ; std::deque<int,std::allocator<int> >::pop_back
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\deque
;	COMDAT ?pop_back@?$deque@HV?$allocator@H@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?pop_back@?$deque@HV?$allocator@H@std@@@std@@QAEXXZ PROC ; std::deque<int,std::allocator<int> >::pop_back, COMDAT
; _this$ = ecx

; 1273 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1274 : 		if (empty())
; 1275 : 			_DEBUG_ERROR("deque empty before pop");
; 1276 : 		else
; 1277 : 			{	// something to erase, do it
; 1278 : 			_Orphan_off(this->_Myoff + this->_Mysize - 1);
; 1279 : 			size_type _Newoff = this->_Mysize + this->_Myoff - 1;
; 1280 : 			size_type _Block = _Newoff / _DEQUESIZ;
; 1281 : 			if (this->_Mapsize <= _Block)
; 1282 : 				_Block -= this->_Mapsize;
; 1283 : 			_Dest_val(this->_Alval,
; 1284 : 				this->_Map[_Block] + _Newoff % _DEQUESIZ);
; 1285 : 			if (--this->_Mysize == 0)
; 1286 : 				this->_Myoff = 0;
; 1287 : 			}
; 1288 : 
; 1289 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1290 : 		if (!empty())

  00000	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00003	85 c0		 test	 eax, eax
  00005	74 0d		 je	 SHORT $LN1@pop_back

; 1291 : 			{	// something to erase, do it
; 1292 : 			size_type _Newoff = this->_Mysize + this->_Myoff - 1;
; 1293 : 			size_type _Block = _Newoff / _DEQUESIZ;
; 1294 : 			if (this->_Mapsize <= _Block)
; 1295 : 				_Block -= this->_Mapsize;
; 1296 : 			_Dest_val(this->_Alval,
; 1297 : 				this->_Map[_Block] + _Newoff % _DEQUESIZ);
; 1298 : 			if (--this->_Mysize == 0)

  00007	48		 dec	 eax
  00008	89 41 10	 mov	 DWORD PTR [ecx+16], eax
  0000b	75 07		 jne	 SHORT $LN1@pop_back

; 1299 : 				this->_Myoff = 0;

  0000d	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0
$LN1@pop_back:

; 1300 : 			}
; 1301 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1302 : 		}

  00014	c3		 ret	 0
?pop_back@?$deque@HV?$allocator@H@std@@@std@@QAEXXZ ENDP ; std::deque<int,std::allocator<int> >::pop_back
_TEXT	ENDS
PUBLIC	?_Tidy@?$deque@HV?$allocator@H@std@@@std@@IAEXXZ ; std::deque<int,std::allocator<int> >::_Tidy
; Function compile flags: /Ogtp
;	COMDAT ?_Tidy@?$deque@HV?$allocator@H@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$deque@HV?$allocator@H@std@@@std@@IAEXXZ PROC	; std::deque<int,std::allocator<int> >::_Tidy, COMDAT
; _this$ = ecx

; 1638 : 		{	// free all storage

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	8b f1		 mov	 esi, ecx

; 1639 : 		while (!empty())

  00004	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00007	33 db		 xor	 ebx, ebx
  00009	3b c3		 cmp	 eax, ebx
  0000b	74 15		 je	 SHORT $LN5@Tidy
  0000d	8d 49 00	 npad	 3
$LL6@Tidy:

; 1640 : 			pop_back();

  00010	3b c3		 cmp	 eax, ebx
  00012	74 09		 je	 SHORT $LN11@Tidy
  00014	48		 dec	 eax
  00015	89 46 10	 mov	 DWORD PTR [esi+16], eax
  00018	75 03		 jne	 SHORT $LN11@Tidy
  0001a	89 5e 0c	 mov	 DWORD PTR [esi+12], ebx
$LN11@Tidy:

; 1639 : 		while (!empty())

  0001d	39 5e 10	 cmp	 DWORD PTR [esi+16], ebx
  00020	75 ee		 jne	 SHORT $LL6@Tidy
$LN5@Tidy:
  00022	57		 push	 edi

; 1641 : 		for (size_type _Count = this->_Mapsize; 0 < _Count; )

  00023	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  00026	3b fb		 cmp	 edi, ebx
  00028	76 21		 jbe	 SHORT $LN3@Tidy
  0002a	8d 9b 00 00 00
	00		 npad	 6
$LL4@Tidy:
  00030	8b 46 04	 mov	 eax, DWORD PTR [esi+4]

; 1642 : 			{	// free storage for a block and destroy pointer
; 1643 : 			if (*(this->_Map + --_Count) != 0)

  00033	4f		 dec	 edi
  00034	39 1c b8	 cmp	 DWORD PTR [eax+edi*4], ebx
  00037	8d 04 b8	 lea	 eax, DWORD PTR [eax+edi*4]
  0003a	74 0b		 je	 SHORT $LN2@Tidy

; 1644 : 				{	// free block and destroy its pointer
; 1645 : 				this->_Alval.deallocate(*(this->_Map + _Count), _DEQUESIZ);

  0003c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003e	51		 push	 ecx
  0003f	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00044	83 c4 04	 add	 esp, 4
$LN2@Tidy:

; 1641 : 		for (size_type _Count = this->_Mapsize; 0 < _Count; )

  00047	3b fb		 cmp	 edi, ebx
  00049	77 e5		 ja	 SHORT $LL4@Tidy
$LN3@Tidy:

; 1646 : 				_Dest_val(this->_Almap, this->_Map + _Count);
; 1647 : 				}
; 1648 : 			}
; 1649 : 
; 1650 : 		if (this->_Map != 0)

  0004b	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0004e	5f		 pop	 edi
  0004f	3b c3		 cmp	 eax, ebx
  00051	74 09		 je	 SHORT $LN24@Tidy

; 1651 : 			this->_Almap.deallocate(this->_Map,
; 1652 : 				this->_Mapsize);	// free storage for map

  00053	50		 push	 eax
  00054	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00059	83 c4 04	 add	 esp, 4
$LN24@Tidy:

; 1653 : 		this->_Mapsize = 0;
; 1654 : 		this->_Map = 0;

  0005c	89 5e 04	 mov	 DWORD PTR [esi+4], ebx
  0005f	89 5e 08	 mov	 DWORD PTR [esi+8], ebx
  00062	5e		 pop	 esi
  00063	5b		 pop	 ebx

; 1655 : 		}

  00064	c3		 ret	 0
?_Tidy@?$deque@HV?$allocator@H@std@@@std@@IAEXXZ ENDP	; std::deque<int,std::allocator<int> >::_Tidy
_TEXT	ENDS
PUBLIC	??1?$_Deque_val@HV?$allocator@H@std@@@std@@QAE@XZ ; std::_Deque_val<int,std::allocator<int> >::~_Deque_val<int,std::allocator<int> >
; Function compile flags: /Ogtp
;	COMDAT ??1?$_Deque_val@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Deque_val@HV?$allocator@H@std@@@std@@QAE@XZ PROC	; std::_Deque_val<int,std::allocator<int> >::~_Deque_val<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 742  : 		{	// destroy proxy

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 743  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 744  : 			_Alproxy(_Alval);
; 745  : 		this->_Orphan_all();
; 746  : 		_Dest_val(_Alproxy, this->_Myproxy);
; 747  : 		_Alproxy.deallocate(this->_Myproxy, 1);

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	50		 push	 eax
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	83 c4 04	 add	 esp, 4

; 748  : 		this->_Myproxy = 0;

  0000e	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00014	5e		 pop	 esi

; 749  : 		}

  00015	c3		 ret	 0
??1?$_Deque_val@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::_Deque_val<int,std::allocator<int> >::~_Deque_val<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	?_Growmap@?$deque@HV?$allocator@H@std@@@std@@IAEXI@Z ; std::deque<int,std::allocator<int> >::_Growmap
; Function compile flags: /Ogtp
;	COMDAT ?_Growmap@?$deque@HV?$allocator@H@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
$T156712 = -24						; size = 12
tv519 = -12						; size = 4
tv512 = -12						; size = 4
__Myboff$ = -8						; size = 4
__Ptr$156716 = -4					; size = 4
$T156696 = 8						; size = 4
__Count$ = 8						; size = 4
?_Growmap@?$deque@HV?$allocator@H@std@@@std@@IAEXI@Z PROC ; std::deque<int,std::allocator<int> >::_Growmap, COMDAT
; _this$ = ecx

; 1589 : 		{	// grow map by _Count pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	53		 push	 ebx
  00007	8b d9		 mov	 ebx, ecx

; 1590 : 		if (max_size() / _DEQUESIZ - this->_Mapsize < _Count)

  00009	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  0000c	b8 ff ff ff 0f	 mov	 eax, 268435455		; 0fffffffH
  00011	57		 push	 edi
  00012	8b 7d 08	 mov	 edi, DWORD PTR __Count$[ebp]
  00015	2b c1		 sub	 eax, ecx
  00017	3b c7		 cmp	 eax, edi
  00019	73 0a		 jae	 SHORT $LN6@Growmap

; 1591 : 			_Xlen();	// result too long

  0001b	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long?$AA@
  00020	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN111@Growmap:
$LN6@Growmap:

; 1592 : 
; 1593 : 		size_type _Inc = this->_Mapsize / 2;	// try to grow by 50%

  00025	8b c1		 mov	 eax, ecx
  00027	d1 e8		 shr	 eax, 1

; 1594 : 		if (_Inc < _DEQUEMAPSIZ)

  00029	83 f8 08	 cmp	 eax, 8
  0002c	73 05		 jae	 SHORT $LN5@Growmap

; 1595 : 			_Inc = _DEQUEMAPSIZ;

  0002e	b8 08 00 00 00	 mov	 eax, 8
$LN5@Growmap:

; 1596 : 		if (_Count < _Inc && this->_Mapsize <= max_size() / _DEQUESIZ - _Inc)

  00033	3b f8		 cmp	 edi, eax
  00035	73 10		 jae	 SHORT $LN4@Growmap
  00037	ba ff ff ff 0f	 mov	 edx, 268435455		; 0fffffffH
  0003c	2b d0		 sub	 edx, eax
  0003e	3b ca		 cmp	 ecx, edx
  00040	77 05		 ja	 SHORT $LN4@Growmap

; 1597 : 			_Count = _Inc;

  00042	89 45 08	 mov	 DWORD PTR __Count$[ebp], eax
  00045	8b f8		 mov	 edi, eax
$LN4@Growmap:

; 1598 : 		size_type _Myboff = this->_Myoff / _DEQUESIZ;

  00047	56		 push	 esi
  00048	8b 73 0c	 mov	 esi, DWORD PTR [ebx+12]
  0004b	c1 ee 02	 shr	 esi, 2

; 1599 : 		_Mapptr _Newmap = this->_Almap.allocate(this->_Mapsize + _Count);

  0004e	8d 04 39	 lea	 eax, DWORD PTR [ecx+edi]
  00051	89 75 f8	 mov	 DWORD PTR __Myboff$[ebp], esi
  00054	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __Ptr$156716[ebp], 0
  0005b	85 c0		 test	 eax, eax
  0005d	74 23		 je	 SHORT $LN27@Growmap
  0005f	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  00064	0f 87 f6 00 00
	00		 ja	 $LN108@Growmap
  0006a	03 c0		 add	 eax, eax
  0006c	03 c0		 add	 eax, eax
  0006e	50		 push	 eax
  0006f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00074	83 c4 04	 add	 esp, 4
  00077	89 45 fc	 mov	 DWORD PTR __Ptr$156716[ebp], eax
  0007a	85 c0		 test	 eax, eax
  0007c	0f 84 de 00 00
	00		 je	 $LN108@Growmap
$LN27@Growmap:

; 1600 : 		_Mapptr _Myptr = _Newmap + _Myboff;
; 1601 : 
; 1602 : 		_Myptr = _Uninitialized_copy(this->_Map + _Myboff,
; 1603 : 			this->_Map + this->_Mapsize,
; 1604 : 			_Myptr, this->_Almap);	// copy initial to end

  00082	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  00085	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  00088	03 c0		 add	 eax, eax
  0008a	03 c0		 add	 eax, eax
  0008c	03 f6		 add	 esi, esi
  0008e	03 f6		 add	 esi, esi
  00090	8d 14 0e	 lea	 edx, DWORD PTR [esi+ecx]
  00093	2b c2		 sub	 eax, edx
  00095	03 c1		 add	 eax, ecx
  00097	8b 4d fc	 mov	 ecx, DWORD PTR __Ptr$156716[ebp]
  0009a	c1 f8 02	 sar	 eax, 2
  0009d	03 c0		 add	 eax, eax
  0009f	03 c0		 add	 eax, eax
  000a1	50		 push	 eax
  000a2	52		 push	 edx
  000a3	8d 14 0e	 lea	 edx, DWORD PTR [esi+ecx]
  000a6	52		 push	 edx
  000a7	89 45 f4	 mov	 DWORD PTR tv512[ebp], eax
  000aa	e8 00 00 00 00	 call	 _memmove
  000af	03 45 f4	 add	 eax, DWORD PTR tv512[ebp]

; 1605 : 		if (_Myboff <= _Count)
; 1606 : 			{	// increment greater than offset of initial block
; 1607 : 			_Myptr = _Uninitialized_copy(this->_Map,
; 1608 : 				this->_Map + _Myboff,
; 1609 : 				_Myptr, this->_Almap);	// copy rest of old

  000b2	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  000b5	83 c4 0c	 add	 esp, 12			; 0000000cH
  000b8	39 7d f8	 cmp	 DWORD PTR __Myboff$[ebp], edi
  000bb	77 3a		 ja	 SHORT $LN3@Growmap
  000bd	c1 fe 02	 sar	 esi, 2
  000c0	8b d6		 mov	 edx, esi
  000c2	03 d2		 add	 edx, edx
  000c4	03 d2		 add	 edx, edx
  000c6	52		 push	 edx
  000c7	51		 push	 ecx
  000c8	50		 push	 eax

; 1610 : 			_Uninitialized_default_fill_n(_Myptr, _Count - _Myboff,
; 1611 : 				(pointer *)0, this->_Almap);	// clear suffix of new

  000c9	8b f7		 mov	 esi, edi
  000cb	89 55 f4	 mov	 DWORD PTR tv519[ebp], edx
  000ce	e8 00 00 00 00	 call	 _memmove
  000d3	8b d0		 mov	 edx, eax
  000d5	03 55 f4	 add	 edx, DWORD PTR tv519[ebp]
  000d8	83 c4 0c	 add	 esp, 12			; 0000000cH
  000db	2b 75 f8	 sub	 esi, DWORD PTR __Myboff$[ebp]
  000de	74 0b		 je	 SHORT $LN57@Growmap

; 1605 : 		if (_Myboff <= _Count)
; 1606 : 			{	// increment greater than offset of initial block
; 1607 : 			_Myptr = _Uninitialized_copy(this->_Map,
; 1608 : 				this->_Map + _Myboff,
; 1609 : 				_Myptr, this->_Almap);	// copy rest of old

  000e0	8b ce		 mov	 ecx, esi
  000e2	33 c0		 xor	 eax, eax
  000e4	8b fa		 mov	 edi, edx
  000e6	f3 ab		 rep stosd
  000e8	8b 7d 08	 mov	 edi, DWORD PTR __Count$[ebp]

; 1610 : 			_Uninitialized_default_fill_n(_Myptr, _Count - _Myboff,
; 1611 : 				(pointer *)0, this->_Almap);	// clear suffix of new

$LN57@Growmap:

; 1612 : 			_Uninitialized_default_fill_n(_Newmap, _Myboff,
; 1613 : 				(pointer *)0, this->_Almap);	// clear prefix of new

  000eb	8b 4d f8	 mov	 ecx, DWORD PTR __Myboff$[ebp]
  000ee	85 c9		 test	 ecx, ecx
  000f0	74 4c		 je	 SHORT $LN106@Growmap
  000f2	8b 7d fc	 mov	 edi, DWORD PTR __Ptr$156716[ebp]

; 1614 : 			}
; 1615 : 		else

  000f5	eb 40		 jmp	 SHORT $LN110@Growmap
$LN3@Growmap:

; 1616 : 			{	// increment not greater than offset of initial block
; 1617 : 			_Uninitialized_copy(this->_Map,
; 1618 : 				this->_Map + _Count,
; 1619 : 				_Myptr, this->_Almap);	// copy more old

  000f7	8d 14 bd 00 00
	00 00		 lea	 edx, DWORD PTR [edi*4]
  000fe	c1 fa 02	 sar	 edx, 2
  00101	03 d2		 add	 edx, edx
  00103	03 d2		 add	 edx, edx
  00105	52		 push	 edx
  00106	51		 push	 ecx
  00107	50		 push	 eax
  00108	e8 00 00 00 00	 call	 _memmove

; 1620 : 			_Myptr = _Uninitialized_copy(this->_Map + _Count,
; 1621 : 				this->_Map + _Myboff,
; 1622 : 				_Newmap, this->_Almap);	// copy rest of old

  0010d	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  00110	8d 0c b8	 lea	 ecx, DWORD PTR [eax+edi*4]
  00113	2b f1		 sub	 esi, ecx
  00115	03 f0		 add	 esi, eax
  00117	8b 45 fc	 mov	 eax, DWORD PTR __Ptr$156716[ebp]
  0011a	c1 fe 02	 sar	 esi, 2
  0011d	03 f6		 add	 esi, esi
  0011f	03 f6		 add	 esi, esi
  00121	56		 push	 esi
  00122	51		 push	 ecx
  00123	50		 push	 eax
  00124	e8 00 00 00 00	 call	 _memmove
  00129	83 c4 18	 add	 esp, 24			; 00000018H
  0012c	8d 14 06	 lea	 edx, DWORD PTR [esi+eax]

; 1623 : 			_Uninitialized_default_fill_n(_Myptr, _Count,
; 1624 : 				(pointer *)0, this->_Almap);	// clear rest to initial block

  0012f	85 ff		 test	 edi, edi
  00131	74 0b		 je	 SHORT $LN106@Growmap

; 1616 : 			{	// increment not greater than offset of initial block
; 1617 : 			_Uninitialized_copy(this->_Map,
; 1618 : 				this->_Map + _Count,
; 1619 : 				_Myptr, this->_Almap);	// copy more old

  00133	8b cf		 mov	 ecx, edi
  00135	8b fa		 mov	 edi, edx
$LN110@Growmap:
  00137	33 c0		 xor	 eax, eax
  00139	f3 ab		 rep stosd
  0013b	8b 7d 08	 mov	 edi, DWORD PTR __Count$[ebp]
$LN106@Growmap:

; 1625 : 			}
; 1626 : 
; 1627 : 		_Destroy_range(this->_Map + _Myboff, this->_Map + this->_Mapsize,
; 1628 : 			this->_Almap);
; 1629 : 		if (this->_Map != 0)

  0013e	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  00141	5e		 pop	 esi
  00142	85 c0		 test	 eax, eax
  00144	74 09		 je	 SHORT $LN98@Growmap

; 1630 : 			this->_Almap.deallocate(this->_Map,
; 1631 : 				this->_Mapsize);	// free storage for old

  00146	50		 push	 eax
  00147	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0014c	83 c4 04	 add	 esp, 4
$LN98@Growmap:

; 1632 : 
; 1633 : 		this->_Map = _Newmap;	// point at new
; 1634 : 		this->_Mapsize += _Count;

  0014f	01 7b 08	 add	 DWORD PTR [ebx+8], edi
  00152	8b 4d fc	 mov	 ecx, DWORD PTR __Ptr$156716[ebp]
  00155	5f		 pop	 edi
  00156	89 4b 04	 mov	 DWORD PTR [ebx+4], ecx
  00159	5b		 pop	 ebx

; 1635 : 		}

  0015a	8b e5		 mov	 esp, ebp
  0015c	5d		 pop	 ebp
  0015d	c2 04 00	 ret	 4
$LN108@Growmap:

; 1599 : 		_Mapptr _Newmap = this->_Almap.allocate(this->_Mapsize + _Count);

  00160	8d 55 08	 lea	 edx, DWORD PTR $T156696[ebp]
  00163	52		 push	 edx
  00164	8d 4d e8	 lea	 ecx, DWORD PTR $T156712[ebp]
  00167	c7 45 08 00 00
	00 00		 mov	 DWORD PTR $T156696[ebp], 0
  0016e	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00173	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00178	8d 45 e8	 lea	 eax, DWORD PTR $T156712[ebp]
  0017b	50		 push	 eax
  0017c	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T156712[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00183	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN112@Growmap:
$LN109@Growmap:
  00188	cc		 int	 3
?_Growmap@?$deque@HV?$allocator@H@std@@@std@@IAEXI@Z ENDP ; std::deque<int,std::allocator<int> >::_Growmap
_TEXT	ENDS
PUBLIC	??0?$_Deque_val@HV?$allocator@H@std@@@std@@QAE@V?$allocator@H@1@@Z ; std::_Deque_val<int,std::allocator<int> >::_Deque_val<int,std::allocator<int> >
; Function compile flags: /Ogtp
;	COMDAT ??0?$_Deque_val@HV?$allocator@H@std@@@std@@QAE@V?$allocator@H@1@@Z
_TEXT	SEGMENT
$T156997 = -24						; size = 12
$T156956 = -12						; size = 8
$T156975 = -8						; size = 4
__Alproxy$ = -1						; size = 1
__Al$ = 8						; size = 1
??0?$_Deque_val@HV?$allocator@H@std@@@std@@QAE@V?$allocator@H@1@@Z PROC ; std::_Deque_val<int,std::allocator<int> >::_Deque_val<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 728  : 		{	// construct allocators from _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	8b f1		 mov	 esi, ecx
  0000a	33 ff		 xor	 edi, edi

; 729  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 730  : 			_Alproxy(_Alval);
; 731  : 		this->_Myproxy = _Alproxy.allocate(1);

  0000c	6a 08		 push	 8
  0000e	89 3e		 mov	 DWORD PTR [esi], edi
  00010	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00015	83 c4 04	 add	 esp, 4

; 732  : 		_Cons_val(_Alproxy, this->_Myproxy, _Container_proxy());

  00018	89 7d f8	 mov	 DWORD PTR $T156956[ebp+4], edi
  0001b	3b c7		 cmp	 eax, edi
  0001d	74 30		 je	 SHORT $LN13@Deque_val
  0001f	8d 4d f4	 lea	 ecx, DWORD PTR $T156956[ebp]
  00022	51		 push	 ecx
  00023	50		 push	 eax
  00024	8d 55 ff	 lea	 edx, DWORD PTR __Alproxy$[ebp]
  00027	52		 push	 edx
  00028	89 06		 mov	 DWORD PTR [esi], eax
  0002a	89 7d f4	 mov	 DWORD PTR $T156956[ebp], edi
  0002d	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@U_Container_proxy@std@@@std@@U_Container_proxy@2@U32@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@PAU_Container_proxy@0@$$QAU20@@Z ; std::_Cons_val<std::allocator<std::_Container_proxy>,std::_Container_proxy,std::_Container_proxy>

; 733  : 		this->_Myproxy->_Mycont = this;

  00032	8b 06		 mov	 eax, DWORD PTR [esi]
  00034	89 30		 mov	 DWORD PTR [eax], esi
  00036	83 c4 0c	 add	 esp, 12			; 0000000cH

; 734  : 
; 735  : 		_Map = 0;

  00039	89 7e 04	 mov	 DWORD PTR [esi+4], edi

; 736  : 		_Mapsize = 0;

  0003c	89 7e 08	 mov	 DWORD PTR [esi+8], edi

; 737  : 		_Myoff = 0;

  0003f	89 7e 0c	 mov	 DWORD PTR [esi+12], edi

; 738  : 		_Mysize = 0;

  00042	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  00045	5f		 pop	 edi

; 739  : 		}

  00046	8b c6		 mov	 eax, esi
  00048	5e		 pop	 esi
  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c2 04 00	 ret	 4

; 729  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 730  : 			_Alproxy(_Alval);
; 731  : 		this->_Myproxy = _Alproxy.allocate(1);

$LN13@Deque_val:
  0004f	8d 4d f8	 lea	 ecx, DWORD PTR $T156975[ebp]
  00052	51		 push	 ecx
  00053	8d 4d e8	 lea	 ecx, DWORD PTR $T156997[ebp]
  00056	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  0005b	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00060	8d 55 e8	 lea	 edx, DWORD PTR $T156997[ebp]
  00063	52		 push	 edx
  00064	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T156997[ebp], OFFSET ??_7bad_alloc@std@@6B@
  0006b	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN27@Deque_val:
$LN26@Deque_val:
  00070	cc		 int	 3
??0?$_Deque_val@HV?$allocator@H@std@@@std@@QAE@V?$allocator@H@1@@Z ENDP ; std::_Deque_val<int,std::allocator<int> >::_Deque_val<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??0?$_Deque_const_iterator@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z ; std::_Deque_const_iterator<int,std::allocator<int> >::_Deque_const_iterator<int,std::allocator<int> >
; Function compile flags: /Ogtp
;	COMDAT ??0?$_Deque_const_iterator@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0?$_Deque_const_iterator@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z PROC ; std::_Deque_const_iterator<int,std::allocator<int> >::_Deque_const_iterator<int,std::allocator<int> >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 55 08	 mov	 edx, DWORD PTR ___that$[ebp]
  00006	8b c1		 mov	 eax, ecx
  00008	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  0000e	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  00015	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00017	85 c9		 test	 ecx, ecx
  00019	74 0a		 je	 SHORT $LN8@Deque_cons@2
  0001b	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0001d	85 c9		 test	 ecx, ecx
  0001f	74 04		 je	 SHORT $LN8@Deque_cons@2
  00021	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00023	89 08		 mov	 DWORD PTR [eax], ecx
$LN8@Deque_cons@2:
  00025	8b 52 08	 mov	 edx, DWORD PTR [edx+8]
  00028	89 50 08	 mov	 DWORD PTR [eax+8], edx
  0002b	5d		 pop	 ebp
  0002c	c2 04 00	 ret	 4
??0?$_Deque_const_iterator@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z ENDP ; std::_Deque_const_iterator<int,std::allocator<int> >::_Deque_const_iterator<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??0?$_Deque_iterator@HV?$allocator@H@std@@@std@@QAE@IPBU_Container_base12@1@@Z ; std::_Deque_iterator<int,std::allocator<int> >::_Deque_iterator<int,std::allocator<int> >
; Function compile flags: /Ogtp
;	COMDAT ??0?$_Deque_iterator@HV?$allocator@H@std@@@std@@QAE@IPBU_Container_base12@1@@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
__Pdeque$ = 12						; size = 4
??0?$_Deque_iterator@HV?$allocator@H@std@@@std@@QAE@IPBU_Container_base12@1@@Z PROC ; std::_Deque_iterator<int,std::allocator<int> >::_Deque_iterator<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 601  : 		{	// construct with offset _Off in *_Pdeque

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 0c	 mov	 ecx, DWORD PTR __Pdeque$[ebp]
  00008	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  0000e	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  00015	85 c9		 test	 ecx, ecx
  00017	74 0e		 je	 SHORT $LN12@Deque_iter
  00019	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0001b	8b 55 08	 mov	 edx, DWORD PTR __Off$[ebp]
  0001e	89 08		 mov	 DWORD PTR [eax], ecx
  00020	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 602  : 		}

  00023	5d		 pop	 ebp
  00024	c2 08 00	 ret	 8
$LN12@Deque_iter:

; 601  : 		{	// construct with offset _Off in *_Pdeque

  00027	8b 4d 08	 mov	 ecx, DWORD PTR __Off$[ebp]
  0002a	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 602  : 		}

  0002d	5d		 pop	 ebp
  0002e	c2 08 00	 ret	 8
??0?$_Deque_iterator@HV?$allocator@H@std@@@std@@QAE@IPBU_Container_base12@1@@Z ENDP ; std::_Deque_iterator<int,std::allocator<int> >::_Deque_iterator<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	?pop@?$stack@HV?$deque@HV?$allocator@H@std@@@std@@@std@@QAEXXZ ; std::stack<int,std::deque<int,std::allocator<int> > >::pop
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\stack
;	COMDAT ?pop@?$stack@HV?$deque@HV?$allocator@H@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?pop@?$stack@HV?$deque@HV?$allocator@H@std@@@std@@@std@@QAEXXZ PROC ; std::stack<int,std::deque<int,std::allocator<int> > >::pop, COMDAT
; _this$ = ecx

; 104  : 		c.pop_back();

  00000	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00003	85 c0		 test	 eax, eax
  00005	74 0d		 je	 SHORT $LN3@pop
  00007	48		 dec	 eax
  00008	89 41 10	 mov	 DWORD PTR [ecx+16], eax
  0000b	75 07		 jne	 SHORT $LN3@pop
  0000d	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0
$LN3@pop:

; 105  : 		}

  00014	c3		 ret	 0
?pop@?$stack@HV?$deque@HV?$allocator@H@std@@@std@@@std@@QAEXXZ ENDP ; std::stack<int,std::deque<int,std::allocator<int> > >::pop
_TEXT	ENDS
PUBLIC	??1?$deque@HV?$allocator@H@std@@@std@@QAE@XZ	; std::deque<int,std::allocator<int> >::~deque<int,std::allocator<int> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\deque
;	COMDAT ??1?$deque@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$deque@HV?$allocator@H@std@@@std@@QAE@XZ PROC	; std::deque<int,std::allocator<int> >::~deque<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 1021 : 		{	// destroy the deque

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1022 : 		_Tidy();

  00003	e8 00 00 00 00	 call	 ?_Tidy@?$deque@HV?$allocator@H@std@@@std@@IAEXXZ ; std::deque<int,std::allocator<int> >::_Tidy

; 1023 : 		}

  00008	8b 06		 mov	 eax, DWORD PTR [esi]
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00010	83 c4 04	 add	 esp, 4
  00013	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00019	5e		 pop	 esi
  0001a	c3		 ret	 0
??1?$deque@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::deque<int,std::allocator<int> >::~deque<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??0?$deque@HV?$allocator@H@std@@@std@@QAE@XZ	; std::deque<int,std::allocator<int> >::deque<int,std::allocator<int> >
; Function compile flags: /Ogtp
;	COMDAT ??0?$deque@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T157181 = -28						; size = 12
$T157164 = -16						; size = 8
$T157132 = -8						; size = 4
__Alproxy$157188 = -1					; size = 1
??0?$deque@HV?$allocator@H@std@@@std@@QAE@XZ PROC	; std::deque<int,std::allocator<int> >::deque<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 799  : 		{	// construct empty deque

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	8b f1		 mov	 esi, ecx
  0000a	33 ff		 xor	 edi, edi
  0000c	6a 08		 push	 8
  0000e	89 3e		 mov	 DWORD PTR [esi], edi
  00010	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00015	83 c4 04	 add	 esp, 4
  00018	3b c7		 cmp	 eax, edi
  0001a	74 31		 je	 SHORT $LN18@deque
  0001c	8d 4d f0	 lea	 ecx, DWORD PTR $T157164[ebp]
  0001f	51		 push	 ecx
  00020	50		 push	 eax
  00021	8d 55 ff	 lea	 edx, DWORD PTR __Alproxy$157188[ebp]
  00024	52		 push	 edx
  00025	89 06		 mov	 DWORD PTR [esi], eax
  00027	89 7d f0	 mov	 DWORD PTR $T157164[ebp], edi
  0002a	89 7d f4	 mov	 DWORD PTR $T157164[ebp+4], edi
  0002d	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@U_Container_proxy@std@@@std@@U_Container_proxy@2@U32@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@PAU_Container_proxy@0@$$QAU20@@Z ; std::_Cons_val<std::allocator<std::_Container_proxy>,std::_Container_proxy,std::_Container_proxy>
  00032	8b 06		 mov	 eax, DWORD PTR [esi]
  00034	89 30		 mov	 DWORD PTR [eax], esi
  00036	83 c4 0c	 add	 esp, 12			; 0000000cH
  00039	89 7e 04	 mov	 DWORD PTR [esi+4], edi
  0003c	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  0003f	89 7e 0c	 mov	 DWORD PTR [esi+12], edi
  00042	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  00045	5f		 pop	 edi

; 800  : 		}

  00046	8b c6		 mov	 eax, esi
  00048	5e		 pop	 esi
  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0

; 799  : 		{	// construct empty deque

$LN18@deque:
  0004d	8d 4d f8	 lea	 ecx, DWORD PTR $T157132[ebp]
  00050	51		 push	 ecx
  00051	8d 4d e4	 lea	 ecx, DWORD PTR $T157181[ebp]
  00054	89 7d f8	 mov	 DWORD PTR $T157132[ebp], edi
  00057	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  0005c	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00061	8d 55 e4	 lea	 edx, DWORD PTR $T157181[ebp]
  00064	52		 push	 edx
  00065	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR $T157181[ebp], OFFSET ??_7bad_alloc@std@@6B@
  0006c	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN33@deque:
$LN32@deque:
  00071	cc		 int	 3
??0?$deque@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::deque<int,std::allocator<int> >::deque<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	?push_back@?$deque@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::deque<int,std::allocator<int> >::push_back
; Function compile flags: /Ogtp
;	COMDAT ?push_back@?$deque@HV?$allocator@H@std@@@std@@QAEXABH@Z
_TEXT	SEGMENT
$T157227 = -16						; size = 12
$T157205 = -4						; size = 4
__Val$ = 8						; size = 4
?push_back@?$deque@HV?$allocator@H@std@@@std@@QAEXABH@Z PROC ; std::deque<int,std::allocator<int> >::push_back, COMDAT
; _this$ = ecx

; 1263 : 		{	// insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx

; 1264 : 		this->_Orphan_all();
; 1265 : 		_PUSH_BACK_BEGIN;

  0000a	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0000d	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  00010	03 c8		 add	 ecx, eax
  00012	57		 push	 edi
  00013	f6 c1 03	 test	 cl, 3
  00016	75 14		 jne	 SHORT $LN3@push_back
  00018	83 c0 04	 add	 eax, 4
  0001b	c1 e8 02	 shr	 eax, 2
  0001e	39 46 08	 cmp	 DWORD PTR [esi+8], eax
  00021	77 09		 ja	 SHORT $LN3@push_back
  00023	6a 01		 push	 1
  00025	8b ce		 mov	 ecx, esi
  00027	e8 00 00 00 00	 call	 ?_Growmap@?$deque@HV?$allocator@H@std@@@std@@IAEXI@Z ; std::deque<int,std::allocator<int> >::_Growmap
$LN3@push_back:
  0002c	8b 5e 0c	 mov	 ebx, DWORD PTR [esi+12]
  0002f	03 5e 10	 add	 ebx, DWORD PTR [esi+16]
  00032	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00035	8b fb		 mov	 edi, ebx
  00037	c1 ef 02	 shr	 edi, 2
  0003a	3b c7		 cmp	 eax, edi
  0003c	77 02		 ja	 SHORT $LN2@push_back
  0003e	2b f8		 sub	 edi, eax
$LN2@push_back:
  00040	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00043	83 3c ba 00	 cmp	 DWORD PTR [edx+edi*4], 0
  00047	75 14		 jne	 SHORT $LN1@push_back
  00049	6a 10		 push	 16			; 00000010H
  0004b	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00050	83 c4 04	 add	 esp, 4
  00053	85 c0		 test	 eax, eax
  00055	74 2f		 je	 SHORT $LN10@push_back
  00057	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0005a	89 04 b9	 mov	 DWORD PTR [ecx+edi*4], eax
$LN1@push_back:

; 1266 : 		_Cons_val(this->_Alval,
; 1267 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ, _Val);

  0005d	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00060	8b 4d 08	 mov	 ecx, DWORD PTR __Val$[ebp]
  00063	8b 04 ba	 mov	 eax, DWORD PTR [edx+edi*4]
  00066	51		 push	 ecx
  00067	83 e3 03	 and	 ebx, 3
  0006a	8d 0c 98	 lea	 ecx, DWORD PTR [eax+ebx*4]
  0006d	51		 push	 ecx
  0006e	8d 56 14	 lea	 edx, DWORD PTR [esi+20]
  00071	52		 push	 edx
  00072	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@H@std@@HABH@std@@YAXAAV?$allocator@H@0@PAHABH@Z ; std::_Cons_val<std::allocator<int>,int,int const &>
  00077	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1268 : 		_PUSH_BACK_END;

  0007a	ff 46 10	 inc	 DWORD PTR [esi+16]
  0007d	5f		 pop	 edi
  0007e	5e		 pop	 esi
  0007f	5b		 pop	 ebx

; 1269 : 		}

  00080	8b e5		 mov	 esp, ebp
  00082	5d		 pop	 ebp
  00083	c2 04 00	 ret	 4

; 1264 : 		this->_Orphan_all();
; 1265 : 		_PUSH_BACK_BEGIN;

$LN10@push_back:
  00086	8d 55 fc	 lea	 edx, DWORD PTR $T157205[ebp]
  00089	52		 push	 edx
  0008a	8d 4d f0	 lea	 ecx, DWORD PTR $T157227[ebp]
  0008d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T157205[ebp], 0
  00094	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00099	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0009e	8d 45 f0	 lea	 eax, DWORD PTR $T157227[ebp]
  000a1	50		 push	 eax
  000a2	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T157227[ebp], OFFSET ??_7bad_alloc@std@@6B@
  000a9	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN22@push_back:
$LN21@push_back:
  000ae	cc		 int	 3
?push_back@?$deque@HV?$allocator@H@std@@@std@@QAEXABH@Z ENDP ; std::deque<int,std::allocator<int> >::push_back
_TEXT	ENDS
PUBLIC	?end@?$deque@HV?$allocator@H@std@@@std@@QAE?AV?$_Deque_iterator@HV?$allocator@H@std@@@2@XZ ; std::deque<int,std::allocator<int> >::end
; Function compile flags: /Ogtp
;	COMDAT ?end@?$deque@HV?$allocator@H@std@@@std@@QAE?AV?$_Deque_iterator@HV?$allocator@H@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$deque@HV?$allocator@H@std@@@std@@QAE?AV?$_Deque_iterator@HV?$allocator@H@std@@@2@XZ PROC ; std::deque<int,std::allocator<int> >::end, COMDAT
; _this$ = ecx

; 1060 : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1061 : 		return (iterator(this->_Myoff + this->_Mysize, this));

  00003	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00006	03 51 0c	 add	 edx, DWORD PTR [ecx+12]
  00009	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0000c	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0000e	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  00015	89 08		 mov	 DWORD PTR [eax], ecx
  00017	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 1062 : 		}

  0001a	5d		 pop	 ebp
  0001b	c2 04 00	 ret	 4
?end@?$deque@HV?$allocator@H@std@@@std@@QAE?AV?$_Deque_iterator@HV?$allocator@H@std@@@2@XZ ENDP ; std::deque<int,std::allocator<int> >::end
_TEXT	ENDS
PUBLIC	??0?$_Deque_iterator@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z ; std::_Deque_iterator<int,std::allocator<int> >::_Deque_iterator<int,std::allocator<int> >
; Function compile flags: /Ogtp
;	COMDAT ??0?$_Deque_iterator@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0?$_Deque_iterator@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z PROC ; std::_Deque_iterator<int,std::allocator<int> >::_Deque_iterator<int,std::allocator<int> >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 55 08	 mov	 edx, DWORD PTR ___that$[ebp]
  00006	8b c1		 mov	 eax, ecx
  00008	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  0000e	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  00015	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00017	85 c9		 test	 ecx, ecx
  00019	74 0a		 je	 SHORT $LN10@Deque_iter@2
  0001b	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0001d	85 c9		 test	 ecx, ecx
  0001f	74 04		 je	 SHORT $LN10@Deque_iter@2
  00021	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00023	89 08		 mov	 DWORD PTR [eax], ecx
$LN10@Deque_iter@2:
  00025	8b 52 08	 mov	 edx, DWORD PTR [edx+8]
  00028	89 50 08	 mov	 DWORD PTR [eax+8], edx
  0002b	5d		 pop	 ebp
  0002c	c2 04 00	 ret	 4
??0?$_Deque_iterator@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z ENDP ; std::_Deque_iterator<int,std::allocator<int> >::_Deque_iterator<int,std::allocator<int> >
_TEXT	ENDS
PUBLIC	??1?$stack@HV?$deque@HV?$allocator@H@std@@@std@@@std@@QAE@XZ ; std::stack<int,std::deque<int,std::allocator<int> > >::~stack<int,std::deque<int,std::allocator<int> > >
; Function compile flags: /Ogtp
;	COMDAT ??1?$stack@HV?$deque@HV?$allocator@H@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$stack@HV?$deque@HV?$allocator@H@std@@@std@@@std@@QAE@XZ PROC ; std::stack<int,std::deque<int,std::allocator<int> > >::~stack<int,std::deque<int,std::allocator<int> > >, COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	e8 00 00 00 00	 call	 ?_Tidy@?$deque@HV?$allocator@H@std@@@std@@IAEXXZ ; std::deque<int,std::allocator<int> >::_Tidy
  00008	8b 06		 mov	 eax, DWORD PTR [esi]
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00010	83 c4 04	 add	 esp, 4
  00013	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00019	5e		 pop	 esi
  0001a	c3		 ret	 0
??1?$stack@HV?$deque@HV?$allocator@H@std@@@std@@@std@@QAE@XZ ENDP ; std::stack<int,std::deque<int,std::allocator<int> > >::~stack<int,std::deque<int,std::allocator<int> > >
_TEXT	ENDS
PUBLIC	??_7CQueueTimer@@6B@				; CQueueTimer::`vftable'
PUBLIC	??1CQueueTimer@@UAE@XZ				; CQueueTimer::~CQueueTimer
PUBLIC	??_R4CQueueTimer@@6B@				; CQueueTimer::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCQueueTimer@@@8				; CQueueTimer `RTTI Type Descriptor'
PUBLIC	??_R3CQueueTimer@@8				; CQueueTimer::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CQueueTimer@@8				; CQueueTimer::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CQueueTimer@@8			; CQueueTimer::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??1TSync@@QAE@XZ:PROC				; TSync::~TSync
EXTRN	___security_cookie:DWORD
EXTRN	___CxxFrameHandler3:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	??_ECQueueTimer@@UAEPAXI@Z:PROC			; CQueueTimer::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@CQueueTimer@@8
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
rdata$r	SEGMENT
??_R1A@?0A@EA@CQueueTimer@@8 DD FLAT:??_R0?AVCQueueTimer@@@8 ; CQueueTimer::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CQueueTimer@@8
rdata$r	ENDS
;	COMDAT ??_R2CQueueTimer@@8
rdata$r	SEGMENT
??_R2CQueueTimer@@8 DD FLAT:??_R1A@?0A@EA@CQueueTimer@@8 ; CQueueTimer::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CQueueTimer@@8
rdata$r	SEGMENT
??_R3CQueueTimer@@8 DD 00H				; CQueueTimer::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CQueueTimer@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCQueueTimer@@@8
_DATA	SEGMENT
??_R0?AVCQueueTimer@@@8 DD FLAT:??_7type_info@@6B@	; CQueueTimer `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCQueueTimer@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CQueueTimer@@6B@
rdata$r	SEGMENT
??_R4CQueueTimer@@6B@ DD 00H				; CQueueTimer::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCQueueTimer@@@8
	DD	FLAT:??_R3CQueueTimer@@8
rdata$r	ENDS
;	COMDAT ??_7CQueueTimer@@6B@
CONST	SEGMENT
??_7CQueueTimer@@6B@ DD FLAT:??_R4CQueueTimer@@6B@	; CQueueTimer::`vftable'
	DD	FLAT:??_ECQueueTimer@@UAEPAXI@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1CQueueTimer@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CQueueTimer@@UAE@XZ$0
__ehfuncinfo$??1CQueueTimer@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1CQueueTimer@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\muserver_dev\development\mu-s8ep2-repack\gameserver\source\queuetimer.cpp
xdata$x	ENDS
;	COMDAT ??1CQueueTimer@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CQueueTimer@@UAE@XZ PROC				; CQueueTimer::~CQueueTimer, COMDAT
; _this$ = ecx

; 22   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1CQueueTimer@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b f1		 mov	 esi, ecx
  00026	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  00029	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7CQueueTimer@@6B@

; 23   : 	if( this->m_timerqueue != INVALID_HANDLE_VALUE )

  0002f	83 7e 08 ff	 cmp	 DWORD PTR [esi+8], -1
  00033	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0003a	74 05		 je	 SHORT $LN33@CQueueTime

; 24   : 	{
; 25   : 		this->DeleteQueueTimer();

  0003c	e8 00 00 00 00	 call	 ?DeleteQueueTimer@CQueueTimer@@QAEXXZ ; CQueueTimer::DeleteQueueTimer
$LN33@CQueueTime:

; 26   : 	}
; 27   : 
; 28   : 	while( this->m_stack.empty() == 0 )

  00041	83 7e 1c 00	 cmp	 DWORD PTR [esi+28], 0
  00045	74 1a		 je	 SHORT $LN1@CQueueTime
$LL2@CQueueTime:

; 29   : 		this->m_stack.pop();

  00047	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  0004a	85 c0		 test	 eax, eax
  0004c	74 0d		 je	 SHORT $LN14@CQueueTime
  0004e	48		 dec	 eax
  0004f	89 46 1c	 mov	 DWORD PTR [esi+28], eax
  00052	75 07		 jne	 SHORT $LN14@CQueueTime
  00054	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], 0
$LN14@CQueueTime:

; 26   : 	}
; 27   : 
; 28   : 	while( this->m_stack.empty() == 0 )

  0005b	83 7e 1c 00	 cmp	 DWORD PTR [esi+28], 0
  0005f	75 e6		 jne	 SHORT $LL2@CQueueTime
$LN1@CQueueTime:

; 30   : }

  00061	8d 4e 24	 lea	 ecx, DWORD PTR [esi+36]
  00064	e8 00 00 00 00	 call	 ??1TSync@@QAE@XZ	; TSync::~TSync
  00069	8d 4e 0c	 lea	 ecx, DWORD PTR [esi+12]
  0006c	e8 00 00 00 00	 call	 ?_Tidy@?$deque@HV?$allocator@H@std@@@std@@IAEXXZ ; std::deque<int,std::allocator<int> >::_Tidy
  00071	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00074	50		 push	 eax
  00075	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0007a	83 c4 04	 add	 esp, 4
  0007d	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
  00084	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00087	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0008e	59		 pop	 ecx
  0008f	5e		 pop	 esi
  00090	8b e5		 mov	 esp, ebp
  00092	5d		 pop	 ebp
  00093	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CQueueTimer@@UAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00006	e9 00 00 00 00	 jmp	 ??1?$stack@HV?$deque@HV?$allocator@H@std@@@std@@@std@@QAE@XZ
__ehhandler$??1CQueueTimer@@UAE@XZ:
  0000b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000f	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00012	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00015	33 c8		 xor	 ecx, eax
  00017	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001c	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1CQueueTimer@@UAE@XZ
  00021	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1CQueueTimer@@UAE@XZ ENDP				; CQueueTimer::~CQueueTimer
PUBLIC	?PopEventID@CQueueTimer@@QAEXXZ			; CQueueTimer::PopEventID
; Function compile flags: /Ogtp
;	COMDAT ?PopEventID@CQueueTimer@@QAEXXZ
_TEXT	SEGMENT
?PopEventID@CQueueTimer@@QAEXXZ PROC			; CQueueTimer::PopEventID, COMDAT
; _this$ = ecx

; 44   : 	this->m_stack.pop();

  00000	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  00003	85 c0		 test	 eax, eax
  00005	74 0d		 je	 SHORT $LN5@PopEventID
  00007	48		 dec	 eax
  00008	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
  0000b	75 07		 jne	 SHORT $LN5@PopEventID
  0000d	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], 0
$LN5@PopEventID:

; 45   : }

  00014	c3		 ret	 0
?PopEventID@CQueueTimer@@QAEXXZ ENDP			; CQueueTimer::PopEventID
_TEXT	ENDS
PUBLIC	??0?$stack@HV?$deque@HV?$allocator@H@std@@@std@@@std@@QAE@XZ ; std::stack<int,std::deque<int,std::allocator<int> > >::stack<int,std::deque<int,std::allocator<int> > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\stack
;	COMDAT ??0?$stack@HV?$deque@HV?$allocator@H@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T157593 = -28						; size = 12
$T157575 = -16						; size = 8
$T157508 = -8						; size = 4
__Alproxy$157573 = -1					; size = 1
??0?$stack@HV?$deque@HV?$allocator@H@std@@@std@@@std@@QAE@XZ PROC ; std::stack<int,std::deque<int,std::allocator<int> > >::stack<int,std::deque<int,std::allocator<int> > >, COMDAT
; _this$ = ecx

; 26   : 		{	// construct with empty container

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	8b f1		 mov	 esi, ecx
  0000a	33 ff		 xor	 edi, edi
  0000c	6a 08		 push	 8
  0000e	89 3e		 mov	 DWORD PTR [esi], edi
  00010	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00015	83 c4 04	 add	 esp, 4
  00018	3b c7		 cmp	 eax, edi
  0001a	74 31		 je	 SHORT $LN21@stack
  0001c	8d 4d f0	 lea	 ecx, DWORD PTR $T157575[ebp]
  0001f	51		 push	 ecx
  00020	50		 push	 eax
  00021	8d 55 ff	 lea	 edx, DWORD PTR __Alproxy$157573[ebp]
  00024	52		 push	 edx
  00025	89 06		 mov	 DWORD PTR [esi], eax
  00027	89 7d f0	 mov	 DWORD PTR $T157575[ebp], edi
  0002a	89 7d f4	 mov	 DWORD PTR $T157575[ebp+4], edi
  0002d	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@U_Container_proxy@std@@@std@@U_Container_proxy@2@U32@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@PAU_Container_proxy@0@$$QAU20@@Z ; std::_Cons_val<std::allocator<std::_Container_proxy>,std::_Container_proxy,std::_Container_proxy>
  00032	8b 06		 mov	 eax, DWORD PTR [esi]
  00034	89 30		 mov	 DWORD PTR [eax], esi
  00036	83 c4 0c	 add	 esp, 12			; 0000000cH
  00039	89 7e 04	 mov	 DWORD PTR [esi+4], edi
  0003c	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  0003f	89 7e 0c	 mov	 DWORD PTR [esi+12], edi
  00042	89 7e 10	 mov	 DWORD PTR [esi+16], edi
  00045	5f		 pop	 edi

; 27   : 		}

  00046	8b c6		 mov	 eax, esi
  00048	5e		 pop	 esi
  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0

; 26   : 		{	// construct with empty container

$LN21@stack:
  0004d	8d 4d f8	 lea	 ecx, DWORD PTR $T157508[ebp]
  00050	51		 push	 ecx
  00051	8d 4d e4	 lea	 ecx, DWORD PTR $T157593[ebp]
  00054	89 7d f8	 mov	 DWORD PTR $T157508[ebp], edi
  00057	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  0005c	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00061	8d 55 e4	 lea	 edx, DWORD PTR $T157593[ebp]
  00064	52		 push	 edx
  00065	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR $T157593[ebp], OFFSET ??_7bad_alloc@std@@6B@
  0006c	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN37@stack:
$LN36@stack:
  00071	cc		 int	 3
??0?$stack@HV?$deque@HV?$allocator@H@std@@@std@@@std@@QAE@XZ ENDP ; std::stack<int,std::deque<int,std::allocator<int> > >::stack<int,std::deque<int,std::allocator<int> > >
_TEXT	ENDS
PUBLIC	?push@?$stack@HV?$deque@HV?$allocator@H@std@@@std@@@std@@QAEXABH@Z ; std::stack<int,std::deque<int,std::allocator<int> > >::push
; Function compile flags: /Ogtp
;	COMDAT ?push@?$stack@HV?$deque@HV?$allocator@H@std@@@std@@@std@@QAEXABH@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push@?$stack@HV?$deque@HV?$allocator@H@std@@@std@@@std@@QAEXABH@Z PROC ; std::stack<int,std::deque<int,std::allocator<int> > >::push, COMDAT
; _this$ = ecx

; 98   : 		{	// insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 100  : 		}

  00003	5d		 pop	 ebp

; 99   : 		c.push_back(_Val);

  00004	e9 00 00 00 00	 jmp	 ?push_back@?$deque@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::deque<int,std::allocator<int> >::push_back
?push@?$stack@HV?$deque@HV?$allocator@H@std@@@std@@@std@@QAEXABH@Z ENDP ; std::stack<int,std::deque<int,std::allocator<int> > >::push
_TEXT	ENDS
PUBLIC	??G?$_Deque_iterator@HV?$allocator@H@std@@@std@@QBE?AV01@H@Z ; std::_Deque_iterator<int,std::allocator<int> >::operator-
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\deque
;	COMDAT ??G?$_Deque_iterator@HV?$allocator@H@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??G?$_Deque_iterator@HV?$allocator@H@std@@@std@@QBE?AV01@H@Z PROC ; std::_Deque_iterator<int,std::allocator<int> >::operator-, COMDAT
; _this$ = ecx

; 671  : 		{	// return this - integer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 672  : 		_Myiter _Tmp = *this;

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	33 d2		 xor	 edx, edx
  00007	85 c0		 test	 eax, eax
  00009	74 08		 je	 SHORT $LN12@operator@4
  0000b	8b 00		 mov	 eax, DWORD PTR [eax]
  0000d	85 c0		 test	 eax, eax
  0000f	74 02		 je	 SHORT $LN12@operator@4
  00011	8b 10		 mov	 edx, DWORD PTR [eax]
$LN12@operator@4:

; 673  : 		return (_Tmp -= _Off);

  00013	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00016	2b 4d 0c	 sub	 ecx, DWORD PTR __Off$[ebp]
  00019	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0001c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00022	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  00029	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  0002c	85 d2		 test	 edx, edx
  0002e	74 0a		 je	 SHORT $LN28@operator@4
  00030	8b 12		 mov	 edx, DWORD PTR [edx]
  00032	85 d2		 test	 edx, edx
  00034	74 04		 je	 SHORT $LN28@operator@4
  00036	8b 12		 mov	 edx, DWORD PTR [edx]
  00038	89 10		 mov	 DWORD PTR [eax], edx
$LN28@operator@4:

; 674  : 		}

  0003a	5d		 pop	 ebp
  0003b	c2 08 00	 ret	 8
??G?$_Deque_iterator@HV?$allocator@H@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Deque_iterator<int,std::allocator<int> >::operator-
_TEXT	ENDS
PUBLIC	??0CQueueTimer@@QAE@XZ				; CQueueTimer::CQueueTimer
EXTRN	??0TSync@@QAE@XZ:PROC				; TSync::TSync
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??0CQueueTimer@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CQueueTimer@@QAE@XZ$0
__ehfuncinfo$??0CQueueTimer@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0CQueueTimer@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\muserver_dev\development\mu-s8ep2-repack\gameserver\source\queuetimer.cpp
xdata$x	ENDS
;	COMDAT ??0CQueueTimer@@QAE@XZ
_TEXT	SEGMENT
$T157859 = -44						; size = 12
$T157848 = -32						; size = 8
_this$ = -24						; size = 4
$T157751 = -20						; size = 4
__Alproxy$157872 = -13					; size = 1
__$EHRec$ = -12						; size = 12
??0CQueueTimer@@QAE@XZ PROC				; CQueueTimer::CQueueTimer, COMDAT
; _this$ = ecx

; 11   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0CQueueTimer@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 20	 sub	 esp, 32			; 00000020H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	8b f9		 mov	 edi, ecx
  0002a	89 7d e8	 mov	 DWORD PTR _this$[ebp], edi
  0002d	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7CQueueTimer@@6B@
  00033	8d 77 0c	 lea	 esi, DWORD PTR [edi+12]
  00036	33 db		 xor	 ebx, ebx
  00038	6a 08		 push	 8
  0003a	89 1e		 mov	 DWORD PTR [esi], ebx
  0003c	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00041	83 c4 04	 add	 esp, 4
  00044	3b c3		 cmp	 eax, ebx
  00046	74 52		 je	 SHORT $LN25@CQueueTime@2
  00048	8d 4d e0	 lea	 ecx, DWORD PTR $T157848[ebp]
  0004b	51		 push	 ecx
  0004c	50		 push	 eax
  0004d	8d 55 f3	 lea	 edx, DWORD PTR __Alproxy$157872[ebp]
  00050	52		 push	 edx
  00051	89 06		 mov	 DWORD PTR [esi], eax
  00053	89 5d e0	 mov	 DWORD PTR $T157848[ebp], ebx
  00056	89 5d e4	 mov	 DWORD PTR $T157848[ebp+4], ebx
  00059	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@U_Container_proxy@std@@@std@@U_Container_proxy@2@U32@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@PAU_Container_proxy@0@$$QAU20@@Z ; std::_Cons_val<std::allocator<std::_Container_proxy>,std::_Container_proxy,std::_Container_proxy>
  0005e	8b 06		 mov	 eax, DWORD PTR [esi]
  00060	89 30		 mov	 DWORD PTR [eax], esi
  00062	83 c4 0c	 add	 esp, 12			; 0000000cH
  00065	89 5e 04	 mov	 DWORD PTR [esi+4], ebx
  00068	89 5e 08	 mov	 DWORD PTR [esi+8], ebx
  0006b	89 5e 0c	 mov	 DWORD PTR [esi+12], ebx
  0006e	89 5e 10	 mov	 DWORD PTR [esi+16], ebx
  00071	8d 4f 24	 lea	 ecx, DWORD PTR [edi+36]
  00074	89 5d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], ebx
  00077	e8 00 00 00 00	 call	 ??0TSync@@QAE@XZ	; TSync::TSync

; 12   : 	this->m_callback = 0;
; 13   : 	this->QueueTimerInit();

  0007c	8b cf		 mov	 ecx, edi
  0007e	89 5f 04	 mov	 DWORD PTR [edi+4], ebx
  00081	e8 00 00 00 00	 call	 ?QueueTimerInit@CQueueTimer@@QAEXXZ ; CQueueTimer::QueueTimerInit

; 14   : }

  00086	8b c7		 mov	 eax, edi
  00088	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0008b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00092	59		 pop	 ecx
  00093	5f		 pop	 edi
  00094	5e		 pop	 esi
  00095	5b		 pop	 ebx
  00096	8b e5		 mov	 esp, ebp
  00098	5d		 pop	 ebp
  00099	c3		 ret	 0

; 11   : {

$LN25@CQueueTime@2:
  0009a	8d 4d ec	 lea	 ecx, DWORD PTR $T157751[ebp]
  0009d	51		 push	 ecx
  0009e	8d 4d d4	 lea	 ecx, DWORD PTR $T157859[ebp]
  000a1	89 5d ec	 mov	 DWORD PTR $T157751[ebp], ebx
  000a4	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  000a9	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  000ae	8d 55 d4	 lea	 edx, DWORD PTR $T157859[ebp]
  000b1	52		 push	 edx
  000b2	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR $T157859[ebp], OFFSET ??_7bad_alloc@std@@6B@
  000b9	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN43@CQueueTime@2:
$LN42@CQueueTime@2:
  000be	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CQueueTimer@@QAE@XZ$0:
  00000	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00006	e9 00 00 00 00	 jmp	 ??1?$stack@HV?$deque@HV?$allocator@H@std@@@std@@@std@@QAE@XZ
__ehhandler$??0CQueueTimer@@QAE@XZ:
  0000b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000f	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00012	8b 4a d0	 mov	 ecx, DWORD PTR [edx-48]
  00015	33 c8		 xor	 ecx, eax
  00017	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001c	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0CQueueTimer@@QAE@XZ
  00021	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0CQueueTimer@@QAE@XZ ENDP				; CQueueTimer::CQueueTimer
; Function compile flags: /Ogtp
;	COMDAT ??_GCQueueTimer@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCQueueTimer@@UAEPAXI@Z PROC				; CQueueTimer::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1CQueueTimer@@UAE@XZ	; CQueueTimer::~CQueueTimer
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 09		 je	 SHORT $LN4@scalar@2
  00011	56		 push	 esi
  00012	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00017	83 c4 04	 add	 esp, 4
$LN4@scalar@2:
  0001a	8b c6		 mov	 eax, esi
  0001c	5e		 pop	 esi
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
??_GCQueueTimer@@UAEPAXI@Z ENDP				; CQueueTimer::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?PushEventID@CQueueTimer@@QAEXH@Z		; CQueueTimer::PushEventID
; Function compile flags: /Ogtp
;	COMDAT ?PushEventID@CQueueTimer@@QAEXH@Z
_TEXT	SEGMENT
_eventID$ = 8						; size = 4
?PushEventID@CQueueTimer@@QAEXH@Z PROC			; CQueueTimer::PushEventID, COMDAT
; _this$ = ecx

; 38   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 39   : 	this->m_stack.push(eventID);

  00003	8d 45 08	 lea	 eax, DWORD PTR _eventID$[ebp]
  00006	50		 push	 eax
  00007	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0000a	e8 00 00 00 00	 call	 ?push_back@?$deque@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::deque<int,std::allocator<int> >::push_back

; 40   : }

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
?PushEventID@CQueueTimer@@QAEXH@Z ENDP			; CQueueTimer::PushEventID
_TEXT	ENDS
PUBLIC	?back@?$deque@HV?$allocator@H@std@@@std@@QAEAAHXZ ; std::deque<int,std::allocator<int> >::back
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\deque
;	COMDAT ?back@?$deque@HV?$allocator@H@std@@@std@@QAEAAHXZ
_TEXT	SEGMENT
$T157897 = -24						; size = 12
$T157898 = -12						; size = 12
?back@?$deque@HV?$allocator@H@std@@@std@@QAEAAHXZ PROC	; std::deque<int,std::allocator<int> >::back, COMDAT
; _this$ = ecx

; 1213 : 		{	// return last element of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	56		 push	 esi

; 1214 : 		return (*(end() - 1));

  00007	6a 01		 push	 1
  00009	8d 45 f4	 lea	 eax, DWORD PTR $T157898[ebp]
  0000c	50		 push	 eax
  0000d	8d 55 e8	 lea	 edx, DWORD PTR $T157897[ebp]
  00010	52		 push	 edx
  00011	e8 00 00 00 00	 call	 ?end@?$deque@HV?$allocator@H@std@@@std@@QAE?AV?$_Deque_iterator@HV?$allocator@H@std@@@2@XZ ; std::deque<int,std::allocator<int> >::end
  00016	8b c8		 mov	 ecx, eax
  00018	e8 00 00 00 00	 call	 ??G?$_Deque_iterator@HV?$allocator@H@std@@@std@@QBE?AV01@H@Z ; std::_Deque_iterator<int,std::allocator<int> >::operator-
  0001d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001f	85 c9		 test	 ecx, ecx
  00021	75 04		 jne	 SHORT $LN13@back
  00023	33 f6		 xor	 esi, esi
  00025	eb 02		 jmp	 SHORT $LN14@back
$LN13@back:
  00027	8b 31		 mov	 esi, DWORD PTR [ecx]
$LN14@back:
  00029	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0002c	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0002f	8b c8		 mov	 ecx, eax
  00031	c1 e9 02	 shr	 ecx, 2
  00034	83 e0 03	 and	 eax, 3
  00037	3b d1		 cmp	 edx, ecx
  00039	77 02		 ja	 SHORT $LN5@back
  0003b	2b ca		 sub	 ecx, edx
$LN5@back:
  0003d	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00040	8b 0c 8a	 mov	 ecx, DWORD PTR [edx+ecx*4]
  00043	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  00046	5e		 pop	 esi

; 1215 : 		}

  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c3		 ret	 0
?back@?$deque@HV?$allocator@H@std@@@std@@QAEAAHXZ ENDP	; std::deque<int,std::allocator<int> >::back
_TEXT	ENDS
PUBLIC	?top@?$stack@HV?$deque@HV?$allocator@H@std@@@std@@@std@@QAEAAHXZ ; std::stack<int,std::deque<int,std::allocator<int> > >::top
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\stack
;	COMDAT ?top@?$stack@HV?$deque@HV?$allocator@H@std@@@std@@@std@@QAEAAHXZ
_TEXT	SEGMENT
$T157983 = -24						; size = 12
$T157984 = -12						; size = 12
?top@?$stack@HV?$deque@HV?$allocator@H@std@@@std@@@std@@QAEAAHXZ PROC ; std::stack<int,std::deque<int,std::allocator<int> > >::top, COMDAT
; _this$ = ecx

; 88   : 		{	// return last element of mutable stack

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	56		 push	 esi

; 89   : 		return (c.back());

  00007	6a 01		 push	 1
  00009	8d 45 f4	 lea	 eax, DWORD PTR $T157984[ebp]
  0000c	50		 push	 eax
  0000d	8d 55 e8	 lea	 edx, DWORD PTR $T157983[ebp]
  00010	52		 push	 edx
  00011	e8 00 00 00 00	 call	 ?end@?$deque@HV?$allocator@H@std@@@std@@QAE?AV?$_Deque_iterator@HV?$allocator@H@std@@@2@XZ ; std::deque<int,std::allocator<int> >::end
  00016	8b c8		 mov	 ecx, eax
  00018	e8 00 00 00 00	 call	 ??G?$_Deque_iterator@HV?$allocator@H@std@@@std@@QBE?AV01@H@Z ; std::_Deque_iterator<int,std::allocator<int> >::operator-
  0001d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001f	85 c9		 test	 ecx, ecx
  00021	75 04		 jne	 SHORT $LN15@top
  00023	33 f6		 xor	 esi, esi
  00025	eb 02		 jmp	 SHORT $LN16@top
$LN15@top:
  00027	8b 31		 mov	 esi, DWORD PTR [ecx]
$LN16@top:
  00029	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0002c	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0002f	8b c8		 mov	 ecx, eax
  00031	c1 e9 02	 shr	 ecx, 2
  00034	83 e0 03	 and	 eax, 3
  00037	3b d1		 cmp	 edx, ecx
  00039	77 02		 ja	 SHORT $LN7@top
  0003b	2b ca		 sub	 ecx, edx
$LN7@top:
  0003d	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00040	8b 0c 8a	 mov	 ecx, DWORD PTR [edx+ecx*4]
  00043	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  00046	5e		 pop	 esi

; 90   : 		}

  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c3		 ret	 0
?top@?$stack@HV?$deque@HV?$allocator@H@std@@@std@@@std@@QAEAAHXZ ENDP ; std::stack<int,std::deque<int,std::allocator<int> > >::top
_TEXT	ENDS
PUBLIC	?GetEvenetID@CQueueTimer@@QAEPAHXZ		; CQueueTimer::GetEvenetID
; Function compile flags: /Ogtp
; File c:\muserver_dev\development\mu-s8ep2-repack\gameserver\source\queuetimer.cpp
;	COMDAT ?GetEvenetID@CQueueTimer@@QAEPAHXZ
_TEXT	SEGMENT
$T158070 = -24						; size = 12
$T158071 = -12						; size = 12
?GetEvenetID@CQueueTimer@@QAEPAHXZ PROC			; CQueueTimer::GetEvenetID, COMDAT
; _this$ = ecx

; 48   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	56		 push	 esi

; 49   : 	return &this->m_stack.top();

  00007	6a 01		 push	 1
  00009	8d 45 f4	 lea	 eax, DWORD PTR $T158071[ebp]
  0000c	50		 push	 eax
  0000d	8d 55 e8	 lea	 edx, DWORD PTR $T158070[ebp]
  00010	52		 push	 edx
  00011	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00014	e8 00 00 00 00	 call	 ?end@?$deque@HV?$allocator@H@std@@@std@@QAE?AV?$_Deque_iterator@HV?$allocator@H@std@@@2@XZ ; std::deque<int,std::allocator<int> >::end
  00019	8b c8		 mov	 ecx, eax
  0001b	e8 00 00 00 00	 call	 ??G?$_Deque_iterator@HV?$allocator@H@std@@@std@@QBE?AV01@H@Z ; std::_Deque_iterator<int,std::allocator<int> >::operator-
  00020	8b 08		 mov	 ecx, DWORD PTR [eax]
  00022	85 c9		 test	 ecx, ecx
  00024	75 04		 jne	 SHORT $LN17@GetEvenetI
  00026	33 f6		 xor	 esi, esi
  00028	eb 02		 jmp	 SHORT $LN18@GetEvenetI
$LN17@GetEvenetI:
  0002a	8b 31		 mov	 esi, DWORD PTR [ecx]
$LN18@GetEvenetI:
  0002c	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0002f	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00032	8b c8		 mov	 ecx, eax
  00034	c1 e9 02	 shr	 ecx, 2
  00037	83 e0 03	 and	 eax, 3
  0003a	3b d1		 cmp	 edx, ecx
  0003c	77 02		 ja	 SHORT $LN9@GetEvenetI
  0003e	2b ca		 sub	 ecx, edx
$LN9@GetEvenetI:
  00040	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00043	8b 0c 8a	 mov	 ecx, DWORD PTR [edx+ecx*4]
  00046	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  00049	5e		 pop	 esi

; 50   : }

  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
?GetEvenetID@CQueueTimer@@QAEPAHXZ ENDP			; CQueueTimer::GetEvenetID
_TEXT	ENDS
PUBLIC	?CreateTimer@CQueueTimer@@QAEHHKK@Z		; CQueueTimer::CreateTimer
EXTRN	__imp__CreateTimerQueueTimer@28:PROC
; Function compile flags: /Ogtp
;	COMDAT ?CreateTimer@CQueueTimer@@QAEHHKK@Z
_TEXT	SEGMENT
_hTimer$ = -4						; size = 4
_eventID$ = 8						; size = 4
_period$ = 12						; size = 4
_flags$ = 16						; size = 4
?CreateTimer@CQueueTimer@@QAEHHKK@Z PROC		; CQueueTimer::CreateTimer, COMDAT
; _this$ = ecx

; 53   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 54   : 	HANDLE hTimer = INVALID_HANDLE_VALUE;
; 55   : 	int* tmpEventID;
; 56   : 	int result;
; 57   : 
; 58   : 	this->PushEventID(eventID);

  00004	8b 45 08	 mov	 eax, DWORD PTR _eventID$[ebp]
  00007	56		 push	 esi
  00008	50		 push	 eax
  00009	8b f1		 mov	 esi, ecx
  0000b	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR _hTimer$[ebp], -1
  00012	e8 00 00 00 00	 call	 ?PushEventID@CQueueTimer@@QAEXH@Z ; CQueueTimer::PushEventID

; 59   : 	tmpEventID = this->GetEvenetID();

  00017	8b ce		 mov	 ecx, esi
  00019	e8 00 00 00 00	 call	 ?GetEvenetID@CQueueTimer@@QAEPAHXZ ; CQueueTimer::GetEvenetID

; 60   : 
; 61   : 	result = CreateTimerQueueTimer(&hTimer,this->m_timerqueue,(WAITORTIMERCALLBACK)this->m_callback,tmpEventID,1000,period,flags);

  0001e	8b 4d 10	 mov	 ecx, DWORD PTR _flags$[ebp]
  00021	8b 55 0c	 mov	 edx, DWORD PTR _period$[ebp]
  00024	51		 push	 ecx
  00025	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00028	52		 push	 edx
  00029	68 e8 03 00 00	 push	 1000			; 000003e8H
  0002e	50		 push	 eax
  0002f	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00032	50		 push	 eax
  00033	51		 push	 ecx
  00034	8d 55 fc	 lea	 edx, DWORD PTR _hTimer$[ebp]
  00037	52		 push	 edx
  00038	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateTimerQueueTimer@28
  0003e	8b d0		 mov	 edx, eax

; 62   : 
; 63   : 	if( !result )

  00040	85 d2		 test	 edx, edx
  00042	75 09		 jne	 SHORT $LN1@CreateTime

; 64   : 		this->PopEventID();

  00044	8b ce		 mov	 ecx, esi
  00046	e8 00 00 00 00	 call	 ?PopEventID@CQueueTimer@@QAEXXZ ; CQueueTimer::PopEventID

; 65   : 
; 66   : return result;

  0004b	8b c2		 mov	 eax, edx
$LN1@CreateTime:
  0004d	5e		 pop	 esi

; 67   : }

  0004e	8b e5		 mov	 esp, ebp
  00050	5d		 pop	 ebp
  00051	c2 0c 00	 ret	 12			; 0000000cH
?CreateTimer@CQueueTimer@@QAEHHKK@Z ENDP		; CQueueTimer::CreateTimer
_TEXT	ENDS
END
