; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	C:\muserver_dev\development\MU-S8EP2-Repack\GameServer\Source\MuTimer.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?_EEM_DS@?$deque@HV?$allocator@H@std@@@std@@2HB	; std::deque<int,std::allocator<int> >::_EEM_DS
PUBLIC	?BLOCKSIZE@?$FixedBlockSize@$07@CryptoPP@@2HB	; CryptoPP::FixedBlockSize<8>::BLOCKSIZE
PUBLIC	?KEYLENGTH@?$FixedKeyLength@$07$03$0A@@CryptoPP@@2HB ; CryptoPP::FixedKeyLength<8,4,0>::KEYLENGTH
PUBLIC	?MIN_KEYLENGTH@?$FixedKeyLength@$07$03$0A@@CryptoPP@@2HB ; CryptoPP::FixedKeyLength<8,4,0>::MIN_KEYLENGTH
PUBLIC	?MAX_KEYLENGTH@?$FixedKeyLength@$07$03$0A@@CryptoPP@@2HB ; CryptoPP::FixedKeyLength<8,4,0>::MAX_KEYLENGTH
PUBLIC	?DEFAULT_KEYLENGTH@?$FixedKeyLength@$07$03$0A@@CryptoPP@@2HB ; CryptoPP::FixedKeyLength<8,4,0>::DEFAULT_KEYLENGTH
PUBLIC	?IV_REQUIREMENT@?$FixedKeyLength@$07$03$0A@@CryptoPP@@2HB ; CryptoPP::FixedKeyLength<8,4,0>::IV_REQUIREMENT
PUBLIC	?IV_LENGTH@?$FixedKeyLength@$07$03$0A@@CryptoPP@@2HB ; CryptoPP::FixedKeyLength<8,4,0>::IV_LENGTH
PUBLIC	?KEYLENGTH@?$FixedKeyLength@$0BA@$03$0A@@CryptoPP@@2HB ; CryptoPP::FixedKeyLength<16,4,0>::KEYLENGTH
PUBLIC	?MIN_KEYLENGTH@?$FixedKeyLength@$0BA@$03$0A@@CryptoPP@@2HB ; CryptoPP::FixedKeyLength<16,4,0>::MIN_KEYLENGTH
PUBLIC	?MAX_KEYLENGTH@?$FixedKeyLength@$0BA@$03$0A@@CryptoPP@@2HB ; CryptoPP::FixedKeyLength<16,4,0>::MAX_KEYLENGTH
PUBLIC	?DEFAULT_KEYLENGTH@?$FixedKeyLength@$0BA@$03$0A@@CryptoPP@@2HB ; CryptoPP::FixedKeyLength<16,4,0>::DEFAULT_KEYLENGTH
PUBLIC	?IV_REQUIREMENT@?$FixedKeyLength@$0BA@$03$0A@@CryptoPP@@2HB ; CryptoPP::FixedKeyLength<16,4,0>::IV_REQUIREMENT
PUBLIC	?IV_LENGTH@?$FixedKeyLength@$0BA@$03$0A@@CryptoPP@@2HB ; CryptoPP::FixedKeyLength<16,4,0>::IV_LENGTH
PUBLIC	?KEYLENGTH@?$FixedKeyLength@$0BI@$03$0A@@CryptoPP@@2HB ; CryptoPP::FixedKeyLength<24,4,0>::KEYLENGTH
PUBLIC	?MIN_KEYLENGTH@?$FixedKeyLength@$0BI@$03$0A@@CryptoPP@@2HB ; CryptoPP::FixedKeyLength<24,4,0>::MIN_KEYLENGTH
PUBLIC	?MAX_KEYLENGTH@?$FixedKeyLength@$0BI@$03$0A@@CryptoPP@@2HB ; CryptoPP::FixedKeyLength<24,4,0>::MAX_KEYLENGTH
PUBLIC	?DEFAULT_KEYLENGTH@?$FixedKeyLength@$0BI@$03$0A@@CryptoPP@@2HB ; CryptoPP::FixedKeyLength<24,4,0>::DEFAULT_KEYLENGTH
PUBLIC	?IV_REQUIREMENT@?$FixedKeyLength@$0BI@$03$0A@@CryptoPP@@2HB ; CryptoPP::FixedKeyLength<24,4,0>::IV_REQUIREMENT
PUBLIC	?IV_LENGTH@?$FixedKeyLength@$0BI@$03$0A@@CryptoPP@@2HB ; CryptoPP::FixedKeyLength<24,4,0>::IV_LENGTH
;	COMDAT ?IV_LENGTH@?$FixedKeyLength@$0BI@$03$0A@@CryptoPP@@2HB
CONST	SEGMENT
?IV_LENGTH@?$FixedKeyLength@$0BI@$03$0A@@CryptoPP@@2HB DD 00H ; CryptoPP::FixedKeyLength<24,4,0>::IV_LENGTH
CONST	ENDS
;	COMDAT ?IV_REQUIREMENT@?$FixedKeyLength@$0BI@$03$0A@@CryptoPP@@2HB
CONST	SEGMENT
?IV_REQUIREMENT@?$FixedKeyLength@$0BI@$03$0A@@CryptoPP@@2HB DD 04H ; CryptoPP::FixedKeyLength<24,4,0>::IV_REQUIREMENT
CONST	ENDS
;	COMDAT ?DEFAULT_KEYLENGTH@?$FixedKeyLength@$0BI@$03$0A@@CryptoPP@@2HB
CONST	SEGMENT
?DEFAULT_KEYLENGTH@?$FixedKeyLength@$0BI@$03$0A@@CryptoPP@@2HB DD 018H ; CryptoPP::FixedKeyLength<24,4,0>::DEFAULT_KEYLENGTH
CONST	ENDS
;	COMDAT ?MAX_KEYLENGTH@?$FixedKeyLength@$0BI@$03$0A@@CryptoPP@@2HB
CONST	SEGMENT
?MAX_KEYLENGTH@?$FixedKeyLength@$0BI@$03$0A@@CryptoPP@@2HB DD 018H ; CryptoPP::FixedKeyLength<24,4,0>::MAX_KEYLENGTH
CONST	ENDS
;	COMDAT ?MIN_KEYLENGTH@?$FixedKeyLength@$0BI@$03$0A@@CryptoPP@@2HB
CONST	SEGMENT
?MIN_KEYLENGTH@?$FixedKeyLength@$0BI@$03$0A@@CryptoPP@@2HB DD 018H ; CryptoPP::FixedKeyLength<24,4,0>::MIN_KEYLENGTH
CONST	ENDS
;	COMDAT ?KEYLENGTH@?$FixedKeyLength@$0BI@$03$0A@@CryptoPP@@2HB
CONST	SEGMENT
?KEYLENGTH@?$FixedKeyLength@$0BI@$03$0A@@CryptoPP@@2HB DD 018H ; CryptoPP::FixedKeyLength<24,4,0>::KEYLENGTH
CONST	ENDS
;	COMDAT ?IV_LENGTH@?$FixedKeyLength@$0BA@$03$0A@@CryptoPP@@2HB
CONST	SEGMENT
?IV_LENGTH@?$FixedKeyLength@$0BA@$03$0A@@CryptoPP@@2HB DD 00H ; CryptoPP::FixedKeyLength<16,4,0>::IV_LENGTH
CONST	ENDS
;	COMDAT ?IV_REQUIREMENT@?$FixedKeyLength@$0BA@$03$0A@@CryptoPP@@2HB
CONST	SEGMENT
?IV_REQUIREMENT@?$FixedKeyLength@$0BA@$03$0A@@CryptoPP@@2HB DD 04H ; CryptoPP::FixedKeyLength<16,4,0>::IV_REQUIREMENT
CONST	ENDS
;	COMDAT ?DEFAULT_KEYLENGTH@?$FixedKeyLength@$0BA@$03$0A@@CryptoPP@@2HB
CONST	SEGMENT
?DEFAULT_KEYLENGTH@?$FixedKeyLength@$0BA@$03$0A@@CryptoPP@@2HB DD 010H ; CryptoPP::FixedKeyLength<16,4,0>::DEFAULT_KEYLENGTH
CONST	ENDS
;	COMDAT ?MAX_KEYLENGTH@?$FixedKeyLength@$0BA@$03$0A@@CryptoPP@@2HB
CONST	SEGMENT
?MAX_KEYLENGTH@?$FixedKeyLength@$0BA@$03$0A@@CryptoPP@@2HB DD 010H ; CryptoPP::FixedKeyLength<16,4,0>::MAX_KEYLENGTH
CONST	ENDS
;	COMDAT ?MIN_KEYLENGTH@?$FixedKeyLength@$0BA@$03$0A@@CryptoPP@@2HB
CONST	SEGMENT
?MIN_KEYLENGTH@?$FixedKeyLength@$0BA@$03$0A@@CryptoPP@@2HB DD 010H ; CryptoPP::FixedKeyLength<16,4,0>::MIN_KEYLENGTH
CONST	ENDS
;	COMDAT ?KEYLENGTH@?$FixedKeyLength@$0BA@$03$0A@@CryptoPP@@2HB
CONST	SEGMENT
?KEYLENGTH@?$FixedKeyLength@$0BA@$03$0A@@CryptoPP@@2HB DD 010H ; CryptoPP::FixedKeyLength<16,4,0>::KEYLENGTH
CONST	ENDS
;	COMDAT ?IV_LENGTH@?$FixedKeyLength@$07$03$0A@@CryptoPP@@2HB
CONST	SEGMENT
?IV_LENGTH@?$FixedKeyLength@$07$03$0A@@CryptoPP@@2HB DD 00H ; CryptoPP::FixedKeyLength<8,4,0>::IV_LENGTH
CONST	ENDS
;	COMDAT ?IV_REQUIREMENT@?$FixedKeyLength@$07$03$0A@@CryptoPP@@2HB
CONST	SEGMENT
?IV_REQUIREMENT@?$FixedKeyLength@$07$03$0A@@CryptoPP@@2HB DD 04H ; CryptoPP::FixedKeyLength<8,4,0>::IV_REQUIREMENT
CONST	ENDS
;	COMDAT ?DEFAULT_KEYLENGTH@?$FixedKeyLength@$07$03$0A@@CryptoPP@@2HB
CONST	SEGMENT
?DEFAULT_KEYLENGTH@?$FixedKeyLength@$07$03$0A@@CryptoPP@@2HB DD 08H ; CryptoPP::FixedKeyLength<8,4,0>::DEFAULT_KEYLENGTH
CONST	ENDS
;	COMDAT ?MAX_KEYLENGTH@?$FixedKeyLength@$07$03$0A@@CryptoPP@@2HB
CONST	SEGMENT
?MAX_KEYLENGTH@?$FixedKeyLength@$07$03$0A@@CryptoPP@@2HB DD 08H ; CryptoPP::FixedKeyLength<8,4,0>::MAX_KEYLENGTH
CONST	ENDS
;	COMDAT ?MIN_KEYLENGTH@?$FixedKeyLength@$07$03$0A@@CryptoPP@@2HB
CONST	SEGMENT
?MIN_KEYLENGTH@?$FixedKeyLength@$07$03$0A@@CryptoPP@@2HB DD 08H ; CryptoPP::FixedKeyLength<8,4,0>::MIN_KEYLENGTH
CONST	ENDS
;	COMDAT ?KEYLENGTH@?$FixedKeyLength@$07$03$0A@@CryptoPP@@2HB
CONST	SEGMENT
?KEYLENGTH@?$FixedKeyLength@$07$03$0A@@CryptoPP@@2HB DD 08H ; CryptoPP::FixedKeyLength<8,4,0>::KEYLENGTH
CONST	ENDS
;	COMDAT ?BLOCKSIZE@?$FixedBlockSize@$07@CryptoPP@@2HB
CONST	SEGMENT
?BLOCKSIZE@?$FixedBlockSize@$07@CryptoPP@@2HB DD 08H	; CryptoPP::FixedBlockSize<8>::BLOCKSIZE
CONST	ENDS
_DATA	SEGMENT
_g_sttBLOODCASTLE_LEVEL DD 0fH
	DD	050H
	DD	0aH
	DD	03cH
	DD	051H
	DD	082H
	DD	03dH
	DD	06eH
	DD	083H
	DD	0b4H
	DD	06fH
	DD	0a0H
	DD	0b5H
	DD	0e6H
	DD	0a1H
	DD	0d2H
	DD	0e7H
	DD	0118H
	DD	0d3H
	DD	0104H
	DD	0119H
	DD	014aH
	DD	0105H
	DD	0136H
	DD	014bH
	DD	0190H
	DD	0137H
	DD	0190H
	DD	00H
	DD	0190H
	DD	00H
	DD	0190H
_g_sttCHAOSCASTLE_LEVEL DD 0aH
	DD	031H
	DD	0aH
	DD	01dH
	DD	032H
	DD	077H
	DD	01eH
	DD	063H
	DD	078H
	DD	0b3H
	DD	064H
	DD	09fH
	DD	0b4H
	DD	0efH
	DD	0a0H
	DD	0dbH
	DD	0f0H
	DD	012bH
	DD	0dcH
	DD	0117H
	DD	012cH
	DD	0190H
	DD	0118H
	DD	0190H
	DD	00H
	DD	0190H
	DD	00H
	DD	0190H
_g_iChaosCastle_BlowOutDistance DD 03H
	DD	04H
	DD	03H
	DD	04H
	DD	02H
	DD	03H
	DD	00H
	DD	01H
_g_iChaosCastle_BlowOutDamage DD 0fH
	DD	0fH
	DD	0aH
	DD	05H
_g_iChaosCastle_EnterCost DD 061a8H
	DD	013880H
	DD	0249f0H
	DD	03d090H
	DD	061a80H
	DD	09eb10H
	DD	0f4240H
_g_iChaosCastle_GuardSetValue DD 09c4H
	DD	09c4H
	DD	09c4H
	DD	09c4H
	DD	09c4H
	DD	09c4H
	DD	09c4H
_g_iChaosCastle_MonsterItems DD 01c0dH
	DD	01H
	DD	01c0eH
	DD	01H
	DD	01c0dH
	DD	01H
	DD	01c0eH
	DD	01H
	DD	01c0dH
	DD	01H
	DD	01c0eH
	DD	01H
	DD	01c0dH
	DD	01H
	DD	01c0eH
	DD	01H
	DD	01c0dH
	DD	01H
	DD	01c0eH
	DD	02H
	DD	01c0dH
	DD	01H
	DD	01c0eH
	DD	02H
	DD	01c0dH
	DD	01H
	DD	01c0eH
	DD	02H
_g_iChaosCastle_GroundAxis DD 017H
	DD	04bH
	DD	02cH
	DD	06cH
_g_iChaosCastle_DamageAxis DD 017H
	DD	04bH
	DD	02cH
	DD	06cH
	DD	019H
	DD	04dH
	DD	02aH
	DD	06aH
	DD	01bH
	DD	04fH
	DD	028H
	DD	068H
	DD	01dH
	DD	051H
	DD	026H
	DD	066H
_g_iChaosCastle_MapHollowZone DD 017H
	DD	04bH
	DD	02cH
	DD	04cH
	DD	02bH
	DD	04dH
	DD	02cH
	DD	06cH
	DD	017H
	DD	06bH
	DD	02aH
	DD	06cH
	DD	017H
	DD	04dH
	DD	018H
	DD	06aH
	DD	017H
	DD	04bH
	DD	02cH
	DD	04cH
	DD	02bH
	DD	04dH
	DD	02cH
	DD	06cH
	DD	017H
	DD	06bH
	DD	02aH
	DD	06cH
	DD	017H
	DD	04dH
	DD	018H
	DD	06aH
	DD	019H
	DD	04dH
	DD	02aH
	DD	04eH
	DD	029H
	DD	04fH
	DD	02aH
	DD	06aH
	DD	019H
	DD	069H
	DD	028H
	DD	06aH
	DD	019H
	DD	04fH
	DD	01aH
	DD	068H
	DD	01bH
	DD	04fH
	DD	028H
	DD	050H
	DD	027H
	DD	051H
	DD	028H
	DD	068H
	DD	01bH
	DD	067H
	DD	026H
	DD	068H
	DD	01bH
	DD	051H
	DD	01cH
	DD	066H
_IT_TicketRate DD 046H
	DD	046H
	DD	046H
	DD	046H
	DD	046H
	DD	046H
_IT_TicketZen DD 02dc6c0H
	DD	04c4b40H
	DD	06acfc0H
	DD	0895440H
	DD	0a7d8c0H
	DD	0c65d40H
_IT_REWARD_A DD	0493e0H
	DD	053020H
	DD	05cc60H
	DD	0668a0H
	DD	0704e0H
	DD	07a120H
_IT_REWARD_B DD	0c350H
	DD	0ea60H
	DD	011170H
	DD	013880H
	DD	015f90H
	DD	0186a0H
_IT_REWARD_C DD	0258H
	DD	04b0H
	DD	0708H
	DD	0960H
	DD	0bb8H
	DD	0e10H
_IT_REWARD_D DD	04b0H
	DD	0960H
	DD	0e10H
	DD	012c0H
	DD	01770H
	DD	01c20H
_IT_REWARD_E DD	0aH
	DD	014H
	DD	01eH
	DD	028H
	DD	032H
	DD	03cH
_g_sttDEVILSQUARE_LEVEL DD 0fH
	DD	082H
	DD	0aH
	DD	06eH
	DD	03aH
	DD	083H
	DD	0b4H
	DD	06fH
	DD	0a0H
	DD	03bH
	DD	0b5H
	DD	0e6H
	DD	0a1H
	DD	0d2H
	DD	03cH
	DD	0e7H
	DD	0118H
	DD	0d3H
	DD	0104H
	DD	03dH
	DD	0119H
	DD	014aH
	DD	0105H
	DD	0136H
	DD	06fH
	DD	014bH
	DD	0190H
	DD	0137H
	DD	0190H
	DD	070H
	DD	00H
	DD	0190H
	DD	00H
	DD	0190H
	DD	010eH
_DATA	ENDS
;	COMDAT ?_EEM_DS@?$deque@HV?$allocator@H@std@@@std@@2HB
CONST	SEGMENT
?_EEM_DS@?$deque@HV?$allocator@H@std@@@std@@2HB DD 04H	; std::deque<int,std::allocator<int> >::_EEM_DS
CONST	ENDS
PUBLIC	??1OBJECTSTRUCT@@QAE@XZ				; OBJECTSTRUCT::~OBJECTSTRUCT
EXTRN	??1CSkillDelay@@UAE@XZ:PROC			; CSkillDelay::~CSkillDelay
EXTRN	??1TMonsterAIAgro@@UAE@XZ:PROC			; TMonsterAIAgro::~TMonsterAIAgro
EXTRN	___security_cookie:DWORD
EXTRN	___CxxFrameHandler3:PROC
EXTRN	@__security_check_cookie@4:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1OBJECTSTRUCT@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1OBJECTSTRUCT@@QAE@XZ$0
__ehfuncinfo$??1OBJECTSTRUCT@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1OBJECTSTRUCT@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
xdata$x	ENDS
;	COMDAT ??1OBJECTSTRUCT@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1OBJECTSTRUCT@@QAE@XZ PROC				; OBJECTSTRUCT::~OBJECTSTRUCT, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1OBJECTSTRUCT@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b f1		 mov	 esi, ecx
  00026	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  00029	8d 8e ec 20 00
	00		 lea	 ecx, DWORD PTR [esi+8428]
  0002f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00036	e8 00 00 00 00	 call	 ??1TMonsterAIAgro@@UAE@XZ ; TMonsterAIAgro::~TMonsterAIAgro
  0003b	8d 8e 0c 16 00
	00		 lea	 ecx, DWORD PTR [esi+5644]
  00041	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00048	e8 00 00 00 00	 call	 ??1CSkillDelay@@UAE@XZ	; CSkillDelay::~CSkillDelay
  0004d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00050	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00057	59		 pop	 ecx
  00058	5e		 pop	 esi
  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1OBJECTSTRUCT@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	81 c1 0c 16 00
	00		 add	 ecx, 5644		; 0000160cH
  00009	e9 00 00 00 00	 jmp	 ??1CSkillDelay@@UAE@XZ	; CSkillDelay::~CSkillDelay
__ehhandler$??1OBJECTSTRUCT@@QAE@XZ:
  0000e	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00012	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00015	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00018	33 c8		 xor	 ecx, eax
  0001a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001f	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1OBJECTSTRUCT@@QAE@XZ
  00024	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1OBJECTSTRUCT@@QAE@XZ ENDP				; OBJECTSTRUCT::~OBJECTSTRUCT
PUBLIC	??_H@YGXPAXIHP6EPAX0@Z@Z			; `vector constructor iterator'
; Function compile flags: /Ogtp
;	COMDAT ??_H@YGXPAXIHP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIHP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi
  00004	8b 7d 10	 mov	 edi, DWORD PTR ___n$[ebp]
  00007	4f		 dec	 edi
  00008	78 14		 js	 SHORT $LN1@vector
  0000a	53		 push	 ebx
  0000b	8b 5d 14	 mov	 ebx, DWORD PTR ___f$[ebp]
  0000e	56		 push	 esi
  0000f	8b 75 08	 mov	 esi, DWORD PTR ___t$[ebp]
$LL2@vector:
  00012	8b ce		 mov	 ecx, esi
  00014	ff d3		 call	 ebx
  00016	03 75 0c	 add	 esi, DWORD PTR ___s$[ebp]
  00019	4f		 dec	 edi
  0001a	79 f6		 jns	 SHORT $LL2@vector
  0001c	5e		 pop	 esi
  0001d	5b		 pop	 ebx
$LN1@vector:
  0001e	5f		 pop	 edi
  0001f	5d		 pop	 ebp
  00020	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIHP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
PUBLIC	?getInstance@MonsterSpawnerMng@@SAPAV1@XZ	; MonsterSpawnerMng::getInstance
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	??0MonsterSpawnerMng@@QAE@XZ:PROC		; MonsterSpawnerMng::MonsterSpawnerMng
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	?m_Instance@MonsterSpawnerMng@@0PAV1@A:DWORD	; MonsterSpawnerMng::m_Instance
;	COMDAT xdata$x
; File c:\muserver_dev\development\mu-s8ep2-repack\gameserver\source\monsterspawner.h
xdata$x	SEGMENT
__unwindtable$?getInstance@MonsterSpawnerMng@@SAPAV1@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?getInstance@MonsterSpawnerMng@@SAPAV1@XZ$0
__ehfuncinfo$?getInstance@MonsterSpawnerMng@@SAPAV1@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?getInstance@MonsterSpawnerMng@@SAPAV1@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
xdata$x	ENDS
;	COMDAT ?getInstance@MonsterSpawnerMng@@SAPAV1@XZ
_TEXT	SEGMENT
$T212789 = -16						; size = 4
__$EHRec$ = -12						; size = 12
?getInstance@MonsterSpawnerMng@@SAPAV1@XZ PROC		; MonsterSpawnerMng::getInstance, COMDAT

; 137  : 	static MonsterSpawnerMng* getInstance() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?getInstance@MonsterSpawnerMng@@SAPAV1@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 138  : 		if (m_Instance == NULL) {

  00023	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_Instance@MonsterSpawnerMng@@0PAV1@A ; MonsterSpawnerMng::m_Instance
  00028	85 c0		 test	 eax, eax
  0002a	75 3a		 jne	 SHORT $LN1@getInstanc

; 139  : 			m_Instance = new MonsterSpawnerMng();

  0002c	6a 24		 push	 36			; 00000024H
  0002e	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00033	83 c4 04	 add	 esp, 4
  00036	89 45 f0	 mov	 DWORD PTR $T212789[ebp], eax
  00039	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00040	85 c0		 test	 eax, eax
  00042	74 1b		 je	 SHORT $LN4@getInstanc
  00044	8b c8		 mov	 ecx, eax
  00046	e8 00 00 00 00	 call	 ??0MonsterSpawnerMng@@QAE@XZ ; MonsterSpawnerMng::MonsterSpawnerMng
  0004b	a3 00 00 00 00	 mov	 DWORD PTR ?m_Instance@MonsterSpawnerMng@@0PAV1@A, eax ; MonsterSpawnerMng::m_Instance

; 140  : 		}
; 141  : 		return m_Instance;
; 142  : 	}

  00050	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00053	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005a	59		 pop	 ecx
  0005b	8b e5		 mov	 esp, ebp
  0005d	5d		 pop	 ebp
  0005e	c3		 ret	 0
$LN4@getInstanc:

; 139  : 			m_Instance = new MonsterSpawnerMng();

  0005f	33 c0		 xor	 eax, eax
  00061	a3 00 00 00 00	 mov	 DWORD PTR ?m_Instance@MonsterSpawnerMng@@0PAV1@A, eax ; MonsterSpawnerMng::m_Instance
$LN1@getInstanc:

; 140  : 		}
; 141  : 		return m_Instance;
; 142  : 	}

  00066	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00069	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00070	59		 pop	 ecx
  00071	8b e5		 mov	 esp, ebp
  00073	5d		 pop	 ebp
  00074	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?getInstance@MonsterSpawnerMng@@SAPAV1@XZ$0:
  00000	8b 45 f0	 mov	 eax, DWORD PTR $T212789[ebp]
  00003	50		 push	 eax
  00004	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00009	59		 pop	 ecx
  0000a	c3		 ret	 0
__ehhandler$?getInstance@MonsterSpawnerMng@@SAPAV1@XZ:
  0000b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000f	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00012	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00015	33 c8		 xor	 ecx, eax
  00017	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001c	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?getInstance@MonsterSpawnerMng@@SAPAV1@XZ
  00021	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?getInstance@MonsterSpawnerMng@@SAPAV1@XZ ENDP		; MonsterSpawnerMng::getInstance
PUBLIC	??_7CMuTimer@@6B@				; CMuTimer::`vftable'
PUBLIC	??1CMuTimer@@UAE@XZ				; CMuTimer::~CMuTimer
PUBLIC	??_R4CMuTimer@@6B@				; CMuTimer::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCMuTimer@@@8				; CMuTimer `RTTI Type Descriptor'
PUBLIC	??_R3CMuTimer@@8				; CMuTimer::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CMuTimer@@8				; CMuTimer::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CMuTimer@@8			; CMuTimer::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??1CQueueTimer@@UAE@XZ:PROC			; CQueueTimer::~CQueueTimer
EXTRN	__imp__timeEndPeriod@4:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_ECMuTimer@@UAEPAXI@Z:PROC			; CMuTimer::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@CMuTimer@@8
; File c:\muserver_dev\development\mu-s8ep2-repack\gameserver\source\mutimer.cpp
rdata$r	SEGMENT
??_R1A@?0A@EA@CMuTimer@@8 DD FLAT:??_R0?AVCMuTimer@@@8	; CMuTimer::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CMuTimer@@8
rdata$r	ENDS
;	COMDAT ??_R2CMuTimer@@8
rdata$r	SEGMENT
??_R2CMuTimer@@8 DD FLAT:??_R1A@?0A@EA@CMuTimer@@8	; CMuTimer::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CMuTimer@@8
rdata$r	SEGMENT
??_R3CMuTimer@@8 DD 00H					; CMuTimer::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CMuTimer@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCMuTimer@@@8
_DATA	SEGMENT
??_R0?AVCMuTimer@@@8 DD FLAT:??_7type_info@@6B@		; CMuTimer `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCMuTimer@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CMuTimer@@6B@
rdata$r	SEGMENT
??_R4CMuTimer@@6B@ DD 00H				; CMuTimer::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCMuTimer@@@8
	DD	FLAT:??_R3CMuTimer@@8
rdata$r	ENDS
;	COMDAT ??_7CMuTimer@@6B@
CONST	SEGMENT
??_7CMuTimer@@6B@ DD FLAT:??_R4CMuTimer@@6B@		; CMuTimer::`vftable'
	DD	FLAT:??_ECMuTimer@@UAEPAXI@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1CMuTimer@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CMuTimer@@UAE@XZ$0
__ehfuncinfo$??1CMuTimer@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1CMuTimer@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
xdata$x	ENDS
;	COMDAT ??1CMuTimer@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CMuTimer@@UAE@XZ PROC				; CMuTimer::~CMuTimer, COMDAT
; _this$ = ecx

; 61   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1CMuTimer@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b f1		 mov	 esi, ecx
  00026	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  00029	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7CMuTimer@@6B@

; 62   : 	timeEndPeriod(1);

  0002f	6a 01		 push	 1
  00031	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00038	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__timeEndPeriod@4

; 63   : }

  0003e	8d 4e 44	 lea	 ecx, DWORD PTR [esi+68]
  00041	e8 00 00 00 00	 call	 ??1CQueueTimer@@UAE@XZ	; CQueueTimer::~CQueueTimer
  00046	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00049	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00050	e8 00 00 00 00	 call	 ??1CQueueTimer@@UAE@XZ	; CQueueTimer::~CQueueTimer
  00055	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00058	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005f	59		 pop	 ecx
  00060	5e		 pop	 esi
  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CMuTimer@@UAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 04	 add	 ecx, 4
  00006	e9 00 00 00 00	 jmp	 ??1CQueueTimer@@UAE@XZ	; CQueueTimer::~CQueueTimer
__ehhandler$??1CMuTimer@@UAE@XZ:
  0000b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000f	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00012	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00015	33 c8		 xor	 ecx, eax
  00017	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001c	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1CMuTimer@@UAE@XZ
  00021	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1CMuTimer@@UAE@XZ ENDP				; CMuTimer::~CMuTimer
PUBLIC	?SetMuTimer@CMuTimer@@QAEXXZ			; CMuTimer::SetMuTimer
EXTRN	?g_ConnectMemberReloadTime@@3HA:DWORD		; g_ConnectMemberReloadTime
EXTRN	?g_ConnectMemberReload@@3_NA:BYTE		; g_ConnectMemberReload
EXTRN	?CreateTimer@CQueueTimer@@QAEHHKK@Z:PROC	; CQueueTimer::CreateTimer
; Function compile flags: /Ogtp
;	COMDAT ?SetMuTimer@CMuTimer@@QAEXXZ
_TEXT	SEGMENT
?SetMuTimer@CMuTimer@@QAEXXZ PROC			; CMuTimer::SetMuTimer, COMDAT
; _this$ = ecx

; 66   : {

  00000	56		 push	 esi
  00001	57		 push	 edi

; 67   : VM_START
; 68   : 	INT		result;
; 69   : 
; 70   : 	DWORD	MuTimer1Flag = 0x20;
; 71   : 	DWORD	MuTimer2Flag = 0x01;
; 72   : 
; 73   : 	MuTimer1Flag = 0x00010000|MuTimer1Flag;
; 74   : 	MuTimer2Flag = 0x00010000|MuTimer2Flag;
; 75   : 
; 76   : 	result = this->m_QueueTimer1.CreateTimer(WM_SET_DATE,60000,MuTimer1Flag);

  00002	68 20 00 01 00	 push	 65568			; 00010020H
  00007	8b f9		 mov	 edi, ecx
  00009	68 60 ea 00 00	 push	 60000			; 0000ea60H
  0000e	68 e9 03 00 00	 push	 1001			; 000003e9H
  00013	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]
  00016	e8 00 00 00 00	 call	 ?CreateTimer@CQueueTimer@@QAEHHKK@Z ; CQueueTimer::CreateTimer

; 77   : 	result = this->m_QueueTimer1.CreateTimer(WM_LOG_DATE_CHANGE,60000,MuTimer1Flag);

  0001b	68 20 00 01 00	 push	 65568			; 00010020H
  00020	68 60 ea 00 00	 push	 60000			; 0000ea60H
  00025	68 eb 03 00 00	 push	 1003			; 000003ebH
  0002a	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]
  0002d	e8 00 00 00 00	 call	 ?CreateTimer@CQueueTimer@@QAEHHKK@Z ; CQueueTimer::CreateTimer

; 78   : 	
; 79   : 	//result = this->m_QueueTimer1.CreateTimer(0x3EF,10000,MuTimer1Flag);
; 80   : 	result = this->m_QueueTimer1.CreateTimer(WM_CONNECT_DATASERVER,10000,MuTimer1Flag);

  00032	68 20 00 01 00	 push	 65568			; 00010020H
  00037	68 10 27 00 00	 push	 10000			; 00002710H
  0003c	68 ef 03 00 00	 push	 1007			; 000003efH
  00041	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]
  00044	e8 00 00 00 00	 call	 ?CreateTimer@CQueueTimer@@QAEHHKK@Z ; CQueueTimer::CreateTimer

; 81   : 	
; 82   : 	result = this->m_QueueTimer1.CreateTimer(WM_GS_CLOSE,1000,MuTimer1Flag);

  00049	68 20 00 01 00	 push	 65568			; 00010020H
  0004e	68 e8 03 00 00	 push	 1000			; 000003e8H
  00053	68 ea 03 00 00	 push	 1002			; 000003eaH
  00058	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]
  0005b	e8 00 00 00 00	 call	 ?CreateTimer@CQueueTimer@@QAEHHKK@Z ; CQueueTimer::CreateTimer

; 83   : 	result = this->m_QueueTimer1.CreateTimer(WM_MONSTER_AND_MSG_PROC,500,MuTimer1Flag);

  00060	68 20 00 01 00	 push	 65568			; 00010020H
  00065	68 f4 01 00 00	 push	 500			; 000001f4H
  0006a	68 ee 03 00 00	 push	 1006			; 000003eeH
  0006f	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]
  00072	e8 00 00 00 00	 call	 ?CreateTimer@CQueueTimer@@QAEHHKK@Z ; CQueueTimer::CreateTimer

; 84   : 	result = this->m_QueueTimer1.CreateTimer(WM_MOVE_MONSTER_PROC,300,MuTimer1Flag);

  00077	68 20 00 01 00	 push	 65568			; 00010020H
  0007c	68 2c 01 00 00	 push	 300			; 0000012cH
  00081	68 ed 03 00 00	 push	 1005			; 000003edH
  00086	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]
  00089	e8 00 00 00 00	 call	 ?CreateTimer@CQueueTimer@@QAEHHKK@Z ; CQueueTimer::CreateTimer

; 85   : 	result = this->m_QueueTimer1.CreateTimer(WM_EVENT_RUN_PROC,100,MuTimer1Flag);

  0008e	68 20 00 01 00	 push	 65568			; 00010020H
  00093	6a 64		 push	 100			; 00000064H
  00095	68 ec 03 00 00	 push	 1004			; 000003ecH
  0009a	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]
  0009d	e8 00 00 00 00	 call	 ?CreateTimer@CQueueTimer@@QAEHHKK@Z ; CQueueTimer::CreateTimer

; 86   : 	result = this->m_QueueTimer1.CreateTimer(WM_AI_MONSTER_MOVE_PROC,100,MuTimer1Flag);

  000a2	68 20 00 01 00	 push	 65568			; 00010020H
  000a7	6a 64		 push	 100			; 00000064H
  000a9	68 f2 03 00 00	 push	 1010			; 000003f2H
  000ae	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]
  000b1	e8 00 00 00 00	 call	 ?CreateTimer@CQueueTimer@@QAEHHKK@Z ; CQueueTimer::CreateTimer

; 87   : 	result = this->m_QueueTimer1.CreateTimer(WM_AI_MONSTER_PROC,500,MuTimer1Flag);

  000b6	68 20 00 01 00	 push	 65568			; 00010020H
  000bb	68 f4 01 00 00	 push	 500			; 000001f4H
  000c0	68 f3 03 00 00	 push	 1011			; 000003f3H
  000c5	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]
  000c8	e8 00 00 00 00	 call	 ?CreateTimer@CQueueTimer@@QAEHHKK@Z ; CQueueTimer::CreateTimer

; 88   : 	result = this->m_QueueTimer1.CreateTimer(WM_GUILD_LIST_REQUEST,0,MuTimer1Flag | 8);

  000cd	68 28 00 01 00	 push	 65576			; 00010028H
  000d2	6a 00		 push	 0
  000d4	68 f0 03 00 00	 push	 1008			; 000003f0H
  000d9	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]
  000dc	e8 00 00 00 00	 call	 ?CreateTimer@CQueueTimer@@QAEHHKK@Z ; CQueueTimer::CreateTimer

; 89   : 	result = this->m_QueueTimer1.CreateTimer(WM_SECOND_MSG_PROCESS,1000,MuTimer1Flag);

  000e1	68 20 00 01 00	 push	 65568			; 00010020H
  000e6	68 e8 03 00 00	 push	 1000			; 000003e8H
  000eb	68 e8 03 00 00	 push	 1000			; 000003e8H
  000f0	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]
  000f3	e8 00 00 00 00	 call	 ?CreateTimer@CQueueTimer@@QAEHHKK@Z ; CQueueTimer::CreateTimer

; 90   : 
; 91   : 	result = this->m_QueueTimer1.CreateTimer(WM_DUEL_RUN_PROC,1000,MuTimer1Flag);

  000f8	68 20 00 01 00	 push	 65568			; 00010020H
  000fd	68 e8 03 00 00	 push	 1000			; 000003e8H
  00102	68 f6 03 00 00	 push	 1014			; 000003f6H
  00107	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]
  0010a	e8 00 00 00 00	 call	 ?CreateTimer@CQueueTimer@@QAEHHKK@Z ; CQueueTimer::CreateTimer

; 92   : 
; 93   : 	if( g_ConnectMemberReload == true && g_ConnectMemberReloadTime > 0 )

  0010f	80 3d 00 00 00
	00 01		 cmp	 BYTE PTR ?g_ConnectMemberReload@@3_NA, 1 ; g_ConnectMemberReload
  00116	75 22		 jne	 SHORT $LN1@SetMuTimer
  00118	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_ConnectMemberReloadTime@@3HA ; g_ConnectMemberReloadTime
  0011d	85 c0		 test	 eax, eax
  0011f	7e 19		 jle	 SHORT $LN1@SetMuTimer

; 94   : 	{
; 95   : 		result = this->m_QueueTimer1.CreateTimer(WM_CONNECTMEMBER_RELOAD, 1000 * 60 * g_ConnectMemberReloadTime, MuTimer1Flag);

  00121	69 c0 60 ea 00
	00		 imul	 eax, 60000		; 0000ea60H
  00127	68 20 00 01 00	 push	 65568			; 00010020H
  0012c	50		 push	 eax
  0012d	68 f8 03 00 00	 push	 1016			; 000003f8H
  00132	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]
  00135	e8 00 00 00 00	 call	 ?CreateTimer@CQueueTimer@@QAEHHKK@Z ; CQueueTimer::CreateTimer
$LN1@SetMuTimer:

; 96   : 	}
; 97   : 
; 98   : 	//THE PROBLEM IS IN THESE TIMERS
; 99   : 	result = this->m_QueueTimer2.CreateTimer(WM_FIRST_MSG_PROCESS, 1000, MuTimer2Flag);

  0013a	68 01 00 01 00	 push	 65537			; 00010001H
  0013f	68 e8 03 00 00	 push	 1000			; 000003e8H
  00144	6a 65		 push	 101			; 00000065H
  00146	8d 4f 44	 lea	 ecx, DWORD PTR [edi+68]
  00149	e8 00 00 00 00	 call	 ?CreateTimer@CQueueTimer@@QAEHHKK@Z ; CQueueTimer::CreateTimer

; 100  : 	result = this->m_QueueTimer2.CreateTimer(WM_VIEWPORT_UPDATE, 1000, MuTimer2Flag);

  0014e	68 01 00 01 00	 push	 65537			; 00010001H
  00153	68 e8 03 00 00	 push	 1000			; 000003e8H
  00158	68 f4 03 00 00	 push	 1012			; 000003f4H
  0015d	8d 4f 44	 lea	 ecx, DWORD PTR [edi+68]
  00160	e8 00 00 00 00	 call	 ?CreateTimer@CQueueTimer@@QAEHHKK@Z ; CQueueTimer::CreateTimer
  00165	5f		 pop	 edi
  00166	5e		 pop	 esi

; 101  : VM_END
; 102  : }

  00167	c3		 ret	 0
?SetMuTimer@CMuTimer@@QAEXXZ ENDP			; CMuTimer::SetMuTimer
_TEXT	ENDS
PUBLIC	?GetTimerEnd@CMuTimer@@QAEHXZ			; CMuTimer::GetTimerEnd
; Function compile flags: /Ogtp
;	COMDAT ?GetTimerEnd@CMuTimer@@QAEHXZ
_TEXT	SEGMENT
?GetTimerEnd@CMuTimer@@QAEHXZ PROC			; CMuTimer::GetTimerEnd, COMDAT
; _this$ = ecx

; 305  : 	return this->m_bTimerEnd;

  00000	8b 81 84 00 00
	00		 mov	 eax, DWORD PTR [ecx+132]

; 306  : }

  00006	c3		 ret	 0
?GetTimerEnd@CMuTimer@@QAEHXZ ENDP			; CMuTimer::GetTimerEnd
_TEXT	ENDS
PUBLIC	?TimerProcQueue2@@YGXPAXH@Z			; TimerProcQueue2
EXTRN	?GameServerInfoSend@@YAXXZ:PROC			; GameServerInfoSend
EXTRN	?gObjSetState@@YAXXZ:PROC			; gObjSetState
EXTRN	?gObjUnionUpdateProc@@YAXH@Z:PROC		; gObjUnionUpdateProc
EXTRN	?gObj@@3PAUOBJECTSTRUCT@@A:DWORD		; gObj
EXTRN	?gObjIsConnected@@YAHH@Z:PROC			; gObjIsConnected
EXTRN	?PShop_ViewportListRegenarate@@YAXF@Z:PROC	; PShop_ViewportListRegenarate
EXTRN	?gDoPShopOpen@@3HA:DWORD			; gDoPShopOpen
EXTRN	?SyncUnlock@CQueueTimer@@QAEXXZ:PROC		; CQueueTimer::SyncUnlock
EXTRN	?gObjViewportListProtocol@@YAXF@Z:PROC		; gObjViewportListProtocol
EXTRN	?gObjViewportListCreate@@YAXF@Z:PROC		; gObjViewportListCreate
EXTRN	?gObjViewportListDestroy@@YAXF@Z:PROC		; gObjViewportListDestroy
EXTRN	?gObjStateSetCreate@@YAXH@Z:PROC		; gObjStateSetCreate
EXTRN	?SyncLock@CQueueTimer@@QAEXXZ:PROC		; CQueueTimer::SyncLock
; Function compile flags: /Ogtp
;	COMDAT ?TimerProcQueue2@@YGXPAXH@Z
_TEXT	SEGMENT
_lpParametar$ = 8					; size = 4
_TimerOrWaitFired$ = 12					; size = 4
?TimerProcQueue2@@YGXPAXH@Z PROC			; TimerProcQueue2, COMDAT

; 309  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 310  : 	if (g_MuTimer.GetTimerEnd() == TRUE)

  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MuTimer@@3VCMuTimer@@A ; g_MuTimer
  00008	e8 00 00 00 00	 call	 ?GetTimerEnd@CMuTimer@@QAEHXZ ; CMuTimer::GetTimerEnd
  0000d	83 f8 01	 cmp	 eax, 1
  00010	0f 84 e2 00 00
	00		 je	 $LN20@TimerProcQ

; 311  : 	{
; 312  : 		return;
; 313  : 	}
; 314  : 	
; 315  : 	g_MuTimer.m_QueueTimer2.SyncLock();

  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	b9 44 00 00 00	 mov	 ecx, OFFSET ?g_MuTimer@@3VCMuTimer@@A+68
  0001d	e8 00 00 00 00	 call	 ?SyncLock@CQueueTimer@@QAEXXZ ; CQueueTimer::SyncLock

; 316  : 		
; 317  : 	int nEventID = *(DWORD*)lpParametar;

  00022	8b 45 08	 mov	 eax, DWORD PTR _lpParametar$[ebp]
  00025	8b 00		 mov	 eax, DWORD PTR [eax]

; 318  : 	
; 319  : 	switch (nEventID)

  00027	83 f8 65	 cmp	 eax, 101		; 00000065H
  0002a	74 4b		 je	 SHORT $LN16@TimerProcQ
  0002c	3d f4 03 00 00	 cmp	 eax, 1012		; 000003f4H
  00031	0f 85 b5 00 00
	00		 jne	 $LN17@TimerProcQ

; 349  : 
; 350  : 		} break;
; 351  : 		
; 352  : 		case WM_VIEWPORT_UPDATE:
; 353  : 		{
; 354  : 			for (int n = 0; n < OBJMAX; n++)

  00037	33 f6		 xor	 esi, esi
  00039	8d a4 24 00 00
	00 00		 npad	 7
$LL3@TimerProcQ:

; 355  : 			{
; 356  : 				gObjStateSetCreate(n);

  00040	56		 push	 esi
  00041	e8 00 00 00 00	 call	 ?gObjStateSetCreate@@YAXH@Z ; gObjStateSetCreate

; 357  : 				gObjViewportListDestroy(n);

  00046	0f b7 fe	 movzx	 edi, si
  00049	57		 push	 edi
  0004a	e8 00 00 00 00	 call	 ?gObjViewportListDestroy@@YAXF@Z ; gObjViewportListDestroy

; 358  : 				gObjViewportListCreate(n);

  0004f	57		 push	 edi
  00050	e8 00 00 00 00	 call	 ?gObjViewportListCreate@@YAXF@Z ; gObjViewportListCreate

; 359  : 				gObjViewportListProtocol(n);

  00055	57		 push	 edi
  00056	e8 00 00 00 00	 call	 ?gObjViewportListProtocol@@YAXF@Z ; gObjViewportListProtocol
  0005b	46		 inc	 esi
  0005c	83 c4 10	 add	 esp, 16			; 00000010H
  0005f	81 fe ec 2c 00
	00		 cmp	 esi, 11500		; 00002cecH
  00065	7c d9		 jl	 SHORT $LL3@TimerProcQ

; 360  : 			}
; 361  : 		} 
; 362  : 		break;
; 363  : 	}
; 364  : 		
; 365  : 	g_MuTimer.m_QueueTimer2.SyncUnlock();

  00067	b9 44 00 00 00	 mov	 ecx, OFFSET ?g_MuTimer@@3VCMuTimer@@A+68
  0006c	e8 00 00 00 00	 call	 ?SyncUnlock@CQueueTimer@@QAEXXZ ; CQueueTimer::SyncUnlock
  00071	5f		 pop	 edi
  00072	5e		 pop	 esi

; 366  : }

  00073	5d		 pop	 ebp
  00074	c2 08 00	 ret	 8
$LN16@TimerProcQ:

; 320  : 	{
; 321  : 		case WM_FIRST_MSG_PROCESS:
; 322  : 		{
; 323  : 			int n;
; 324  : 
; 325  : 			if (gDoPShopOpen != FALSE)

  00077	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gDoPShopOpen@@3HA, 0 ; gDoPShopOpen
  0007e	74 4b		 je	 SHORT $LN9@TimerProcQ

; 326  : 			{
; 327  : 				for (n=OBJ_STARTUSERINDEX; n<OBJMAX; n++)

  00080	be 04 29 00 00	 mov	 esi, 10500		; 00002904H
$LL14@TimerProcQ:

; 328  : 				{
; 329  : 					PShop_ViewportListRegenarate(n);

  00085	56		 push	 esi
  00086	e8 00 00 00 00	 call	 ?PShop_ViewportListRegenarate@@YAXF@Z ; PShop_ViewportListRegenarate
  0008b	46		 inc	 esi
  0008c	83 c4 04	 add	 esp, 4
  0008f	81 fe ec 2c 00
	00		 cmp	 esi, 11500		; 00002cecH
  00095	7c ee		 jl	 SHORT $LL14@TimerProcQ

; 330  : 				}
; 331  : 				
; 332  : 				for (n=OBJ_STARTUSERINDEX; n<OBJMAX; n++)

  00097	bf 04 29 00 00	 mov	 edi, 10500		; 00002904H
  0009c	be 00 dd 49 06	 mov	 esi, 105504000		; 0649dd00H
$LL11@TimerProcQ:

; 333  : 				{
; 334  : 					if (gObjIsConnected(n) != PLAYER_EMPTY)

  000a1	57		 push	 edi
  000a2	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  000a7	83 c4 04	 add	 esp, 4
  000aa	85 c0		 test	 eax, eax
  000ac	74 0e		 je	 SHORT $LN10@TimerProcQ

; 335  : 					{
; 336  : 						gObj[n].m_bPShopItemChange = false;

  000ae	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000b4	c6 84 0e 5e 12
	00 00 00	 mov	 BYTE PTR [esi+ecx+4702], 0
$LN10@TimerProcQ:

; 330  : 				}
; 331  : 				
; 332  : 				for (n=OBJ_STARTUSERINDEX; n<OBJMAX; n++)

  000bc	81 c6 40 27 00
	00		 add	 esi, 10048		; 00002740H
  000c2	47		 inc	 edi
  000c3	81 fe 00 2f e3
	06		 cmp	 esi, 115552000		; 06e32f00H
  000c9	7c d6		 jl	 SHORT $LL11@TimerProcQ
$LN9@TimerProcQ:

; 337  : 					}
; 338  : 				}
; 339  : 			}
; 340  : 			
; 341  : 			for (n=OBJ_STARTUSERINDEX; n<OBJMAX; n++)

  000cb	be 04 29 00 00	 mov	 esi, 10500		; 00002904H
$LL7@TimerProcQ:

; 342  : 			{
; 343  : 				gObjUnionUpdateProc(n);

  000d0	56		 push	 esi
  000d1	e8 00 00 00 00	 call	 ?gObjUnionUpdateProc@@YAXH@Z ; gObjUnionUpdateProc
  000d6	46		 inc	 esi
  000d7	83 c4 04	 add	 esp, 4
  000da	81 fe ec 2c 00
	00		 cmp	 esi, 11500		; 00002cecH
  000e0	7c ee		 jl	 SHORT $LL7@TimerProcQ

; 344  : 			}
; 345  : 			
; 346  : 			gObjSetState();

  000e2	e8 00 00 00 00	 call	 ?gObjSetState@@YAXXZ	; gObjSetState

; 347  : 
; 348  : 			GameServerInfoSend();

  000e7	e8 00 00 00 00	 call	 ?GameServerInfoSend@@YAXXZ ; GameServerInfoSend
$LN17@TimerProcQ:

; 360  : 			}
; 361  : 		} 
; 362  : 		break;
; 363  : 	}
; 364  : 		
; 365  : 	g_MuTimer.m_QueueTimer2.SyncUnlock();

  000ec	b9 44 00 00 00	 mov	 ecx, OFFSET ?g_MuTimer@@3VCMuTimer@@A+68
  000f1	e8 00 00 00 00	 call	 ?SyncUnlock@CQueueTimer@@QAEXXZ ; CQueueTimer::SyncUnlock
  000f6	5f		 pop	 edi
  000f7	5e		 pop	 esi
$LN20@TimerProcQ:

; 366  : }

  000f8	5d		 pop	 ebp
  000f9	c2 08 00	 ret	 8
?TimerProcQueue2@@YGXPAXH@Z ENDP			; TimerProcQueue2
_TEXT	ENDS
PUBLIC	?SetTimerEnd@CMuTimer@@QAEXXZ			; CMuTimer::SetTimerEnd
; Function compile flags: /Ogtp
;	COMDAT ?SetTimerEnd@CMuTimer@@QAEXXZ
_TEXT	SEGMENT
?SetTimerEnd@CMuTimer@@QAEXXZ PROC			; CMuTimer::SetTimerEnd, COMDAT
; _this$ = ecx

; 370  : 	this->m_bTimerEnd = TRUE;

  00000	c7 81 84 00 00
	00 01 00 00 00	 mov	 DWORD PTR [ecx+132], 1

; 371  : }

  0000a	c3		 ret	 0
?SetTimerEnd@CMuTimer@@QAEXXZ ENDP			; CMuTimer::SetTimerEnd
_TEXT	ENDS
PUBLIC	??_EOBJECTSTRUCT@@QAEPAXI@Z			; OBJECTSTRUCT::`vector deleting destructor'
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	??_M@YGXPAXIHP6EX0@Z@Z:PROC			; `eh vector destructor iterator'
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??_EOBJECTSTRUCT@@QAEPAXI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??_EOBJECTSTRUCT@@QAEPAXI@Z$0
__ehfuncinfo$??_EOBJECTSTRUCT@@QAEPAXI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??_EOBJECTSTRUCT@@QAEPAXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
xdata$x	ENDS
;	COMDAT ??_EOBJECTSTRUCT@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_EOBJECTSTRUCT@@QAEPAXI@Z PROC			; OBJECTSTRUCT::`vector deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??_EOBJECTSTRUCT@@QAEPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	53		 push	 ebx
  00013	56		 push	 esi
  00014	57		 push	 edi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00026	8b f1		 mov	 esi, ecx
  00028	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  0002b	8a 5d 08	 mov	 bl, BYTE PTR ___flags$[ebp]
  0002e	f6 c3 02	 test	 bl, 2
  00031	74 3b		 je	 SHORT $LN3@vector@2
  00033	8b 46 fc	 mov	 eax, DWORD PTR [esi-4]
  00036	68 00 00 00 00	 push	 OFFSET ??1OBJECTSTRUCT@@QAE@XZ
  0003b	8d 7e fc	 lea	 edi, DWORD PTR [esi-4]
  0003e	50		 push	 eax
  0003f	68 40 27 00 00	 push	 10048			; 00002740H
  00044	56		 push	 esi
  00045	e8 00 00 00 00	 call	 ??_M@YGXPAXIHP6EX0@Z@Z
  0004a	f6 c3 01	 test	 bl, 1
  0004d	74 09		 je	 SHORT $LN2@vector@2
  0004f	57		 push	 edi
  00050	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00055	83 c4 04	 add	 esp, 4
$LN2@vector@2:
  00058	8b c7		 mov	 eax, edi
  0005a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0005d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00064	59		 pop	 ecx
  00065	5f		 pop	 edi
  00066	5e		 pop	 esi
  00067	5b		 pop	 ebx
  00068	8b e5		 mov	 esp, ebp
  0006a	5d		 pop	 ebp
  0006b	c2 04 00	 ret	 4
$LN3@vector@2:
  0006e	8d 8e ec 20 00
	00		 lea	 ecx, DWORD PTR [esi+8428]
  00074	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0007b	e8 00 00 00 00	 call	 ??1TMonsterAIAgro@@UAE@XZ ; TMonsterAIAgro::~TMonsterAIAgro
  00080	8d 8e 0c 16 00
	00		 lea	 ecx, DWORD PTR [esi+5644]
  00086	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0008d	e8 00 00 00 00	 call	 ??1CSkillDelay@@UAE@XZ	; CSkillDelay::~CSkillDelay
  00092	f6 c3 01	 test	 bl, 1
  00095	74 09		 je	 SHORT $LN1@vector@2
  00097	56		 push	 esi
  00098	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0009d	83 c4 04	 add	 esp, 4
$LN1@vector@2:
  000a0	8b c6		 mov	 eax, esi
  000a2	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000a5	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000ac	59		 pop	 ecx
  000ad	5f		 pop	 edi
  000ae	5e		 pop	 esi
  000af	5b		 pop	 ebx
  000b0	8b e5		 mov	 esp, ebp
  000b2	5d		 pop	 ebp
  000b3	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??_EOBJECTSTRUCT@@QAEPAXI@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	81 c1 0c 16 00
	00		 add	 ecx, 5644		; 0000160cH
  00009	e9 00 00 00 00	 jmp	 ??1CSkillDelay@@UAE@XZ	; CSkillDelay::~CSkillDelay
__ehhandler$??_EOBJECTSTRUCT@@QAEPAXI@Z:
  0000e	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00012	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00015	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00018	33 c8		 xor	 ecx, eax
  0001a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001f	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??_EOBJECTSTRUCT@@QAEPAXI@Z
  00024	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??_EOBJECTSTRUCT@@QAEPAXI@Z ENDP			; OBJECTSTRUCT::`vector deleting destructor'
; Function compile flags: /Ogtp
;	COMDAT ??_GCMuTimer@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCMuTimer@@UAEPAXI@Z PROC				; CMuTimer::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1CMuTimer@@UAE@XZ	; CMuTimer::~CMuTimer
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 09		 je	 SHORT $LN4@scalar
  00011	56		 push	 esi
  00012	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00017	83 c4 04	 add	 esp, 4
$LN4@scalar:
  0001a	8b c6		 mov	 eax, esi
  0001c	5e		 pop	 esi
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
??_GCMuTimer@@UAEPAXI@Z ENDP				; CMuTimer::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_C@_0BC@FGIEIEFL@ConnectMember?4txt?$AA@	; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?TimerProcQueue@@YGXPAXH@Z			; TimerProcQueue
EXTRN	?g_iCastleItemMixLimit@@3HA:DWORD		; g_iCastleItemMixLimit
EXTRN	?LogDateChange@@YAHXZ:PROC			; LogDateChange
EXTRN	?ClearOverTimeUserData@CTemporaryUserManager@@QAEHK@Z:PROC ; CTemporaryUserManager::ClearOverTimeUserData
EXTRN	?cpTimerTempUserManager@@3PAVCTemporaryUserManager@@A:DWORD ; cpTimerTempUserManager
EXTRN	?g_MaintainUserConnectionSecond@@3HA:DWORD	; g_MaintainUserConnectionSecond
EXTRN	?TimeCheckCashDelete@CWhisperCash@@QAEXXZ:PROC	; CWhisperCash::TimeCheckCashDelete
EXTRN	?WhisperCash@@3VCWhisperCash@@A:BYTE		; WhisperCash
EXTRN	?gSetDate@@YAXXZ:PROC				; gSetDate
EXTRN	?UpdateRun@CGensSystem@@QAEXXZ:PROC		; CGensSystem::UpdateRun
EXTRN	?gGensSystem@@3VCGensSystem@@A:BYTE		; gGensSystem
EXTRN	?CrywolfSecondAct@CCrywolf@@QAEXXZ:PROC		; CCrywolf::CrywolfSecondAct
EXTRN	?AdjustTributeMoney@CCastleSiegeSync@@QAEXXZ:PROC ; CCastleSiegeSync::AdjustTributeMoney
EXTRN	?g_CastleSiegeSync@@3VCCastleSiegeSync@@A:BYTE	; g_CastleSiegeSync
EXTRN	?SendCastleStateSync@CCastleSiege@@QAEXXZ:PROC	; CCastleSiege::SendCastleStateSync
EXTRN	?DataRequest@CCastleSiege@@QAEHXZ:PROC		; CCastleSiege::DataRequest
EXTRN	?GetDataLoadState@CCastleSiege@@QAEHXZ:PROC	; CCastleSiege::GetDataLoadState
EXTRN	?GetActiveDS@DBSockMng@@QAEHXZ:PROC		; DBSockMng::GetActiveDS
EXTRN	?cDBSMng@@3VDBSockMng@@A:BYTE			; cDBSMng
EXTRN	?gObjSecondProc@@YAXXZ:PROC			; gObjSecondProc
EXTRN	?gObjAllLogOut@@YAXXZ:PROC			; gObjAllLogOut
EXTRN	__imp__KillTimer@8:PROC
EXTRN	?ghWnd@@3PAUHWND__@@A:DWORD			; ghWnd
EXTRN	__imp__wsprintfA:PROC
EXTRN	?LogAddC@@3P6AXEPADZZA:DWORD			; LogAddC
EXTRN	?AllSendServerMsg@@YAXPAD@Z:PROC		; AllSendServerMsg
EXTRN	?Get@Message@@QAEPADH@Z:PROC			; Message::Get
EXTRN	?lMsg@@3VMessage@@A:BYTE			; lMsg
EXTRN	?gCloseMsgTime@@3HA:DWORD			; gCloseMsgTime
EXTRN	?gCloseMsg@@3HA:DWORD				; gCloseMsg
EXTRN	?Load@CConMember@@QAEXPAD@Z:PROC		; CConMember::Load
EXTRN	?ConMember@@3VCConMember@@A:BYTE		; ConMember
EXTRN	?GetNewPath@CDirPath@@QAEPADPAD@Z:PROC		; CDirPath::GetNewPath
EXTRN	?gDirPath@@3VCDirPath@@A:BYTE			; gDirPath
EXTRN	?Run@CEventManagement@@QAEXXZ:PROC		; CEventManagement::Run
EXTRN	?g_EventManager@@3VCEventManagement@@A:BYTE	; g_EventManager
EXTRN	?Run@CEledoradoEvent@@QAEXXZ:PROC		; CEledoradoEvent::Run
EXTRN	?gEledoradoEvent@@3VCEledoradoEvent@@A:BYTE	; gEledoradoEvent
EXTRN	?Run@CAttackEvent@@QAEXXZ:PROC			; CAttackEvent::Run
EXTRN	?AttackEvent@@3PAVCAttackEvent@@A:DWORD		; AttackEvent
EXTRN	?Run@CDragonEvent@@QAEXXZ:PROC			; CDragonEvent::Run
EXTRN	?DragonEvent@@3PAVCDragonEvent@@A:DWORD		; DragonEvent
EXTRN	?wsGServer@@3VCwsGameServer@@A:BYTE		; wsGServer
EXTRN	?WeatherVariationProcess@MapClass@@QAEXXZ:PROC	; MapClass::WeatherVariationProcess
EXTRN	?MapC@@3PAVMapClass@@A:BYTE			; MapC
EXTRN	?MonsterAIProc@TMonsterAI@@SAXXZ:PROC		; TMonsterAI::MonsterAIProc
EXTRN	?MonsterMoveProc@TMonsterAI@@SAXXZ:PROC		; TMonsterAI::MonsterMoveProc
EXTRN	?Run@CDoubleGoerEvent@@QAEXXZ:PROC		; CDoubleGoerEvent::Run
EXTRN	?gDoubleGoer@@3VCDoubleGoerEvent@@A:BYTE	; gDoubleGoer
EXTRN	?Run@CImperialGuardian@@QAEXXZ:PROC		; CImperialGuardian::Run
EXTRN	?g_ImperialGuardian@@3VCImperialGuardian@@A:BYTE ; g_ImperialGuardian
EXTRN	?Run@CXMasAttackEvent@@QAEXXZ:PROC		; CXMasAttackEvent::Run
EXTRN	?g_XMasAttackEvent@@3VCXMasAttackEvent@@A:BYTE	; g_XMasAttackEvent
EXTRN	?Run@CRaklion@@QAEXXZ:PROC			; CRaklion::Run
EXTRN	?g_Raklion@@3VCRaklion@@A:BYTE			; g_Raklion
EXTRN	?Run@CKanturu@@QAEXXZ:PROC			; CKanturu::Run
EXTRN	?Run@CCrywolf@@QAEXXZ:PROC			; CCrywolf::Run
EXTRN	?g_Crywolf@@3VCCrywolf@@A:BYTE			; g_Crywolf
EXTRN	?WeaponAttackProc@CWeapon@@QAEXXZ:PROC		; CWeapon::WeaponAttackProc
EXTRN	?g_CsNPC_Weapon@@3VCWeapon@@A:BYTE		; g_CsNPC_Weapon
EXTRN	?Run@CCastleDeepEvent@@QAEXXZ:PROC		; CCastleDeepEvent::Run
EXTRN	?g_CastleDeepEvent@@3VCCastleDeepEvent@@A:BYTE	; g_CastleDeepEvent
EXTRN	?Run@CCastleSiege@@QAEXXZ:PROC			; CCastleSiege::Run
EXTRN	?g_CastleSiege@@3VCCastleSiege@@A:BYTE		; g_CastleSiege
EXTRN	?Run@CIllusionTempleEvent@@QAEXXZ:PROC		; CIllusionTempleEvent::Run
EXTRN	?g_IllusionTemple@@3VCIllusionTempleEvent@@A:BYTE ; g_IllusionTemple
EXTRN	?Run@CChaosCastle@@QAEXXZ:PROC			; CChaosCastle::Run
EXTRN	?g_ChaosCastle@@3VCChaosCastle@@A:BYTE		; g_ChaosCastle
EXTRN	?Run@CRingAttackEvent@@QAEXXZ:PROC		; CRingAttackEvent::Run
EXTRN	?g_RingAttackEvent@@3VCRingAttackEvent@@A:BYTE	; g_RingAttackEvent
EXTRN	?Run@CBloodCastle@@QAEXXZ:PROC			; CBloodCastle::Run
EXTRN	?g_BloodCastle@@3VCBloodCastle@@A:BYTE		; g_BloodCastle
EXTRN	?procRun@MonsterSpawnerMng@@QAEXXZ:PROC		; MonsterSpawnerMng::procRun
EXTRN	?UserMonsterCountCheck@CKanturu@@QAEXXZ:PROC	; CKanturu::UserMonsterCountCheck
EXTRN	?g_Kanturu@@3VCKanturu@@A:BYTE			; g_Kanturu
EXTRN	?MoveMonsterProc@@YAXXZ:PROC			; MoveMonsterProc
EXTRN	?Run@CNewPVP@@QAEXXZ:PROC			; CNewPVP::Run
EXTRN	?g_NewPVP@@3VCNewPVP@@A:BYTE			; g_NewPVP
EXTRN	?MonsterAndMsgProc@@YAXXZ:PROC			; MonsterAndMsgProc
EXTRN	?DGGuildListRequest@@YAXXZ:PROC			; DGGuildListRequest
;	COMDAT ??_C@_0BC@FGIEIEFL@ConnectMember?4txt?$AA@
CONST	SEGMENT
??_C@_0BC@FGIEIEFL@ConnectMember?4txt?$AA@ DB 'ConnectMember.txt', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?TimerProcQueue@@YGXPAXH@Z
_TEXT	SEGMENT
_szTemp$206467 = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_lpParametar$ = 8					; size = 4
_TimerOrWaitFired$ = 12					; size = 4
?TimerProcQueue@@YGXPAXH@Z PROC				; TimerProcQueue, COMDAT

; 105  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 04 01 00
	00		 sub	 esp, 260		; 00000104H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 106  : 	if( g_MuTimer.GetTimerEnd() == TRUE )

  00013	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MuTimer@@3VCMuTimer@@A ; g_MuTimer
  00018	e8 00 00 00 00	 call	 ?GetTimerEnd@CMuTimer@@QAEHXZ ; CMuTimer::GetTimerEnd
  0001d	83 f8 01	 cmp	 eax, 1
  00020	0f 84 09 03 00
	00		 je	 $LN29@TimerProcQ@2

; 107  : 		return;
; 108  : 
; 109  : 	g_MuTimer.m_QueueTimer1.SyncLock();

  00026	b9 04 00 00 00	 mov	 ecx, OFFSET ?g_MuTimer@@3VCMuTimer@@A+4
  0002b	e8 00 00 00 00	 call	 ?SyncLock@CQueueTimer@@QAEXXZ ; CQueueTimer::SyncLock

; 110  : 
; 111  : 	int nEventID = *(int*)(lpParametar);
; 112  : 	
; 113  : 	switch(nEventID)

  00030	8b 45 08	 mov	 eax, DWORD PTR _lpParametar$[ebp]
  00033	8b 00		 mov	 eax, DWORD PTR [eax]
  00035	05 18 fc ff ff	 add	 eax, -1000		; fffffc18H
  0003a	83 f8 10	 cmp	 eax, 16			; 00000010H
  0003d	0f 87 e2 02 00
	00		 ja	 $LN2@TimerProcQ@2
  00043	56		 push	 esi
  00044	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN35@TimerProcQ@2[eax*4]
$LN25@TimerProcQ@2:

; 114  : 	{
; 115  : 	case WM_GUILD_LIST_REQUEST:	DGGuildListRequest();	break;

  0004b	e8 00 00 00 00	 call	 ?DGGuildListRequest@@YAXXZ ; DGGuildListRequest
  00050	e9 cf 02 00 00	 jmp	 $LN33@TimerProcQ@2
$LN24@TimerProcQ@2:

; 116  : 	case WM_MONSTER_AND_MSG_PROC:
; 117  : 		MonsterAndMsgProc();

  00055	e8 00 00 00 00	 call	 ?MonsterAndMsgProc@@YAXXZ ; MonsterAndMsgProc

; 118  : 		//gDuelSystem.Run();
; 119  : #if (ENABLETEST_NEWPVP == 1)
; 120  : 		g_NewPVP.Run();

  0005a	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_NewPVP@@3VCNewPVP@@A ; g_NewPVP
  0005f	e8 00 00 00 00	 call	 ?Run@CNewPVP@@QAEXXZ	; CNewPVP::Run

; 121  : #endif
; 122  : 		break;

  00064	e9 bb 02 00 00	 jmp	 $LN33@TimerProcQ@2
$LN22@TimerProcQ@2:

; 123  : 	case WM_DUEL_RUN_PROC:
; 124  : 		//g_DuelManager.Run();
; 125  : 		break;
; 126  : 	case WM_MOVE_MONSTER_PROC:
; 127  : 		MoveMonsterProc();

  00069	e8 00 00 00 00	 call	 ?MoveMonsterProc@@YAXXZ	; MoveMonsterProc

; 128  : 		g_Kanturu.UserMonsterCountCheck();

  0006e	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_Kanturu@@3VCKanturu@@A ; g_Kanturu
  00073	e8 00 00 00 00	 call	 ?UserMonsterCountCheck@CKanturu@@QAEXXZ ; CKanturu::UserMonsterCountCheck

; 129  : 		break;

  00078	e9 a7 02 00 00	 jmp	 $LN33@TimerProcQ@2
$LN21@TimerProcQ@2:

; 130  : 	case WM_EVENT_RUN_PROC:
; 131  : #if (ENABLE_CUSTOM_MONSTERSPAWNER == 1)
; 132  : 		MonsterSpawnerMng::getInstance()->procRun();

  0007d	e8 00 00 00 00	 call	 ?getInstance@MonsterSpawnerMng@@SAPAV1@XZ ; MonsterSpawnerMng::getInstance
  00082	8b c8		 mov	 ecx, eax
  00084	e8 00 00 00 00	 call	 ?procRun@MonsterSpawnerMng@@QAEXXZ ; MonsterSpawnerMng::procRun

; 133  : #endif
; 134  : 		g_BloodCastle.Run();

  00089	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_BloodCastle@@3VCBloodCastle@@A ; g_BloodCastle
  0008e	e8 00 00 00 00	 call	 ?Run@CBloodCastle@@QAEXXZ ; CBloodCastle::Run

; 135  : 		g_RingAttackEvent.Run();

  00093	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_RingAttackEvent@@3VCRingAttackEvent@@A ; g_RingAttackEvent
  00098	e8 00 00 00 00	 call	 ?Run@CRingAttackEvent@@QAEXXZ ; CRingAttackEvent::Run

; 136  : 		g_ChaosCastle.Run();

  0009d	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ChaosCastle@@3VCChaosCastle@@A ; g_ChaosCastle
  000a2	e8 00 00 00 00	 call	 ?Run@CChaosCastle@@QAEXXZ ; CChaosCastle::Run

; 137  : 		g_IllusionTemple.Run();

  000a7	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_IllusionTemple@@3VCIllusionTempleEvent@@A ; g_IllusionTemple
  000ac	e8 00 00 00 00	 call	 ?Run@CIllusionTempleEvent@@QAEXXZ ; CIllusionTempleEvent::Run

; 138  : #if (GS_CASTLE==1)
; 139  : 		g_CastleSiege.Run();

  000b1	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  000b6	e8 00 00 00 00	 call	 ?Run@CCastleSiege@@QAEXXZ ; CCastleSiege::Run

; 140  : 		g_CastleDeepEvent.Run();

  000bb	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleDeepEvent@@3VCCastleDeepEvent@@A ; g_CastleDeepEvent
  000c0	e8 00 00 00 00	 call	 ?Run@CCastleDeepEvent@@QAEXXZ ; CCastleDeepEvent::Run

; 141  : 		g_CsNPC_Weapon.WeaponAttackProc();

  000c5	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CsNPC_Weapon@@3VCWeapon@@A ; g_CsNPC_Weapon
  000ca	e8 00 00 00 00	 call	 ?WeaponAttackProc@CWeapon@@QAEXXZ ; CWeapon::WeaponAttackProc

; 142  : 		g_Crywolf.Run();

  000cf	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_Crywolf@@3VCCrywolf@@A ; g_Crywolf
  000d4	e8 00 00 00 00	 call	 ?Run@CCrywolf@@QAEXXZ	; CCrywolf::Run

; 143  : #endif
; 144  : #if (GS_CASTLE == 0 || GS_SPEC == 1)
; 145  : 		g_Kanturu.Run();

  000d9	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_Kanturu@@3VCKanturu@@A ; g_Kanturu
  000de	e8 00 00 00 00	 call	 ?Run@CKanturu@@QAEXXZ	; CKanturu::Run

; 146  : 		g_CsNPC_Weapon.WeaponAttackProc();

  000e3	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CsNPC_Weapon@@3VCWeapon@@A ; g_CsNPC_Weapon
  000e8	e8 00 00 00 00	 call	 ?WeaponAttackProc@CWeapon@@QAEXXZ ; CWeapon::WeaponAttackProc

; 147  : #endif
; 148  : 		g_Raklion.Run();

  000ed	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_Raklion@@3VCRaklion@@A ; g_Raklion
  000f2	e8 00 00 00 00	 call	 ?Run@CRaklion@@QAEXXZ	; CRaklion::Run

; 149  : 		g_XMasAttackEvent.Run();

  000f7	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_XMasAttackEvent@@3VCXMasAttackEvent@@A ; g_XMasAttackEvent
  000fc	e8 00 00 00 00	 call	 ?Run@CXMasAttackEvent@@QAEXXZ ; CXMasAttackEvent::Run

; 150  : 		g_ImperialGuardian.Run();

  00101	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ImperialGuardian@@3VCImperialGuardian@@A ; g_ImperialGuardian
  00106	e8 00 00 00 00	 call	 ?Run@CImperialGuardian@@QAEXXZ ; CImperialGuardian::Run

; 151  : 		gDoubleGoer.Run();

  0010b	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDoubleGoer@@3VCDoubleGoerEvent@@A ; gDoubleGoer
  00110	e8 00 00 00 00	 call	 ?Run@CDoubleGoerEvent@@QAEXXZ ; CDoubleGoerEvent::Run

; 152  : 
; 153  : #if (ENABLETEST_ACHERON == 1)
; 154  : 		g_AcheronGuardianEvent.Run();
; 155  : #endif
; 156  : 
; 157  : #ifdef VMPROTECT
; 158  : 		if( VMProtectIsDebuggerPresent(true) )
; 159  : 		{
; 160  : 			ExitProcess(0);
; 161  : 		}
; 162  : #endif
; 163  : 		break;

  00115	e9 0a 02 00 00	 jmp	 $LN33@TimerProcQ@2
$LN20@TimerProcQ@2:

; 164  : 	case WM_AI_MONSTER_MOVE_PROC: TMonsterAI::MonsterMoveProc();	break;

  0011a	e8 00 00 00 00	 call	 ?MonsterMoveProc@TMonsterAI@@SAXXZ ; TMonsterAI::MonsterMoveProc
  0011f	e9 00 02 00 00	 jmp	 $LN33@TimerProcQ@2
$LN19@TimerProcQ@2:

; 165  : 	case WM_AI_MONSTER_PROC: TMonsterAI::MonsterAIProc();	break;

  00124	e8 00 00 00 00	 call	 ?MonsterAIProc@TMonsterAI@@SAXXZ ; TMonsterAI::MonsterAIProc
  00129	e9 f6 01 00 00	 jmp	 $LN33@TimerProcQ@2
$LN18@TimerProcQ@2:

; 166  : 	case WM_SECOND_MSG_PROCESS:
; 167  : 		{
; 168  : 			for(int n = 0; n < MAX_NUMBER_MAP; n++ )

  0012e	be 00 00 00 00	 mov	 esi, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
$LL17@TimerProcQ@2:

; 169  : 			{
; 170  : 				MapC[n].WeatherVariationProcess();

  00133	8b ce		 mov	 ecx, esi
  00135	e8 00 00 00 00	 call	 ?WeatherVariationProcess@MapClass@@QAEXXZ ; MapClass::WeatherVariationProcess
  0013a	81 c6 28 38 05
	00		 add	 esi, 342056		; 00053828H
  00140	81 fe a0 ef 09
	02		 cmp	 esi, OFFSET ?MapC@@3PAVMapClass@@A+34205600
  00146	7c eb		 jl	 SHORT $LL17@TimerProcQ@2

; 171  : 			}
; 172  : 
; 173  : 			wsGServer.m_SendSec = wsGServer.m_SendSecTmp;

  00148	8b 0d 20 00 00
	00		 mov	 ecx, DWORD PTR ?wsGServer@@3VCwsGameServer@@A+32

; 174  : 			wsGServer.m_RecvSec = wsGServer.m_RecvSecTmp;

  0014e	8b 15 28 00 00
	00		 mov	 edx, DWORD PTR ?wsGServer@@3VCwsGameServer@@A+40
  00154	89 0d 1c 00 00
	00		 mov	 DWORD PTR ?wsGServer@@3VCwsGameServer@@A+28, ecx

; 175  : 			wsGServer.m_SendSecTmp = 0;
; 176  : 			wsGServer.m_RecvSecTmp = 0;
; 177  : 			DragonEvent->Run();

  0015a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?DragonEvent@@3PAVCDragonEvent@@A ; DragonEvent
  00160	33 f6		 xor	 esi, esi
  00162	89 15 24 00 00
	00		 mov	 DWORD PTR ?wsGServer@@3VCwsGameServer@@A+36, edx
  00168	89 35 20 00 00
	00		 mov	 DWORD PTR ?wsGServer@@3VCwsGameServer@@A+32, esi
  0016e	89 35 28 00 00
	00		 mov	 DWORD PTR ?wsGServer@@3VCwsGameServer@@A+40, esi
  00174	e8 00 00 00 00	 call	 ?Run@CDragonEvent@@QAEXXZ ; CDragonEvent::Run

; 178  : 			AttackEvent->Run();

  00179	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?AttackEvent@@3PAVCAttackEvent@@A ; AttackEvent
  0017f	e8 00 00 00 00	 call	 ?Run@CAttackEvent@@QAEXXZ ; CAttackEvent::Run

; 179  : 			gEledoradoEvent.Run();

  00184	b9 00 00 00 00	 mov	 ecx, OFFSET ?gEledoradoEvent@@3VCEledoradoEvent@@A ; gEledoradoEvent
  00189	e8 00 00 00 00	 call	 ?Run@CEledoradoEvent@@QAEXXZ ; CEledoradoEvent::Run

; 180  : 			g_EventManager.Run();

  0018e	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_EventManager@@3VCEventManagement@@A ; g_EventManager
  00193	e8 00 00 00 00	 call	 ?Run@CEventManagement@@QAEXXZ ; CEventManagement::Run

; 181  : #if (CUSTOM_OLYMP==1)
; 182  : 			g_CustomOlymp.Run();
; 183  : #endif
; 184  : 		}
; 185  : 		break;

  00198	e9 87 01 00 00	 jmp	 $LN33@TimerProcQ@2
$LN14@TimerProcQ@2:

; 186  : 	case WM_CONNECTMEMBER_RELOAD:
; 187  : 		{
; 188  : 			ConMember.Load(gDirPath.GetNewPath(FILE_WHITELIST));

  0019d	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@FGIEIEFL@ConnectMember?4txt?$AA@
  001a2	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDirPath@@3VCDirPath@@A ; gDirPath
  001a7	e8 00 00 00 00	 call	 ?GetNewPath@CDirPath@@QAEPADPAD@Z ; CDirPath::GetNewPath
  001ac	50		 push	 eax
  001ad	b9 00 00 00 00	 mov	 ecx, OFFSET ?ConMember@@3VCConMember@@A ; ConMember
  001b2	e8 00 00 00 00	 call	 ?Load@CConMember@@QAEXPAD@Z ; CConMember::Load

; 189  : 		}
; 190  : 		break;

  001b7	e9 68 01 00 00	 jmp	 $LN33@TimerProcQ@2
$LN13@TimerProcQ@2:

; 191  : 	case WM_GS_CLOSE:
; 192  : 		if ( gCloseMsg != 0 )

  001bc	33 f6		 xor	 esi, esi
  001be	39 35 00 00 00
	00		 cmp	 DWORD PTR ?gCloseMsg@@3HA, esi ; gCloseMsg
  001c4	0f 84 d1 00 00
	00		 je	 $LN7@TimerProcQ@2

; 193  : 		{
; 194  : 			gCloseMsgTime--;

  001ca	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gCloseMsgTime@@3HA ; gCloseMsgTime
  001d0	49		 dec	 ecx
  001d1	89 0d 00 00 00
	00		 mov	 DWORD PTR ?gCloseMsgTime@@3HA, ecx ; gCloseMsgTime

; 195  : 
; 196  : 			if ( gCloseMsgTime <= 1 )

  001d7	83 f9 01	 cmp	 ecx, 1
  001da	7f 3b		 jg	 SHORT $LN11@TimerProcQ@2

; 197  : 			{
; 198  : 				if ( gCloseMsgTime == 1 )

  001dc	0f 85 93 00 00
	00		 jne	 $LN8@TimerProcQ@2

; 199  : 				{
; 200  : 					AllSendServerMsg(lMsg.Get(MSGGET(1, 193)));

  001e2	68 c1 01 00 00	 push	 449			; 000001c1H
  001e7	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  001ec	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  001f1	50		 push	 eax
  001f2	e8 00 00 00 00	 call	 ?AllSendServerMsg@@YAXPAD@Z ; AllSendServerMsg
  001f7	83 c4 04	 add	 esp, 4

; 201  : 					LogAddC(2, lMsg.Get(MSGGET(1, 193)));

  001fa	68 c1 01 00 00	 push	 449			; 000001c1H
  001ff	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  00204	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  00209	50		 push	 eax
  0020a	6a 02		 push	 2
  0020c	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  00212	83 c4 08	 add	 esp, 8

; 202  : 				}
; 203  : 			}
; 204  : 			else

  00215	eb 58		 jmp	 SHORT $LN34@TimerProcQ@2
$LN11@TimerProcQ@2:

; 205  : 			{
; 206  : 				if ( (gCloseMsgTime % 10) == 0 )

  00217	b8 67 66 66 66	 mov	 eax, 1717986919		; 66666667H
  0021c	f7 e9		 imul	 ecx
  0021e	c1 fa 02	 sar	 edx, 2
  00221	8b c2		 mov	 eax, edx
  00223	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00226	03 c2		 add	 eax, edx
  00228	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]
  0022b	03 c0		 add	 eax, eax
  0022d	8b d1		 mov	 edx, ecx
  0022f	2b d0		 sub	 edx, eax
  00231	75 42		 jne	 SHORT $LN8@TimerProcQ@2

; 207  : 				{
; 208  : 					char szTemp[256];
; 209  : 
; 210  : 					wsprintf( szTemp, lMsg.Get(MSGGET(1, 194)), gCloseMsgTime);

  00233	51		 push	 ecx
  00234	68 c2 01 00 00	 push	 450			; 000001c2H
  00239	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  0023e	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  00243	50		 push	 eax
  00244	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _szTemp$206467[ebp]
  0024a	50		 push	 eax
  0024b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA

; 211  : 					AllSendServerMsg(szTemp);

  00251	8d 8d fc fe ff
	ff		 lea	 ecx, DWORD PTR _szTemp$206467[ebp]
  00257	51		 push	 ecx
  00258	e8 00 00 00 00	 call	 ?AllSendServerMsg@@YAXPAD@Z ; AllSendServerMsg

; 212  : 					LogAddC(2, szTemp);

  0025d	8d 95 fc fe ff
	ff		 lea	 edx, DWORD PTR _szTemp$206467[ebp]
  00263	52		 push	 edx
  00264	6a 02		 push	 2
  00266	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  0026c	83 c4 18	 add	 esp, 24			; 00000018H
$LN34@TimerProcQ@2:
  0026f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gCloseMsgTime@@3HA ; gCloseMsgTime
$LN8@TimerProcQ@2:

; 213  : 				}
; 214  : 			}
; 215  : 
; 216  : 			if ( gCloseMsgTime < 0 )

  00275	3b ce		 cmp	 ecx, esi
  00277	7d 22		 jge	 SHORT $LN7@TimerProcQ@2

; 217  : 			{
; 218  : 				KillTimer(ghWnd, WM_GS_CLOSE);

  00279	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ghWnd@@3PAUHWND__@@A ; ghWnd
  0027e	68 ea 03 00 00	 push	 1002			; 000003eaH
  00283	50		 push	 eax
  00284	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KillTimer@8

; 219  : 				gObjAllLogOut();

  0028a	e8 00 00 00 00	 call	 ?gObjAllLogOut@@YAXXZ	; gObjAllLogOut

; 220  : 				gCloseMsgTime = 0;

  0028f	89 35 00 00 00
	00		 mov	 DWORD PTR ?gCloseMsgTime@@3HA, esi ; gCloseMsgTime

; 221  : 				gCloseMsg = 0;

  00295	89 35 00 00 00
	00		 mov	 DWORD PTR ?gCloseMsg@@3HA, esi ; gCloseMsg
$LN7@TimerProcQ@2:

; 222  : 			}
; 223  : 		}
; 224  : 		gObjSecondProc();

  0029b	e8 00 00 00 00	 call	 ?gObjSecondProc@@YAXXZ	; gObjSecondProc

; 225  : #if (GS_CASTLE == 1)
; 226  : 		if(cDBSMng.GetActiveDS() > -1)

  002a0	b9 00 00 00 00	 mov	 ecx, OFFSET ?cDBSMng@@3VDBSockMng@@A ; cDBSMng
  002a5	e8 00 00 00 00	 call	 ?GetActiveDS@DBSockMng@@QAEHXZ ; DBSockMng::GetActiveDS
  002aa	83 f8 ff	 cmp	 eax, -1
  002ad	7e 19		 jle	 SHORT $LN5@TimerProcQ@2

; 227  : 		{
; 228  : 			if(g_CastleSiege.GetDataLoadState() == 2)

  002af	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  002b4	e8 00 00 00 00	 call	 ?GetDataLoadState@CCastleSiege@@QAEHXZ ; CCastleSiege::GetDataLoadState
  002b9	83 f8 02	 cmp	 eax, 2
  002bc	75 0a		 jne	 SHORT $LN5@TimerProcQ@2

; 229  : 			{
; 230  : 				g_CastleSiege.DataRequest();

  002be	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  002c3	e8 00 00 00 00	 call	 ?DataRequest@CCastleSiege@@QAEHXZ ; CCastleSiege::DataRequest
$LN5@TimerProcQ@2:

; 231  : 			}
; 232  : 
; 233  : #if (CUSTOM_OLYMP==1)
; 234  : 			if(g_CustomOlymp.GetDataLoadState() == 2 )
; 235  : 			{
; 236  : 				g_CustomOlymp.DataRequest();
; 237  : 			}
; 238  : 			
; 239  : #endif
; 240  : 		}
; 241  : 					
; 242  : 		g_CastleSiege.SendCastleStateSync();

  002c8	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiege@@3VCCastleSiege@@A ; g_CastleSiege
  002cd	e8 00 00 00 00	 call	 ?SendCastleStateSync@CCastleSiege@@QAEXXZ ; CCastleSiege::SendCastleStateSync

; 243  : 		g_CastleSiegeSync.AdjustTributeMoney();

  002d2	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CastleSiegeSync@@3VCCastleSiegeSync@@A ; g_CastleSiegeSync
  002d7	e8 00 00 00 00	 call	 ?AdjustTributeMoney@CCastleSiegeSync@@QAEXXZ ; CCastleSiegeSync::AdjustTributeMoney

; 244  : 		g_Crywolf.CrywolfSecondAct();

  002dc	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_Crywolf@@3VCCrywolf@@A ; g_Crywolf
  002e1	e8 00 00 00 00	 call	 ?CrywolfSecondAct@CCrywolf@@QAEXXZ ; CCrywolf::CrywolfSecondAct

; 245  : #endif
; 246  : #if (GS_CASTLE == 0 || GS_SPEC == 1)
; 247  : 		//g_CastleSiegeSync.AdjustTributeMoney();
; 248  : #if(__GENS_SYSTEM__ == 1)
; 249  : 		gGensSystem.UpdateRun();

  002e6	b9 00 00 00 00	 mov	 ecx, OFFSET ?gGensSystem@@3VCGensSystem@@A ; gGensSystem
  002eb	e8 00 00 00 00	 call	 ?UpdateRun@CGensSystem@@QAEXXZ ; CGensSystem::UpdateRun

; 250  : #endif
; 251  : #endif
; 252  : 		//g_PeriodItemEx.CheckPeriodData(); --  need to decompile
; 253  : 		//g_CashShopInGame.CheckMileageUpdate(); -- need to decompile
; 254  : 		//g_CashShopInGame.CheckShopServerReconnect(); -- need to decompile
; 255  : 		//g_HacktoolBlockEx.CheckHacktoolUse(); -- need to decompile
; 256  : 
; 257  : 		/*if ( DBSockMng::GetActiveDS(&cDBSMng) > -1 && !CArcaBattle::IsDataLoadWinGuild(&g_ArcaBattle) )
; 258  :           CArcaBattle::GDReqWinGuildInfo(&g_ArcaBattle);
; 259  :         if ( DBSockMng::GetActiveDS(&cDBSMng) > -1 && !CArcaBattle::IsDataLoadProcState(&g_ArcaBattle) )
; 260  :           CArcaBattle::GDReqProcState(&g_ArcaBattle);
; 261  :         if ( DBSockMng::GetActiveDS(&cDBSMng) > -1
; 262  :           && !CArcaBattle::IsInitABProcMultiCast(&g_ArcaBattle)
; 263  :           && CArcaBattle::IsArcaBattleServer(&g_ArcaBattle) == 1 )
; 264  :           CArcaBattle::SetArcaBattleProcMultiCast(&g_ArcaBattle, 1);
; 265  :         if ( DBSockMng::GetActiveDS(&cDBSMng) > -1
; 266  :           && !CAcheronGuardianEvent::IsInitAEProcMultiCast(&g_AcheronGuardianEvent)
; 267  :           && CArcaBattle::IsArcaBattleServer(&g_ArcaBattle) == 1 )
; 268  :           CAcheronGuardianEvent::SetAcheronEventProcMultiCast(&g_AcheronGuardianEvent, 1);*/
; 269  : 		break;

  002f0	eb 32		 jmp	 SHORT $LN33@TimerProcQ@2
$LN4@TimerProcQ@2:

; 270  : 	case WM_SET_DATE:
; 271  : 		gSetDate();

  002f2	e8 00 00 00 00	 call	 ?gSetDate@@YAXXZ	; gSetDate

; 272  : 		WhisperCash.TimeCheckCashDelete();

  002f7	b9 00 00 00 00	 mov	 ecx, OFFSET ?WhisperCash@@3VCWhisperCash@@A ; WhisperCash
  002fc	e8 00 00 00 00	 call	 ?TimeCheckCashDelete@CWhisperCash@@QAEXXZ ; CWhisperCash::TimeCheckCashDelete

; 273  : 		break;

  00301	eb 21		 jmp	 SHORT $LN33@TimerProcQ@2
$LN3@TimerProcQ@2:

; 274  : 	case WM_LOG_DATE_CHANGE:
; 275  : 
; 276  : 		cpTimerTempUserManager->ClearOverTimeUserData(g_MaintainUserConnectionSecond);

  00303	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?g_MaintainUserConnectionSecond@@3HA ; g_MaintainUserConnectionSecond
  00309	51		 push	 ecx
  0030a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?cpTimerTempUserManager@@3PAVCTemporaryUserManager@@A ; cpTimerTempUserManager
  00310	e8 00 00 00 00	 call	 ?ClearOverTimeUserData@CTemporaryUserManager@@QAEHK@Z ; CTemporaryUserManager::ClearOverTimeUserData

; 277  : 		/*
; 278  : 		if( g_GensAbusingResetTime > 0 )
; 279  : 		{
; 280  : 			for(int n = OBJ_STARTUSERINDEX; n < OBJMAX; n++)
; 281  : 			{
; 282  : 				if( gObjIsConnected(n) )
; 283  : 					g_GensSystem.AbusingInfoReset(&gObj[n]);
; 284  : 			}
; 285  : 		}
; 286  : 		*/
; 287  : 
; 288  : #if (GS_CASTLE == 1)
; 289  : 		if(LogDateChange() == TRUE)

  00315	e8 00 00 00 00	 call	 ?LogDateChange@@YAHXZ	; LogDateChange
  0031a	83 f8 01	 cmp	 eax, 1
  0031d	75 05		 jne	 SHORT $LN33@TimerProcQ@2

; 290  : 			g_iCastleItemMixLimit = 1;

  0031f	a3 00 00 00 00	 mov	 DWORD PTR ?g_iCastleItemMixLimit@@3HA, eax ; g_iCastleItemMixLimit
$LN33@TimerProcQ@2:
  00324	5e		 pop	 esi
$LN2@TimerProcQ@2:

; 291  : #else
; 292  : 		LogDateChange()
; 293  : #endif
; 294  : 		break;
; 295  : 
; 296  : 	default:
; 297  : 		break;
; 298  : 	}
; 299  : 
; 300  : 	g_MuTimer.m_QueueTimer1.SyncUnlock();

  00325	b9 04 00 00 00	 mov	 ecx, OFFSET ?g_MuTimer@@3VCMuTimer@@A+4
  0032a	e8 00 00 00 00	 call	 ?SyncUnlock@CQueueTimer@@QAEXXZ ; CQueueTimer::SyncUnlock
$LN29@TimerProcQ@2:

; 301  : }

  0032f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00332	33 cd		 xor	 ecx, ebp
  00334	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00339	8b e5		 mov	 esp, ebp
  0033b	5d		 pop	 ebp
  0033c	c2 08 00	 ret	 8
  0033f	90		 npad	 1
$LN35@TimerProcQ@2:
  00340	00 00 00 00	 DD	 $LN18@TimerProcQ@2
  00344	00 00 00 00	 DD	 $LN4@TimerProcQ@2
  00348	00 00 00 00	 DD	 $LN13@TimerProcQ@2
  0034c	00 00 00 00	 DD	 $LN3@TimerProcQ@2
  00350	00 00 00 00	 DD	 $LN21@TimerProcQ@2
  00354	00 00 00 00	 DD	 $LN22@TimerProcQ@2
  00358	00 00 00 00	 DD	 $LN24@TimerProcQ@2
  0035c	00 00 00 00	 DD	 $LN33@TimerProcQ@2
  00360	00 00 00 00	 DD	 $LN25@TimerProcQ@2
  00364	00 00 00 00	 DD	 $LN33@TimerProcQ@2
  00368	00 00 00 00	 DD	 $LN20@TimerProcQ@2
  0036c	00 00 00 00	 DD	 $LN19@TimerProcQ@2
  00370	00 00 00 00	 DD	 $LN33@TimerProcQ@2
  00374	00 00 00 00	 DD	 $LN33@TimerProcQ@2
  00378	00 00 00 00	 DD	 $LN33@TimerProcQ@2
  0037c	00 00 00 00	 DD	 $LN33@TimerProcQ@2
  00380	00 00 00 00	 DD	 $LN14@TimerProcQ@2
?TimerProcQueue@@YGXPAXH@Z ENDP				; TimerProcQueue
_TEXT	ENDS
PUBLIC	??0CMuTimer@@QAE@XZ				; CMuTimer::CMuTimer
EXTRN	?RegCallBack@CQueueTimer@@QAEXP6GXPAXE@Z@Z:PROC	; CQueueTimer::RegCallBack
EXTRN	__imp__timeBeginPeriod@4:PROC
EXTRN	??0CQueueTimer@@QAE@XZ:PROC			; CQueueTimer::CQueueTimer
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0CMuTimer@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CMuTimer@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0CMuTimer@@QAE@XZ$1
__ehfuncinfo$??0CMuTimer@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0CMuTimer@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
xdata$x	ENDS
;	COMDAT ??0CMuTimer@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CMuTimer@@QAE@XZ PROC				; CMuTimer::CMuTimer, COMDAT
; _this$ = ecx

; 53   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0CMuTimer@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	53		 push	 ebx
  00013	56		 push	 esi
  00014	57		 push	 edi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00026	8b f1		 mov	 esi, ecx
  00028	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  0002b	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  0002e	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7CMuTimer@@6B@
  00034	e8 00 00 00 00	 call	 ??0CQueueTimer@@QAE@XZ	; CQueueTimer::CQueueTimer
  00039	8d 4e 44	 lea	 ecx, DWORD PTR [esi+68]
  0003c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00043	e8 00 00 00 00	 call	 ??0CQueueTimer@@QAE@XZ	; CQueueTimer::CQueueTimer

; 54   : 	timeBeginPeriod(1);

  00048	6a 01		 push	 1
  0004a	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  0004e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__timeBeginPeriod@4

; 55   : 	this->m_bTimerEnd = 0;
; 56   : 	this->m_QueueTimer1.RegCallBack((WAITORTIMERCALLBACK)TimerProcQueue);

  00054	68 00 00 00 00	 push	 OFFSET ?TimerProcQueue@@YGXPAXH@Z ; TimerProcQueue
  00059	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  0005c	c7 86 84 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+132], 0
  00066	e8 00 00 00 00	 call	 ?RegCallBack@CQueueTimer@@QAEXP6GXPAXE@Z@Z ; CQueueTimer::RegCallBack

; 57   : 	this->m_QueueTimer2.RegCallBack((WAITORTIMERCALLBACK)TimerProcQueue2);

  0006b	68 00 00 00 00	 push	 OFFSET ?TimerProcQueue2@@YGXPAXH@Z ; TimerProcQueue2
  00070	8d 4e 44	 lea	 ecx, DWORD PTR [esi+68]
  00073	e8 00 00 00 00	 call	 ?RegCallBack@CQueueTimer@@QAEXP6GXPAXE@Z@Z ; CQueueTimer::RegCallBack

; 58   : }

  00078	8b c6		 mov	 eax, esi
  0007a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0007d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00084	59		 pop	 ecx
  00085	5f		 pop	 edi
  00086	5e		 pop	 esi
  00087	5b		 pop	 ebx
  00088	8b e5		 mov	 esp, ebp
  0008a	5d		 pop	 ebp
  0008b	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CMuTimer@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 04	 add	 ecx, 4
  00006	e9 00 00 00 00	 jmp	 ??1CQueueTimer@@UAE@XZ	; CQueueTimer::~CQueueTimer
__unwindfunclet$??0CMuTimer@@QAE@XZ$1:
  0000b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	83 c1 44	 add	 ecx, 68			; 00000044H
  00011	e9 00 00 00 00	 jmp	 ??1CQueueTimer@@UAE@XZ	; CQueueTimer::~CQueueTimer
__ehhandler$??0CMuTimer@@QAE@XZ:
  00016	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001d	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00020	33 c8		 xor	 ecx, eax
  00022	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00027	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0CMuTimer@@QAE@XZ
  0002c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0CMuTimer@@QAE@XZ ENDP				; CMuTimer::CMuTimer
EXTRN	_atexit:PROC
; Function compile flags: /Ogtp
;	COMDAT ??__Eg_MuTimer@@YAXXZ
text$yc	SEGMENT
??__Eg_MuTimer@@YAXXZ PROC				; `dynamic initializer for 'g_MuTimer'', COMDAT

; 45   : CMuTimer g_MuTimer;

  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MuTimer@@3VCMuTimer@@A ; g_MuTimer
  00005	e8 00 00 00 00	 call	 ??0CMuTimer@@QAE@XZ	; CMuTimer::CMuTimer
  0000a	68 00 00 00 00	 push	 OFFSET ??__Fg_MuTimer@@YAXXZ ; `dynamic atexit destructor for 'g_MuTimer''
  0000f	e8 00 00 00 00	 call	 _atexit
  00014	59		 pop	 ecx
  00015	c3		 ret	 0
??__Eg_MuTimer@@YAXXZ ENDP				; `dynamic initializer for 'g_MuTimer''
; Function compile flags: /Ogtp
text$yc	ENDS
;	COMDAT ??__Fg_MuTimer@@YAXXZ
text$yd	SEGMENT
??__Fg_MuTimer@@YAXXZ PROC				; `dynamic atexit destructor for 'g_MuTimer'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MuTimer@@3VCMuTimer@@A ; g_MuTimer
  00005	e9 00 00 00 00	 jmp	 ??1CMuTimer@@UAE@XZ	; CMuTimer::~CMuTimer
??__Fg_MuTimer@@YAXXZ ENDP				; `dynamic atexit destructor for 'g_MuTimer''
text$yd	ENDS
PUBLIC	?g_MuTimer@@3VCMuTimer@@A			; g_MuTimer
_BSS	SEGMENT
?g_MuTimer@@3VCMuTimer@@A DB 088H DUP (?)		; g_MuTimer
_BSS	ENDS
CRT$XCU	SEGMENT
_g_MuTimer$initializer$ DD FLAT:??__Eg_MuTimer@@YAXXZ
CRT$XCU	ENDS
END
