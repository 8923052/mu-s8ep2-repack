; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	C:\muserver_dev\development\MU-S8EP2-Repack\GameServer\Source\DoubleGoerEvent.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?BLOCKSIZE@?$FixedBlockSize@$07@CryptoPP@@2HB	; CryptoPP::FixedBlockSize<8>::BLOCKSIZE
PUBLIC	?KEYLENGTH@?$FixedKeyLength@$07$03$0A@@CryptoPP@@2HB ; CryptoPP::FixedKeyLength<8,4,0>::KEYLENGTH
PUBLIC	?MIN_KEYLENGTH@?$FixedKeyLength@$07$03$0A@@CryptoPP@@2HB ; CryptoPP::FixedKeyLength<8,4,0>::MIN_KEYLENGTH
PUBLIC	?MAX_KEYLENGTH@?$FixedKeyLength@$07$03$0A@@CryptoPP@@2HB ; CryptoPP::FixedKeyLength<8,4,0>::MAX_KEYLENGTH
PUBLIC	?DEFAULT_KEYLENGTH@?$FixedKeyLength@$07$03$0A@@CryptoPP@@2HB ; CryptoPP::FixedKeyLength<8,4,0>::DEFAULT_KEYLENGTH
PUBLIC	?IV_REQUIREMENT@?$FixedKeyLength@$07$03$0A@@CryptoPP@@2HB ; CryptoPP::FixedKeyLength<8,4,0>::IV_REQUIREMENT
PUBLIC	?IV_LENGTH@?$FixedKeyLength@$07$03$0A@@CryptoPP@@2HB ; CryptoPP::FixedKeyLength<8,4,0>::IV_LENGTH
PUBLIC	?KEYLENGTH@?$FixedKeyLength@$0BA@$03$0A@@CryptoPP@@2HB ; CryptoPP::FixedKeyLength<16,4,0>::KEYLENGTH
PUBLIC	?MIN_KEYLENGTH@?$FixedKeyLength@$0BA@$03$0A@@CryptoPP@@2HB ; CryptoPP::FixedKeyLength<16,4,0>::MIN_KEYLENGTH
PUBLIC	?MAX_KEYLENGTH@?$FixedKeyLength@$0BA@$03$0A@@CryptoPP@@2HB ; CryptoPP::FixedKeyLength<16,4,0>::MAX_KEYLENGTH
PUBLIC	?DEFAULT_KEYLENGTH@?$FixedKeyLength@$0BA@$03$0A@@CryptoPP@@2HB ; CryptoPP::FixedKeyLength<16,4,0>::DEFAULT_KEYLENGTH
PUBLIC	?IV_REQUIREMENT@?$FixedKeyLength@$0BA@$03$0A@@CryptoPP@@2HB ; CryptoPP::FixedKeyLength<16,4,0>::IV_REQUIREMENT
PUBLIC	?IV_LENGTH@?$FixedKeyLength@$0BA@$03$0A@@CryptoPP@@2HB ; CryptoPP::FixedKeyLength<16,4,0>::IV_LENGTH
PUBLIC	?KEYLENGTH@?$FixedKeyLength@$0BI@$03$0A@@CryptoPP@@2HB ; CryptoPP::FixedKeyLength<24,4,0>::KEYLENGTH
PUBLIC	?MIN_KEYLENGTH@?$FixedKeyLength@$0BI@$03$0A@@CryptoPP@@2HB ; CryptoPP::FixedKeyLength<24,4,0>::MIN_KEYLENGTH
PUBLIC	?MAX_KEYLENGTH@?$FixedKeyLength@$0BI@$03$0A@@CryptoPP@@2HB ; CryptoPP::FixedKeyLength<24,4,0>::MAX_KEYLENGTH
PUBLIC	?DEFAULT_KEYLENGTH@?$FixedKeyLength@$0BI@$03$0A@@CryptoPP@@2HB ; CryptoPP::FixedKeyLength<24,4,0>::DEFAULT_KEYLENGTH
PUBLIC	?IV_REQUIREMENT@?$FixedKeyLength@$0BI@$03$0A@@CryptoPP@@2HB ; CryptoPP::FixedKeyLength<24,4,0>::IV_REQUIREMENT
PUBLIC	?IV_LENGTH@?$FixedKeyLength@$0BI@$03$0A@@CryptoPP@@2HB ; CryptoPP::FixedKeyLength<24,4,0>::IV_LENGTH
PUBLIC	?g_DoubleGoerEvent_Gates@@3PAHA			; g_DoubleGoerEvent_Gates
PUBLIC	?g_DoubleGoerEvent_DefPts@@3PAUDOUBLEGOER_DEFPOINTS@@A ; g_DoubleGoerEvent_DefPts
PUBLIC	?g_DoubleGoerEvent_BlockPts@@3PAUDOUBLEGOER_BLOCK@@A ; g_DoubleGoerEvent_BlockPts
_DATA	SEGMENT
_g_sttBLOODCASTLE_LEVEL DD 0fH
	DD	050H
	DD	0aH
	DD	03cH
	DD	051H
	DD	082H
	DD	03dH
	DD	06eH
	DD	083H
	DD	0b4H
	DD	06fH
	DD	0a0H
	DD	0b5H
	DD	0e6H
	DD	0a1H
	DD	0d2H
	DD	0e7H
	DD	0118H
	DD	0d3H
	DD	0104H
	DD	0119H
	DD	014aH
	DD	0105H
	DD	0136H
	DD	014bH
	DD	0190H
	DD	0137H
	DD	0190H
	DD	00H
	DD	0190H
	DD	00H
	DD	0190H
?g_DoubleGoerEvent_Gates@@3PAHA DD 0149H		; g_DoubleGoerEvent_Gates
	DD	014aH
	DD	014bH
	DD	014cH
?g_DoubleGoerEvent_DefPts@@3PAUDOUBLEGOER_DEFPOINTS@@A DB 0c5H ; g_DoubleGoerEvent_DefPts
	DB	01bH
	DB	0e0H
	DB	065H
	DD	04062e148r			; 3.545
	DB	04eH
	ORG $+3
	DB	089H
	DB	043H
	DB	072H
	DB	0b4H
	DD	040a170a4r			; 5.045
	DB	06fH
	ORG $+3
	DB	06eH
	DB	038H
	DB	06eH
	DB	096H
	DD	04082e8a7r			; 4.0909
	DB	05aH
	ORG $+3
	DB	05fH
	DB	0bH
	DB	02cH
	DB	06cH
	DD	0409a2d0er			; 4.818
	DB	06aH
	ORG $+3
?g_DoubleGoerEvent_BlockPts@@3PAUDOUBLEGOER_BLOCK@@A DB 0bfH ; g_DoubleGoerEvent_BlockPts
	DB	021H
	DB	0c8H
	DB	024H
	DB	086H
	DB	04cH
	DB	08dH
	DB	04fH
	DB	065H
	DB	041H
	DB	071H
	DB	044H
	DB	05cH
	DB	017H
	DB	062H
	DB	01aH
_DATA	ENDS
;	COMDAT ?IV_LENGTH@?$FixedKeyLength@$0BI@$03$0A@@CryptoPP@@2HB
CONST	SEGMENT
?IV_LENGTH@?$FixedKeyLength@$0BI@$03$0A@@CryptoPP@@2HB DD 00H ; CryptoPP::FixedKeyLength<24,4,0>::IV_LENGTH
CONST	ENDS
;	COMDAT ?IV_REQUIREMENT@?$FixedKeyLength@$0BI@$03$0A@@CryptoPP@@2HB
CONST	SEGMENT
?IV_REQUIREMENT@?$FixedKeyLength@$0BI@$03$0A@@CryptoPP@@2HB DD 04H ; CryptoPP::FixedKeyLength<24,4,0>::IV_REQUIREMENT
CONST	ENDS
;	COMDAT ?DEFAULT_KEYLENGTH@?$FixedKeyLength@$0BI@$03$0A@@CryptoPP@@2HB
CONST	SEGMENT
?DEFAULT_KEYLENGTH@?$FixedKeyLength@$0BI@$03$0A@@CryptoPP@@2HB DD 018H ; CryptoPP::FixedKeyLength<24,4,0>::DEFAULT_KEYLENGTH
CONST	ENDS
;	COMDAT ?MAX_KEYLENGTH@?$FixedKeyLength@$0BI@$03$0A@@CryptoPP@@2HB
CONST	SEGMENT
?MAX_KEYLENGTH@?$FixedKeyLength@$0BI@$03$0A@@CryptoPP@@2HB DD 018H ; CryptoPP::FixedKeyLength<24,4,0>::MAX_KEYLENGTH
CONST	ENDS
;	COMDAT ?MIN_KEYLENGTH@?$FixedKeyLength@$0BI@$03$0A@@CryptoPP@@2HB
CONST	SEGMENT
?MIN_KEYLENGTH@?$FixedKeyLength@$0BI@$03$0A@@CryptoPP@@2HB DD 018H ; CryptoPP::FixedKeyLength<24,4,0>::MIN_KEYLENGTH
CONST	ENDS
;	COMDAT ?KEYLENGTH@?$FixedKeyLength@$0BI@$03$0A@@CryptoPP@@2HB
CONST	SEGMENT
?KEYLENGTH@?$FixedKeyLength@$0BI@$03$0A@@CryptoPP@@2HB DD 018H ; CryptoPP::FixedKeyLength<24,4,0>::KEYLENGTH
CONST	ENDS
;	COMDAT ?IV_LENGTH@?$FixedKeyLength@$0BA@$03$0A@@CryptoPP@@2HB
CONST	SEGMENT
?IV_LENGTH@?$FixedKeyLength@$0BA@$03$0A@@CryptoPP@@2HB DD 00H ; CryptoPP::FixedKeyLength<16,4,0>::IV_LENGTH
CONST	ENDS
;	COMDAT ?IV_REQUIREMENT@?$FixedKeyLength@$0BA@$03$0A@@CryptoPP@@2HB
CONST	SEGMENT
?IV_REQUIREMENT@?$FixedKeyLength@$0BA@$03$0A@@CryptoPP@@2HB DD 04H ; CryptoPP::FixedKeyLength<16,4,0>::IV_REQUIREMENT
CONST	ENDS
;	COMDAT ?DEFAULT_KEYLENGTH@?$FixedKeyLength@$0BA@$03$0A@@CryptoPP@@2HB
CONST	SEGMENT
?DEFAULT_KEYLENGTH@?$FixedKeyLength@$0BA@$03$0A@@CryptoPP@@2HB DD 010H ; CryptoPP::FixedKeyLength<16,4,0>::DEFAULT_KEYLENGTH
CONST	ENDS
;	COMDAT ?MAX_KEYLENGTH@?$FixedKeyLength@$0BA@$03$0A@@CryptoPP@@2HB
CONST	SEGMENT
?MAX_KEYLENGTH@?$FixedKeyLength@$0BA@$03$0A@@CryptoPP@@2HB DD 010H ; CryptoPP::FixedKeyLength<16,4,0>::MAX_KEYLENGTH
CONST	ENDS
;	COMDAT ?MIN_KEYLENGTH@?$FixedKeyLength@$0BA@$03$0A@@CryptoPP@@2HB
CONST	SEGMENT
?MIN_KEYLENGTH@?$FixedKeyLength@$0BA@$03$0A@@CryptoPP@@2HB DD 010H ; CryptoPP::FixedKeyLength<16,4,0>::MIN_KEYLENGTH
CONST	ENDS
;	COMDAT ?KEYLENGTH@?$FixedKeyLength@$0BA@$03$0A@@CryptoPP@@2HB
CONST	SEGMENT
?KEYLENGTH@?$FixedKeyLength@$0BA@$03$0A@@CryptoPP@@2HB DD 010H ; CryptoPP::FixedKeyLength<16,4,0>::KEYLENGTH
CONST	ENDS
;	COMDAT ?IV_LENGTH@?$FixedKeyLength@$07$03$0A@@CryptoPP@@2HB
CONST	SEGMENT
?IV_LENGTH@?$FixedKeyLength@$07$03$0A@@CryptoPP@@2HB DD 00H ; CryptoPP::FixedKeyLength<8,4,0>::IV_LENGTH
CONST	ENDS
;	COMDAT ?IV_REQUIREMENT@?$FixedKeyLength@$07$03$0A@@CryptoPP@@2HB
CONST	SEGMENT
?IV_REQUIREMENT@?$FixedKeyLength@$07$03$0A@@CryptoPP@@2HB DD 04H ; CryptoPP::FixedKeyLength<8,4,0>::IV_REQUIREMENT
CONST	ENDS
;	COMDAT ?DEFAULT_KEYLENGTH@?$FixedKeyLength@$07$03$0A@@CryptoPP@@2HB
CONST	SEGMENT
?DEFAULT_KEYLENGTH@?$FixedKeyLength@$07$03$0A@@CryptoPP@@2HB DD 08H ; CryptoPP::FixedKeyLength<8,4,0>::DEFAULT_KEYLENGTH
CONST	ENDS
;	COMDAT ?MAX_KEYLENGTH@?$FixedKeyLength@$07$03$0A@@CryptoPP@@2HB
CONST	SEGMENT
?MAX_KEYLENGTH@?$FixedKeyLength@$07$03$0A@@CryptoPP@@2HB DD 08H ; CryptoPP::FixedKeyLength<8,4,0>::MAX_KEYLENGTH
CONST	ENDS
;	COMDAT ?MIN_KEYLENGTH@?$FixedKeyLength@$07$03$0A@@CryptoPP@@2HB
CONST	SEGMENT
?MIN_KEYLENGTH@?$FixedKeyLength@$07$03$0A@@CryptoPP@@2HB DD 08H ; CryptoPP::FixedKeyLength<8,4,0>::MIN_KEYLENGTH
CONST	ENDS
;	COMDAT ?KEYLENGTH@?$FixedKeyLength@$07$03$0A@@CryptoPP@@2HB
CONST	SEGMENT
?KEYLENGTH@?$FixedKeyLength@$07$03$0A@@CryptoPP@@2HB DD 08H ; CryptoPP::FixedKeyLength<8,4,0>::KEYLENGTH
CONST	ENDS
;	COMDAT ?BLOCKSIZE@?$FixedBlockSize@$07@CryptoPP@@2HB
CONST	SEGMENT
?BLOCKSIZE@?$FixedBlockSize@$07@CryptoPP@@2HB DD 08H	; CryptoPP::FixedBlockSize<8>::BLOCKSIZE
CONST	ENDS
PUBLIC	??2@YAPAXIPAX@Z					; operator new
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\new.h
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 81   :         {return (_Where); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]
  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
PUBLIC	??3@YAXPAX0@Z					; operator delete
; Function compile flags: /Ogtp
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 83   :         {return; }

  00000	c3		 ret	 0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
PUBLIC	??1OBJECTSTRUCT@@QAE@XZ				; OBJECTSTRUCT::~OBJECTSTRUCT
EXTRN	??1CSkillDelay@@UAE@XZ:PROC			; CSkillDelay::~CSkillDelay
EXTRN	??1TMonsterAIAgro@@UAE@XZ:PROC			; TMonsterAIAgro::~TMonsterAIAgro
EXTRN	___security_cookie:DWORD
EXTRN	___CxxFrameHandler3:PROC
EXTRN	@__security_check_cookie@4:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1OBJECTSTRUCT@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1OBJECTSTRUCT@@QAE@XZ$0
__ehfuncinfo$??1OBJECTSTRUCT@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1OBJECTSTRUCT@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
xdata$x	ENDS
;	COMDAT ??1OBJECTSTRUCT@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1OBJECTSTRUCT@@QAE@XZ PROC				; OBJECTSTRUCT::~OBJECTSTRUCT, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1OBJECTSTRUCT@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b f1		 mov	 esi, ecx
  00026	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  00029	8d 8e ec 20 00
	00		 lea	 ecx, DWORD PTR [esi+8428]
  0002f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00036	e8 00 00 00 00	 call	 ??1TMonsterAIAgro@@UAE@XZ ; TMonsterAIAgro::~TMonsterAIAgro
  0003b	8d 8e 0c 16 00
	00		 lea	 ecx, DWORD PTR [esi+5644]
  00041	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00048	e8 00 00 00 00	 call	 ??1CSkillDelay@@UAE@XZ	; CSkillDelay::~CSkillDelay
  0004d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00050	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00057	59		 pop	 ecx
  00058	5e		 pop	 esi
  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1OBJECTSTRUCT@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	81 c1 0c 16 00
	00		 add	 ecx, 5644		; 0000160cH
  00009	e9 00 00 00 00	 jmp	 ??1CSkillDelay@@UAE@XZ	; CSkillDelay::~CSkillDelay
__ehhandler$??1OBJECTSTRUCT@@QAE@XZ:
  0000e	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00012	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00015	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00018	33 c8		 xor	 ecx, eax
  0001a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001f	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1OBJECTSTRUCT@@QAE@XZ
  00024	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1OBJECTSTRUCT@@QAE@XZ ENDP				; OBJECTSTRUCT::~OBJECTSTRUCT
PUBLIC	??0_st_reward@CDoubleGoerEvent@@QAE@XZ		; CDoubleGoerEvent::_st_reward::_st_reward
; Function compile flags: /Ogtp
; File c:\muserver_dev\development\mu-s8ep2-repack\gameserver\source\doublegoerevent.h
;	COMDAT ??0_st_reward@CDoubleGoerEvent@@QAE@XZ
_TEXT	SEGMENT
??0_st_reward@CDoubleGoerEvent@@QAE@XZ PROC		; CDoubleGoerEvent::_st_reward::_st_reward, COMDAT
; _this$ = ecx

; 107  : 		_st_reward()

  00000	8b c1		 mov	 eax, ecx

; 108  : 		{
; 109  : 			m_ResetMin = 0;

  00002	33 c9		 xor	 ecx, ecx
  00004	89 08		 mov	 DWORD PTR [eax], ecx

; 110  : 			m_ResetMax = 0;

  00006	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 111  : 			m_LevelMin = 0;

  00009	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 112  : 			m_LevelMax = 0;

  0000c	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 113  : 			m_SilverBox = NULL;

  0000f	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 114  : 			m_GoldenBox = NULL;

  00012	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 115  : 		}

  00015	c3		 ret	 0
??0_st_reward@CDoubleGoerEvent@@QAE@XZ ENDP		; CDoubleGoerEvent::_st_reward::_st_reward
_TEXT	ENDS
PUBLIC	__$ArrayPad$
EXTRN	_isalnum:PROC
EXTRN	_isalpha:PROC
EXTRN	_atof:PROC
EXTRN	_isdigit:PROC
EXTRN	_getc:PROC
EXTRN	_ungetc:PROC
EXTRN	_isspace:PROC
EXTRN	_fgetc:PROC
EXTRN	__fltused:DWORD
_BSS	SEGMENT
_CurrentToken DD 01H DUP (?)
_TokenNumber DD	01H DUP (?)
_SMDFile DD	01H DUP (?)
_TokenString DB	064H DUP (?)
; Function compile flags: /Ogtp
; File c:\muserver_dev\development\mu-s8ep2-repack\gameserver\include\readscript.h
_BSS	ENDS
;	COMDAT ?GetToken@@YA?AW4SMDToken@@XZ
_TEXT	SEGMENT
_TempString$ = -104					; size = 100
__$ArrayPad$ = -4					; size = 4
?GetToken@@YA?AW4SMDToken@@XZ PROC			; GetToken, COMDAT

; 24   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 68	 sub	 esp, 104		; 00000068H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 25   : 	int ch;
; 26   : 	char* p;
; 27   : 	char TempString[100];
; 28   : 
; 29   : 	TokenString[0]=0;

  00010	c6 05 00 00 00
	00 00		 mov	 BYTE PTR _TokenString, 0
  00017	53		 push	 ebx
  00018	eb 06 8d 9b 00
	00 00 00	 npad	 8
$LL31@GetToken:

; 30   : 
; 31   : 	do
; 32   : 	{
; 33   : 		if ((ch=fgetc(SMDFile)) == -1)

  00020	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 _fgetc
  0002b	8b d8		 mov	 ebx, eax
  0002d	83 c4 04	 add	 esp, 4
  00030	83 fb ff	 cmp	 ebx, -1
  00033	74 5e		 je	 SHORT $LN39@GetToken

; 36   : 		}
; 37   : 		else
; 38   : 		{	
; 39   : 			if (ch=='/')		// this is /

  00035	83 fb 2f	 cmp	 ebx, 47			; 0000002fH
  00038	75 31		 jne	 SHORT $LN30@GetToken

; 40   : 			{
; 41   : 				if((ch=fgetc(SMDFile)) == '/')

  0003a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SMDFile
  00040	51		 push	 ecx
  00041	e8 00 00 00 00	 call	 _fgetc
  00046	8b d8		 mov	 ebx, eax
  00048	83 c4 04	 add	 esp, 4
  0004b	83 fb 2f	 cmp	 ebx, 47			; 0000002fH
  0004e	75 1b		 jne	 SHORT $LN30@GetToken
$LL24@GetToken:

; 42   : 				{
; 43   : 					while ((ch != '\n') && (ch != -1))	// End of Line (EOL)

  00050	83 fb ff	 cmp	 ebx, -1
  00053	74 3e		 je	 SHORT $LN39@GetToken

; 44   : 					{
; 45   : 						ch=fgetc(SMDFile);

  00055	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SMDFile
  0005b	52		 push	 edx
  0005c	e8 00 00 00 00	 call	 _fgetc
  00061	8b d8		 mov	 ebx, eax
  00063	83 c4 04	 add	 esp, 4
  00066	83 fb 0a	 cmp	 ebx, 10			; 0000000aH
  00069	75 e5		 jne	 SHORT $LL24@GetToken
$LN30@GetToken:

; 46   : 					}
; 47   : 	
; 48   : 					if (ch == -1)
; 49   : 					{
; 50   : 						return END;	// End of FILE
; 51   : 					}
; 52   : 				}
; 53   : 			}
; 54   : 		}
; 55   : 	}
; 56   : 	while (isspace(ch) != 0);

  0006b	53		 push	 ebx
  0006c	e8 00 00 00 00	 call	 _isspace
  00071	83 c4 04	 add	 esp, 4
  00074	85 c0		 test	 eax, eax
  00076	75 a8		 jne	 SHORT $LL31@GetToken

; 57   : 
; 58   : 	
; 59   : 	switch(ch)

  00078	8d 43 de	 lea	 eax, DWORD PTR [ebx-34]
  0007b	56		 push	 esi
  0007c	83 f8 5b	 cmp	 eax, 91			; 0000005bH
  0007f	0f 87 29 01 00
	00		 ja	 $LN6@GetToken
  00085	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR $LN46@GetToken[eax]
  0008c	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN50@GetToken[eax*4]
$LN39@GetToken:

; 34   : 		{
; 35   : 			return END;	// End of FILE (EOF)

  00093	b8 02 00 00 00	 mov	 eax, 2
  00098	5b		 pop	 ebx

; 147  : 		}
; 148  : 		break;
; 149  : 
; 150  : 	}
; 151  : 
; 152  : 	return NAME;
; 153  : }

  00099	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0009c	33 cd		 xor	 ecx, ebp
  0009e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000a3	8b e5		 mov	 esp, ebp
  000a5	5d		 pop	 ebp
  000a6	c3		 ret	 0
$LN19@GetToken:

; 60   : 	{
; 61   : 
; 62   : 	case 0x23:	// #
; 63   : 		return CurrentToken=COMMAND;

  000a7	b8 23 00 00 00	 mov	 eax, 35			; 00000023H
  000ac	e9 92 01 00 00	 jmp	 $LN48@GetToken
$LN18@GetToken:

; 64   : 		break;
; 65   : 	
; 66   : 	case 0x3B:	// ;
; 67   : 		return CurrentToken=SEMICOLON;

  000b1	b8 3b 00 00 00	 mov	 eax, 59			; 0000003bH
  000b6	e9 88 01 00 00	 jmp	 $LN48@GetToken
$LN17@GetToken:

; 68   : 		break;
; 69   : 	
; 70   : 	case 0x2C:	// ,
; 71   : 
; 72   : 		return CurrentToken=COMMA;

  000bb	b8 2c 00 00 00	 mov	 eax, 44			; 0000002cH
  000c0	e9 7e 01 00 00	 jmp	 $LN48@GetToken
$LN16@GetToken:

; 73   : 		break;
; 74   : 	
; 75   : 	case 0x7B:	// {
; 76   : 		return CurrentToken = LP;

  000c5	b8 7b 00 00 00	 mov	 eax, 123		; 0000007bH
  000ca	e9 74 01 00 00	 jmp	 $LN48@GetToken
$LN15@GetToken:

; 77   : 		break;
; 78   : 
; 79   : 	case 0x7D:	// }
; 80   : 		return CurrentToken = RP;

  000cf	b8 7d 00 00 00	 mov	 eax, 125		; 0000007dH
  000d4	e9 6a 01 00 00	 jmp	 $LN48@GetToken
$LN14@GetToken:

; 81   : 		break;
; 82   : 	// Nice Index Table :)	by Deathway
; 83   : 	// Numbers Case
; 84   : 	case 0x2D:	//-
; 85   : 	case 0x2E:	//.
; 86   : 	case '0':	//0
; 87   : 	case '1':	//1
; 88   : 	case '2':	//2
; 89   : 	case '3':	//3
; 90   : 	case '4':	//4		
; 91   : 	case '5':	//5
; 92   : 	case '6':	//6
; 93   : 	case '7':	//7
; 94   : 	case '8':	//8
; 95   : 	case '9':	//9
; 96   : 		ungetc(ch, SMDFile);

  000d9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SMDFile
  000df	51		 push	 ecx
  000e0	53		 push	 ebx
  000e1	e8 00 00 00 00	 call	 _ungetc

; 97   : 		p = TempString;
; 98   : 		
; 99   : 		while (((ch=getc(SMDFile)) != -1) && ((ch == 0x2E) || (isdigit(ch) != 0) || (ch == 0x2D)))  // 2e '.'  2D '-'

  000e6	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SMDFile
  000ec	52		 push	 edx
  000ed	8d 75 98	 lea	 esi, DWORD PTR _TempString$[ebp]
  000f0	e8 00 00 00 00	 call	 _getc
  000f5	8b d8		 mov	 ebx, eax
  000f7	83 c4 0c	 add	 esp, 12			; 0000000cH
  000fa	83 fb ff	 cmp	 ebx, -1
  000fd	74 30		 je	 SHORT $LN12@GetToken
  000ff	90		 npad	 1
$LL13@GetToken:
  00100	83 fb 2e	 cmp	 ebx, 46			; 0000002eH
  00103	74 12		 je	 SHORT $LN11@GetToken
  00105	53		 push	 ebx
  00106	e8 00 00 00 00	 call	 _isdigit
  0010b	83 c4 04	 add	 esp, 4
  0010e	85 c0		 test	 eax, eax
  00110	75 05		 jne	 SHORT $LN11@GetToken
  00112	83 fb 2d	 cmp	 ebx, 45			; 0000002dH
  00115	75 18		 jne	 SHORT $LN12@GetToken
$LN11@GetToken:
  00117	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile

; 100  : 		{
; 101  : 			*p = ch;	// Construct a String

  0011c	88 1e		 mov	 BYTE PTR [esi], bl
  0011e	50		 push	 eax

; 102  : 			p++;

  0011f	46		 inc	 esi
  00120	e8 00 00 00 00	 call	 _getc
  00125	8b d8		 mov	 ebx, eax
  00127	83 c4 04	 add	 esp, 4
  0012a	83 fb ff	 cmp	 ebx, -1
  0012d	75 d1		 jne	 SHORT $LL13@GetToken
$LN12@GetToken:

; 103  : 		}		
; 104  : 		*p = 0;
; 105  : 		TokenNumber = (float)atof( TempString);	// Select the first Byte as Main ID

  0012f	8d 4d 98	 lea	 ecx, DWORD PTR _TempString$[ebp]
  00132	51		 push	 ecx
  00133	c6 06 00	 mov	 BYTE PTR [esi], 0
  00136	e8 00 00 00 00	 call	 _atof
  0013b	d9 1d 00 00 00
	00		 fstp	 DWORD PTR _TokenNumber
  00141	83 c4 04	 add	 esp, 4
  00144	5e		 pop	 esi

; 106  : 		return CurrentToken  = NUMBER ;

  00145	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _CurrentToken, 1
  0014f	b8 01 00 00 00	 mov	 eax, 1
  00154	5b		 pop	 ebx

; 147  : 		}
; 148  : 		break;
; 149  : 
; 150  : 	}
; 151  : 
; 152  : 	return NAME;
; 153  : }

  00155	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00158	33 cd		 xor	 ecx, ebp
  0015a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0015f	8b e5		 mov	 esp, ebp
  00161	5d		 pop	 ebp
  00162	c3		 ret	 0
$LN10@GetToken:

; 107  : 		break;
; 108  : 
; 109  : 	case '\"':	// "	String Case
; 110  : 		p=&TokenString[0];
; 111  : 		
; 112  : 		while (((ch=getc(SMDFile)) != -1 ) && (ch != 0x22))	// nice

  00163	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SMDFile
  00169	52		 push	 edx
  0016a	be 00 00 00 00	 mov	 esi, OFFSET _TokenString
  0016f	e8 00 00 00 00	 call	 _getc
  00174	83 c4 04	 add	 esp, 4
  00177	83 f8 ff	 cmp	 eax, -1
  0017a	74 23		 je	 SHORT $LN8@GetToken
  0017c	8d 64 24 00	 npad	 4
$LL9@GetToken:
  00180	83 f8 22	 cmp	 eax, 34			; 00000022H
  00183	0f 84 96 00 00
	00		 je	 $LN7@GetToken

; 113  : 		{
; 114  : 			*p = ch;

  00189	88 06		 mov	 BYTE PTR [esi], al
  0018b	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile
  00190	50		 push	 eax

; 115  : 			p++;

  00191	46		 inc	 esi
  00192	e8 00 00 00 00	 call	 _getc
  00197	83 c4 04	 add	 esp, 4
  0019a	83 f8 ff	 cmp	 eax, -1
  0019d	75 e1		 jne	 SHORT $LL9@GetToken
$LN8@GetToken:

; 116  : 		}
; 117  : 		if (ch != 0x22 )

  0019f	83 f8 22	 cmp	 eax, 34			; 00000022H
  001a2	74 7b		 je	 SHORT $LN7@GetToken

; 118  : 		{
; 119  : 			ungetc(ch, SMDFile);

  001a4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SMDFile
  001aa	51		 push	 ecx
  001ab	50		 push	 eax

; 120  : 		}
; 121  : 		*p = 0;
; 122  : 		return CurrentToken = NAME;

  001ac	eb 69		 jmp	 SHORT $LN49@GetToken
$LN6@GetToken:

; 123  : 		break;
; 124  : 
; 125  : 	default:	// Others
; 126  : 		if (isalpha(ch))

  001ae	53		 push	 ebx
  001af	e8 00 00 00 00	 call	 _isalpha
  001b4	83 c4 04	 add	 esp, 4
  001b7	85 c0		 test	 eax, eax
  001b9	0f 84 7f 00 00
	00		 je	 $LN5@GetToken

; 127  : 		{
; 128  : 			p=&TokenString[0];
; 129  : 			*p=ch;
; 130  : 			p++;
; 131  : 
; 132  : 			while ( ((ch=getc(SMDFile)) != -1) && ( (ch == 0x2E) || (ch == 0x5F) || (isalnum(ch) != 0) ) )

  001bf	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SMDFile
  001c5	52		 push	 edx
  001c6	88 1d 00 00 00
	00		 mov	 BYTE PTR _TokenString, bl
  001cc	be 01 00 00 00	 mov	 esi, OFFSET _TokenString+1
  001d1	e8 00 00 00 00	 call	 _getc
  001d6	8b d8		 mov	 ebx, eax
  001d8	83 c4 04	 add	 esp, 4
  001db	83 fb ff	 cmp	 ebx, -1
  001de	74 2f		 je	 SHORT $LN3@GetToken
$LL4@GetToken:
  001e0	83 fb 2e	 cmp	 ebx, 46			; 0000002eH
  001e3	74 12		 je	 SHORT $LN2@GetToken
  001e5	83 fb 5f	 cmp	 ebx, 95			; 0000005fH
  001e8	74 0d		 je	 SHORT $LN2@GetToken
  001ea	53		 push	 ebx
  001eb	e8 00 00 00 00	 call	 _isalnum
  001f0	83 c4 04	 add	 esp, 4
  001f3	85 c0		 test	 eax, eax
  001f5	74 18		 je	 SHORT $LN3@GetToken
$LN2@GetToken:
  001f7	a1 00 00 00 00	 mov	 eax, DWORD PTR _SMDFile

; 133  : 			{
; 134  : 				*p=ch;

  001fc	88 1e		 mov	 BYTE PTR [esi], bl
  001fe	50		 push	 eax

; 135  : 				p++;

  001ff	46		 inc	 esi
  00200	e8 00 00 00 00	 call	 _getc
  00205	8b d8		 mov	 ebx, eax
  00207	83 c4 04	 add	 esp, 4
  0020a	83 fb ff	 cmp	 ebx, -1
  0020d	75 d1		 jne	 SHORT $LL4@GetToken
$LN3@GetToken:

; 136  : 				
; 137  : 			}
; 138  : 
; 139  : 			ungetc(ch, SMDFile);

  0020f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _SMDFile
  00215	51		 push	 ecx
  00216	53		 push	 ebx
$LN49@GetToken:
  00217	e8 00 00 00 00	 call	 _ungetc
  0021c	83 c4 08	 add	 esp, 8
$LN7@GetToken:

; 140  : 			*p=0;

  0021f	c6 06 00	 mov	 BYTE PTR [esi], 0
  00222	5e		 pop	 esi

; 141  : 			CurrentToken=NAME;

  00223	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _CurrentToken, 0

; 142  : 			return CurrentToken;

  0022d	33 c0		 xor	 eax, eax
  0022f	5b		 pop	 ebx

; 147  : 		}
; 148  : 		break;
; 149  : 
; 150  : 	}
; 151  : 
; 152  : 	return NAME;
; 153  : }

  00230	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00233	33 cd		 xor	 ecx, ebp
  00235	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0023a	8b e5		 mov	 esp, ebp
  0023c	5d		 pop	 ebp
  0023d	c3		 ret	 0
$LN5@GetToken:

; 143  : 		}
; 144  : 		else
; 145  : 		{
; 146  : 			return CurrentToken = SMD_ERROR; // '<'

  0023e	b8 3c 00 00 00	 mov	 eax, 60			; 0000003cH
$LN48@GetToken:

; 147  : 		}
; 148  : 		break;
; 149  : 
; 150  : 	}
; 151  : 
; 152  : 	return NAME;
; 153  : }

  00243	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00246	5e		 pop	 esi
  00247	33 cd		 xor	 ecx, ebp
  00249	a3 00 00 00 00	 mov	 DWORD PTR _CurrentToken, eax
  0024e	5b		 pop	 ebx
  0024f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00254	8b e5		 mov	 esp, ebp
  00256	5d		 pop	 ebp
  00257	c3		 ret	 0
$LN50@GetToken:
  00258	00 00 00 00	 DD	 $LN10@GetToken
  0025c	00 00 00 00	 DD	 $LN19@GetToken
  00260	00 00 00 00	 DD	 $LN17@GetToken
  00264	00 00 00 00	 DD	 $LN14@GetToken
  00268	00 00 00 00	 DD	 $LN18@GetToken
  0026c	00 00 00 00	 DD	 $LN16@GetToken
  00270	00 00 00 00	 DD	 $LN15@GetToken
  00274	00 00 00 00	 DD	 $LN6@GetToken
$LN46@GetToken:
  00278	00		 DB	 0
  00279	01		 DB	 1
  0027a	07		 DB	 7
  0027b	07		 DB	 7
  0027c	07		 DB	 7
  0027d	07		 DB	 7
  0027e	07		 DB	 7
  0027f	07		 DB	 7
  00280	07		 DB	 7
  00281	07		 DB	 7
  00282	02		 DB	 2
  00283	03		 DB	 3
  00284	03		 DB	 3
  00285	07		 DB	 7
  00286	03		 DB	 3
  00287	03		 DB	 3
  00288	03		 DB	 3
  00289	03		 DB	 3
  0028a	03		 DB	 3
  0028b	03		 DB	 3
  0028c	03		 DB	 3
  0028d	03		 DB	 3
  0028e	03		 DB	 3
  0028f	03		 DB	 3
  00290	07		 DB	 7
  00291	04		 DB	 4
  00292	07		 DB	 7
  00293	07		 DB	 7
  00294	07		 DB	 7
  00295	07		 DB	 7
  00296	07		 DB	 7
  00297	07		 DB	 7
  00298	07		 DB	 7
  00299	07		 DB	 7
  0029a	07		 DB	 7
  0029b	07		 DB	 7
  0029c	07		 DB	 7
  0029d	07		 DB	 7
  0029e	07		 DB	 7
  0029f	07		 DB	 7
  002a0	07		 DB	 7
  002a1	07		 DB	 7
  002a2	07		 DB	 7
  002a3	07		 DB	 7
  002a4	07		 DB	 7
  002a5	07		 DB	 7
  002a6	07		 DB	 7
  002a7	07		 DB	 7
  002a8	07		 DB	 7
  002a9	07		 DB	 7
  002aa	07		 DB	 7
  002ab	07		 DB	 7
  002ac	07		 DB	 7
  002ad	07		 DB	 7
  002ae	07		 DB	 7
  002af	07		 DB	 7
  002b0	07		 DB	 7
  002b1	07		 DB	 7
  002b2	07		 DB	 7
  002b3	07		 DB	 7
  002b4	07		 DB	 7
  002b5	07		 DB	 7
  002b6	07		 DB	 7
  002b7	07		 DB	 7
  002b8	07		 DB	 7
  002b9	07		 DB	 7
  002ba	07		 DB	 7
  002bb	07		 DB	 7
  002bc	07		 DB	 7
  002bd	07		 DB	 7
  002be	07		 DB	 7
  002bf	07		 DB	 7
  002c0	07		 DB	 7
  002c1	07		 DB	 7
  002c2	07		 DB	 7
  002c3	07		 DB	 7
  002c4	07		 DB	 7
  002c5	07		 DB	 7
  002c6	07		 DB	 7
  002c7	07		 DB	 7
  002c8	07		 DB	 7
  002c9	07		 DB	 7
  002ca	07		 DB	 7
  002cb	07		 DB	 7
  002cc	07		 DB	 7
  002cd	07		 DB	 7
  002ce	07		 DB	 7
  002cf	07		 DB	 7
  002d0	07		 DB	 7
  002d1	05		 DB	 5
  002d2	07		 DB	 7
  002d3	06		 DB	 6
?GetToken@@YA?AW4SMDToken@@XZ ENDP			; GetToken
_TEXT	ENDS
PUBLIC	?Init@CDoubleGoerEvent@@QAEXXZ			; CDoubleGoerEvent::Init
; Function compile flags: /Ogtp
; File c:\muserver_dev\development\mu-s8ep2-repack\gameserver\source\doublegoerevent.cpp
;	COMDAT ?Init@CDoubleGoerEvent@@QAEXXZ
_TEXT	SEGMENT
?Init@CDoubleGoerEvent@@QAEXXZ PROC			; CDoubleGoerEvent::Init, COMDAT
; _this$ = ecx

; 89   : {

  00000	8b d1		 mov	 edx, ecx

; 90   : 	int i;
; 91   : 	for(i = 0; i < DOUBLEGOER_MAXPLAYER; i++)
; 92   : 	{
; 93   : 		m_PlayerInfo[i].aIndex = -1;

  00002	83 c8 ff	 or	 eax, -1
  00005	89 82 88 00 00
	00		 mov	 DWORD PTR [edx+136], eax
  0000b	89 82 90 00 00
	00		 mov	 DWORD PTR [edx+144], eax
  00011	89 82 98 00 00
	00		 mov	 DWORD PTR [edx+152], eax
  00017	89 82 a0 00 00
	00		 mov	 DWORD PTR [edx+160], eax
  0001d	89 82 a8 00 00
	00		 mov	 DWORD PTR [edx+168], eax
  00023	56		 push	 esi

; 94   : 	}
; 95   : 
; 96   : 	m_iLeaderIndex = -1;
; 97   : 	m_iPlayerCount = 0;

  00024	33 f6		 xor	 esi, esi
  00026	89 82 80 00 00
	00		 mov	 DWORD PTR [edx+128], eax
  0002c	89 72 34	 mov	 DWORD PTR [edx+52], esi
  0002f	57		 push	 edi
  00030	8d ba b0 00 00
	00		 lea	 edi, DWORD PTR [edx+176]

; 98   : 
; 99   : 	for(i = 0; i < DOUBLEGOER_MAXMONSTER; i++)
; 100  : 	{
; 101  : 		m_MonsterInfo[i] = -1;

  00036	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  0003b	f3 ab		 rep stosd

; 102  : 	}
; 103  : 
; 104  : 	for(i = 0; i < DOUBLEGOER_MAXBOX; i++)
; 105  : 	{
; 106  : 		m_BoxInfo[i] = -1;

  0003d	89 82 40 02 00
	00		 mov	 DWORD PTR [edx+576], eax
  00043	89 82 44 02 00
	00		 mov	 DWORD PTR [edx+580], eax
  00049	89 82 48 02 00
	00		 mov	 DWORD PTR [edx+584], eax
  0004f	89 82 4c 02 00
	00		 mov	 DWORD PTR [edx+588], eax
  00055	89 82 50 02 00
	00		 mov	 DWORD PTR [edx+592], eax
  0005b	89 82 54 02 00
	00		 mov	 DWORD PTR [edx+596], eax

; 107  : 	}
; 108  : 
; 109  : 	m_iMonsterPassed = 0;
; 110  : 	m_bSEND_PLAY_START = FALSE;
; 111  : 	m_bMSG_BEFORE_START = FALSE;
; 112  : 
; 113  : 	m_bSUMMON_1ST_BOSS = FALSE;
; 114  : 	m_bSUMMON_2ND_BOSS = FALSE;
; 115  : 	m_bSUMMON_3RD_BOSS = FALSE;
; 116  : 
; 117  : 	m_iBossIndex = -1;

  00061	89 42 64	 mov	 DWORD PTR [edx+100], eax

; 118  : 
; 119  : 	m_iWaveDist = 0;
; 120  : 	m_iCurentMap = -1;

  00064	89 42 30	 mov	 DWORD PTR [edx+48], eax

; 121  : 
; 122  : 	m_iMONSTER_MINUTE_SPAWN = m_iEVENT_TIME;

  00067	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  0006a	5f		 pop	 edi
  0006b	89 72 38	 mov	 DWORD PTR [edx+56], esi
  0006e	89 72 54	 mov	 DWORD PTR [edx+84], esi
  00071	89 72 44	 mov	 DWORD PTR [edx+68], esi
  00074	89 72 58	 mov	 DWORD PTR [edx+88], esi
  00077	89 72 5c	 mov	 DWORD PTR [edx+92], esi
  0007a	89 72 60	 mov	 DWORD PTR [edx+96], esi
  0007d	89 72 3c	 mov	 DWORD PTR [edx+60], esi
  00080	89 42 40	 mov	 DWORD PTR [edx+64], eax
  00083	5e		 pop	 esi

; 123  : }

  00084	c3		 ret	 0
?Init@CDoubleGoerEvent@@QAEXXZ ENDP			; CDoubleGoerEvent::Init
_TEXT	ENDS
PUBLIC	??_C@_0CC@MHPEIGJE@?$FLDoppelganger?$FN?5SetState_WAITING?$CI@ ; `string'
PUBLIC	?SetState_WAITING@CDoubleGoerEvent@@QAEXXZ	; CDoubleGoerEvent::SetState_WAITING
EXTRN	_rand:PROC
EXTRN	__imp__GetTickCount@0:PROC
EXTRN	?LogAddTD@@3P6AXPADZZA:DWORD			; LogAddTD
;	COMDAT ??_C@_0CC@MHPEIGJE@?$FLDoppelganger?$FN?5SetState_WAITING?$CI@
CONST	SEGMENT
??_C@_0CC@MHPEIGJE@?$FLDoppelganger?$FN?5SetState_WAITING?$CI@ DB '[Doppe'
	DB	'lganger] SetState_WAITING()', 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?SetState_WAITING@CDoubleGoerEvent@@QAEXXZ
_TEXT	SEGMENT
?SetState_WAITING@CDoubleGoerEvent@@QAEXXZ PROC		; CDoubleGoerEvent::SetState_WAITING, COMDAT
; _this$ = ecx

; 615  : {

  00000	56		 push	 esi

; 616  : 	LogAddTD("[Doppelganger] SetState_WAITING()");

  00001	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@MHPEIGJE@?$FLDoppelganger?$FN?5SetState_WAITING?$CI@
  00006	8b f1		 mov	 esi, ecx
  00008	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 617  : 	m_iREMAIN_TIME = m_iEVENT_WAIT*60*1000;

  0000e	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00011	69 c0 60 ea 00
	00		 imul	 eax, 60000		; 0000ea60H
  00017	83 c4 04	 add	 esp, 4
  0001a	89 46 28	 mov	 DWORD PTR [esi+40], eax

; 618  : 	m_dwTICK_COUNT = GetTickCount();

  0001d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00023	89 46 2c	 mov	 DWORD PTR [esi+44], eax

; 619  : 
; 620  : 	m_iCurentMap = MAP_INDEX_DOUBLEGOER1 + rand()%DOUBLEGOER_MAXMAP;

  00026	e8 00 00 00 00	 call	 _rand
  0002b	25 03 00 00 80	 and	 eax, -2147483645	; 80000003H
  00030	79 05		 jns	 SHORT $LN3@SetState_W
  00032	48		 dec	 eax
  00033	83 c8 fc	 or	 eax, -4			; fffffffcH
  00036	40		 inc	 eax
$LN3@SetState_W:
  00037	83 c0 41	 add	 eax, 65			; 00000041H
  0003a	89 46 30	 mov	 DWORD PTR [esi+48], eax
  0003d	5e		 pop	 esi

; 621  : }

  0003e	c3		 ret	 0
?SetState_WAITING@CDoubleGoerEvent@@QAEXXZ ENDP		; CDoubleGoerEvent::SetState_WAITING
_TEXT	ENDS
PUBLIC	??_C@_0CC@GGFFAAMP@?$FLDoppelganger?$FN?5SetState_PLAYING?$CI@ ; `string'
PUBLIC	?SetState_PLAYING@CDoubleGoerEvent@@QAEXXZ	; CDoubleGoerEvent::SetState_PLAYING
;	COMDAT ??_C@_0CC@GGFFAAMP@?$FLDoppelganger?$FN?5SetState_PLAYING?$CI@
CONST	SEGMENT
??_C@_0CC@GGFFAAMP@?$FLDoppelganger?$FN?5SetState_PLAYING?$CI@ DB '[Doppe'
	DB	'lganger] SetState_PLAYING()', 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?SetState_PLAYING@CDoubleGoerEvent@@QAEXXZ
_TEXT	SEGMENT
?SetState_PLAYING@CDoubleGoerEvent@@QAEXXZ PROC		; CDoubleGoerEvent::SetState_PLAYING, COMDAT
; _this$ = ecx

; 624  : {

  00000	56		 push	 esi

; 625  : 	LogAddTD("[Doppelganger] SetState_PLAYING()");

  00001	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@GGFFAAMP@?$FLDoppelganger?$FN?5SetState_PLAYING?$CI@
  00006	8b f1		 mov	 esi, ecx
  00008	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 626  : 	m_iREMAIN_TIME = m_iEVENT_TIME*60*1000;

  0000e	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00011	69 c0 60 ea 00
	00		 imul	 eax, 60000		; 0000ea60H
  00017	83 c4 04	 add	 esp, 4
  0001a	89 46 28	 mov	 DWORD PTR [esi+40], eax

; 627  : 	m_dwTICK_COUNT = GetTickCount();

  0001d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00023	89 46 2c	 mov	 DWORD PTR [esi+44], eax
  00026	5e		 pop	 esi

; 628  : }

  00027	c3		 ret	 0
?SetState_PLAYING@CDoubleGoerEvent@@QAEXXZ ENDP		; CDoubleGoerEvent::SetState_PLAYING
_TEXT	ENDS
PUBLIC	?GetOpenTime@CDoubleGoerEvent@@QAEEXZ		; CDoubleGoerEvent::GetOpenTime
; Function compile flags: /Ogtp
;	COMDAT ?GetOpenTime@CDoubleGoerEvent@@QAEEXZ
_TEXT	SEGMENT
?GetOpenTime@CDoubleGoerEvent@@QAEEXZ PROC		; CDoubleGoerEvent::GetOpenTime, COMDAT
; _this$ = ecx

; 673  : 	if( m_iState == DOUBLEGOER_STATE_PLAYING )

  00000	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  00003	83 f8 02	 cmp	 eax, 2
  00006	75 1a		 jne	 SHORT $LN3@GetOpenTim

; 674  : 	{
; 675  : 		return m_iREMAIN_TIME/60000 + m_iEVENT_PLAYEND+1;

  00008	b8 73 b2 e7 45	 mov	 eax, 1172812403		; 45e7b273H
  0000d	f7 69 28	 imul	 DWORD PTR [ecx+40]
  00010	8b 49 18	 mov	 ecx, DWORD PTR [ecx+24]
  00013	c1 fa 0e	 sar	 edx, 14			; 0000000eH
  00016	8b c2		 mov	 eax, edx
  00018	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0001b	03 c2		 add	 eax, edx
  0001d	8d 44 08 01	 lea	 eax, DWORD PTR [eax+ecx+1]

; 683  : }

  00021	c3		 ret	 0
$LN3@GetOpenTim:

; 676  : 	}
; 677  : 	else if( m_iState == DOUBLEGOER_STATE_PLAYEND )

  00022	83 f8 03	 cmp	 eax, 3
  00025	75 17		 jne	 SHORT $LN1@GetOpenTim

; 678  : 	{
; 679  : 		return m_iREMAIN_TIME/60000+1;

  00027	8b 49 28	 mov	 ecx, DWORD PTR [ecx+40]
  0002a	b8 73 b2 e7 45	 mov	 eax, 1172812403		; 45e7b273H
  0002f	f7 e9		 imul	 ecx
  00031	c1 fa 0e	 sar	 edx, 14			; 0000000eH
  00034	8b c2		 mov	 eax, edx
  00036	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00039	8d 44 02 01	 lea	 eax, DWORD PTR [edx+eax+1]

; 683  : }

  0003d	c3		 ret	 0
$LN1@GetOpenTim:

; 680  : 	}
; 681  : 
; 682  : return 0;

  0003e	32 c0		 xor	 al, al

; 683  : }

  00040	c3		 ret	 0
?GetOpenTime@CDoubleGoerEvent@@QAEEXZ ENDP		; CDoubleGoerEvent::GetOpenTime
_TEXT	ENDS
PUBLIC	?DelUser@CDoubleGoerEvent@@QAEHH@Z		; CDoubleGoerEvent::DelUser
; Function compile flags: /Ogtp
;	COMDAT ?DelUser@CDoubleGoerEvent@@QAEHH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
?DelUser@CDoubleGoerEvent@@QAEHH@Z PROC			; CDoubleGoerEvent::DelUser, COMDAT
; _this$ = ecx

; 705  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 706  : 	for(int i = 0; i < DOUBLEGOER_MAXPLAYER; i++)

  00004	8b 75 08	 mov	 esi, DWORD PTR _aIndex$[ebp]
  00007	33 c0		 xor	 eax, eax
  00009	8d 91 88 00 00
	00		 lea	 edx, DWORD PTR [ecx+136]
  0000f	90		 npad	 1
$LL4@DelUser:

; 707  : 	{
; 708  : 		if( m_PlayerInfo[i].aIndex == aIndex )

  00010	39 32		 cmp	 DWORD PTR [edx], esi
  00012	74 10		 je	 SHORT $LN8@DelUser

; 706  : 	for(int i = 0; i < DOUBLEGOER_MAXPLAYER; i++)

  00014	40		 inc	 eax
  00015	83 c2 08	 add	 edx, 8
  00018	83 f8 05	 cmp	 eax, 5
  0001b	7c f3		 jl	 SHORT $LL4@DelUser

; 713  : 		}
; 714  : 	}
; 715  : return false;

  0001d	33 c0		 xor	 eax, eax
  0001f	5e		 pop	 esi

; 716  : }

  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
$LN8@DelUser:

; 709  : 		{
; 710  : 			m_PlayerInfo[i].aIndex = -1;

  00024	83 ca ff	 or	 edx, -1
  00027	89 94 c1 88 00
	00 00		 mov	 DWORD PTR [ecx+eax*8+136], edx

; 711  : 			m_iPlayerCount--;

  0002e	01 51 34	 add	 DWORD PTR [ecx+52], edx

; 712  : 			return true;

  00031	8d 42 02	 lea	 eax, DWORD PTR [edx+2]
  00034	5e		 pop	 esi

; 716  : }

  00035	5d		 pop	 ebp
  00036	c2 04 00	 ret	 4
?DelUser@CDoubleGoerEvent@@QAEHH@Z ENDP			; CDoubleGoerEvent::DelUser
_TEXT	ENDS
PUBLIC	?AddMonster@CDoubleGoerEvent@@QAEHH@Z		; CDoubleGoerEvent::AddMonster
; Function compile flags: /Ogtp
;	COMDAT ?AddMonster@CDoubleGoerEvent@@QAEHH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
?AddMonster@CDoubleGoerEvent@@QAEHH@Z PROC		; CDoubleGoerEvent::AddMonster, COMDAT
; _this$ = ecx

; 719  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 720  : 	for(int i = 0; i < DOUBLEGOER_MAXMONSTER; i++)

  00003	33 c0		 xor	 eax, eax
  00005	8d 91 b0 00 00
	00		 lea	 edx, DWORD PTR [ecx+176]
  0000b	eb 03 8d 49 00	 npad	 5
$LL4@AddMonster:

; 721  : 	{
; 722  : 		if( m_MonsterInfo[i] == -1 )

  00010	83 3a ff	 cmp	 DWORD PTR [edx], -1
  00013	74 0f		 je	 SHORT $LN8@AddMonster

; 720  : 	for(int i = 0; i < DOUBLEGOER_MAXMONSTER; i++)

  00015	40		 inc	 eax
  00016	83 c2 04	 add	 edx, 4
  00019	83 f8 64	 cmp	 eax, 100		; 00000064H
  0001c	7c f2		 jl	 SHORT $LL4@AddMonster

; 726  : 		}
; 727  : 	}
; 728  : return false;

  0001e	33 c0		 xor	 eax, eax

; 729  : }

  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
$LN8@AddMonster:

; 723  : 		{
; 724  : 			m_MonsterInfo[i] = aIndex;

  00024	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00027	89 94 81 b0 00
	00 00		 mov	 DWORD PTR [ecx+eax*4+176], edx

; 725  : 			return true;

  0002e	b8 01 00 00 00	 mov	 eax, 1

; 729  : }

  00033	5d		 pop	 ebp
  00034	c2 04 00	 ret	 4
?AddMonster@CDoubleGoerEvent@@QAEHH@Z ENDP		; CDoubleGoerEvent::AddMonster
_TEXT	ENDS
PUBLIC	?AddBox@CDoubleGoerEvent@@QAEHH@Z		; CDoubleGoerEvent::AddBox
; Function compile flags: /Ogtp
;	COMDAT ?AddBox@CDoubleGoerEvent@@QAEHH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
?AddBox@CDoubleGoerEvent@@QAEHH@Z PROC			; CDoubleGoerEvent::AddBox, COMDAT
; _this$ = ecx

; 732  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 733  : 	for(int i = 0; i < DOUBLEGOER_MAXBOX; i++)

  00003	33 c0		 xor	 eax, eax
  00005	8d 91 40 02 00
	00		 lea	 edx, DWORD PTR [ecx+576]
  0000b	eb 03 8d 49 00	 npad	 5
$LL4@AddBox:

; 734  : 	{
; 735  : 		if( m_BoxInfo[i] == -1 )

  00010	83 3a ff	 cmp	 DWORD PTR [edx], -1
  00013	74 0f		 je	 SHORT $LN8@AddBox

; 733  : 	for(int i = 0; i < DOUBLEGOER_MAXBOX; i++)

  00015	40		 inc	 eax
  00016	83 c2 04	 add	 edx, 4
  00019	83 f8 06	 cmp	 eax, 6
  0001c	7c f2		 jl	 SHORT $LL4@AddBox

; 739  : 		}
; 740  : 	}
; 741  : return false;

  0001e	33 c0		 xor	 eax, eax

; 742  : }

  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
$LN8@AddBox:

; 736  : 		{
; 737  : 			m_BoxInfo[i] = aIndex;

  00024	8b 55 08	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00027	89 94 81 40 02
	00 00		 mov	 DWORD PTR [ecx+eax*4+576], edx

; 738  : 			return true;

  0002e	b8 01 00 00 00	 mov	 eax, 1

; 742  : }

  00033	5d		 pop	 ebp
  00034	c2 04 00	 ret	 4
?AddBox@CDoubleGoerEvent@@QAEHH@Z ENDP			; CDoubleGoerEvent::AddBox
_TEXT	ENDS
PUBLIC	?DelMonster@CDoubleGoerEvent@@QAEHH@Z		; CDoubleGoerEvent::DelMonster
EXTRN	?gObjDel@@YAFH@Z:PROC				; gObjDel
; Function compile flags: /Ogtp
;	COMDAT ?DelMonster@CDoubleGoerEvent@@QAEHH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
?DelMonster@CDoubleGoerEvent@@QAEHH@Z PROC		; CDoubleGoerEvent::DelMonster, COMDAT
; _this$ = ecx

; 745  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 746  : 	for(int i = 0; i < DOUBLEGOER_MAXMONSTER; i++)

  00004	8b 75 08	 mov	 esi, DWORD PTR _aIndex$[ebp]
  00007	33 c0		 xor	 eax, eax
  00009	8d 91 b0 00 00
	00		 lea	 edx, DWORD PTR [ecx+176]
  0000f	90		 npad	 1
$LL4@DelMonster:

; 747  : 	{
; 748  : 		if( m_MonsterInfo[i] == aIndex )

  00010	39 32		 cmp	 DWORD PTR [edx], esi
  00012	74 10		 je	 SHORT $LN8@DelMonster

; 746  : 	for(int i = 0; i < DOUBLEGOER_MAXMONSTER; i++)

  00014	40		 inc	 eax
  00015	83 c2 04	 add	 edx, 4
  00018	83 f8 64	 cmp	 eax, 100		; 00000064H
  0001b	7c f3		 jl	 SHORT $LL4@DelMonster

; 753  : 		}
; 754  : 	}
; 755  : return false;

  0001d	33 c0		 xor	 eax, eax
  0001f	5e		 pop	 esi

; 756  : }

  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
$LN8@DelMonster:

; 749  : 		{
; 750  : 			m_MonsterInfo[i] = -1;
; 751  : 			gObjDel(aIndex);

  00024	56		 push	 esi
  00025	c7 84 81 b0 00
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [ecx+eax*4+176], -1
  00030	e8 00 00 00 00	 call	 ?gObjDel@@YAFH@Z	; gObjDel
  00035	83 c4 04	 add	 esp, 4

; 752  : 			return true;

  00038	b8 01 00 00 00	 mov	 eax, 1
  0003d	5e		 pop	 esi

; 756  : }

  0003e	5d		 pop	 ebp
  0003f	c2 04 00	 ret	 4
?DelMonster@CDoubleGoerEvent@@QAEHH@Z ENDP		; CDoubleGoerEvent::DelMonster
_TEXT	ENDS
PUBLIC	?DelBox@CDoubleGoerEvent@@QAEHH@Z		; CDoubleGoerEvent::DelBox
; Function compile flags: /Ogtp
;	COMDAT ?DelBox@CDoubleGoerEvent@@QAEHH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
?DelBox@CDoubleGoerEvent@@QAEHH@Z PROC			; CDoubleGoerEvent::DelBox, COMDAT
; _this$ = ecx

; 759  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 760  : 	for(int i = 0; i < DOUBLEGOER_MAXBOX; i++)

  00004	8b 75 08	 mov	 esi, DWORD PTR _aIndex$[ebp]
  00007	33 c0		 xor	 eax, eax
  00009	8d 91 40 02 00
	00		 lea	 edx, DWORD PTR [ecx+576]
  0000f	90		 npad	 1
$LL4@DelBox:

; 761  : 	{
; 762  : 		if( m_BoxInfo[i] == aIndex )

  00010	39 32		 cmp	 DWORD PTR [edx], esi
  00012	74 10		 je	 SHORT $LN8@DelBox

; 760  : 	for(int i = 0; i < DOUBLEGOER_MAXBOX; i++)

  00014	40		 inc	 eax
  00015	83 c2 04	 add	 edx, 4
  00018	83 f8 06	 cmp	 eax, 6
  0001b	7c f3		 jl	 SHORT $LL4@DelBox

; 766  : 		}
; 767  : 	}
; 768  : return false;

  0001d	33 c0		 xor	 eax, eax
  0001f	5e		 pop	 esi

; 769  : }

  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
$LN8@DelBox:

; 763  : 		{
; 764  : 			m_BoxInfo[i] = -1;

  00024	c7 84 81 40 02
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [ecx+eax*4+576], -1

; 765  : 			return true;

  0002f	b8 01 00 00 00	 mov	 eax, 1
  00034	5e		 pop	 esi

; 769  : }

  00035	5d		 pop	 ebp
  00036	c2 04 00	 ret	 4
?DelBox@CDoubleGoerEvent@@QAEHH@Z ENDP			; CDoubleGoerEvent::DelBox
_TEXT	ENDS
PUBLIC	?SendData@CDoubleGoerEvent@@QAEXPAEH@Z		; CDoubleGoerEvent::SendData
EXTRN	?DataSend@@YAHHPAEK@Z:PROC			; DataSend
; Function compile flags: /Ogtp
;	COMDAT ?SendData@CDoubleGoerEvent@@QAEXPAEH@Z
_TEXT	SEGMENT
_pMsg$ = 8						; size = 4
_size$ = 12						; size = 4
?SendData@CDoubleGoerEvent@@QAEXPAEH@Z PROC		; CDoubleGoerEvent::SendData, COMDAT
; _this$ = ecx

; 772  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 773  : 	for(int i = 0; i < DOUBLEGOER_MAXPLAYER; i++)

  00004	8b 5d 0c	 mov	 ebx, DWORD PTR _size$[ebp]
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8d b1 88 00 00
	00		 lea	 esi, DWORD PTR [ecx+136]
  0000f	bf 05 00 00 00	 mov	 edi, 5
$LL4@SendData:

; 774  : 	{
; 775  : 		int aIndex = m_PlayerInfo[i].aIndex;

  00014	8b 06		 mov	 eax, DWORD PTR [esi]

; 776  : 		if(  OBJMAX_RANGE(aIndex) )

  00016	85 c0		 test	 eax, eax
  00018	78 1c		 js	 SHORT $LN3@SendData
  0001a	33 c9		 xor	 ecx, ecx
  0001c	3d eb 2c 00 00	 cmp	 eax, 11499		; 00002cebH
  00021	0f 9e c1	 setle	 cl
  00024	85 c9		 test	 ecx, ecx
  00026	74 0e		 je	 SHORT $LN3@SendData

; 777  : 		{
; 778  : 			DataSend(aIndex,pMsg,size);

  00028	8b 4d 08	 mov	 ecx, DWORD PTR _pMsg$[ebp]
  0002b	53		 push	 ebx
  0002c	51		 push	 ecx
  0002d	50		 push	 eax
  0002e	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00033	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN3@SendData:

; 773  : 	for(int i = 0; i < DOUBLEGOER_MAXPLAYER; i++)

  00036	83 c6 08	 add	 esi, 8
  00039	4f		 dec	 edi
  0003a	75 d8		 jne	 SHORT $LL4@SendData
  0003c	5f		 pop	 edi
  0003d	5e		 pop	 esi
  0003e	5b		 pop	 ebx

; 779  : 		}
; 780  : 	}
; 781  : }

  0003f	5d		 pop	 ebp
  00040	c2 08 00	 ret	 8
?SendData@CDoubleGoerEvent@@QAEXPAEH@Z ENDP		; CDoubleGoerEvent::SendData
_TEXT	ENDS
PUBLIC	?SendStart@CDoubleGoerEvent@@QAEXXZ		; CDoubleGoerEvent::SendStart
EXTRN	?PHeadSubSetB@@YAXPAEEEH@Z:PROC			; PHeadSubSetB
; Function compile flags: /Ogtp
;	COMDAT ?SendStart@CDoubleGoerEvent@@QAEXXZ
_TEXT	SEGMENT
_pMsg$ = -8						; size = 5
?SendStart@CDoubleGoerEvent@@QAEXXZ PROC		; CDoubleGoerEvent::SendStart, COMDAT
; _this$ = ecx

; 784  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx

; 785  : 	m_bSEND_PLAY_START = TRUE;
; 786  : 	m_iREMAIN_TIME = m_iEVENT_TIME*60*1000;

  00009	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0000c	57		 push	 edi
  0000d	69 c0 60 ea 00
	00		 imul	 eax, 60000		; 0000ea60H

; 787  : 
; 788  : 	PMSG_DOUBLEGOER_SET_START pMsg;
; 789  : 	PHeadSubSetB((LPBYTE)&pMsg,0xBF,16,sizeof(pMsg));

  00013	6a 05		 push	 5
  00015	6a 10		 push	 16			; 00000010H
  00017	8d 4d f8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0001a	68 bf 00 00 00	 push	 191			; 000000bfH
  0001f	51		 push	 ecx
  00020	c7 46 54 01 00
	00 00		 mov	 DWORD PTR [esi+84], 1
  00027	89 46 28	 mov	 DWORD PTR [esi+40], eax
  0002a	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB
  0002f	83 c4 10	 add	 esp, 16			; 00000010H

; 790  : 	pMsg.btResult = 2;

  00032	c6 45 fc 02	 mov	 BYTE PTR _pMsg$[ebp+4], 2
  00036	81 c6 88 00 00
	00		 add	 esi, 136		; 00000088H
  0003c	bf 05 00 00 00	 mov	 edi, 5
$LL4@SendStart:

; 793  : 	{
; 794  : 		int aIndex = m_PlayerInfo[i].aIndex;

  00041	8b 06		 mov	 eax, DWORD PTR [esi]

; 795  : 		if( OBJMAX_RANGE(aIndex) )

  00043	85 c0		 test	 eax, eax
  00045	78 20		 js	 SHORT $LN3@SendStart
  00047	33 c9		 xor	 ecx, ecx
  00049	3d eb 2c 00 00	 cmp	 eax, 11499		; 00002cebH
  0004e	0f 9e c1	 setle	 cl
  00051	85 c9		 test	 ecx, ecx
  00053	74 12		 je	 SHORT $LN3@SendStart

; 796  : 		{
; 797  : 			DataSend(aIndex,(LPBYTE)&pMsg,pMsg.h.size);

  00055	0f b6 55 f9	 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  00059	52		 push	 edx
  0005a	8d 4d f8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0005d	51		 push	 ecx
  0005e	50		 push	 eax
  0005f	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00064	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN3@SendStart:

; 791  : 
; 792  : 	for(int i = 0; i < DOUBLEGOER_MAXPLAYER; i++)

  00067	83 c6 08	 add	 esi, 8
  0006a	4f		 dec	 edi
  0006b	75 d4		 jne	 SHORT $LL4@SendStart
  0006d	5f		 pop	 edi
  0006e	5e		 pop	 esi

; 798  : 		}
; 799  : 	}
; 800  : }

  0006f	8b e5		 mov	 esp, ebp
  00071	5d		 pop	 ebp
  00072	c3		 ret	 0
?SendStart@CDoubleGoerEvent@@QAEXXZ ENDP		; CDoubleGoerEvent::SendStart
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?SendPlayInfo@CDoubleGoerEvent@@QAEXXZ		; CDoubleGoerEvent::SendPlayInfo
; Function compile flags: /Ogtp
;	COMDAT ?SendPlayInfo@CDoubleGoerEvent@@QAEXXZ
_TEXT	SEGMENT
tv267 = -40						; size = 4
tv265 = -40						; size = 4
tv270 = -34						; size = 2
_pMsg$ = -32						; size = 28
__$ArrayPad$ = -4					; size = 4
?SendPlayInfo@CDoubleGoerEvent@@QAEXXZ PROC		; CDoubleGoerEvent::SendPlayInfo, COMDAT
; _this$ = ecx

; 803  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	57		 push	 edi

; 804  : 	PMSG_DOUBLEGOER_PLAYINFO pMsg;
; 805  : 	PHeadSubSetB((LPBYTE)&pMsg,0xBF,18,sizeof(pMsg));

  00012	6a 1c		 push	 28			; 0000001cH
  00014	6a 12		 push	 18			; 00000012H
  00016	8d 45 e0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00019	68 bf 00 00 00	 push	 191			; 000000bfH
  0001e	50		 push	 eax
  0001f	8b f1		 mov	 esi, ecx
  00021	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 806  : 
; 807  : 	pMsg.EventTime = m_iREMAIN_TIME/1000;

  00026	b8 d3 4d 62 10	 mov	 eax, 274877907		; 10624dd3H
  0002b	f7 6e 28	 imul	 DWORD PTR [esi+40]
  0002e	c1 fa 06	 sar	 edx, 6
  00031	8b ca		 mov	 ecx, edx
  00033	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00036	83 c4 10	 add	 esp, 16			; 00000010H
  00039	03 ca		 add	 ecx, edx
  0003b	66 89 4d e4	 mov	 WORD PTR _pMsg$[ebp+4], cx

; 808  : 	pMsg.btCount = 0;

  0003f	c6 45 e6 00	 mov	 BYTE PTR _pMsg$[ebp+6], 0

; 811  : 	{
; 812  : 		int aIndex = m_PlayerInfo[i].aIndex;

  00043	8d 8e 8c 00 00
	00		 lea	 ecx, DWORD PTR [esi+140]
  00049	bf 05 00 00 00	 mov	 edi, 5
  0004e	8b ff		 npad	 2
$LL4@SendPlayIn:
  00050	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]

; 813  : 
; 814  : 		if( OBJMAX_RANGE(aIndex) )

  00053	85 c0		 test	 eax, eax
  00055	78 50		 js	 SHORT $LN3@SendPlayIn
  00057	33 d2		 xor	 edx, edx
  00059	3d eb 2c 00 00	 cmp	 eax, 11499		; 00002cebH
  0005e	0f 9e c2	 setle	 dl
  00061	85 d2		 test	 edx, edx
  00063	74 42		 je	 SHORT $LN3@SendPlayIn

; 815  : 		{
; 816  : 			pMsg.m_Info[pMsg.btCount].aIndex = aIndex;

  00065	0f b6 55 e6	 movzx	 edx, BYTE PTR _pMsg$[ebp+6]

; 817  : 			pMsg.m_Info[pMsg.btCount].Pos = (BYTE)(m_PlayerInfo[i].Dist/g_DoubleGoerEvent_DefPts[m_iCurentMap-MAP_INDEX_DOUBLEGOER1].distDiv);

  00069	db 01		 fild	 DWORD PTR [ecx]
  0006b	66 89 44 95 e8	 mov	 WORD PTR _pMsg$[ebp+edx*4+8], ax
  00070	d9 7d de	 fnstcw	 WORD PTR tv270[ebp]
  00073	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  00076	8d 84 40 3d ff
	ff ff		 lea	 eax, DWORD PTR [eax+eax*2-195]
  0007d	d8 34 85 04 00
	00 00		 fdiv	 DWORD PTR ?g_DoubleGoerEvent_DefPts@@3PAUDOUBLEGOER_DEFPOINTS@@A[eax*4+4]
  00084	0f b7 45 de	 movzx	 eax, WORD PTR tv270[ebp]
  00088	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  0008d	89 45 d8	 mov	 DWORD PTR tv267[ebp], eax
  00090	0f b6 45 e6	 movzx	 eax, BYTE PTR _pMsg$[ebp+6]
  00094	d9 6d d8	 fldcw	 WORD PTR tv267[ebp]
  00097	db 5d d8	 fistp	 DWORD PTR tv265[ebp]
  0009a	8a 55 d8	 mov	 dl, BYTE PTR tv265[ebp]
  0009d	88 54 85 eb	 mov	 BYTE PTR _pMsg$[ebp+eax*4+11], dl

; 818  : 			pMsg.btCount++;

  000a1	fe 45 e6	 inc	 BYTE PTR _pMsg$[ebp+6]
  000a4	d9 6d de	 fldcw	 WORD PTR tv270[ebp]
$LN3@SendPlayIn:

; 809  : 
; 810  : 	for(int i = 0; i < DOUBLEGOER_MAXPLAYER; i++)

  000a7	83 c1 08	 add	 ecx, 8
  000aa	4f		 dec	 edi
  000ab	75 a3		 jne	 SHORT $LL4@SendPlayIn

; 819  : 		}
; 820  : 	}
; 821  : 
; 822  : 	SendData((LPBYTE)&pMsg,pMsg.h.size);

  000ad	0f b6 4d e1	 movzx	 ecx, BYTE PTR _pMsg$[ebp+1]
  000b1	51		 push	 ecx
  000b2	8d 55 e0	 lea	 edx, DWORD PTR _pMsg$[ebp]
  000b5	52		 push	 edx
  000b6	8b ce		 mov	 ecx, esi
  000b8	e8 00 00 00 00	 call	 ?SendData@CDoubleGoerEvent@@QAEXPAEH@Z ; CDoubleGoerEvent::SendData

; 823  : }

  000bd	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000c0	5f		 pop	 edi
  000c1	33 cd		 xor	 ecx, ebp
  000c3	5e		 pop	 esi
  000c4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000c9	8b e5		 mov	 esp, ebp
  000cb	5d		 pop	 ebp
  000cc	c3		 ret	 0
?SendPlayInfo@CDoubleGoerEvent@@QAEXXZ ENDP		; CDoubleGoerEvent::SendPlayInfo
_TEXT	ENDS
PUBLIC	?SendMonsterCount@CDoubleGoerEvent@@QAEXXZ	; CDoubleGoerEvent::SendMonsterCount
; Function compile flags: /Ogtp
;	COMDAT ?SendMonsterCount@CDoubleGoerEvent@@QAEXXZ
_TEXT	SEGMENT
_pMsg$ = -8						; size = 6
?SendMonsterCount@CDoubleGoerEvent@@QAEXXZ PROC		; CDoubleGoerEvent::SendMonsterCount, COMDAT
; _this$ = ecx

; 826  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi

; 827  : 	PMSG_DOUBLEGOER_MONSTERSET pMsg;
; 828  : 	PHeadSubSetB((LPBYTE)&pMsg,0xBF,20,sizeof(pMsg));

  00007	6a 06		 push	 6
  00009	6a 14		 push	 20			; 00000014H
  0000b	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0000e	68 bf 00 00 00	 push	 191			; 000000bfH
  00013	50		 push	 eax
  00014	8b f1		 mov	 esi, ecx
  00016	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 829  : 
; 830  : 	pMsg.btMaxMon = 3;
; 831  : 	pMsg.btCurMon = m_iMonsterPassed;
; 832  : 
; 833  : 	SendData((LPBYTE)&pMsg,pMsg.h.size);

  0001b	0f b6 55 f9	 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  0001f	8a 4e 38	 mov	 cl, BYTE PTR [esi+56]
  00022	83 c4 10	 add	 esp, 16			; 00000010H
  00025	52		 push	 edx
  00026	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00029	88 4d fd	 mov	 BYTE PTR _pMsg$[ebp+5], cl
  0002c	50		 push	 eax
  0002d	8b ce		 mov	 ecx, esi
  0002f	c6 45 fc 03	 mov	 BYTE PTR _pMsg$[ebp+4], 3
  00033	e8 00 00 00 00	 call	 ?SendData@CDoubleGoerEvent@@QAEXPAEH@Z ; CDoubleGoerEvent::SendData
  00038	5e		 pop	 esi

; 834  : }

  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c3		 ret	 0
?SendMonsterCount@CDoubleGoerEvent@@QAEXXZ ENDP		; CDoubleGoerEvent::SendMonsterCount
_TEXT	ENDS
PUBLIC	?SendWaveInfo@CDoubleGoerEvent@@QAEXXZ		; CDoubleGoerEvent::SendWaveInfo
; Function compile flags: /Ogtp
;	COMDAT ?SendWaveInfo@CDoubleGoerEvent@@QAEXXZ
_TEXT	SEGMENT
_pMsg$ = -8						; size = 5
?SendWaveInfo@CDoubleGoerEvent@@QAEXXZ PROC		; CDoubleGoerEvent::SendWaveInfo, COMDAT
; _this$ = ecx

; 837  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi

; 838  : 	PMSG_DOUBLEGOER_WAVEINFO pMsg;
; 839  : 	PHeadSubSetB((LPBYTE)&pMsg,0xBF,15,sizeof(pMsg));

  00007	6a 05		 push	 5
  00009	6a 0f		 push	 15			; 0000000fH
  0000b	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0000e	68 bf 00 00 00	 push	 191			; 000000bfH
  00013	50		 push	 eax
  00014	8b f1		 mov	 esi, ecx
  00016	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 840  : 
; 841  : 	pMsg.btDist = m_iWaveDist;
; 842  : 
; 843  : 	SendData((LPBYTE)&pMsg,pMsg.h.size);

  0001b	0f b6 55 f9	 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  0001f	8a 4e 3c	 mov	 cl, BYTE PTR [esi+60]
  00022	83 c4 10	 add	 esp, 16			; 00000010H
  00025	52		 push	 edx
  00026	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00029	88 4d fc	 mov	 BYTE PTR _pMsg$[ebp+4], cl
  0002c	50		 push	 eax
  0002d	8b ce		 mov	 ecx, esi
  0002f	e8 00 00 00 00	 call	 ?SendData@CDoubleGoerEvent@@QAEXPAEH@Z ; CDoubleGoerEvent::SendData
  00034	5e		 pop	 esi

; 844  : }

  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
?SendWaveInfo@CDoubleGoerEvent@@QAEXXZ ENDP		; CDoubleGoerEvent::SendWaveInfo
_TEXT	ENDS
PUBLIC	??_C@_0O@CKAEPJAF@error?5?3?5?$CFs?5?$CFd?$AA@	; `string'
PUBLIC	??_C@_0BE@NJECGONL@DoubleGoerEvent?4cpp?$AA@	; `string'
PUBLIC	?SetMonster@CDoubleGoerEvent@@QAEHHHHH@Z	; CDoubleGoerEvent::SetMonster
EXTRN	?SetStandAttr@MapClass@@QAEXHH@Z:PROC		; MapClass::SetStandAttr
EXTRN	?MapC@@3PAVMapClass@@A:BYTE			; MapC
EXTRN	?CreateFrustrum@@YAXHHH@Z:PROC			; CreateFrustrum
EXTRN	?gObjSetInventory1Pointer@@YAXPAUOBJECTSTRUCT@@@Z:PROC ; gObjSetInventory1Pointer
EXTRN	?gObjMonsterHitDamageInit@@YAXPAUOBJECTSTRUCT@@@Z:PROC ; gObjMonsterHitDamageInit
EXTRN	?gObjMonsterMagicAdd@@YAHPAUOBJECTSTRUCT@@GE@Z:PROC ; gObjMonsterMagicAdd
EXTRN	?ConvertMonsterStat@CMonsterStatCalc@@QAEHPAUOBJECTSTRUCT@@HH@Z:PROC ; CMonsterStatCalc::ConvertMonsterStat
EXTRN	?g_MonsterStatCalc@@3VCMonsterStatCalc@@A:BYTE	; g_MonsterStatCalc
EXTRN	?gObj@@3PAUOBJECTSTRUCT@@A:DWORD		; gObj
EXTRN	?LogAdd@@3P6AXPADZZA:DWORD			; LogAdd
;	COMDAT ??_C@_0O@CKAEPJAF@error?5?3?5?$CFs?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0O@CKAEPJAF@error?5?3?5?$CFs?5?$CFd?$AA@ DB 'error : %s %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@NJECGONL@DoubleGoerEvent?4cpp?$AA@
CONST	SEGMENT
??_C@_0BE@NJECGONL@DoubleGoerEvent?4cpp?$AA@ DB 'DoubleGoerEvent.cpp', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?SetMonster@CDoubleGoerEvent@@QAEHHHHH@Z
_TEXT	SEGMENT
_nIndex$ = 8						; size = 4
_MonsterClass$ = 12					; size = 4
_nMaxLevel$ = 16					; size = 4
_nMaxReset$ = 20					; size = 4
?SetMonster@CDoubleGoerEvent@@QAEHHHHH@Z PROC		; CDoubleGoerEvent::SetMonster, COMDAT
; _this$ = ecx

; 1040 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 1041 : 	if( !OBJMAX_RANGE(nIndex) )

  00004	8b 7d 08	 mov	 edi, DWORD PTR _nIndex$[ebp]
  00007	85 ff		 test	 edi, edi
  00009	78 0f		 js	 SHORT $LN7@SetMonster
  0000b	33 c0		 xor	 eax, eax
  0000d	81 ff eb 2c 00
	00		 cmp	 edi, 11499		; 00002cebH
  00013	0f 9e c0	 setle	 al
  00016	85 c0		 test	 eax, eax
  00018	75 1f		 jne	 SHORT $LN2@SetMonster
$LN7@SetMonster:

; 1042 : 	{
; 1043 : 		LogAdd("error : %s %d",__FILE__,__LINE__);

  0001a	68 13 04 00 00	 push	 1043			; 00000413H
  0001f	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@NJECGONL@DoubleGoerEvent?4cpp?$AA@
  00024	68 00 00 00 00	 push	 OFFSET ??_C@_0O@CKAEPJAF@error?5?3?5?$CFs?5?$CFd?$AA@
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  0002f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1044 : 		return false;

  00032	33 c0		 xor	 eax, eax
  00034	5f		 pop	 edi

; 1078 : }

  00035	5d		 pop	 ebp
  00036	c2 10 00	 ret	 16			; 00000010H
$LN2@SetMonster:
  00039	56		 push	 esi

; 1045 : 	}
; 1046 : 
; 1047 : 	LPOBJ lpObj = &gObj[nIndex];

  0003a	8b f7		 mov	 esi, edi
  0003c	69 f6 40 27 00
	00		 imul	 esi, 10048		; 00002740H
  00042	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 1048 : 	lpObj->ConnectCheckTime = GetTickCount();

  00048	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0

; 1049 : 	lpObj->ShopNumber = -1;
; 1050 : 	lpObj->TargetNumber = -1;
; 1051 : 	lpObj->m_RecallMon = -1;
; 1052 : 	lpObj->Connected = PLAYER_PLAYING;
; 1053 : 	lpObj->Live = TRUE;
; 1054 : 	lpObj->m_State = 1;
; 1055 : 	lpObj->DieRegen = 0;
; 1056 : 	lpObj->Type = OBJ_MONSTER;
; 1057 : 	lpObj->Class = MonsterClass;

  0004e	66 8b 55 0c	 mov	 dx, WORD PTR _MonsterClass$[ebp]
  00052	89 46 3c	 mov	 DWORD PTR [esi+60], eax
  00055	83 c8 ff	 or	 eax, -1
  00058	0b c8		 or	 ecx, eax
  0005a	66 89 8e 38 06
	00 00		 mov	 WORD PTR [esi+1592], cx

; 1058 : 	lpObj->LastAttackerID = -1;
; 1059 : 
; 1060 : 	g_MonsterStatCalc.ConvertMonsterStat(lpObj, nMaxLevel, nMaxReset);

  00061	8b 4d 14	 mov	 ecx, DWORD PTR _nMaxReset$[ebp]
  00064	51		 push	 ecx
  00065	66 89 96 90 00
	00 00		 mov	 WORD PTR [esi+144], dx
  0006c	8b 55 10	 mov	 edx, DWORD PTR _nMaxLevel$[ebp]
  0006f	66 89 86 3c 06
	00 00		 mov	 WORD PTR [esi+1596], ax
  00076	89 86 30 06 00
	00		 mov	 DWORD PTR [esi+1584], eax
  0007c	52		 push	 edx
  0007d	0b c0		 or	 eax, eax
  0007f	56		 push	 esi
  00080	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MonsterStatCalc@@3VCMonsterStatCalc@@A ; g_MonsterStatCalc
  00085	c7 46 04 03 00
	00 00		 mov	 DWORD PTR [esi+4], 3
  0008c	c7 86 d0 01 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+464], 1
  00096	c6 86 8a 05 00
	00 00		 mov	 BYTE PTR [esi+1418], 0
  0009d	66 c7 46 50 02
	01		 mov	 WORD PTR [esi+80], 258	; 00000102H
  000a3	66 89 86 3e 06
	00 00		 mov	 WORD PTR [esi+1598], ax
  000aa	e8 00 00 00 00	 call	 ?ConvertMonsterStat@CMonsterStatCalc@@QAEHPAUOBJECTSTRUCT@@HH@Z ; CMonsterStatCalc::ConvertMonsterStat

; 1061 : 
; 1062 : 	*lpObj->pInventoryCount = 0;

  000af	8b 86 c4 11 00
	00		 mov	 eax, DWORD PTR [esi+4548]
  000b5	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1063 : 
; 1064 : 	if( lpObj->m_AttackType )

  000b8	0f b7 86 92 06
	00 00		 movzx	 eax, WORD PTR [esi+1682]
  000bf	66 85 c0	 test	 ax, ax
  000c2	74 0c		 je	 SHORT $LN1@SetMonster

; 1065 : 	{
; 1066 : 		gObjMonsterMagicAdd(lpObj,lpObj->m_AttackType,1);

  000c4	6a 01		 push	 1
  000c6	50		 push	 eax
  000c7	56		 push	 esi
  000c8	e8 00 00 00 00	 call	 ?gObjMonsterMagicAdd@@YAHPAUOBJECTSTRUCT@@GE@Z ; gObjMonsterMagicAdd
  000cd	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@SetMonster:

; 1067 : 	}
; 1068 : 
; 1069 : 	gObjMonsterHitDamageInit(lpObj);

  000d0	56		 push	 esi
  000d1	e8 00 00 00 00	 call	 ?gObjMonsterHitDamageInit@@YAXPAUOBJECTSTRUCT@@@Z ; gObjMonsterHitDamageInit

; 1070 : 	gObjSetInventory1Pointer(lpObj);

  000d6	56		 push	 esi
  000d7	e8 00 00 00 00	 call	 ?gObjSetInventory1Pointer@@YAXPAUOBJECTSTRUCT@@@Z ; gObjSetInventory1Pointer

; 1071 : 	CreateFrustrum(lpObj->X,lpObj->Y,nIndex);

  000dc	0f b6 8e 21 01
	00 00		 movzx	 ecx, BYTE PTR [esi+289]
  000e3	0f b6 96 20 01
	00 00		 movzx	 edx, BYTE PTR [esi+288]
  000ea	57		 push	 edi
  000eb	51		 push	 ecx
  000ec	52		 push	 edx
  000ed	e8 00 00 00 00	 call	 ?CreateFrustrum@@YAXHHH@Z ; CreateFrustrum

; 1072 : 
; 1073 : 	MapC[lpObj->MapNumber].SetStandAttr(lpObj->X,lpObj->Y);

  000f2	0f b6 86 21 01
	00 00		 movzx	 eax, BYTE PTR [esi+289]
  000f9	0f b6 8e 20 01
	00 00		 movzx	 ecx, BYTE PTR [esi+288]
  00100	83 c4 14	 add	 esp, 20			; 00000014H
  00103	50		 push	 eax
  00104	51		 push	 ecx
  00105	0f b6 8e 23 01
	00 00		 movzx	 ecx, BYTE PTR [esi+291]
  0010c	69 c9 28 38 05
	00		 imul	 ecx, 342056		; 00053828H
  00112	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?MapC@@3PAVMapClass@@A ; MapC
  00118	e8 00 00 00 00	 call	 ?SetStandAttr@MapClass@@QAEXHH@Z ; MapClass::SetStandAttr

; 1074 : 
; 1075 : 	lpObj->m_OldX = lpObj->X;
; 1076 : 	lpObj->m_OldY = lpObj->Y;

  0011d	8a 86 21 01 00
	00		 mov	 al, BYTE PTR [esi+289]
  00123	8a 96 20 01 00
	00		 mov	 dl, BYTE PTR [esi+288]
  00129	88 86 51 01 00
	00		 mov	 BYTE PTR [esi+337], al
  0012f	88 96 50 01 00
	00		 mov	 BYTE PTR [esi+336], dl
  00135	5e		 pop	 esi

; 1077 : 	return true;

  00136	b8 01 00 00 00	 mov	 eax, 1
  0013b	5f		 pop	 edi

; 1078 : }

  0013c	5d		 pop	 ebp
  0013d	c2 10 00	 ret	 16			; 00000010H
?SetMonster@CDoubleGoerEvent@@QAEHHHHH@Z ENDP		; CDoubleGoerEvent::SetMonster
_TEXT	ENDS
PUBLIC	?RemoveMonster@CDoubleGoerEvent@@QAEXXZ		; CDoubleGoerEvent::RemoveMonster
; Function compile flags: /Ogtp
;	COMDAT ?RemoveMonster@CDoubleGoerEvent@@QAEXXZ
_TEXT	SEGMENT
?RemoveMonster@CDoubleGoerEvent@@QAEXXZ PROC		; CDoubleGoerEvent::RemoveMonster, COMDAT
; _this$ = ecx

; 1081 : {

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	8b d9		 mov	 ebx, ecx
  00004	57		 push	 edi

; 1082 : 	/*for(int i = 0; i < OBJ_MAXMONSTER; i++)
; 1083 : 	{
; 1084 : 		if( DG_MAP_RANGE(gObj[i].MapNumber) )
; 1085 : 		{
; 1086 : 			gObjDel(i);
; 1087 : 		}
; 1088 : 	}*/
; 1089 : 
; 1090 : 	int i;
; 1091 : 	for(i = 0; i < DOUBLEGOER_MAXMONSTER; i++)

  00005	8d b3 b0 00 00
	00		 lea	 esi, DWORD PTR [ebx+176]
  0000b	bf 64 00 00 00	 mov	 edi, 100		; 00000064H
$LL8@RemoveMons:

; 1092 : 	{
; 1093 : 		if( m_MonsterInfo[i] != -1 )

  00010	8b 06		 mov	 eax, DWORD PTR [esi]
  00012	83 f8 ff	 cmp	 eax, -1
  00015	74 0f		 je	 SHORT $LN7@RemoveMons

; 1094 : 		{
; 1095 : 			gObjDel(m_MonsterInfo[i]);

  00017	50		 push	 eax
  00018	e8 00 00 00 00	 call	 ?gObjDel@@YAFH@Z	; gObjDel
  0001d	83 c4 04	 add	 esp, 4

; 1096 : 			m_MonsterInfo[i] = -1;

  00020	c7 06 ff ff ff
	ff		 mov	 DWORD PTR [esi], -1
$LN7@RemoveMons:

; 1082 : 	/*for(int i = 0; i < OBJ_MAXMONSTER; i++)
; 1083 : 	{
; 1084 : 		if( DG_MAP_RANGE(gObj[i].MapNumber) )
; 1085 : 		{
; 1086 : 			gObjDel(i);
; 1087 : 		}
; 1088 : 	}*/
; 1089 : 
; 1090 : 	int i;
; 1091 : 	for(i = 0; i < DOUBLEGOER_MAXMONSTER; i++)

  00026	83 c6 04	 add	 esi, 4
  00029	4f		 dec	 edi
  0002a	75 e4		 jne	 SHORT $LL8@RemoveMons

; 1097 : 		}
; 1098 : 	}
; 1099 : 
; 1100 : 	for(i = 0; i < DOUBLEGOER_MAXBOX; i++)

  0002c	8d b3 40 02 00
	00		 lea	 esi, DWORD PTR [ebx+576]
  00032	bf 06 00 00 00	 mov	 edi, 6
$LL4@RemoveMons:

; 1101 : 	{
; 1102 : 		if( m_BoxInfo[i] != -1 )

  00037	8b 06		 mov	 eax, DWORD PTR [esi]
  00039	83 f8 ff	 cmp	 eax, -1
  0003c	74 0f		 je	 SHORT $LN3@RemoveMons

; 1103 : 		{
; 1104 : 			gObjDel(m_BoxInfo[i]);

  0003e	50		 push	 eax
  0003f	e8 00 00 00 00	 call	 ?gObjDel@@YAFH@Z	; gObjDel
  00044	83 c4 04	 add	 esp, 4

; 1105 : 			m_BoxInfo[i] = -1;

  00047	c7 06 ff ff ff
	ff		 mov	 DWORD PTR [esi], -1
$LN3@RemoveMons:

; 1097 : 		}
; 1098 : 	}
; 1099 : 
; 1100 : 	for(i = 0; i < DOUBLEGOER_MAXBOX; i++)

  0004d	83 c6 04	 add	 esi, 4
  00050	4f		 dec	 edi
  00051	75 e4		 jne	 SHORT $LL4@RemoveMons

; 1106 : 		}
; 1107 : 	}
; 1108 : }

  00053	5f		 pop	 edi
  00054	5e		 pop	 esi
  00055	5b		 pop	 ebx
  00056	c3		 ret	 0
?RemoveMonster@CDoubleGoerEvent@@QAEXXZ ENDP		; CDoubleGoerEvent::RemoveMonster
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?SendBlockInfo@CDoubleGoerEvent@@QAEXHHH@Z	; CDoubleGoerEvent::SendBlockInfo
EXTRN	?PHeadSetB@@YAXPAEEH@Z:PROC			; PHeadSetB
EXTRN	_memset:PROC
; Function compile flags: /Ogtp
;	COMDAT ?SendBlockInfo@CDoubleGoerEvent@@QAEXHHH@Z
_TEXT	SEGMENT
_cTEMP_BUF$ = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_iIndex$ = 8						; size = 4
_MapIndex$ = 12						; size = 4
_bType$ = 16						; size = 4
?SendBlockInfo@CDoubleGoerEvent@@QAEXHHH@Z PROC		; CDoubleGoerEvent::SendBlockInfo, COMDAT
; _this$ = ecx

; 1346 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 04 01 00
	00		 sub	 esp, 260		; 00000104H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	56		 push	 esi

; 1347 : 	if( MapIndex < 0 || MapIndex >= 4 )

  00014	8b 75 0c	 mov	 esi, DWORD PTR _MapIndex$[ebp]
  00017	83 fe 03	 cmp	 esi, 3
  0001a	0f 87 95 00 00
	00		 ja	 $LN1@SendBlockI

; 1348 : 		return;
; 1349 : 
; 1350 : 	char cTEMP_BUF[256] = {0};

  00020	68 ff 00 00 00	 push	 255			; 000000ffH
  00025	8d 85 fd fe ff
	ff		 lea	 eax, DWORD PTR _cTEMP_BUF$[ebp+1]
  0002b	6a 00		 push	 0
  0002d	50		 push	 eax
  0002e	c6 85 fc fe ff
	ff 00		 mov	 BYTE PTR _cTEMP_BUF$[ebp], 0
  00035	e8 00 00 00 00	 call	 _memset

; 1351 : 	PMSG_SETMAPATTR_COUNT * lpMsg = (PMSG_SETMAPATTR_COUNT *)cTEMP_BUF;
; 1352 : 
; 1353 : 	PHeadSetB((LPBYTE)lpMsg, 0x46, sizeof(PMSG_SETMAPATTR_COUNT)+sizeof(PMSG_SETMAPATTR)*6);

  0003a	6a 13		 push	 19			; 00000013H
  0003c	8d 8d fc fe ff
	ff		 lea	 ecx, DWORD PTR _cTEMP_BUF$[ebp]
  00042	6a 46		 push	 70			; 00000046H
  00044	51		 push	 ecx
  00045	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 1354 : 	PMSG_SETMAPATTR * lpMsgBody = (PMSG_SETMAPATTR *)&cTEMP_BUF[7];
; 1355 : 
; 1356 : 	lpMsg->btType = 0;
; 1357 : 	lpMsg->btCount = 1;
; 1358 : 	lpMsg->btMapAttr = 16;
; 1359 : 	lpMsg->btMapSetType=bType;
; 1360 : 
; 1361 : 	lpMsgBody[0].btX = g_DoubleGoerEvent_BlockPts[MapIndex].stX;

  0004a	0f b6 04 b5 00
	00 00 00	 movzx	 eax, BYTE PTR ?g_DoubleGoerEvent_BlockPts@@3PAUDOUBLEGOER_BLOCK@@A[esi*4]
  00052	8a 55 10	 mov	 dl, BYTE PTR _bType$[ebp]

; 1362 : 	lpMsgBody[0].btY = g_DoubleGoerEvent_BlockPts[MapIndex].stY;

  00055	8a 0c b5 01 00
	00 00		 mov	 cl, BYTE PTR ?g_DoubleGoerEvent_BlockPts@@3PAUDOUBLEGOER_BLOCK@@A[esi*4+1]
  0005c	88 95 01 ff ff
	ff		 mov	 BYTE PTR _cTEMP_BUF$[ebp+5], dl

; 1363 : 	lpMsgBody[1].btX   = g_DoubleGoerEvent_BlockPts[MapIndex].ptX;

  00062	0f b6 14 b5 02
	00 00 00	 movzx	 edx, BYTE PTR ?g_DoubleGoerEvent_BlockPts@@3PAUDOUBLEGOER_BLOCK@@A[esi*4+2]
  0006a	88 85 03 ff ff
	ff		 mov	 BYTE PTR _cTEMP_BUF$[ebp+7], al

; 1364 : 	lpMsgBody[1].btY   = g_DoubleGoerEvent_BlockPts[MapIndex].ptY;

  00070	0f b6 04 b5 03
	00 00 00	 movzx	 eax, BYTE PTR ?g_DoubleGoerEvent_BlockPts@@3PAUDOUBLEGOER_BLOCK@@A[esi*4+3]
  00078	88 8d 04 ff ff
	ff		 mov	 BYTE PTR _cTEMP_BUF$[ebp+8], cl

; 1365 : 
; 1366 : 	DataSend(iIndex,(LPBYTE)lpMsg,lpMsg->h.size);

  0007e	0f b6 8d fd fe
	ff ff		 movzx	 ecx, BYTE PTR _cTEMP_BUF$[ebp+1]
  00085	88 95 05 ff ff
	ff		 mov	 BYTE PTR _cTEMP_BUF$[ebp+9], dl
  0008b	51		 push	 ecx
  0008c	8d 95 fc fe ff
	ff		 lea	 edx, DWORD PTR _cTEMP_BUF$[ebp]
  00092	88 85 06 ff ff
	ff		 mov	 BYTE PTR _cTEMP_BUF$[ebp+10], al
  00098	8b 45 08	 mov	 eax, DWORD PTR _iIndex$[ebp]
  0009b	52		 push	 edx
  0009c	50		 push	 eax
  0009d	c6 85 02 ff ff
	ff 01		 mov	 BYTE PTR _cTEMP_BUF$[ebp+6], 1
  000a4	66 c7 85 ff fe
	ff ff 00 10	 mov	 WORD PTR _cTEMP_BUF$[ebp+3], 4096 ; 00001000H
  000ad	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  000b2	83 c4 24	 add	 esp, 36			; 00000024H
$LN1@SendBlockI:

; 1367 : }

  000b5	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000b8	33 cd		 xor	 ecx, ebp
  000ba	5e		 pop	 esi
  000bb	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000c0	8b e5		 mov	 esp, ebp
  000c2	5d		 pop	 ebp
  000c3	c2 0c 00	 ret	 12			; 0000000cH
?SendBlockInfo@CDoubleGoerEvent@@QAEXHHH@Z ENDP		; CDoubleGoerEvent::SendBlockInfo
_TEXT	ENDS
PUBLIC	?empty@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QBE_NXZ ; std::vector<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >::empty
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?empty@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QBE_NXZ PROC ; std::vector<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >::empty, COMDAT
; _this$ = ecx

; 889  : 		return (this->_Myfirst == this->_Mylast);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	33 d2		 xor	 edx, edx
  00004	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  00007	0f 94 c0	 sete	 al

; 890  : 		}

  0000a	c3		 ret	 0
?empty@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QBE_NXZ ENDP ; std::vector<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >::empty
_TEXT	ENDS
PUBLIC	?_Inside@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@IBE_NPBU_st_reward@CDoubleGoerEvent@@@Z ; std::vector<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >::_Inside
; Function compile flags: /Ogtp
;	COMDAT ?_Inside@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@IBE_NPBU_st_reward@CDoubleGoerEvent@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?_Inside@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@IBE_NPBU_st_reward@CDoubleGoerEvent@@@Z PROC ; std::vector<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >::_Inside, COMDAT
; _this$ = ecx

; 1285 : 		{	// test if _Ptr points inside vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1286 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  00009	73 0d		 jae	 SHORT $LN3@Inside
  0000b	39 01		 cmp	 DWORD PTR [ecx], eax
  0000d	77 09		 ja	 SHORT $LN3@Inside
  0000f	b8 01 00 00 00	 mov	 eax, 1

; 1287 : 		}

  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
$LN3@Inside:

; 1286 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  00018	33 c0		 xor	 eax, eax

; 1287 : 		}

  0001a	5d		 pop	 ebp
  0001b	c2 04 00	 ret	 4
?_Inside@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@IBE_NPBU_st_reward@CDoubleGoerEvent@@@Z ENDP ; std::vector<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >::_Inside
_TEXT	ENDS
PUBLIC	?_Orphan_range@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@IBEXPAU_st_reward@CDoubleGoerEvent@@0@Z ; std::vector<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >::_Orphan_range
; Function compile flags: /Ogtp
;	COMDAT ?_Orphan_range@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@IBEXPAU_st_reward@CDoubleGoerEvent@@0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?_Orphan_range@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@IBEXPAU_st_reward@CDoubleGoerEvent@@0@Z PROC ; std::vector<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >::_Orphan_range, COMDAT
; _this$ = ecx

; 1454 : 		}

  00000	c2 08 00	 ret	 8
?_Orphan_range@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@IBEXPAU_st_reward@CDoubleGoerEvent@@0@Z ENDP ; std::vector<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >::_Orphan_range
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QAE@XZ ; std::_Vector_val<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >::~_Vector_val<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >
; Function compile flags: /Ogtp
;	COMDAT ??1?$_Vector_val@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >::~_Vector_val<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >, COMDAT
; _this$ = ecx

; 434  : 		}

  00000	c3		 ret	 0
??1?$_Vector_val@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >::~_Vector_val<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >
_TEXT	ENDS
PUBLIC	??0?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@QAE@XZ ; std::allocator<CDoubleGoerEvent::_st_reward>::allocator<CDoubleGoerEvent::_st_reward>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??0?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@QAE@XZ PROC ; std::allocator<CDoubleGoerEvent::_st_reward>::allocator<CDoubleGoerEvent::_st_reward>, COMDAT
; _this$ = ecx

; 161  : 	_ALLOCATOR() _THROW0()

  00000	8b c1		 mov	 eax, ecx

; 162  : 		{	// construct default allocator (do nothing)
; 163  : 		}

  00002	c3		 ret	 0
??0?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@QAE@XZ ENDP ; std::allocator<CDoubleGoerEvent::_st_reward>::allocator<CDoubleGoerEvent::_st_reward>
_TEXT	ENDS
PUBLIC	?capacity@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QBEIXZ ; std::vector<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >::capacity
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?capacity@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QBEIXZ PROC ; std::vector<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >::capacity, COMDAT
; _this$ = ecx

; 777  : 		return (this->_Myend - this->_Myfirst);

  00000	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00003	2b 11		 sub	 edx, DWORD PTR [ecx]
  00005	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0000a	f7 ea		 imul	 edx
  0000c	c1 fa 02	 sar	 edx, 2
  0000f	8b c2		 mov	 eax, edx
  00011	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00014	03 c2		 add	 eax, edx

; 778  : 		}

  00016	c3		 ret	 0
?capacity@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QBEIXZ ENDP ; std::vector<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >::capacity
_TEXT	ENDS
PUBLIC	?size@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QBEIXZ ; std::vector<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >::size
; Function compile flags: /Ogtp
;	COMDAT ?size@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QBEIXZ PROC ; std::vector<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >::size, COMDAT
; _this$ = ecx

; 879  : 		return (this->_Mylast - this->_Myfirst);

  00000	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00003	2b 11		 sub	 edx, DWORD PTR [ecx]
  00005	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0000a	f7 ea		 imul	 edx
  0000c	c1 fa 02	 sar	 edx, 2
  0000f	8b c2		 mov	 eax, edx
  00011	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00014	03 c2		 add	 eax, edx

; 880  : 		}

  00016	c3		 ret	 0
?size@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QBEIXZ ENDP ; std::vector<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >::size
_TEXT	ENDS
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?_Xlen@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@IBEXXZ ; std::vector<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >::_Xlen
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?_Xlen@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
?_Xlen@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@IBEXXZ PROC ; std::vector<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >::_Xlen, COMDAT
; _this$ = ecx

; 1427 : 		_Xlength_error("vector<T> too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN4@Xlen:
$LN3@Xlen:
  0000a	cc		 int	 3
?_Xlen@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@IBEXXZ ENDP ; std::vector<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >::_Xlen
_TEXT	ENDS
PUBLIC	??0?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@QAE@ABV01@@Z ; std::allocator<CDoubleGoerEvent::_st_reward>::allocator<CDoubleGoerEvent::_st_reward>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??0?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@QAE@ABV01@@Z PROC ; std::allocator<CDoubleGoerEvent::_st_reward>::allocator<CDoubleGoerEvent::_st_reward>, COMDAT
; _this$ = ecx

; 165  : 	_ALLOCATOR(const _ALLOCATOR<_Ty>&) _THROW0()

  00000	8b c1		 mov	 eax, ecx

; 166  : 		{	// construct by copying (do nothing)
; 167  : 		}

  00002	c2 04 00	 ret	 4
??0?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<CDoubleGoerEvent::_st_reward>::allocator<CDoubleGoerEvent::_st_reward>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@QAEXPAU_st_reward@CDoubleGoerEvent@@I@Z ; std::allocator<CDoubleGoerEvent::_st_reward>::deallocate
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Ogtp
;	COMDAT ?deallocate@?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@QAEXPAU_st_reward@CDoubleGoerEvent@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@QAEXPAU_st_reward@CDoubleGoerEvent@@I@Z PROC ; std::allocator<CDoubleGoerEvent::_st_reward>::deallocate, COMDAT
; _this$ = ecx

; 181  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 182  : 		::operator delete(_Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000c	83 c4 04	 add	 esp, 4

; 183  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 08 00	 ret	 8
?deallocate@?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@QAEXPAU_st_reward@CDoubleGoerEvent@@I@Z ENDP ; std::allocator<CDoubleGoerEvent::_st_reward>::deallocate
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@std@@QBEABU_st_reward@CDoubleGoerEvent@@XZ ; std::_Vector_const_iterator<std::_Vector_val<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> > >::operator*
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@std@@QBEABU_st_reward@CDoubleGoerEvent@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@V?$_Vector_val@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@std@@QBEABU_st_reward@CDoubleGoerEvent@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> > >::operator*, COMDAT
; _this$ = ecx

; 64   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 65   : 		if (this->_Getcont() == 0
; 66   : 			|| this->_Ptr == 0
; 67   : 			|| this->_Ptr < ((_Myvec *)this->_Getcont())->_Myfirst
; 68   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 69   : 			{	// report error
; 70   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 71   : 			_SCL_SECURE_OUT_OF_RANGE;
; 72   : 			}
; 73   : 
; 74   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 75   : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 76   : 		_SCL_SECURE_VALIDATE_RANGE(
; 77   : 			this->_Ptr != 0
; 78   : 			&& ((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr
; 79   : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 80   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 81   : 
; 82   : 		__analysis_assume(this->_Ptr != 0);
; 83   : 
; 84   : 		return (*this->_Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 85   : 		}

  00002	c3		 ret	 0
??D?$_Vector_const_iterator@V?$_Vector_val@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@std@@QBEABU_st_reward@CDoubleGoerEvent@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> > >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@V?$_Vector_val@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> > >::operator++
; Function compile flags: /Ogtp
;	COMDAT ??E?$_Vector_const_iterator@V?$_Vector_val@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@V?$_Vector_val@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> > >::operator++, COMDAT
; _this$ = ecx

; 93   : 		{	// preincrement

  00000	8b c1		 mov	 eax, ecx

; 94   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 95   : 		if (this->_Getcont() == 0
; 96   : 			|| this->_Ptr == 0
; 97   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 98   : 			{	// report error
; 99   : 			_DEBUG_ERROR("vector iterator not incrementable");
; 100  : 			_SCL_SECURE_OUT_OF_RANGE;
; 101  : 			}
; 102  : 
; 103  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 104  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 105  : 		_SCL_SECURE_VALIDATE_RANGE(
; 106  : 			this->_Ptr != 0
; 107  : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 108  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 109  : 
; 110  : 		++this->_Ptr;

  00002	83 00 18	 add	 DWORD PTR [eax], 24	; 00000018H

; 111  : 		return (*this);
; 112  : 		}

  00005	c3		 ret	 0
??E?$_Vector_const_iterator@V?$_Vector_val@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> > >::operator++
_TEXT	ENDS
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> > >::_Compat
; Function compile flags: /Ogtp
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> > >::_Compat, COMDAT
; _this$ = ecx

; 253  : 		}

  00000	c2 04 00	 ret	 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> > >::_Compat
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@QBEIXZ ; std::allocator<CDoubleGoerEvent::_st_reward>::max_size
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?max_size@?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@QBEIXZ PROC ; std::allocator<CDoubleGoerEvent::_st_reward>::max_size, COMDAT
; _this$ = ecx

; 218  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 219  : 		return (0 < _Count ? _Count : 1);

  00000	b8 aa aa aa 0a	 mov	 eax, 178956970		; 0aaaaaaaH

; 220  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@QBEIXZ ENDP ; std::allocator<CDoubleGoerEvent::_st_reward>::max_size
_TEXT	ENDS
PUBLIC	??$addressof@$$CBU_st_reward@CDoubleGoerEvent@@@std@@YAPBU_st_reward@CDoubleGoerEvent@@ABU12@@Z ; std::addressof<CDoubleGoerEvent::_st_reward const >
; Function compile flags: /Ogtp
;	COMDAT ??$addressof@$$CBU_st_reward@CDoubleGoerEvent@@@std@@YAPBU_st_reward@CDoubleGoerEvent@@ABU12@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@$$CBU_st_reward@CDoubleGoerEvent@@@std@@YAPBU_st_reward@CDoubleGoerEvent@@ABU12@@Z PROC ; std::addressof<CDoubleGoerEvent::_st_reward const >, COMDAT

; 110  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 111  : 	return ((_Ty *) &(char&)_Val);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 112  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@$$CBU_st_reward@CDoubleGoerEvent@@@std@@YAPBU_st_reward@CDoubleGoerEvent@@ABU12@@Z ENDP ; std::addressof<CDoubleGoerEvent::_st_reward const >
_TEXT	ENDS
PUBLIC	??$forward@AAU_st_reward@CDoubleGoerEvent@@@std@@YAAAU_st_reward@CDoubleGoerEvent@@AAU12@@Z ; std::forward<CDoubleGoerEvent::_st_reward &>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$forward@AAU_st_reward@CDoubleGoerEvent@@@std@@YAAAU_st_reward@CDoubleGoerEvent@@AAU12@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAU_st_reward@CDoubleGoerEvent@@@std@@YAAAU_st_reward@CDoubleGoerEvent@@AAU12@@Z PROC ; std::forward<CDoubleGoerEvent::_st_reward &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAU_st_reward@CDoubleGoerEvent@@@std@@YAAAU_st_reward@CDoubleGoerEvent@@AAU12@@Z ENDP ; std::forward<CDoubleGoerEvent::_st_reward &>
_TEXT	ENDS
PUBLIC	??$construct@AAU_st_reward@CDoubleGoerEvent@@@?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@QAEXPAU_st_reward@CDoubleGoerEvent@@AAU23@@Z ; std::allocator<CDoubleGoerEvent::_st_reward>::construct<CDoubleGoerEvent::_st_reward &>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$construct@AAU_st_reward@CDoubleGoerEvent@@@?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@QAEXPAU_st_reward@CDoubleGoerEvent@@AAU23@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$construct@AAU_st_reward@CDoubleGoerEvent@@@?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@QAEXPAU_st_reward@CDoubleGoerEvent@@AAU23@@Z PROC ; std::allocator<CDoubleGoerEvent::_st_reward>::construct<CDoubleGoerEvent::_st_reward &>, COMDAT
; _this$ = ecx

; 206  : 		void construct(pointer _Ptr, _Other&& _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 207  : 		{	// construct object at _Ptr with value _Val
; 208  : 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Other>(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 25		 je	 SHORT $LN3@construct
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0000d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000f	89 10		 mov	 DWORD PTR [eax], edx
  00011	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00014	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00017	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0001a	89 50 08	 mov	 DWORD PTR [eax+8], edx
  0001d	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00020	89 50 0c	 mov	 DWORD PTR [eax+12], edx
  00023	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00026	89 50 10	 mov	 DWORD PTR [eax+16], edx
  00029	8b 49 14	 mov	 ecx, DWORD PTR [ecx+20]
  0002c	89 48 14	 mov	 DWORD PTR [eax+20], ecx
$LN3@construct:

; 209  : 		}

  0002f	5d		 pop	 ebp
  00030	c2 08 00	 ret	 8
??$construct@AAU_st_reward@CDoubleGoerEvent@@@?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@QAEXPAU_st_reward@CDoubleGoerEvent@@AAU23@@Z ENDP ; std::allocator<CDoubleGoerEvent::_st_reward>::construct<CDoubleGoerEvent::_st_reward &>
_TEXT	ENDS
PUBLIC	??$forward@ABU_st_reward@CDoubleGoerEvent@@@std@@YAABU_st_reward@CDoubleGoerEvent@@ABU12@@Z ; std::forward<CDoubleGoerEvent::_st_reward const &>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$forward@ABU_st_reward@CDoubleGoerEvent@@@std@@YAABU_st_reward@CDoubleGoerEvent@@ABU12@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABU_st_reward@CDoubleGoerEvent@@@std@@YAABU_st_reward@CDoubleGoerEvent@@ABU12@@Z PROC ; std::forward<CDoubleGoerEvent::_st_reward const &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@ABU_st_reward@CDoubleGoerEvent@@@std@@YAABU_st_reward@CDoubleGoerEvent@@ABU12@@Z ENDP ; std::forward<CDoubleGoerEvent::_st_reward const &>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@U_st_reward@CDoubleGoerEvent@@U12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAU_st_reward@CDoubleGoerEvent@@0@Z ; std::_Ptr_cat<CDoubleGoerEvent::_st_reward,CDoubleGoerEvent::_st_reward>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@U_st_reward@CDoubleGoerEvent@@U12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAU_st_reward@CDoubleGoerEvent@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@U_st_reward@CDoubleGoerEvent@@U12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAU_st_reward@CDoubleGoerEvent@@0@Z PROC ; std::_Ptr_cat<CDoubleGoerEvent::_st_reward,CDoubleGoerEvent::_st_reward>, COMDAT

; 516  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 517  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::_Type _Cat;
; 518  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 519  : 	}

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??$_Ptr_cat@U_st_reward@CDoubleGoerEvent@@U12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAU_st_reward@CDoubleGoerEvent@@0@Z ENDP ; std::_Ptr_cat<CDoubleGoerEvent::_st_reward,CDoubleGoerEvent::_st_reward>
_TEXT	ENDS
PUBLIC	??$_Construct@U_st_reward@CDoubleGoerEvent@@ABU12@@std@@YAXPAU_st_reward@CDoubleGoerEvent@@ABU12@@Z ; std::_Construct<CDoubleGoerEvent::_st_reward,CDoubleGoerEvent::_st_reward const &>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Construct@U_st_reward@CDoubleGoerEvent@@ABU12@@std@@YAXPAU_st_reward@CDoubleGoerEvent@@ABU12@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@U_st_reward@CDoubleGoerEvent@@ABU12@@std@@YAXPAU_st_reward@CDoubleGoerEvent@@ABU12@@Z PROC ; std::_Construct<CDoubleGoerEvent::_st_reward,CDoubleGoerEvent::_st_reward const &>, COMDAT

; 46   : 	{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   : 	void _FARQ *_Vptr = _Ptr;
; 48   : 	::new (_Vptr) _Ty1(_STD forward<_Ty2>(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 25		 je	 SHORT $LN3@Construct
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0000d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000f	89 10		 mov	 DWORD PTR [eax], edx
  00011	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00014	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00017	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0001a	89 50 08	 mov	 DWORD PTR [eax+8], edx
  0001d	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00020	89 50 0c	 mov	 DWORD PTR [eax+12], edx
  00023	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00026	89 50 10	 mov	 DWORD PTR [eax+16], edx
  00029	8b 49 14	 mov	 ecx, DWORD PTR [ecx+20]
  0002c	89 48 14	 mov	 DWORD PTR [eax+20], ecx
$LN3@Construct:

; 49   : 	}

  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
??$_Construct@U_st_reward@CDoubleGoerEvent@@ABU12@@std@@YAXPAU_st_reward@CDoubleGoerEvent@@ABU12@@Z ENDP ; std::_Construct<CDoubleGoerEvent::_st_reward,CDoubleGoerEvent::_st_reward const &>
_TEXT	ENDS
PUBLIC	??$move@AAU_st_reward@CDoubleGoerEvent@@@std@@YA$$QAU_st_reward@CDoubleGoerEvent@@AAU12@@Z ; std::move<CDoubleGoerEvent::_st_reward &>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$move@AAU_st_reward@CDoubleGoerEvent@@@std@@YA$$QAU_st_reward@CDoubleGoerEvent@@AAU12@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAU_st_reward@CDoubleGoerEvent@@@std@@YA$$QAU_st_reward@CDoubleGoerEvent@@AAU12@@Z PROC ; std::move<CDoubleGoerEvent::_st_reward &>, COMDAT

; 86   : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 87   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 88   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAU_st_reward@CDoubleGoerEvent@@@std@@YA$$QAU_st_reward@CDoubleGoerEvent@@AAU12@@Z ENDP ; std::move<CDoubleGoerEvent::_st_reward &>
_TEXT	ENDS
PUBLIC	??$_Val_type@PAU_st_reward@CDoubleGoerEvent@@@std@@YAPAU_st_reward@CDoubleGoerEvent@@PAU12@@Z ; std::_Val_type<CDoubleGoerEvent::_st_reward *>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??$_Val_type@PAU_st_reward@CDoubleGoerEvent@@@std@@YAPAU_st_reward@CDoubleGoerEvent@@PAU12@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAU_st_reward@CDoubleGoerEvent@@@std@@YAPAU_st_reward@CDoubleGoerEvent@@PAU12@@Z PROC ; std::_Val_type<CDoubleGoerEvent::_st_reward *>, COMDAT

; 790  : 	return (0);

  00000	33 c0		 xor	 eax, eax

; 791  : 	}

  00002	c3		 ret	 0
??$_Val_type@PAU_st_reward@CDoubleGoerEvent@@@std@@YAPAU_st_reward@CDoubleGoerEvent@@PAU12@@Z ENDP ; std::_Val_type<CDoubleGoerEvent::_st_reward *>
_TEXT	ENDS
PUBLIC	??$_Destroy@U_st_reward@CDoubleGoerEvent@@@std@@YAXPAU_st_reward@CDoubleGoerEvent@@@Z ; std::_Destroy<CDoubleGoerEvent::_st_reward>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Destroy@U_st_reward@CDoubleGoerEvent@@@std@@YAXPAU_st_reward@CDoubleGoerEvent@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@U_st_reward@CDoubleGoerEvent@@@std@@YAXPAU_st_reward@CDoubleGoerEvent@@@Z PROC ; std::_Destroy<CDoubleGoerEvent::_st_reward>, COMDAT

; 63   : 	_Ptr->~_Ty();
; 64   : 	}

  00000	c3		 ret	 0
??$_Destroy@U_st_reward@CDoubleGoerEvent@@@std@@YAXPAU_st_reward@CDoubleGoerEvent@@@Z ENDP ; std::_Destroy<CDoubleGoerEvent::_st_reward>
_TEXT	ENDS
PUBLIC	??$forward@U_st_reward@CDoubleGoerEvent@@@std@@YA$$QAU_st_reward@CDoubleGoerEvent@@AAU12@@Z ; std::forward<CDoubleGoerEvent::_st_reward>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$forward@U_st_reward@CDoubleGoerEvent@@@std@@YA$$QAU_st_reward@CDoubleGoerEvent@@AAU12@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@U_st_reward@CDoubleGoerEvent@@@std@@YA$$QAU_st_reward@CDoubleGoerEvent@@AAU12@@Z PROC ; std::forward<CDoubleGoerEvent::_st_reward>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@U_st_reward@CDoubleGoerEvent@@@std@@YA$$QAU_st_reward@CDoubleGoerEvent@@AAU12@@Z ENDP ; std::forward<CDoubleGoerEvent::_st_reward>
_TEXT	ENDS
PUBLIC	_sqrtf
EXTRN	__CIsqrt:PROC
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\math.h
;	COMDAT _sqrtf
_TEXT	SEGMENT
tv69 = 8						; size = 4
__X$ = 8						; size = 4
_sqrtf	PROC						; COMDAT

; 434  :         {return ((float)sqrt((double)_X)); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	d9 45 08	 fld	 DWORD PTR __X$[ebp]
  00006	e8 00 00 00 00	 call	 __CIsqrt
  0000b	d9 5d 08	 fstp	 DWORD PTR tv69[ebp]
  0000e	d9 45 08	 fld	 DWORD PTR tv69[ebp]
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
_sqrtf	ENDP
_TEXT	ENDS
PUBLIC	?sqrt@@YAMM@Z					; sqrt
; Function compile flags: /Ogtp
;	COMDAT ?sqrt@@YAMM@Z
_TEXT	SEGMENT
tv73 = 8						; size = 4
__X$ = 8						; size = 4
?sqrt@@YAMM@Z PROC					; sqrt, COMDAT

; 542  :         {return (sqrtf(_X)); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	d9 45 08	 fld	 DWORD PTR __X$[ebp]
  00006	e8 00 00 00 00	 call	 __CIsqrt
  0000b	d9 5d 08	 fstp	 DWORD PTR tv73[ebp]
  0000e	d9 45 08	 fld	 DWORD PTR tv73[ebp]
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?sqrt@@YAMM@Z ENDP					; sqrt
_TEXT	ENDS
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??0bad_alloc@std@@QAE@PBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
EXTRN	??0exception@std@@QAE@ABQBD@Z:PROC		; std::exception::exception
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R2exception@std@@8
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\exception
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@PBD@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0bad_alloc@std@@QAE@PBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 345  : 		{	// construct from message string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8d 45 08	 lea	 eax, DWORD PTR __Message$[ebp]
  00007	50		 push	 eax
  00008	8b f1		 mov	 esi, ecx
  0000a	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  0000f	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@

; 346  : 		}

  00015	8b c6		 mov	 eax, esi
  00017	5e		 pop	 esi
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@PBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
EXTRN	??1exception@std@@UAE@XZ:PROC			; std::exception::~exception
; Function compile flags: /Ogtp
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 354  : 		{	// destroy the object

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@

; 355  : 		}

  00006	e9 00 00 00 00	 jmp	 ??1exception@std@@UAE@XZ ; std::exception::~exception
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
  0000c	e8 00 00 00 00	 call	 ??1exception@std@@UAE@XZ ; std::exception::~exception
  00011	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00015	74 09		 je	 SHORT $LN6@scalar
  00017	56		 push	 esi
  00018	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0001d	83 c4 04	 add	 esp, 4
$LN6@scalar:
  00020	8b c6		 mov	 eax, esi
  00022	5e		 pop	 esi
  00023	5d		 pop	 ebp
  00024	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?_Orphan_all@_Container_base0@std@@QAEXXZ	; std::_Container_base0::_Orphan_all
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ?_Orphan_all@_Container_base0@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@_Container_base0@std@@QAEXXZ PROC		; std::_Container_base0::_Orphan_all, COMDAT
; _this$ = ecx

; 38   : 		}

  00000	c3		 ret	 0
?_Orphan_all@_Container_base0@std@@QAEXXZ ENDP		; std::_Container_base0::_Orphan_all
_TEXT	ENDS
PUBLIC	?_Adopt@_Iterator_base0@std@@QAEXPBX@Z		; std::_Iterator_base0::_Adopt
; Function compile flags: /Ogtp
;	COMDAT ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z PROC		; std::_Iterator_base0::_Adopt, COMDAT
; _this$ = ecx

; 49   : 		}

  00000	c2 04 00	 ret	 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ENDP		; std::_Iterator_base0::_Adopt
_TEXT	ENDS
PUBLIC	??_EOBJECTSTRUCT@@QAEPAXI@Z			; OBJECTSTRUCT::`vector deleting destructor'
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	??_M@YGXPAXIHP6EX0@Z@Z:PROC			; `eh vector destructor iterator'
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??_EOBJECTSTRUCT@@QAEPAXI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??_EOBJECTSTRUCT@@QAEPAXI@Z$0
__ehfuncinfo$??_EOBJECTSTRUCT@@QAEPAXI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??_EOBJECTSTRUCT@@QAEPAXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
xdata$x	ENDS
;	COMDAT ??_EOBJECTSTRUCT@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_EOBJECTSTRUCT@@QAEPAXI@Z PROC			; OBJECTSTRUCT::`vector deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??_EOBJECTSTRUCT@@QAEPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	53		 push	 ebx
  00013	56		 push	 esi
  00014	57		 push	 edi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00026	8b f1		 mov	 esi, ecx
  00028	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  0002b	8a 5d 08	 mov	 bl, BYTE PTR ___flags$[ebp]
  0002e	f6 c3 02	 test	 bl, 2
  00031	74 3b		 je	 SHORT $LN3@vector
  00033	8b 46 fc	 mov	 eax, DWORD PTR [esi-4]
  00036	68 00 00 00 00	 push	 OFFSET ??1OBJECTSTRUCT@@QAE@XZ
  0003b	8d 7e fc	 lea	 edi, DWORD PTR [esi-4]
  0003e	50		 push	 eax
  0003f	68 40 27 00 00	 push	 10048			; 00002740H
  00044	56		 push	 esi
  00045	e8 00 00 00 00	 call	 ??_M@YGXPAXIHP6EX0@Z@Z
  0004a	f6 c3 01	 test	 bl, 1
  0004d	74 09		 je	 SHORT $LN2@vector
  0004f	57		 push	 edi
  00050	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00055	83 c4 04	 add	 esp, 4
$LN2@vector:
  00058	8b c7		 mov	 eax, edi
  0005a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0005d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00064	59		 pop	 ecx
  00065	5f		 pop	 edi
  00066	5e		 pop	 esi
  00067	5b		 pop	 ebx
  00068	8b e5		 mov	 esp, ebp
  0006a	5d		 pop	 ebp
  0006b	c2 04 00	 ret	 4
$LN3@vector:
  0006e	8d 8e ec 20 00
	00		 lea	 ecx, DWORD PTR [esi+8428]
  00074	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0007b	e8 00 00 00 00	 call	 ??1TMonsterAIAgro@@UAE@XZ ; TMonsterAIAgro::~TMonsterAIAgro
  00080	8d 8e 0c 16 00
	00		 lea	 ecx, DWORD PTR [esi+5644]
  00086	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0008d	e8 00 00 00 00	 call	 ??1CSkillDelay@@UAE@XZ	; CSkillDelay::~CSkillDelay
  00092	f6 c3 01	 test	 bl, 1
  00095	74 09		 je	 SHORT $LN1@vector
  00097	56		 push	 esi
  00098	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0009d	83 c4 04	 add	 esp, 4
$LN1@vector:
  000a0	8b c6		 mov	 eax, esi
  000a2	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000a5	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000ac	59		 pop	 ecx
  000ad	5f		 pop	 edi
  000ae	5e		 pop	 esi
  000af	5b		 pop	 ebx
  000b0	8b e5		 mov	 esp, ebp
  000b2	5d		 pop	 ebp
  000b3	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??_EOBJECTSTRUCT@@QAEPAXI@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	81 c1 0c 16 00
	00		 add	 ecx, 5644		; 0000160cH
  00009	e9 00 00 00 00	 jmp	 ??1CSkillDelay@@UAE@XZ	; CSkillDelay::~CSkillDelay
__ehhandler$??_EOBJECTSTRUCT@@QAEPAXI@Z:
  0000e	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00012	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00015	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00018	33 c8		 xor	 ecx, eax
  0001a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001f	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??_EOBJECTSTRUCT@@QAEPAXI@Z
  00024	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??_EOBJECTSTRUCT@@QAEPAXI@Z ENDP			; OBJECTSTRUCT::`vector deleting destructor'
PUBLIC	??_C@_0FD@MGPMOHAK@?$FLDoppelganger?$FN?5?$FLUSER?5REMOVE?$FN?5Use@ ; `string'
PUBLIC	??_C@_0DN@HFBIMMNA@?$FLDoppelganger?$FN?5?$FLUSER?5REMOVE?$FN?5Use@ ; `string'
PUBLIC	?CheckUser@CDoubleGoerEvent@@QAEXXZ		; CDoubleGoerEvent::CheckUser
EXTRN	?gObjIsConnected@@YAHH@Z:PROC			; gObjIsConnected
;	COMDAT ??_C@_0FD@MGPMOHAK@?$FLDoppelganger?$FN?5?$FLUSER?5REMOVE?$FN?5Use@
; File c:\muserver_dev\development\mu-s8ep2-repack\gameserver\source\doublegoerevent.cpp
CONST	SEGMENT
??_C@_0FD@MGPMOHAK@?$FLDoppelganger?$FN?5?$FLUSER?5REMOVE?$FN?5Use@ DB '['
	DB	'Doppelganger] [USER REMOVE] User not on map [%d](%s)(%s) CurM'
	DB	'ap:[%d]-UserMap:[%d]', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@HFBIMMNA@?$FLDoppelganger?$FN?5?$FLUSER?5REMOVE?$FN?5Use@
CONST	SEGMENT
??_C@_0DN@HFBIMMNA@?$FLDoppelganger?$FN?5?$FLUSER?5REMOVE?$FN?5Use@ DB '['
	DB	'Doppelganger] [USER REMOVE] User not connected [%d](%s)(%s)', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?CheckUser@CDoubleGoerEvent@@QAEXXZ
_TEXT	SEGMENT
_pMsg$183712 = -16					; size = 5
tv178 = -8						; size = 4
tv275 = -4						; size = 4
?CheckUser@CDoubleGoerEvent@@QAEXXZ PROC		; CDoubleGoerEvent::CheckUser, COMDAT
; _this$ = ecx

; 375  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	53		 push	 ebx
  00007	8b d9		 mov	 ebx, ecx

; 376  : 	for(int i = 0; i < DOUBLEGOER_MAXPLAYER; i++)

  00009	8d 83 88 00 00
	00		 lea	 eax, DWORD PTR [ebx+136]
  0000f	56		 push	 esi
  00010	89 45 fc	 mov	 DWORD PTR tv275[ebp], eax
  00013	c7 45 f8 05 00
	00 00		 mov	 DWORD PTR tv178[ebp], 5
  0001a	57		 push	 edi
  0001b	eb 03 8d 49 00	 npad	 5
$LL10@CheckUser:

; 377  : 	{
; 378  : 		int aIndex = m_PlayerInfo[i].aIndex;

  00020	8b 4d fc	 mov	 ecx, DWORD PTR tv275[ebp]
  00023	8b 31		 mov	 esi, DWORD PTR [ecx]

; 379  : 
; 380  : 		if( OBJMAX_RANGE(aIndex) )

  00025	85 f6		 test	 esi, esi
  00027	0f 88 c9 00 00
	00		 js	 $LN9@CheckUser
  0002d	33 c0		 xor	 eax, eax
  0002f	81 fe eb 2c 00
	00		 cmp	 esi, 11499		; 00002cebH
  00035	0f 9e c0	 setle	 al
  00038	85 c0		 test	 eax, eax
  0003a	0f 84 b6 00 00
	00		 je	 $LN9@CheckUser

; 381  : 		{
; 382  : 			if( !gObjIsConnected(aIndex) )

  00040	56		 push	 esi
  00041	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00046	83 c4 04	 add	 esp, 4
  00049	85 c0		 test	 eax, eax
  0004b	75 30		 jne	 SHORT $LN6@CheckUser

; 383  : 			{
; 384  : 				DelUser(aIndex);

  0004d	56		 push	 esi
  0004e	8b cb		 mov	 ecx, ebx
  00050	e8 00 00 00 00	 call	 ?DelUser@CDoubleGoerEvent@@QAEHH@Z ; CDoubleGoerEvent::DelUser

; 385  : 				LogAddTD("[Doppelganger] [USER REMOVE] User not connected [%d](%s)(%s)",aIndex,
; 386  : 					gObj[aIndex].AccountID,gObj[aIndex].Name);

  00055	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0005a	8b d6		 mov	 edx, esi
  0005c	69 d2 40 27 00
	00		 imul	 edx, 10048		; 00002740H
  00062	03 c2		 add	 eax, edx
  00064	8d 48 5d	 lea	 ecx, DWORD PTR [eax+93]
  00067	51		 push	 ecx
  00068	83 c0 52	 add	 eax, 82			; 00000052H
  0006b	50		 push	 eax
  0006c	56		 push	 esi
  0006d	68 00 00 00 00	 push	 OFFSET ??_C@_0DN@HFBIMMNA@?$FLDoppelganger?$FN?5?$FLUSER?5REMOVE?$FN?5Use@
  00072	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00078	83 c4 10	 add	 esp, 16			; 00000010H
  0007b	eb 79		 jmp	 SHORT $LN9@CheckUser
$LN6@CheckUser:

; 387  : 			}
; 388  : 			else if( gObj[aIndex].MapNumber != m_iCurentMap )

  0007d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00083	8b fe		 mov	 edi, esi
  00085	69 ff 40 27 00
	00		 imul	 edi, 10048		; 00002740H
  0008b	0f b6 84 17 23
	01 00 00	 movzx	 eax, BYTE PTR [edi+edx+291]
  00093	3b 43 30	 cmp	 eax, DWORD PTR [ebx+48]
  00096	74 5e		 je	 SHORT $LN9@CheckUser

; 389  : 			{
; 390  : 				if( m_iState == DOUBLEGOER_STATE_PLAYING )

  00098	83 7b 24 02	 cmp	 DWORD PTR [ebx+36], 2
  0009c	75 25		 jne	 SHORT $LN3@CheckUser

; 391  : 				{
; 392  : 					PMSG_DOUBLEGOER_EVENTEND pMsg;
; 393  : 					PHeadSubSetB((LPBYTE)&pMsg,0xBF,19,sizeof(pMsg));

  0009e	6a 05		 push	 5
  000a0	6a 13		 push	 19			; 00000013H
  000a2	8d 4d f0	 lea	 ecx, DWORD PTR _pMsg$183712[ebp]
  000a5	68 bf 00 00 00	 push	 191			; 000000bfH
  000aa	51		 push	 ecx
  000ab	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 394  : 					pMsg.btResult = 1;
; 395  : 
; 396  : 					DataSend(aIndex,(LPBYTE)&pMsg,sizeof(pMsg));

  000b0	6a 05		 push	 5
  000b2	8d 55 f0	 lea	 edx, DWORD PTR _pMsg$183712[ebp]
  000b5	52		 push	 edx
  000b6	56		 push	 esi
  000b7	c6 45 f4 01	 mov	 BYTE PTR _pMsg$183712[ebp+4], 1
  000bb	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  000c0	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN3@CheckUser:

; 397  : 				}
; 398  : 
; 399  : 				DelUser(aIndex);

  000c3	56		 push	 esi
  000c4	8b cb		 mov	 ecx, ebx
  000c6	e8 00 00 00 00	 call	 ?DelUser@CDoubleGoerEvent@@QAEHH@Z ; CDoubleGoerEvent::DelUser

; 400  : 				LogAddTD("[Doppelganger] [USER REMOVE] User not on map [%d](%s)(%s) CurMap:[%d]-UserMap:[%d]",aIndex,
; 401  : 					gObj[aIndex].AccountID,gObj[aIndex].Name,m_iCurentMap,gObj[aIndex].MapNumber);

  000cb	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000d0	0f b6 8c 07 23
	01 00 00	 movzx	 ecx, BYTE PTR [edi+eax+291]
  000d8	8b 53 30	 mov	 edx, DWORD PTR [ebx+48]
  000db	51		 push	 ecx
  000dc	52		 push	 edx
  000dd	8d 4c 07 5d	 lea	 ecx, DWORD PTR [edi+eax+93]
  000e1	51		 push	 ecx
  000e2	8d 54 07 52	 lea	 edx, DWORD PTR [edi+eax+82]
  000e6	52		 push	 edx
  000e7	56		 push	 esi
  000e8	68 00 00 00 00	 push	 OFFSET ??_C@_0FD@MGPMOHAK@?$FLDoppelganger?$FN?5?$FLUSER?5REMOVE?$FN?5Use@
  000ed	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  000f3	83 c4 18	 add	 esp, 24			; 00000018H
$LN9@CheckUser:

; 376  : 	for(int i = 0; i < DOUBLEGOER_MAXPLAYER; i++)

  000f6	83 45 fc 08	 add	 DWORD PTR tv275[ebp], 8
  000fa	ff 4d f8	 dec	 DWORD PTR tv178[ebp]
  000fd	0f 85 1d ff ff
	ff		 jne	 $LL10@CheckUser

; 402  : 			}
; 403  : 		}
; 404  : 	}
; 405  : 
; 406  : 	if( !OBJMAX_RANGE(m_iLeaderIndex) || !gObjIsConnected(m_iLeaderIndex) || gObj[m_iLeaderIndex].MapNumber != m_iCurentMap )

  00103	8b 83 80 00 00
	00		 mov	 eax, DWORD PTR [ebx+128]
  00109	5f		 pop	 edi
  0010a	5e		 pop	 esi
  0010b	85 c0		 test	 eax, eax
  0010d	78 3a		 js	 SHORT $LN1@CheckUser
  0010f	33 c9		 xor	 ecx, ecx
  00111	3d eb 2c 00 00	 cmp	 eax, 11499		; 00002cebH
  00116	0f 9e c1	 setle	 cl
  00119	85 c9		 test	 ecx, ecx
  0011b	74 2c		 je	 SHORT $LN1@CheckUser
  0011d	50		 push	 eax
  0011e	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00123	83 c4 04	 add	 esp, 4
  00126	85 c0		 test	 eax, eax
  00128	74 1f		 je	 SHORT $LN1@CheckUser
  0012a	8b 83 80 00 00
	00		 mov	 eax, DWORD PTR [ebx+128]
  00130	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00136	69 c0 40 27 00
	00		 imul	 eax, 10048		; 00002740H
  0013c	0f b6 94 08 23
	01 00 00	 movzx	 edx, BYTE PTR [eax+ecx+291]
  00144	3b 53 30	 cmp	 edx, DWORD PTR [ebx+48]
  00147	74 0a		 je	 SHORT $LN2@CheckUser
$LN1@CheckUser:

; 407  : 	{
; 408  : 		m_iLeaderIndex = -1;

  00149	c7 83 80 00 00
	00 ff ff ff ff	 mov	 DWORD PTR [ebx+128], -1
$LN2@CheckUser:
  00153	5b		 pop	 ebx

; 409  : 	}
; 410  : }

  00154	8b e5		 mov	 esp, ebp
  00156	5d		 pop	 ebp
  00157	c3		 ret	 0
?CheckUser@CDoubleGoerEvent@@QAEXXZ ENDP		; CDoubleGoerEvent::CheckUser
_TEXT	ENDS
PUBLIC	?SetState_CLOSED@CDoubleGoerEvent@@QAEXXZ	; CDoubleGoerEvent::SetState_CLOSED
EXTRN	?gObjMoveGate@@YAHHH@Z:PROC			; gObjMoveGate
; Function compile flags: /Ogtp
;	COMDAT ?SetState_CLOSED@CDoubleGoerEvent@@QAEXXZ
_TEXT	SEGMENT
?SetState_CLOSED@CDoubleGoerEvent@@QAEXXZ PROC		; CDoubleGoerEvent::SetState_CLOSED, COMDAT
; _this$ = ecx

; 601  : {

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	8b d9		 mov	 ebx, ecx
  00004	57		 push	 edi

; 602  : 	for(int i = 0; i < DOUBLEGOER_MAXPLAYER; i++)

  00005	8d b3 88 00 00
	00		 lea	 esi, DWORD PTR [ebx+136]
  0000b	bf 05 00 00 00	 mov	 edi, 5
$LL4@SetState_C:

; 603  : 	{
; 604  : 		if( m_PlayerInfo[i].aIndex != -1 )

  00010	8b 06		 mov	 eax, DWORD PTR [esi]
  00012	83 f8 ff	 cmp	 eax, -1
  00015	74 0b		 je	 SHORT $LN3@SetState_C

; 605  : 		{
; 606  : 			gObjMoveGate(m_PlayerInfo[i].aIndex,17);

  00017	6a 11		 push	 17			; 00000011H
  00019	50		 push	 eax
  0001a	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  0001f	83 c4 08	 add	 esp, 8
$LN3@SetState_C:

; 602  : 	for(int i = 0; i < DOUBLEGOER_MAXPLAYER; i++)

  00022	83 c6 08	 add	 esi, 8
  00025	4f		 dec	 edi
  00026	75 e8		 jne	 SHORT $LL4@SetState_C

; 607  : 		}
; 608  : 	}
; 609  : 
; 610  : 	RemoveMonster();

  00028	8b cb		 mov	 ecx, ebx
  0002a	e8 00 00 00 00	 call	 ?RemoveMonster@CDoubleGoerEvent@@QAEXXZ ; CDoubleGoerEvent::RemoveMonster
  0002f	5f		 pop	 edi
  00030	5e		 pop	 esi

; 611  : 	Init();

  00031	8b cb		 mov	 ecx, ebx
  00033	5b		 pop	 ebx
  00034	e9 00 00 00 00	 jmp	 ?Init@CDoubleGoerEvent@@QAEXXZ ; CDoubleGoerEvent::Init
?SetState_CLOSED@CDoubleGoerEvent@@QAEXXZ ENDP		; CDoubleGoerEvent::SetState_CLOSED
_TEXT	ENDS
PUBLIC	?AddUser@CDoubleGoerEvent@@QAEHH@Z		; CDoubleGoerEvent::AddUser
; Function compile flags: /Ogtp
;	COMDAT ?AddUser@CDoubleGoerEvent@@QAEHH@Z
_TEXT	SEGMENT
_aIndex$ = 8						; size = 4
?AddUser@CDoubleGoerEvent@@QAEHH@Z PROC			; CDoubleGoerEvent::AddUser, COMDAT
; _this$ = ecx

; 686  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	57		 push	 edi
  00005	8b f9		 mov	 edi, ecx

; 687  : 	for(int i = 0; i < DOUBLEGOER_MAXPLAYER; i++)

  00007	33 db		 xor	 ebx, ebx
  00009	8d 87 88 00 00
	00		 lea	 eax, DWORD PTR [edi+136]
  0000f	90		 npad	 1
$LL4@AddUser:

; 688  : 	{
; 689  : 		if( m_PlayerInfo[i].aIndex == -1 )

  00010	83 38 ff	 cmp	 DWORD PTR [eax], -1
  00013	74 11		 je	 SHORT $LN8@AddUser

; 687  : 	for(int i = 0; i < DOUBLEGOER_MAXPLAYER; i++)

  00015	43		 inc	 ebx
  00016	83 c0 08	 add	 eax, 8
  00019	83 fb 05	 cmp	 ebx, 5
  0001c	7c f2		 jl	 SHORT $LL4@AddUser

; 698  : 			return true;
; 699  : 		}
; 700  : 	}
; 701  : return false;

  0001e	5f		 pop	 edi
  0001f	33 c0		 xor	 eax, eax
  00021	5b		 pop	 ebx

; 702  : }

  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
$LN8@AddUser:

; 690  : 		{
; 691  : 			int MapIndex = m_iCurentMap-MAP_INDEX_DOUBLEGOER1;
; 692  : 			gObjMoveGate(aIndex,g_DoubleGoerEvent_Gates[MapIndex]);

  00026	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00029	56		 push	 esi
  0002a	8b 77 30	 mov	 esi, DWORD PTR [edi+48]
  0002d	8b 04 b5 fc fe
	ff ff		 mov	 eax, DWORD PTR ?g_DoubleGoerEvent_Gates@@3PAHA[esi*4-260]
  00034	83 ee 41	 sub	 esi, 65			; 00000041H
  00037	50		 push	 eax
  00038	51		 push	 ecx
  00039	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  0003e	83 c4 08	 add	 esp, 8

; 693  : 
; 694  : 			SendBlockInfo(aIndex,MapIndex,0);

  00041	6a 00		 push	 0
  00043	56		 push	 esi
  00044	8b 75 08	 mov	 esi, DWORD PTR _aIndex$[ebp]
  00047	56		 push	 esi
  00048	8b cf		 mov	 ecx, edi
  0004a	e8 00 00 00 00	 call	 ?SendBlockInfo@CDoubleGoerEvent@@QAEXHHH@Z ; CDoubleGoerEvent::SendBlockInfo

; 695  : 
; 696  : 			m_PlayerInfo[i].aIndex = aIndex;

  0004f	89 b4 df 88 00
	00 00		 mov	 DWORD PTR [edi+ebx*8+136], esi

; 697  : 			m_iPlayerCount++;

  00056	b8 01 00 00 00	 mov	 eax, 1
  0005b	01 47 34	 add	 DWORD PTR [edi+52], eax
  0005e	5e		 pop	 esi
  0005f	5f		 pop	 edi
  00060	5b		 pop	 ebx

; 702  : }

  00061	5d		 pop	 ebp
  00062	c2 04 00	 ret	 4
?AddUser@CDoubleGoerEvent@@QAEHH@Z ENDP			; CDoubleGoerEvent::AddUser
_TEXT	ENDS
PUBLIC	?CalcDistance@CDoubleGoerEvent@@QAEHHHHH@Z	; CDoubleGoerEvent::CalcDistance
EXTRN	__ftol2_sse:PROC
; Function compile flags: /Ogtp
;	COMDAT ?CalcDistance@CDoubleGoerEvent@@QAEHHHHH@Z
_TEXT	SEGMENT
tv169 = 8						; size = 4
tv163 = 8						; size = 4
tv128 = 8						; size = 4
tv64 = 8						; size = 4
_ty$ = 8						; size = 4
_x1$ = 8						; size = 4
_y1$ = 12						; size = 4
_tx$ = 16						; size = 4
_x2$ = 16						; size = 4
_y2$ = 20						; size = 4
?CalcDistance@CDoubleGoerEvent@@QAEHHHHH@Z PROC		; CDoubleGoerEvent::CalcDistance, COMDAT
; _this$ = ecx

; 864  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 865  : 	float tx = (float)(x1 - x2);

  00003	8b 45 08	 mov	 eax, DWORD PTR _x1$[ebp]
  00006	2b 45 10	 sub	 eax, DWORD PTR _x2$[ebp]

; 866  : 	float ty = (float)(y1 - y2);

  00009	8b 4d 0c	 mov	 ecx, DWORD PTR _y1$[ebp]
  0000c	2b 4d 14	 sub	 ecx, DWORD PTR _y2$[ebp]
  0000f	89 45 08	 mov	 DWORD PTR tv169[ebp], eax
  00012	db 45 08	 fild	 DWORD PTR tv169[ebp]
  00015	89 4d 08	 mov	 DWORD PTR tv163[ebp], ecx
  00018	d9 5d 10	 fstp	 DWORD PTR _tx$[ebp]
  0001b	db 45 08	 fild	 DWORD PTR tv163[ebp]
  0001e	d9 5d 08	 fstp	 DWORD PTR _ty$[ebp]

; 867  : 
; 868  : return (int)sqrt( (tx*tx)+(ty*ty) );

  00021	d9 45 08	 fld	 DWORD PTR _ty$[ebp]
  00024	d9 45 10	 fld	 DWORD PTR _tx$[ebp]
  00027	dc c8		 fmul	 ST(0), ST(0)
  00029	d9 c1		 fld	 ST(1)
  0002b	de ca		 fmulp	 ST(2), ST(0)
  0002d	de c1		 faddp	 ST(1), ST(0)
  0002f	d9 5d 08	 fstp	 DWORD PTR tv64[ebp]
  00032	d9 45 08	 fld	 DWORD PTR tv64[ebp]
  00035	e8 00 00 00 00	 call	 __CIsqrt
  0003a	d9 5d 08	 fstp	 DWORD PTR tv128[ebp]
  0003d	d9 45 08	 fld	 DWORD PTR tv128[ebp]
  00040	e8 00 00 00 00	 call	 __ftol2_sse

; 869  : }

  00045	5d		 pop	 ebp
  00046	c2 10 00	 ret	 16			; 00000010H
?CalcDistance@CDoubleGoerEvent@@QAEHHHHH@Z ENDP		; CDoubleGoerEvent::CalcDistance
_TEXT	ENDS
PUBLIC	?CalcDistance@CDoubleGoerEvent@@QAEXXZ		; CDoubleGoerEvent::CalcDistance
EXTRN	?GCStateInfoSend@@YAXPAUOBJECTSTRUCT@@EE@Z:PROC	; GCStateInfoSend
; Function compile flags: /Ogtp
;	COMDAT ?CalcDistance@CDoubleGoerEvent@@QAEXXZ
_TEXT	SEGMENT
_Dist$183970 = -12					; size = 4
tv75 = -8						; size = 4
tv509 = -4						; size = 4
?CalcDistance@CDoubleGoerEvent@@QAEXXZ PROC		; CDoubleGoerEvent::CalcDistance, COMDAT
; _this$ = ecx

; 872  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	8b d9		 mov	 ebx, ecx
  0000a	57		 push	 edi

; 873  : 	int i;
; 874  : 	for(i = 0; i < DOUBLEGOER_MAXPLAYER; i++)

  0000b	8d b3 8c 00 00
	00		 lea	 esi, DWORD PTR [ebx+140]
  00011	bf 05 00 00 00	 mov	 edi, 5
$LL13@CalcDistan:

; 875  : 	{
; 876  : 		int aIndex = m_PlayerInfo[i].aIndex;

  00016	8b 4e fc	 mov	 ecx, DWORD PTR [esi-4]

; 877  : 
; 878  : 		if( OBJMAX_RANGE(aIndex) )

  00019	85 c9		 test	 ecx, ecx
  0001b	78 53		 js	 SHORT $LN12@CalcDistan
  0001d	33 c0		 xor	 eax, eax
  0001f	81 f9 eb 2c 00
	00		 cmp	 ecx, 11499		; 00002cebH
  00025	0f 9e c0	 setle	 al
  00028	85 c0		 test	 eax, eax
  0002a	74 44		 je	 SHORT $LN12@CalcDistan

; 879  : 		{
; 880  : 			m_PlayerInfo[i].Dist = CalcDistance(gObj[aIndex].X,gObj[aIndex].Y,
; 881  : 				g_DoubleGoerEvent_DefPts[m_iCurentMap-MAP_INDEX_DOUBLEGOER1].ptX,g_DoubleGoerEvent_DefPts[m_iCurentMap-MAP_INDEX_DOUBLEGOER1].ptY);

  0002c	8b 43 30	 mov	 eax, DWORD PTR [ebx+48]
  0002f	69 c9 40 27 00
	00		 imul	 ecx, 10048		; 00002740H
  00035	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0003b	8d 84 40 3d ff
	ff ff		 lea	 eax, DWORD PTR [eax+eax*2-195]
  00042	03 c0		 add	 eax, eax
  00044	0f b6 94 00 03
	00 00 00	 movzx	 edx, BYTE PTR ?g_DoubleGoerEvent_DefPts@@3PAUDOUBLEGOER_DEFPOINTS@@A[eax+eax+3]
  0004c	03 c0		 add	 eax, eax
  0004e	0f b6 80 02 00
	00 00		 movzx	 eax, BYTE PTR ?g_DoubleGoerEvent_DefPts@@3PAUDOUBLEGOER_DEFPOINTS@@A[eax+2]
  00055	52		 push	 edx
  00056	0f b6 91 21 01
	00 00		 movzx	 edx, BYTE PTR [ecx+289]
  0005d	50		 push	 eax
  0005e	0f b6 81 20 01
	00 00		 movzx	 eax, BYTE PTR [ecx+288]
  00065	52		 push	 edx
  00066	50		 push	 eax
  00067	8b cb		 mov	 ecx, ebx
  00069	e8 00 00 00 00	 call	 ?CalcDistance@CDoubleGoerEvent@@QAEHHHHH@Z ; CDoubleGoerEvent::CalcDistance
  0006e	89 06		 mov	 DWORD PTR [esi], eax
$LN12@CalcDistan:

; 873  : 	int i;
; 874  : 	for(i = 0; i < DOUBLEGOER_MAXPLAYER; i++)

  00070	83 c6 08	 add	 esi, 8
  00073	4f		 dec	 edi
  00074	75 a0		 jne	 SHORT $LL13@CalcDistan

; 882  : 		}
; 883  : 	}
; 884  : 
; 885  : 	m_iWaveDist = 0;

  00076	8d 8b b0 00 00
	00		 lea	 ecx, DWORD PTR [ebx+176]
  0007c	89 7b 3c	 mov	 DWORD PTR [ebx+60], edi
  0007f	89 4d fc	 mov	 DWORD PTR tv509[ebp], ecx
  00082	c7 45 f8 64 00
	00 00		 mov	 DWORD PTR tv75[ebp], 100 ; 00000064H
  00089	8d a4 24 00 00
	00 00		 npad	 7
$LL26@CalcDistan:

; 888  : 	{
; 889  : 		if( OBJMAX_RANGE(m_MonsterInfo[i]) )

  00090	8b 55 fc	 mov	 edx, DWORD PTR tv509[ebp]
  00093	8b 02		 mov	 eax, DWORD PTR [edx]
  00095	85 c0		 test	 eax, eax
  00097	0f 88 d8 00 00
	00		 js	 $LN8@CalcDistan
  0009d	33 c9		 xor	 ecx, ecx
  0009f	3d eb 2c 00 00	 cmp	 eax, 11499		; 00002cebH
  000a4	0f 9e c1	 setle	 cl
  000a7	85 c9		 test	 ecx, ecx
  000a9	0f 84 c6 00 00
	00		 je	 $LN8@CalcDistan

; 890  : 		{
; 891  : 			LPOBJ monObj = &gObj[m_MonsterInfo[i]];

  000af	69 c0 40 27 00
	00		 imul	 eax, 10048		; 00002740H
  000b5	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000bb	8b f8		 mov	 edi, eax

; 892  : 
; 893  : 			int Dist = CalcDistance(monObj->X,monObj->Y,g_DoubleGoerEvent_DefPts[m_iCurentMap-MAP_INDEX_DOUBLEGOER1].ptX,
; 894  : 				g_DoubleGoerEvent_DefPts[m_iCurentMap-MAP_INDEX_DOUBLEGOER1].ptY);

  000bd	8b 43 30	 mov	 eax, DWORD PTR [ebx+48]
  000c0	0f b6 97 21 01
	00 00		 movzx	 edx, BYTE PTR [edi+289]
  000c7	8d b4 40 3d ff
	ff ff		 lea	 esi, DWORD PTR [eax+eax*2-195]
  000ce	03 f6		 add	 esi, esi
  000d0	0f b6 84 36 03
	00 00 00	 movzx	 eax, BYTE PTR ?g_DoubleGoerEvent_DefPts@@3PAUDOUBLEGOER_DEFPOINTS@@A[esi+esi+3]
  000d8	0f b6 8c 36 02
	00 00 00	 movzx	 ecx, BYTE PTR ?g_DoubleGoerEvent_DefPts@@3PAUDOUBLEGOER_DEFPOINTS@@A[esi+esi+2]
  000e0	03 f6		 add	 esi, esi
  000e2	50		 push	 eax
  000e3	0f b6 87 20 01
	00 00		 movzx	 eax, BYTE PTR [edi+288]
  000ea	51		 push	 ecx
  000eb	52		 push	 edx
  000ec	50		 push	 eax
  000ed	8b cb		 mov	 ecx, ebx
  000ef	e8 00 00 00 00	 call	 ?CalcDistance@CDoubleGoerEvent@@QAEHHHHH@Z ; CDoubleGoerEvent::CalcDistance

; 895  : 
; 896  : 			if( (Dist+1) >= g_DoubleGoerEvent_DefPts[m_iCurentMap-MAP_INDEX_DOUBLEGOER1].EndDist )

  000f4	0f b6 8e 08 00
	00 00		 movzx	 ecx, BYTE PTR ?g_DoubleGoerEvent_DefPts@@3PAUDOUBLEGOER_DEFPOINTS@@A[esi+8]
  000fb	89 45 f4	 mov	 DWORD PTR _Dist$183970[ebp], eax
  000fe	40		 inc	 eax
  000ff	3b c1		 cmp	 eax, ecx
  00101	7c 51		 jl	 SHORT $LN5@CalcDistan

; 897  : 			{
; 898  : 				GCStateInfoSend(monObj,1,105);

  00103	6a 69		 push	 105			; 00000069H
  00105	6a 01		 push	 1
  00107	57		 push	 edi
  00108	e8 00 00 00 00	 call	 ?GCStateInfoSend@@YAXPAUOBJECTSTRUCT@@EE@Z ; GCStateInfoSend

; 899  : 
; 900  : 				if( monObj->Class == 529 ||
; 901  : 					monObj->Class == 530 ||
; 902  : 					monObj->Class == 531 )

  0010d	0f b7 87 90 00
	00 00		 movzx	 eax, WORD PTR [edi+144]
  00114	ba 11 02 00 00	 mov	 edx, 529		; 00000211H
  00119	83 c4 0c	 add	 esp, 12			; 0000000cH
  0011c	66 3b c2	 cmp	 ax, dx
  0011f	74 19		 je	 SHORT $LN3@CalcDistan
  00121	b9 12 02 00 00	 mov	 ecx, 530		; 00000212H
  00126	66 3b c1	 cmp	 ax, cx
  00129	74 0f		 je	 SHORT $LN3@CalcDistan
  0012b	ba 13 02 00 00	 mov	 edx, 531		; 00000213H
  00130	66 3b c2	 cmp	 ax, dx
  00133	74 05		 je	 SHORT $LN3@CalcDistan

; 905  : 				}
; 906  : 				else
; 907  : 				{
; 908  : 					m_iMonsterPassed++;

  00135	ff 43 38	 inc	 DWORD PTR [ebx+56]
  00138	eb 07		 jmp	 SHORT $LN2@CalcDistan
$LN3@CalcDistan:

; 903  : 				{
; 904  : 					m_iMonsterPassed = 3;

  0013a	c7 43 38 03 00
	00 00		 mov	 DWORD PTR [ebx+56], 3
$LN2@CalcDistan:

; 909  : 				}
; 910  : 
; 911  : 				DelMonster(monObj->m_Index);

  00141	8b 07		 mov	 eax, DWORD PTR [edi]
  00143	50		 push	 eax
  00144	8b cb		 mov	 ecx, ebx
  00146	e8 00 00 00 00	 call	 ?DelMonster@CDoubleGoerEvent@@QAEHH@Z ; CDoubleGoerEvent::DelMonster

; 912  : 				SendMonsterCount();

  0014b	8b cb		 mov	 ecx, ebx
  0014d	e8 00 00 00 00	 call	 ?SendMonsterCount@CDoubleGoerEvent@@QAEXXZ ; CDoubleGoerEvent::SendMonsterCount

; 913  : 				continue;

  00152	eb 21		 jmp	 SHORT $LN8@CalcDistan
$LN5@CalcDistan:

; 914  : 			}
; 915  : 
; 916  : 			if( (Dist/g_DoubleGoerEvent_DefPts[m_iCurentMap-MAP_INDEX_DOUBLEGOER1].distDiv) > m_iWaveDist )

  00154	db 45 f4	 fild	 DWORD PTR _Dist$183970[ebp]
  00157	d8 b6 04 00 00
	00		 fdiv	 DWORD PTR ?g_DoubleGoerEvent_DefPts@@3PAUDOUBLEGOER_DEFPOINTS@@A[esi+4]
  0015d	db 43 3c	 fild	 DWORD PTR [ebx+60]
  00160	d8 d9		 fcomp	 ST(1)
  00162	df e0		 fnstsw	 ax
  00164	f6 c4 05	 test	 ah, 5
  00167	7a 0a		 jp	 SHORT $LN28@CalcDistan

; 917  : 			{
; 918  : 				m_iWaveDist = (int)(Dist/g_DoubleGoerEvent_DefPts[m_iCurentMap-MAP_INDEX_DOUBLEGOER1].distDiv);

  00169	e8 00 00 00 00	 call	 __ftol2_sse
  0016e	89 43 3c	 mov	 DWORD PTR [ebx+60], eax
  00171	eb 02		 jmp	 SHORT $LN8@CalcDistan
$LN28@CalcDistan:
  00173	dd d8		 fstp	 ST(0)
$LN8@CalcDistan:

; 886  : 
; 887  : 	for(i = 0;i < DOUBLEGOER_MAXMONSTER; i++)

  00175	83 45 fc 04	 add	 DWORD PTR tv509[ebp], 4
  00179	ff 4d f8	 dec	 DWORD PTR tv75[ebp]
  0017c	0f 85 0e ff ff
	ff		 jne	 $LL26@CalcDistan
  00182	5f		 pop	 edi
  00183	5e		 pop	 esi
  00184	5b		 pop	 ebx

; 919  : 			}
; 920  : 		}
; 921  : 	}
; 922  : }

  00185	8b e5		 mov	 esp, ebp
  00187	5d		 pop	 ebp
  00188	c3		 ret	 0
?CalcDistance@CDoubleGoerEvent@@QAEXXZ ENDP		; CDoubleGoerEvent::CalcDistance
_TEXT	ENDS
PUBLIC	??_C@_0DM@HDEPMCLL@?$FLDoppelganger?$FN?5SummonMonster?5?$FL?$CFd@ ; `string'
PUBLIC	??_C@_0DC@EFKJFIJH@?$FLDoppelganger?$FN?5Failed?5to?5summon?5@ ; `string'
PUBLIC	??_C@_0CP@HPEENAHP@?$FLDoppelganger?$FN?5Failed?5to?5summon?5@ ; `string'
PUBLIC	??_C@_0DB@LKFLCEDF@?$FLDoppelganger?$FN?5Failed?5to?5set?5mon@ ; `string'
PUBLIC	?SummonMonster@CDoubleGoerEvent@@QAEHHHHHHH@Z	; CDoubleGoerEvent::SummonMonster
EXTRN	?gObjAddMonster@@YAFH@Z:PROC			; gObjAddMonster
;	COMDAT ??_C@_0DM@HDEPMCLL@?$FLDoppelganger?$FN?5SummonMonster?5?$FL?$CFd@
CONST	SEGMENT
??_C@_0DM@HDEPMCLL@?$FLDoppelganger?$FN?5SummonMonster?5?$FL?$CFd@ DB '[D'
	DB	'oppelganger] SummonMonster [%d](%s) Map: %d, X: %d, Y: %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@EFKJFIJH@?$FLDoppelganger?$FN?5Failed?5to?5summon?5@
CONST	SEGMENT
??_C@_0DC@EFKJFIJH@?$FLDoppelganger?$FN?5Failed?5to?5summon?5@ DB '[Doppe'
	DB	'lganger] Failed to summon silver box ID: %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@HPEENAHP@?$FLDoppelganger?$FN?5Failed?5to?5summon?5@
CONST	SEGMENT
??_C@_0CP@HPEENAHP@?$FLDoppelganger?$FN?5Failed?5to?5summon?5@ DB '[Doppe'
	DB	'lganger] Failed to summon monster ID: %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@LKFLCEDF@?$FLDoppelganger?$FN?5Failed?5to?5set?5mon@
CONST	SEGMENT
??_C@_0DB@LKFLCEDF@?$FLDoppelganger?$FN?5Failed?5to?5set?5mon@ DB '[Doppe'
	DB	'lganger] Failed to set monster info ID: %d', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?SummonMonster@CDoubleGoerEvent@@QAEHHHHHHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_Id$ = 8						; size = 4
_map$ = 12						; size = 4
_x$ = 16						; size = 4
_y$ = 20						; size = 4
_MaxLevel$ = 24						; size = 4
_MaxReset$ = 28						; size = 4
?SummonMonster@CDoubleGoerEvent@@QAEHHHHHHH@Z PROC	; CDoubleGoerEvent::SummonMonster, COMDAT
; _this$ = ecx

; 985  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 986  : 	int result = gObjAddMonster(map);

  00004	8b 45 0c	 mov	 eax, DWORD PTR _map$[ebp]
  00007	53		 push	 ebx
  00008	56		 push	 esi
  00009	57		 push	 edi
  0000a	50		 push	 eax
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	e8 00 00 00 00	 call	 ?gObjAddMonster@@YAFH@Z	; gObjAddMonster
  00013	0f bf d8	 movsx	 ebx, ax
  00016	83 c4 04	 add	 esp, 4

; 987  : 
; 988  : 	if ( result >= 0 )

  00019	85 db		 test	 ebx, ebx
  0001b	0f 88 79 01 00
	00		 js	 $LN7@SummonMons

; 989  : 	{
; 990  : 		LPOBJ lpObj = &gObj[result];

  00021	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 991  : 
; 992  : 		lpObj->m_PosNum = -1;
; 993  : 		lpObj->X = x;

  00027	8a 45 10	 mov	 al, BYTE PTR _x$[ebp]
  0002a	8b fb		 mov	 edi, ebx
  0002c	69 ff 40 27 00
	00		 imul	 edi, 10048		; 00002740H
  00032	8d 34 0f	 lea	 esi, DWORD PTR [edi+ecx]

; 994  : 		lpObj->Y = y;

  00035	8a 4d 14	 mov	 cl, BYTE PTR _y$[ebp]
  00038	83 ca ff	 or	 edx, -1
  0003b	66 89 96 98 05
	00 00		 mov	 WORD PTR [esi+1432], dx

; 995  : 		lpObj->MapNumber = map;

  00042	8a 55 0c	 mov	 dl, BYTE PTR _map$[ebp]
  00045	88 86 20 01 00
	00		 mov	 BYTE PTR [esi+288], al

; 996  : 		lpObj->TX = x;

  0004b	88 86 52 01 00
	00		 mov	 BYTE PTR [esi+338], al

; 997  : 		lpObj->TY = y;
; 998  : 		lpObj->m_OldX = x;

  00051	88 86 50 01 00
	00		 mov	 BYTE PTR [esi+336], al

; 999  : 		lpObj->m_OldY = y;
; 1000 : 		lpObj->StartX = x;

  00057	88 86 4e 01 00
	00		 mov	 BYTE PTR [esi+334], al

; 1001 : 		lpObj->StartY = y;
; 1002 : 
; 1003 : 		//if( gObjSetMonster(result, Id) == FALSE )
; 1004 : 
; 1005 : 		if( !this->SetMonster(result, Id, MaxLevel, MaxReset) )

  0005d	8b 45 1c	 mov	 eax, DWORD PTR _MaxReset$[ebp]
  00060	88 8e 21 01 00
	00		 mov	 BYTE PTR [esi+289], cl
  00066	88 8e 53 01 00
	00		 mov	 BYTE PTR [esi+339], cl
  0006c	88 8e 51 01 00
	00		 mov	 BYTE PTR [esi+337], cl
  00072	88 8e 4f 01 00
	00		 mov	 BYTE PTR [esi+335], cl
  00078	8b 4d 18	 mov	 ecx, DWORD PTR _MaxLevel$[ebp]
  0007b	50		 push	 eax
  0007c	51		 push	 ecx
  0007d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00080	88 96 23 01 00
	00		 mov	 BYTE PTR [esi+291], dl
  00086	8b 55 08	 mov	 edx, DWORD PTR _Id$[ebp]
  00089	52		 push	 edx
  0008a	53		 push	 ebx
  0008b	e8 00 00 00 00	 call	 ?SetMonster@CDoubleGoerEvent@@QAEHHHHH@Z ; CDoubleGoerEvent::SetMonster
  00090	85 c0		 test	 eax, eax
  00092	75 23		 jne	 SHORT $LN6@SummonMons

; 1006 : 		{
; 1007 : 			gObjDel(result);

  00094	53		 push	 ebx
  00095	e8 00 00 00 00	 call	 ?gObjDel@@YAFH@Z	; gObjDel

; 1008 : 			LogAddTD("[Doppelganger] Failed to set monster info ID: %d",Id);

  0009a	8b 45 08	 mov	 eax, DWORD PTR _Id$[ebp]
  0009d	50		 push	 eax
  0009e	68 00 00 00 00	 push	 OFFSET ??_C@_0DB@LKFLCEDF@?$FLDoppelganger?$FN?5Failed?5to?5set?5mon@
  000a3	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  000a9	83 c4 0c	 add	 esp, 12			; 0000000cH
  000ac	5f		 pop	 edi
  000ad	5e		 pop	 esi

; 1009 : 			return false;

  000ae	33 c0		 xor	 eax, eax
  000b0	5b		 pop	 ebx

; 1037 : }

  000b1	8b e5		 mov	 esp, ebp
  000b3	5d		 pop	 ebp
  000b4	c2 18 00	 ret	 24			; 00000018H
$LN6@SummonMons:

; 1010 : 		}
; 1011 : 
; 1012 : 		if( Id == 541 || Id == 542 )

  000b7	8b 45 08	 mov	 eax, DWORD PTR _Id$[ebp]
  000ba	3d 1d 02 00 00	 cmp	 eax, 541		; 0000021dH
  000bf	74 3b		 je	 SHORT $LN4@SummonMons
  000c1	3d 1e 02 00 00	 cmp	 eax, 542		; 0000021eH
  000c6	74 34		 je	 SHORT $LN4@SummonMons

; 1025 : 		}
; 1026 : 		else if( AddMonster(result) == FALSE )

  000c8	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000cb	53		 push	 ebx
  000cc	e8 00 00 00 00	 call	 ?AddMonster@CDoubleGoerEvent@@QAEHH@Z ; CDoubleGoerEvent::AddMonster
  000d1	85 c0		 test	 eax, eax
  000d3	0f 85 8f 00 00
	00		 jne	 $LN10@SummonMons

; 1027 : 		{
; 1028 : 			gObjDel(result);

  000d9	53		 push	 ebx
  000da	e8 00 00 00 00	 call	 ?gObjDel@@YAFH@Z	; gObjDel

; 1029 : 			LogAddTD("[Doppelganger] Failed to summon monster ID: %d",Id);

  000df	8b 4d 08	 mov	 ecx, DWORD PTR _Id$[ebp]
  000e2	51		 push	 ecx
  000e3	68 00 00 00 00	 push	 OFFSET ??_C@_0CP@HPEENAHP@?$FLDoppelganger?$FN?5Failed?5to?5summon?5@
  000e8	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  000ee	83 c4 0c	 add	 esp, 12			; 0000000cH
  000f1	5f		 pop	 edi
  000f2	5e		 pop	 esi

; 1030 : 			return false;

  000f3	33 c0		 xor	 eax, eax
  000f5	5b		 pop	 ebx

; 1037 : }

  000f6	8b e5		 mov	 esp, ebp
  000f8	5d		 pop	 ebp
  000f9	c2 18 00	 ret	 24			; 00000018H
$LN4@SummonMons:

; 1013 : 		{
; 1014 : 			if( AddBox(result) == FALSE )

  000fc	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000ff	53		 push	 ebx
  00100	e8 00 00 00 00	 call	 ?AddBox@CDoubleGoerEvent@@QAEHH@Z ; CDoubleGoerEvent::AddBox
  00105	85 c0		 test	 eax, eax
  00107	75 23		 jne	 SHORT $LN3@SummonMons

; 1015 : 			{
; 1016 : 				gObjDel(result);

  00109	53		 push	 ebx
  0010a	e8 00 00 00 00	 call	 ?gObjDel@@YAFH@Z	; gObjDel

; 1017 : 				LogAddTD("[Doppelganger] Failed to summon silver box ID: %d",Id);

  0010f	8b 55 08	 mov	 edx, DWORD PTR _Id$[ebp]
  00112	52		 push	 edx
  00113	68 00 00 00 00	 push	 OFFSET ??_C@_0DC@EFKJFIJH@?$FLDoppelganger?$FN?5Failed?5to?5summon?5@
  00118	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0011e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00121	5f		 pop	 edi
  00122	5e		 pop	 esi

; 1018 : 				return false;

  00123	33 c0		 xor	 eax, eax
  00125	5b		 pop	 ebx

; 1037 : }

  00126	8b e5		 mov	 esp, ebp
  00128	5d		 pop	 ebp
  00129	c2 18 00	 ret	 24			; 00000018H
$LN3@SummonMons:

; 1019 : 			}
; 1020 : 
; 1021 : 			gObj[result].Type = OBJ_NPC;

  0012c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00131	c6 44 07 50 03	 mov	 BYTE PTR [edi+eax+80], 3

; 1022 : 
; 1023 : 			LogAddTD("[Doppelganger] SummonMonster [%d](%s) Map: %d, X: %d, Y: %d",
; 1024 : 				lpObj->Class,lpObj->Name,lpObj->MapNumber,lpObj->X,lpObj->Y);

  00136	0f b6 8e 21 01
	00 00		 movzx	 ecx, BYTE PTR [esi+289]
  0013d	0f b6 96 20 01
	00 00		 movzx	 edx, BYTE PTR [esi+288]
  00144	0f b6 86 23 01
	00 00		 movzx	 eax, BYTE PTR [esi+291]
  0014b	51		 push	 ecx
  0014c	52		 push	 edx
  0014d	0f b7 96 90 00
	00 00		 movzx	 edx, WORD PTR [esi+144]
  00154	50		 push	 eax
  00155	8d 4e 5d	 lea	 ecx, DWORD PTR [esi+93]
  00158	51		 push	 ecx
  00159	52		 push	 edx
  0015a	68 00 00 00 00	 push	 OFFSET ??_C@_0DM@HDEPMCLL@?$FLDoppelganger?$FN?5SummonMonster?5?$FL?$CFd@
  0015f	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00165	83 c4 18	 add	 esp, 24			; 00000018H
$LN10@SummonMons:

; 1031 : 		}
; 1032 : 
; 1033 : 		LogAddTD("[Doppelganger] SummonMonster [%d](%s) Map: %d, X: %d, Y: %d",
; 1034 : 			lpObj->Class,lpObj->Name,lpObj->MapNumber,lpObj->X,lpObj->Y);

  00168	0f b6 86 21 01
	00 00		 movzx	 eax, BYTE PTR [esi+289]
  0016f	0f b6 8e 20 01
	00 00		 movzx	 ecx, BYTE PTR [esi+288]
  00176	0f b6 96 23 01
	00 00		 movzx	 edx, BYTE PTR [esi+291]
  0017d	50		 push	 eax
  0017e	51		 push	 ecx
  0017f	0f b7 8e 90 00
	00 00		 movzx	 ecx, WORD PTR [esi+144]
  00186	52		 push	 edx
  00187	8d 46 5d	 lea	 eax, DWORD PTR [esi+93]
  0018a	50		 push	 eax
  0018b	51		 push	 ecx
  0018c	68 00 00 00 00	 push	 OFFSET ??_C@_0DM@HDEPMCLL@?$FLDoppelganger?$FN?5SummonMonster?5?$FL?$CFd@
  00191	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00197	83 c4 18	 add	 esp, 24			; 00000018H
$LN7@SummonMons:

; 1035 : 	}
; 1036 : return result;

  0019a	5f		 pop	 edi
  0019b	5e		 pop	 esi
  0019c	8b c3		 mov	 eax, ebx
  0019e	5b		 pop	 ebx

; 1037 : }

  0019f	8b e5		 mov	 esp, ebp
  001a1	5d		 pop	 ebp
  001a2	c2 18 00	 ret	 24			; 00000018H
?SummonMonster@CDoubleGoerEvent@@QAEHHHHHHH@Z ENDP	; CDoubleGoerEvent::SummonMonster
_TEXT	ENDS
PUBLIC	?gObjMonsterMove@CDoubleGoerEvent@@QAEXPAUOBJECTSTRUCT@@@Z ; CDoubleGoerEvent::gObjMonsterMove
EXTRN	?s_MonsterAIMovePath@TMonsterAIElement@@2PAVTMonsterAIMovePath@@A:BYTE ; TMonsterAIElement::s_MonsterAIMovePath
EXTRN	?gObjCheckUsedBuffEffect@@YA_NPAUOBJECTSTRUCT@@H@Z:PROC ; gObjCheckUsedBuffEffect
EXTRN	__except_handler4:PROC
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\math.h
xdata$x	SEGMENT
__sehtable$?gObjMonsterMove@CDoubleGoerEvent@@QAEXPAUOBJECTSTRUCT@@@Z DD 0fffffffeH
	DD	00H
	DD	0ffffffa4H
	DD	00H
	DD	0fffffffeH
	DD	FLAT:$LN20@gObjMonste
	DD	FLAT:$LN21@gObjMonste
; Function compile flags: /Ogtp
; File c:\muserver_dev\development\mu-s8ep2-repack\gameserver\source\doublegoerevent.cpp
xdata$x	ENDS
;	COMDAT ?gObjMonsterMove@CDoubleGoerEvent@@QAEXPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_bFindXY$ = -76						; size = 4
_searchc$ = -72						; size = 4
tv607 = -68						; size = 4
tv602 = -68						; size = 4
$T188867 = -68						; size = 4
_iMidY$184068 = -68					; size = 4
_iMidX$184067 = -64					; size = 4
tv180 = -60						; size = 4
_maxmoverange$ = -56					; size = 4
_iTargetY$ = -52					; size = 4
_iTargetX$ = -48					; size = 4
_iMinCost$184066 = -44					; size = 4
tv594 = -40						; size = 4
tv585 = -40						; size = 4
tv579 = -40						; size = 4
tv574 = -40						; size = 4
tv566 = -40						; size = 4
tv560 = -40						; size = 4
_fDistX$184075 = -40					; size = 4
tv592 = -36						; size = 4
tv573 = -36						; size = 4
_fDistY$184077 = -36					; size = 4
tv596 = -32						; size = 4
_tpy$ = -26						; size = 1
_tpx$ = -25						; size = 1
__$SEHRec$ = -24					; size = 24
_lpObj$ = 8						; size = 4
?gObjMonsterMove@CDoubleGoerEvent@@QAEXPAUOBJECTSTRUCT@@@Z PROC ; CDoubleGoerEvent::gObjMonsterMove, COMDAT
; _this$ = ecx

; 1111 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a fe		 push	 -2			; fffffffeH
  00005	68 00 00 00 00	 push	 OFFSET __sehtable$?gObjMonsterMove@CDoubleGoerEvent@@QAEXPAUOBJECTSTRUCT@@@Z
  0000a	68 00 00 00 00	 push	 OFFSET __except_handler4
  0000f	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00015	50		 push	 eax
  00016	83 ec 3c	 sub	 esp, 60			; 0000003cH
  00019	53		 push	 ebx
  0001a	56		 push	 esi
  0001b	57		 push	 edi
  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00021	31 45 f8	 xor	 DWORD PTR __$SEHRec$[ebp+16], eax
  00024	33 c5		 xor	 eax, ebp
  00026	50		 push	 eax
  00027	8d 45 f0	 lea	 eax, DWORD PTR __$SEHRec$[ebp+8]
  0002a	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00030	89 65 e8	 mov	 DWORD PTR __$SEHRec$[ebp], esp
  00033	8b f9		 mov	 edi, ecx

; 1112 : 	if( gObjCheckUsedBuffEffect(lpObj,BUFF_ICEARROW) == TRUE ||
; 1113 : 		gObjCheckUsedBuffEffect(lpObj,BUFF_STUN) == TRUE || 
; 1114 : 		gObjCheckUsedBuffEffect(lpObj,BUFF_SLEEP) == TRUE ||
; 1115 : 		gObjCheckUsedBuffEffect(lpObj,BUFF_FREEZE) == TRUE ||
; 1116 : 		gObjCheckUsedBuffEffect(lpObj,BUFF_EARTHBINDS) == TRUE )

  00035	6a 39		 push	 57			; 00000039H
  00037	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]
  0003a	56		 push	 esi
  0003b	e8 00 00 00 00	 call	 ?gObjCheckUsedBuffEffect@@YA_NPAUOBJECTSTRUCT@@H@Z ; gObjCheckUsedBuffEffect
  00040	83 c4 08	 add	 esp, 8
  00043	3c 01		 cmp	 al, 1
  00045	0f 84 b7 02 00
	00		 je	 $LN15@gObjMonste
  0004b	6a 3d		 push	 61			; 0000003dH
  0004d	56		 push	 esi
  0004e	e8 00 00 00 00	 call	 ?gObjCheckUsedBuffEffect@@YA_NPAUOBJECTSTRUCT@@H@Z ; gObjCheckUsedBuffEffect
  00053	83 c4 08	 add	 esp, 8
  00056	3c 01		 cmp	 al, 1
  00058	0f 84 a4 02 00
	00		 je	 $LN15@gObjMonste
  0005e	6a 48		 push	 72			; 00000048H
  00060	56		 push	 esi
  00061	e8 00 00 00 00	 call	 ?gObjCheckUsedBuffEffect@@YA_NPAUOBJECTSTRUCT@@H@Z ; gObjCheckUsedBuffEffect
  00066	83 c4 08	 add	 esp, 8
  00069	3c 01		 cmp	 al, 1
  0006b	0f 84 91 02 00
	00		 je	 $LN15@gObjMonste
  00071	68 92 00 00 00	 push	 146			; 00000092H
  00076	56		 push	 esi
  00077	e8 00 00 00 00	 call	 ?gObjCheckUsedBuffEffect@@YA_NPAUOBJECTSTRUCT@@H@Z ; gObjCheckUsedBuffEffect
  0007c	83 c4 08	 add	 esp, 8
  0007f	3c 01		 cmp	 al, 1
  00081	0f 84 7b 02 00
	00		 je	 $LN15@gObjMonste
  00087	68 93 00 00 00	 push	 147			; 00000093H
  0008c	56		 push	 esi
  0008d	e8 00 00 00 00	 call	 ?gObjCheckUsedBuffEffect@@YA_NPAUOBJECTSTRUCT@@H@Z ; gObjCheckUsedBuffEffect
  00092	83 c4 08	 add	 esp, 8
  00095	3c 01		 cmp	 al, 1
  00097	0f 84 65 02 00
	00		 je	 $LN15@gObjMonste

; 1117 : 	{
; 1118 : 		return;
; 1119 : 	}
; 1120 : 
; 1121 : 	int maxmoverange = lpObj->m_MoveRange*2+1;

  0009d	0f bf 86 8e 06
	00 00		 movsx	 eax, WORD PTR [esi+1678]
  000a4	8d 4c 00 01	 lea	 ecx, DWORD PTR [eax+eax+1]
  000a8	89 4d c8	 mov	 DWORD PTR _maxmoverange$[ebp], ecx

; 1122 : 	int searchc=10;

  000ab	c7 45 b8 0a 00
	00 00		 mov	 DWORD PTR _searchc$[ebp], 10 ; 0000000aH

; 1123 : 	BYTE tpx;
; 1124 : 	BYTE tpy;
; 1125 : 
; 1126 : 	BOOL bFindXY = FALSE;

  000b2	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR _bFindXY$[ebp], 0

; 1127 : 	int iTargetX = g_DoubleGoerEvent_DefPts[m_iCurentMap-MAP_INDEX_DOUBLEGOER1].stX;

  000b9	8b 47 30	 mov	 eax, DWORD PTR [edi+48]
  000bc	8d 84 40 3d ff
	ff ff		 lea	 eax, DWORD PTR [eax+eax*2-195]
  000c3	03 c0		 add	 eax, eax
  000c5	03 c0		 add	 eax, eax
  000c7	0f b6 90 00 00
	00 00		 movzx	 edx, BYTE PTR ?g_DoubleGoerEvent_DefPts@@3PAUDOUBLEGOER_DEFPOINTS@@A[eax]
  000ce	89 55 d0	 mov	 DWORD PTR _iTargetX$[ebp], edx

; 1128 : 	int iTargetY = g_DoubleGoerEvent_DefPts[m_iCurentMap-MAP_INDEX_DOUBLEGOER1].stY;

  000d1	0f b6 88 01 00
	00 00		 movzx	 ecx, BYTE PTR ?g_DoubleGoerEvent_DefPts@@3PAUDOUBLEGOER_DEFPOINTS@@A[eax+1]
  000d8	89 4d cc	 mov	 DWORD PTR _iTargetY$[ebp], ecx

; 1129 : 
; 1130 : 	int iTargetDistance = (int)(sqrt( float((lpObj->X - iTargetX)*(lpObj->X - iTargetX)+(lpObj->Y - iTargetY)*(lpObj->Y - iTargetY))));

  000db	0f b6 86 21 01
	00 00		 movzx	 eax, BYTE PTR [esi+289]
  000e2	2b c1		 sub	 eax, ecx
  000e4	0f b6 8e 20 01
	00 00		 movzx	 ecx, BYTE PTR [esi+288]
  000eb	2b ca		 sub	 ecx, edx
  000ed	0f af c9	 imul	 ecx, ecx
  000f0	0f af c0	 imul	 eax, eax
  000f3	03 c8		 add	 ecx, eax
  000f5	89 4d bc	 mov	 DWORD PTR tv607[ebp], ecx
  000f8	db 45 bc	 fild	 DWORD PTR tv607[ebp]
  000fb	d9 5d bc	 fstp	 DWORD PTR $T188867[ebp]
  000fe	d9 45 bc	 fld	 DWORD PTR $T188867[ebp]
  00101	e8 00 00 00 00	 call	 __CIsqrt
  00106	d9 5d bc	 fstp	 DWORD PTR tv602[ebp]
  00109	d9 45 bc	 fld	 DWORD PTR tv602[ebp]
  0010c	e8 00 00 00 00	 call	 __ftol2_sse

; 1131 : 	
; 1132 : 	if ( TMonsterAIElement::s_MonsterAIMovePath[lpObj->MapNumber].m_bDataLoad )

  00111	0f b6 8e 23 01
	00 00		 movzx	 ecx, BYTE PTR [esi+291]
  00118	69 c9 cc 12 00
	00		 imul	 ecx, 4812		; 000012ccH
  0011e	83 b9 04 00 00
	00 00		 cmp	 DWORD PTR ?s_MonsterAIMovePath@TMonsterAIElement@@2PAVTMonsterAIMovePath@@A[ecx+4], 0
  00125	0f 84 04 01 00
	00		 je	 $LN40@gObjMonste

; 1133 : 	{
; 1134 : 		if ( iTargetDistance > 4 )

  0012b	83 f8 04	 cmp	 eax, 4
  0012e	0f 8e fb 00 00
	00		 jle	 $LN40@gObjMonste

; 1135 : 		{
; 1136 : 			int iMinCost = 1000000;

  00134	c7 45 d4 40 42
	0f 00		 mov	 DWORD PTR _iMinCost$184066[ebp], 1000000 ; 000f4240H

; 1137 : 			int iMidX = -1;

  0013b	83 c8 ff	 or	 eax, -1
  0013e	89 45 c0	 mov	 DWORD PTR _iMidX$184067[ebp], eax

; 1138 : 			int iMidY = -1;

  00141	89 45 bc	 mov	 DWORD PTR _iMidY$184068[ebp], eax

; 1135 : 		{
; 1136 : 			int iMinCost = 1000000;

  00144	8d 89 14 00 00
	00		 lea	 ecx, DWORD PTR ?s_MonsterAIMovePath@TMonsterAIElement@@2PAVTMonsterAIMovePath@@A[ecx+20]
  0014a	89 4d e0	 mov	 DWORD PTR tv596[ebp], ecx
  0014d	c7 45 c4 2c 01
	00 00		 mov	 DWORD PTR tv180[ebp], 300 ; 0000012cH
  00154	eb 03		 jmp	 SHORT $LN12@gObjMonste
$LL43@gObjMonste:
  00156	8b 4d e0	 mov	 ecx, DWORD PTR tv596[ebp]
$LN12@gObjMonste:

; 1142 : 			{
; 1143 : 				TMonsterAIMovePathInfo & PathInfo = TMonsterAIElement::s_MonsterAIMovePath[lpObj->MapNumber].m_MovePathInfo[i];
; 1144 : 				float fDistX = (float)(lpObj->X - PathInfo.m_iPathX);

  00159	8b 79 fc	 mov	 edi, DWORD PTR [ecx-4]
  0015c	f7 df		 neg	 edi
  0015e	0f b6 86 20 01
	00 00		 movzx	 eax, BYTE PTR [esi+288]
  00165	8d 14 07	 lea	 edx, DWORD PTR [edi+eax]
  00168	89 55 d8	 mov	 DWORD PTR tv594[ebp], edx
  0016b	db 45 d8	 fild	 DWORD PTR tv594[ebp]
  0016e	d9 5d d8	 fstp	 DWORD PTR _fDistX$184075[ebp]

; 1145 : 				float fDistY = (float)(lpObj->Y - PathInfo.m_iPathY);

  00171	8b 19		 mov	 ebx, DWORD PTR [ecx]
  00173	f7 db		 neg	 ebx
  00175	0f b6 86 21 01
	00 00		 movzx	 eax, BYTE PTR [esi+289]
  0017c	03 c3		 add	 eax, ebx
  0017e	89 45 dc	 mov	 DWORD PTR tv592[ebp], eax
  00181	db 45 dc	 fild	 DWORD PTR tv592[ebp]
  00184	d9 5d dc	 fstp	 DWORD PTR _fDistY$184077[ebp]

; 1146 : 				int iPathSpotDist =  (int)sqrt( (fDistX*fDistX) + (fDistY*fDistY) );

  00187	d9 45 dc	 fld	 DWORD PTR _fDistY$184077[ebp]
  0018a	d9 45 d8	 fld	 DWORD PTR _fDistX$184075[ebp]
  0018d	dc c8		 fmul	 ST(0), ST(0)
  0018f	d9 c1		 fld	 ST(1)
  00191	de ca		 fmulp	 ST(2), ST(0)
  00193	de c1		 faddp	 ST(1), ST(0)
  00195	d9 5d d8	 fstp	 DWORD PTR tv585[ebp]
  00198	d9 45 d8	 fld	 DWORD PTR tv585[ebp]
  0019b	e8 00 00 00 00	 call	 __CIsqrt
  001a0	d9 5d d8	 fstp	 DWORD PTR tv579[ebp]
  001a3	d9 45 d8	 fld	 DWORD PTR tv579[ebp]
  001a6	e8 00 00 00 00	 call	 __ftol2_sse

; 1147 : 
; 1148 : 				if ( iPathSpotDist < 5 )

  001ab	83 f8 05	 cmp	 eax, 5
  001ae	7d 56		 jge	 SHORT $LN11@gObjMonste

; 1149 : 				{
; 1150 : 					fDistX = (float)(iTargetX - PathInfo.m_iPathX);

  001b0	03 7d d0	 add	 edi, DWORD PTR _iTargetX$[ebp]
  001b3	89 7d d8	 mov	 DWORD PTR tv574[ebp], edi
  001b6	db 45 d8	 fild	 DWORD PTR tv574[ebp]
  001b9	d9 5d d8	 fstp	 DWORD PTR _fDistX$184075[ebp]

; 1151 : 					fDistY = (float)(iTargetY - PathInfo.m_iPathY);

  001bc	03 5d cc	 add	 ebx, DWORD PTR _iTargetY$[ebp]
  001bf	89 5d dc	 mov	 DWORD PTR tv573[ebp], ebx
  001c2	db 45 dc	 fild	 DWORD PTR tv573[ebp]
  001c5	d9 5d dc	 fstp	 DWORD PTR _fDistY$184077[ebp]

; 1152 : 					int iMidDist = (int)sqrt( (fDistX*fDistX) + (fDistY*fDistY) );

  001c8	d9 45 dc	 fld	 DWORD PTR _fDistY$184077[ebp]
  001cb	d9 45 d8	 fld	 DWORD PTR _fDistX$184075[ebp]
  001ce	dc c8		 fmul	 ST(0), ST(0)
  001d0	d9 c1		 fld	 ST(1)
  001d2	de ca		 fmulp	 ST(2), ST(0)
  001d4	de c1		 faddp	 ST(1), ST(0)
  001d6	d9 5d d8	 fstp	 DWORD PTR tv566[ebp]
  001d9	d9 45 d8	 fld	 DWORD PTR tv566[ebp]
  001dc	e8 00 00 00 00	 call	 __CIsqrt
  001e1	d9 5d d8	 fstp	 DWORD PTR tv560[ebp]
  001e4	d9 45 d8	 fld	 DWORD PTR tv560[ebp]
  001e7	e8 00 00 00 00	 call	 __ftol2_sse

; 1153 : 
; 1154 : 					if ( iMinCost > iMidDist )

  001ec	39 45 d4	 cmp	 DWORD PTR _iMinCost$184066[ebp], eax
  001ef	7e 15		 jle	 SHORT $LN11@gObjMonste

; 1155 : 					{
; 1156 : 						if ( iMidDist )

  001f1	85 c0		 test	 eax, eax
  001f3	74 11		 je	 SHORT $LN11@gObjMonste

; 1157 : 						{
; 1158 : 							iMinCost = iMidDist;

  001f5	89 45 d4	 mov	 DWORD PTR _iMinCost$184066[ebp], eax

; 1159 : 							iMidX = PathInfo.m_iPathX;

  001f8	8b 45 e0	 mov	 eax, DWORD PTR tv596[ebp]
  001fb	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  001fe	89 4d c0	 mov	 DWORD PTR _iMidX$184067[ebp], ecx

; 1160 : 							iMidY = PathInfo.m_iPathY;

  00201	8b 00		 mov	 eax, DWORD PTR [eax]
  00203	89 45 bc	 mov	 DWORD PTR _iMidY$184068[ebp], eax
$LN11@gObjMonste:

; 1139 : 			int iSpotNum = -1;
; 1140 : 
; 1141 : 			for ( int i=0;i<MAX_MONSTER_AI_MOVE_PATH;i++)

  00206	83 45 e0 10	 add	 DWORD PTR tv596[ebp], 16 ; 00000010H
  0020a	ff 4d c4	 dec	 DWORD PTR tv180[ebp]
  0020d	0f 85 43 ff ff
	ff		 jne	 $LL43@gObjMonste

; 1161 : 							iSpotNum = i;
; 1162 : 						}
; 1163 : 					}
; 1164 : 				}
; 1165 : 			}
; 1166 : 
; 1167 : 			if ( iMinCost != 1000000 )

  00213	81 7d d4 40 42
	0f 00		 cmp	 DWORD PTR _iMinCost$184066[ebp], 1000000 ; 000f4240H
  0021a	74 13		 je	 SHORT $LN40@gObjMonste

; 1168 : 			{
; 1169 : 				iTargetX = iMidX;

  0021c	8b 45 c0	 mov	 eax, DWORD PTR _iMidX$184067[ebp]
  0021f	89 45 d0	 mov	 DWORD PTR _iTargetX$[ebp], eax

; 1170 : 				iTargetY = iMidY;

  00222	8b 4d bc	 mov	 ecx, DWORD PTR _iMidY$184068[ebp]
  00225	89 4d cc	 mov	 DWORD PTR _iTargetY$[ebp], ecx

; 1171 : 				bFindXY = TRUE;

  00228	c7 45 b4 01 00
	00 00		 mov	 DWORD PTR _bFindXY$[ebp], 1
$LN40@gObjMonste:
  0022f	bf fe ff ff ff	 mov	 edi, -2			; fffffffeH
$LL5@gObjMonste:

; 1172 : 			}
; 1173 : 		}
; 1174 : 	}
; 1175 : 
; 1176 : 	while ( searchc-- != 0 )

  00234	8b 45 b8	 mov	 eax, DWORD PTR _searchc$[ebp]
  00237	8b d0		 mov	 edx, eax
  00239	48		 dec	 eax
  0023a	89 45 b8	 mov	 DWORD PTR _searchc$[ebp], eax
  0023d	85 d2		 test	 edx, edx
  0023f	0f 84 bd 00 00
	00		 je	 $LN15@gObjMonste

; 1177 : 	{
; 1178 : 		__try

  00245	9b		 fwait
  00246	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$SEHRec$[ebp+20], 0

; 1179 : 		{
; 1180 : 			if( bFindXY == FALSE )

  0024d	83 7d b4 00	 cmp	 DWORD PTR _bFindXY$[ebp], 0
  00251	75 46		 jne	 SHORT $LN2@gObjMonste

; 1181 : 			{
; 1182 : 				tpx = (lpObj->X - lpObj->m_MoveRange) + (rand()%maxmoverange);

  00253	e8 00 00 00 00	 call	 _rand
  00258	8b 4d c8	 mov	 ecx, DWORD PTR _maxmoverange$[ebp]
  0025b	99		 cdq
  0025c	f7 f9		 idiv	 ecx
  0025e	0f b6 86 20 01
	00 00		 movzx	 eax, BYTE PTR [esi+288]
  00265	03 d0		 add	 edx, eax
  00267	0f bf 8e 8e 06
	00 00		 movsx	 ecx, WORD PTR [esi+1678]
  0026e	2b d1		 sub	 edx, ecx
  00270	88 55 e7	 mov	 BYTE PTR _tpx$[ebp], dl

; 1183 : 				tpy = (lpObj->Y - lpObj->m_MoveRange) + (rand()%maxmoverange);

  00273	e8 00 00 00 00	 call	 _rand
  00278	8b 4d c8	 mov	 ecx, DWORD PTR _maxmoverange$[ebp]
  0027b	99		 cdq
  0027c	f7 f9		 idiv	 ecx
  0027e	0f b6 86 21 01
	00 00		 movzx	 eax, BYTE PTR [esi+289]
  00285	03 d0		 add	 edx, eax
  00287	0f bf 8e 8e 06
	00 00		 movsx	 ecx, WORD PTR [esi+1678]
  0028e	2b d1		 sub	 edx, ecx
  00290	88 55 e6	 mov	 BYTE PTR _tpy$[ebp], dl

; 1189 : 			}
; 1190 : 		}

  00293	9b		 fwait
  00294	89 7d fc	 mov	 DWORD PTR __$SEHRec$[ebp+20], edi
  00297	eb 29		 jmp	 SHORT $LN23@gObjMonste
$LN2@gObjMonste:

; 1184 : 			}
; 1185 : 			else
; 1186 : 			{
; 1187 : 				tpx = iTargetX;

  00299	8a 55 d0	 mov	 dl, BYTE PTR _iTargetX$[ebp]
  0029c	88 55 e7	 mov	 BYTE PTR _tpx$[ebp], dl

; 1188 : 				tpy = iTargetY;

  0029f	8a 45 cc	 mov	 al, BYTE PTR _iTargetY$[ebp]
  002a2	88 45 e6	 mov	 BYTE PTR _tpy$[ebp], al

; 1189 : 			}
; 1190 : 		}

  002a5	9b		 fwait
  002a6	89 7d fc	 mov	 DWORD PTR __$SEHRec$[ebp+20], edi
  002a9	eb 17		 jmp	 SHORT $LN23@gObjMonste
$LN20@gObjMonste:
$LN46@gObjMonste:

; 1191 : 		__except(maxmoverange=1, 1)

  002ab	b8 01 00 00 00	 mov	 eax, 1
  002b0	89 45 c8	 mov	 DWORD PTR _maxmoverange$[ebp], eax
$LN45@gObjMonste:
$LN22@gObjMonste:
  002b3	c3		 ret	 0
$LN21@gObjMonste:
  002b4	8b 65 e8	 mov	 esp, DWORD PTR __$SEHRec$[ebp]

; 1192 : 		{
; 1193 : 
; 1194 : 		}

  002b7	bf fe ff ff ff	 mov	 edi, -2			; fffffffeH
  002bc	89 7d fc	 mov	 DWORD PTR __$SEHRec$[ebp+20], edi
  002bf	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]
$LN23@gObjMonste:

; 1195 : 
; 1196 : 
; 1197 : 		lpObj->TargetNumber = -1;

  002c2	83 c9 ff	 or	 ecx, -1
  002c5	66 89 8e 38 06
	00 00		 mov	 WORD PTR [esi+1592], cx

; 1198 : 		lpObj->m_ActState.Attack = 0;
; 1199 : 		lpObj->NextActionTime = 1500;

  002cc	c7 86 a0 05 00
	00 dc 05 00 00	 mov	 DWORD PTR [esi+1440], 1500 ; 000005dcH

; 1201 : 		lpObj->MTX = tpx;

  002d6	8a 55 e7	 mov	 dl, BYTE PTR _tpx$[ebp]
  002d9	88 96 54 01 00
	00		 mov	 BYTE PTR [esi+340], dl

; 1202 : 		lpObj->MTY = tpy;

  002df	8a 45 e6	 mov	 al, BYTE PTR _tpy$[ebp]
  002e2	88 86 55 01 00
	00		 mov	 BYTE PTR [esi+341], al

; 1200 : 		lpObj->m_ActState.Emotion = 0;

  002e8	8b 8e c8 01 00
	00		 mov	 ecx, DWORD PTR [esi+456]
  002ee	81 e1 0d ff ff
	ff		 and	 ecx, -243		; ffffff0dH

; 1203 : 		lpObj->m_ActState.Move = 1;

  002f4	83 c9 04	 or	 ecx, 4
  002f7	89 8e c8 01 00
	00		 mov	 DWORD PTR [esi+456], ecx

; 1204 : 	}

  002fd	e9 32 ff ff ff	 jmp	 $LL5@gObjMonste
$LN15@gObjMonste:

; 1205 : }

  00302	8b 4d f0	 mov	 ecx, DWORD PTR __$SEHRec$[ebp+8]
  00305	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0030c	59		 pop	 ecx
  0030d	5f		 pop	 edi
  0030e	5e		 pop	 esi
  0030f	5b		 pop	 ebx
  00310	8b e5		 mov	 esp, ebp
  00312	5d		 pop	 ebp
  00313	c2 04 00	 ret	 4
?gObjMonsterMove@CDoubleGoerEvent@@QAEXPAUOBJECTSTRUCT@@@Z ENDP ; CDoubleGoerEvent::gObjMonsterMove
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QAE@V?$allocator@U_st_reward@CDoubleGoerEvent@@@1@@Z ; std::_Vector_val<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >::_Vector_val<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??0?$_Vector_val@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QAE@V?$allocator@U_st_reward@CDoubleGoerEvent@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QAE@V?$allocator@U_st_reward@CDoubleGoerEvent@@@1@@Z PROC ; std::_Vector_val<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >::_Vector_val<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >, COMDAT
; _this$ = ecx

; 426  : 		{	// construct allocator from _Al

  00000	8b c1		 mov	 eax, ecx

; 427  : 		_Myfirst = 0;

  00002	33 c9		 xor	 ecx, ecx
  00004	89 08		 mov	 DWORD PTR [eax], ecx

; 428  : 		_Mylast = 0;

  00006	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 429  : 		_Myend = 0;

  00009	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 430  : 		}

  0000c	c2 04 00	 ret	 4
??0?$_Vector_val@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QAE@V?$allocator@U_st_reward@CDoubleGoerEvent@@@1@@Z ENDP ; std::_Vector_val<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >::_Vector_val<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >
_TEXT	ENDS
PUBLIC	??D?$_Vector_iterator@V?$_Vector_val@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@std@@QBEAAU_st_reward@CDoubleGoerEvent@@XZ ; std::_Vector_iterator<std::_Vector_val<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> > >::operator*
; Function compile flags: /Ogtp
;	COMDAT ??D?$_Vector_iterator@V?$_Vector_val@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@std@@QBEAAU_st_reward@CDoubleGoerEvent@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@V?$_Vector_val@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@std@@QBEAAU_st_reward@CDoubleGoerEvent@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> > >::operator*, COMDAT
; _this$ = ecx

; 322  : 		return ((reference)**(_Mybase *)this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 323  : 		}

  00002	c3		 ret	 0
??D?$_Vector_iterator@V?$_Vector_val@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@std@@QBEAAU_st_reward@CDoubleGoerEvent@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> > >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_iterator@V?$_Vector_val@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<std::_Vector_val<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> > >::operator++
; Function compile flags: /Ogtp
;	COMDAT ??E?$_Vector_iterator@V?$_Vector_val@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_iterator@V?$_Vector_val@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<std::_Vector_val<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> > >::operator++, COMDAT
; _this$ = ecx

; 331  : 		{	// preincrement

  00000	8b c1		 mov	 eax, ecx

; 332  : 		++*(_Mybase *)this;

  00002	83 00 18	 add	 DWORD PTR [eax], 24	; 00000018H

; 333  : 		return (*this);
; 334  : 		}

  00005	c3		 ret	 0
??E?$_Vector_iterator@V?$_Vector_val@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> > >::operator++
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> > >::operator==
; Function compile flags: /Ogtp
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@V?$_Vector_val@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> > >::operator==, COMDAT
; _this$ = ecx

; 201  : 		{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 202  : 		_Compat(_Right);
; 203  : 		return (this->_Ptr == _Right._Ptr);

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00008	33 c9		 xor	 ecx, ecx
  0000a	3b 02		 cmp	 eax, DWORD PTR [edx]
  0000c	0f 94 c0	 sete	 al

; 204  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??8?$_Vector_const_iterator@V?$_Vector_val@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> > >::operator==
_TEXT	ENDS
PUBLIC	?max_size@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QBEIXZ ; std::vector<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >::max_size
; Function compile flags: /Ogtp
;	COMDAT ?max_size@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QBEIXZ PROC ; std::vector<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >::max_size, COMDAT
; _this$ = ecx

; 884  : 		return (this->_Alval.max_size());

  00000	b8 aa aa aa 0a	 mov	 eax, 178956970		; 0aaaaaaaH

; 885  : 		}

  00005	c3		 ret	 0
?max_size@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QBEIXZ ENDP ; std::vector<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >::max_size
_TEXT	ENDS
PUBLIC	?_Grow_to@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@IBEII@Z ; std::vector<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >::_Grow_to
; Function compile flags: /Ogtp
;	COMDAT ?_Grow_to@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@IBEII@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Grow_to@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@IBEII@Z PROC ; std::vector<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >::_Grow_to, COMDAT
; _this$ = ecx

; 1274 : 		{	// grow by 50% or at least to _Count

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1275 : 		size_type _Capacity = capacity();

  00003	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00006	2b 11		 sub	 edx, DWORD PTR [ecx]
  00008	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0000d	f7 ea		 imul	 edx
  0000f	c1 fa 02	 sar	 edx, 2
  00012	8b c2		 mov	 eax, edx
  00014	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00017	03 c2		 add	 eax, edx

; 1276 : 
; 1277 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1278 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00019	8b c8		 mov	 ecx, eax
  0001b	d1 e9		 shr	 ecx, 1
  0001d	ba aa aa aa 0a	 mov	 edx, 178956970		; 0aaaaaaaH
  00022	2b d1		 sub	 edx, ecx
  00024	3b d0		 cmp	 edx, eax
  00026	73 04		 jae	 SHORT $LN4@Grow_to
  00028	33 c0		 xor	 eax, eax
  0002a	eb 02		 jmp	 SHORT $LN5@Grow_to
$LN4@Grow_to:
  0002c	03 c1		 add	 eax, ecx
$LN5@Grow_to:

; 1279 : 		if (_Capacity < _Count)

  0002e	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00031	3b c1		 cmp	 eax, ecx
  00033	73 02		 jae	 SHORT $LN1@Grow_to

; 1280 : 			_Capacity = _Count;
; 1281 : 		return (_Capacity);

  00035	8b c1		 mov	 eax, ecx
$LN1@Grow_to:

; 1282 : 		}

  00037	5d		 pop	 ebp
  00038	c2 04 00	 ret	 4
?_Grow_to@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@IBEII@Z ENDP ; std::vector<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >::_Grow_to
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@std@@QAE@PAU_st_reward@CDoubleGoerEvent@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> > >::_Vector_const_iterator<std::_Vector_val<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> > >
; Function compile flags: /Ogtp
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@std@@QAE@PAU_st_reward@CDoubleGoerEvent@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@std@@QAE@PAU_st_reward@CDoubleGoerEvent@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> > >::_Vector_const_iterator<std::_Vector_val<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> > >, COMDAT
; _this$ = ecx

; 45   : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 46   : 		this->_Adopt(_Pvector);
; 47   : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@std@@QAE@PAU_st_reward@CDoubleGoerEvent@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> > >::_Vector_const_iterator<std::_Vector_val<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> > >
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@U_st_reward@CDoubleGoerEvent@@AAU34@@std@@YAXAAV?$allocator@U_st_reward@CDoubleGoerEvent@@@0@PAU_st_reward@CDoubleGoerEvent@@AAU23@@Z ; std::_Cons_val<std::allocator<CDoubleGoerEvent::_st_reward>,CDoubleGoerEvent::_st_reward,CDoubleGoerEvent::_st_reward &>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Cons_val@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@U_st_reward@CDoubleGoerEvent@@AAU34@@std@@YAXAAV?$allocator@U_st_reward@CDoubleGoerEvent@@@0@PAU_st_reward@CDoubleGoerEvent@@AAU23@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@U_st_reward@CDoubleGoerEvent@@AAU34@@std@@YAXAAV?$allocator@U_st_reward@CDoubleGoerEvent@@@0@PAU_st_reward@CDoubleGoerEvent@@AAU23@@Z PROC ; std::_Cons_val<std::allocator<CDoubleGoerEvent::_st_reward>,CDoubleGoerEvent::_st_reward,CDoubleGoerEvent::_st_reward &>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Pdest$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 25		 je	 SHORT $LN7@Cons_val
  0000a	8b 4d 10	 mov	 ecx, DWORD PTR __Src$[ebp]
  0000d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000f	89 10		 mov	 DWORD PTR [eax], edx
  00011	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00014	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00017	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0001a	89 50 08	 mov	 DWORD PTR [eax+8], edx
  0001d	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00020	89 50 0c	 mov	 DWORD PTR [eax+12], edx
  00023	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00026	89 50 10	 mov	 DWORD PTR [eax+16], edx
  00029	8b 49 14	 mov	 ecx, DWORD PTR [ecx+20]
  0002c	89 48 14	 mov	 DWORD PTR [eax+20], ecx
$LN7@Cons_val:

; 281  : 	}

  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
??$_Cons_val@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@U_st_reward@CDoubleGoerEvent@@AAU34@@std@@YAXAAV?$allocator@U_st_reward@CDoubleGoerEvent@@@0@PAU_st_reward@CDoubleGoerEvent@@AAU23@@Z ENDP ; std::_Cons_val<std::allocator<CDoubleGoerEvent::_st_reward>,CDoubleGoerEvent::_st_reward,CDoubleGoerEvent::_st_reward &>
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??$_Allocate@U_st_reward@CDoubleGoerEvent@@@std@@YAPAU_st_reward@CDoubleGoerEvent@@IPAU12@@Z ; std::_Allocate<CDoubleGoerEvent::_st_reward>
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	__CxxThrowException@8:PROC
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\exception
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ??$_Allocate@U_st_reward@CDoubleGoerEvent@@@std@@YAPAU_st_reward@CDoubleGoerEvent@@IPAU12@@Z
_TEXT	SEGMENT
$T188995 = -12						; size = 12
$T189000 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@U_st_reward@CDoubleGoerEvent@@@std@@YAPAU_st_reward@CDoubleGoerEvent@@IPAU12@@Z PROC ; std::_Allocate<CDoubleGoerEvent::_st_reward>, COMDAT

; 30   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 31   : 	void *_Ptr = 0;
; 32   : 
; 33   : 	if (_Count <= 0)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00009	33 c0		 xor	 eax, eax
  0000b	85 c9		 test	 ecx, ecx

; 34   : 		_Count = 0;
; 35   : 	else if (((_SIZT)(-1) / sizeof (_Ty) < _Count)

  0000d	74 46		 je	 SHORT $LN5@Allocate

; 36   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000f	81 f9 aa aa aa
	0a		 cmp	 ecx, 178956970		; 0aaaaaaaH
  00015	77 16		 ja	 SHORT $LN1@Allocate
  00017	8d 04 49	 lea	 eax, DWORD PTR [ecx+ecx*2]
  0001a	03 c0		 add	 eax, eax
  0001c	03 c0		 add	 eax, eax
  0001e	03 c0		 add	 eax, eax
  00020	50		 push	 eax
  00021	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00026	83 c4 04	 add	 esp, 4
  00029	85 c0		 test	 eax, eax

; 38   : 
; 39   : 	return ((_Ty _FARQ *)_Ptr);

  0002b	75 28		 jne	 SHORT $LN5@Allocate
$LN1@Allocate:

; 37   : 		_THROW_NCEE(bad_alloc, 0);

  0002d	8d 4d 08	 lea	 ecx, DWORD PTR $T189000[ebp]
  00030	51		 push	 ecx
  00031	8d 4d f4	 lea	 ecx, DWORD PTR $T188995[ebp]
  00034	c7 45 08 00 00
	00 00		 mov	 DWORD PTR $T189000[ebp], 0
  0003b	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00040	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00045	8d 55 f4	 lea	 edx, DWORD PTR $T188995[ebp]
  00048	52		 push	 edx
  00049	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T188995[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00050	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN10@Allocate:
$LN5@Allocate:

; 40   : 	}

  00055	8b e5		 mov	 esp, ebp
  00057	5d		 pop	 ebp
  00058	c3		 ret	 0
$LN9@Allocate:
??$_Allocate@U_st_reward@CDoubleGoerEvent@@@std@@YAPAU_st_reward@CDoubleGoerEvent@@IPAU12@@Z ENDP ; std::_Allocate<CDoubleGoerEvent::_st_reward>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  00006	56		 push	 esi
  00007	50		 push	 eax
  00008	8b f1		 mov	 esi, ecx
  0000a	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  0000f	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
  00015	8b c6		 mov	 eax, esi
  00017	5e		 pop	 esi
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	?construct@?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@QAEXPAU_st_reward@CDoubleGoerEvent@@ABU34@@Z ; std::allocator<CDoubleGoerEvent::_st_reward>::construct
; Function compile flags: /Ogtp
;	COMDAT ?construct@?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@QAEXPAU_st_reward@CDoubleGoerEvent@@ABU34@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@QAEXPAU_st_reward@CDoubleGoerEvent@@ABU34@@Z PROC ; std::allocator<CDoubleGoerEvent::_st_reward>::construct, COMDAT
; _this$ = ecx

; 196  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 197  : 		_Construct(_Ptr, _Val);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 25		 je	 SHORT $LN5@construct@2
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0000d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000f	89 10		 mov	 DWORD PTR [eax], edx
  00011	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00014	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00017	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0001a	89 50 08	 mov	 DWORD PTR [eax+8], edx
  0001d	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00020	89 50 0c	 mov	 DWORD PTR [eax+12], edx
  00023	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00026	89 50 10	 mov	 DWORD PTR [eax+16], edx
  00029	8b 49 14	 mov	 ecx, DWORD PTR [ecx+20]
  0002c	89 48 14	 mov	 DWORD PTR [eax+20], ecx
$LN5@construct@2:

; 198  : 		}

  0002f	5d		 pop	 ebp
  00030	c2 08 00	 ret	 8
?construct@?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@QAEXPAU_st_reward@CDoubleGoerEvent@@ABU34@@Z ENDP ; std::allocator<CDoubleGoerEvent::_st_reward>::construct
_TEXT	ENDS
PUBLIC	??$_Move@PAU_st_reward@CDoubleGoerEvent@@PAU12@@std@@YAPAU_st_reward@CDoubleGoerEvent@@PAU12@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Move<CDoubleGoerEvent::_st_reward *,CDoubleGoerEvent::_st_reward *>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??$_Move@PAU_st_reward@CDoubleGoerEvent@@PAU12@@std@@YAPAU_st_reward@CDoubleGoerEvent@@PAU12@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Move@PAU_st_reward@CDoubleGoerEvent@@PAU12@@std@@YAPAU_st_reward@CDoubleGoerEvent@@PAU12@00U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Move<CDoubleGoerEvent::_st_reward *,CDoubleGoerEvent::_st_reward *>, COMDAT

; 2512 : 	{	// move [_First, _Last) to [_Dest, ...), arbitrary iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2513 : 	for (; _First != _Last; ++_Dest, ++_First)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00006	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  00009	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0000c	3b ca		 cmp	 ecx, edx
  0000e	74 2e		 je	 SHORT $LN1@Move
  00010	56		 push	 esi
$LL3@Move:

; 2514 : 		*_Dest = _STD move(*_First);

  00011	8b 31		 mov	 esi, DWORD PTR [ecx]
  00013	89 30		 mov	 DWORD PTR [eax], esi
  00015	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  00018	89 70 04	 mov	 DWORD PTR [eax+4], esi
  0001b	8b 71 08	 mov	 esi, DWORD PTR [ecx+8]
  0001e	89 70 08	 mov	 DWORD PTR [eax+8], esi
  00021	8b 71 0c	 mov	 esi, DWORD PTR [ecx+12]
  00024	89 70 0c	 mov	 DWORD PTR [eax+12], esi
  00027	8b 71 10	 mov	 esi, DWORD PTR [ecx+16]
  0002a	89 70 10	 mov	 DWORD PTR [eax+16], esi
  0002d	8b 71 14	 mov	 esi, DWORD PTR [ecx+20]
  00030	89 70 14	 mov	 DWORD PTR [eax+20], esi
  00033	83 c1 18	 add	 ecx, 24			; 00000018H
  00036	83 c0 18	 add	 eax, 24			; 00000018H
  00039	3b ca		 cmp	 ecx, edx
  0003b	75 d4		 jne	 SHORT $LL3@Move
  0003d	5e		 pop	 esi
$LN1@Move:

; 2515 : 	return (_Dest);
; 2516 : 	}

  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
??$_Move@PAU_st_reward@CDoubleGoerEvent@@PAU12@@std@@YAPAU_st_reward@CDoubleGoerEvent@@PAU12@00U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Move<CDoubleGoerEvent::_st_reward *,CDoubleGoerEvent::_st_reward *>
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@QAEXPAU_st_reward@CDoubleGoerEvent@@@Z ; std::allocator<CDoubleGoerEvent::_st_reward>::destroy
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?destroy@?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@QAEXPAU_st_reward@CDoubleGoerEvent@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@QAEXPAU_st_reward@CDoubleGoerEvent@@@Z PROC ; std::allocator<CDoubleGoerEvent::_st_reward>::destroy, COMDAT
; _this$ = ecx

; 213  : 		_Destroy(_Ptr);
; 214  : 		}

  00000	c2 04 00	 ret	 4
?destroy@?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@QAEXPAU_st_reward@CDoubleGoerEvent@@@Z ENDP ; std::allocator<CDoubleGoerEvent::_st_reward>::destroy
_TEXT	ENDS
PUBLIC	?construct@?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@QAEXPAU_st_reward@CDoubleGoerEvent@@$$QAU34@@Z ; std::allocator<CDoubleGoerEvent::_st_reward>::construct
; Function compile flags: /Ogtp
;	COMDAT ?construct@?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@QAEXPAU_st_reward@CDoubleGoerEvent@@$$QAU34@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@QAEXPAU_st_reward@CDoubleGoerEvent@@$$QAU34@@Z PROC ; std::allocator<CDoubleGoerEvent::_st_reward>::construct, COMDAT
; _this$ = ecx

; 201  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 202  : 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Ty>(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 25		 je	 SHORT $LN3@construct@3
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0000d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000f	89 10		 mov	 DWORD PTR [eax], edx
  00011	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00014	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00017	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0001a	89 50 08	 mov	 DWORD PTR [eax+8], edx
  0001d	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00020	89 50 0c	 mov	 DWORD PTR [eax+12], edx
  00023	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00026	89 50 10	 mov	 DWORD PTR [eax+16], edx
  00029	8b 49 14	 mov	 ecx, DWORD PTR [ecx+20]
  0002c	89 48 14	 mov	 DWORD PTR [eax+20], ecx
$LN3@construct@3:

; 203  : 		}

  0002f	5d		 pop	 ebp
  00030	c2 08 00	 ret	 8
?construct@?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@QAEXPAU_st_reward@CDoubleGoerEvent@@$$QAU34@@Z ENDP ; std::allocator<CDoubleGoerEvent::_st_reward>::construct
_TEXT	ENDS
PUBLIC	??_C@_0FD@FHGNFEO@?$FLDoppelganger?$FN?5Event?5?9?5Fail?5?9?$DO?5M@ ; `string'
PUBLIC	??_C@_0FG@OHFCLCKO@?$FLDoppelganger?$FN?5Event?5?9?5Success?5?9@ ; `string'
PUBLIC	??_C@_0CC@DCCGPFK@?$FLDoppelganger?$FN?5SetState_PLAYEND?$CI@ ; `string'
PUBLIC	?SetState_PLAYEND@CDoubleGoerEvent@@QAEXXZ	; CDoubleGoerEvent::SetState_PLAYEND
;	COMDAT ??_C@_0FD@FHGNFEO@?$FLDoppelganger?$FN?5Event?5?9?5Fail?5?9?$DO?5M@
; File c:\muserver_dev\development\mu-s8ep2-repack\gameserver\source\doublegoerevent.cpp
CONST	SEGMENT
??_C@_0FD@FHGNFEO@?$FLDoppelganger?$FN?5Event?5?9?5Fail?5?9?$DO?5M@ DB '['
	DB	'Doppelganger] Event - Fail -> MonsterPassed: %d, PlayerCount:'
	DB	' %d, LeaderIndex: %d', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0FG@OHFCLCKO@?$FLDoppelganger?$FN?5Event?5?9?5Success?5?9@
CONST	SEGMENT
??_C@_0FG@OHFCLCKO@?$FLDoppelganger?$FN?5Event?5?9?5Success?5?9@ DB '[Dop'
	DB	'pelganger] Event - Success -> MonsterPassed: %d, PlayerCount:'
	DB	' %d, LeaderIndex: %d', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@DCCGPFK@?$FLDoppelganger?$FN?5SetState_PLAYEND?$CI@
CONST	SEGMENT
??_C@_0CC@DCCGPFK@?$FLDoppelganger?$FN?5SetState_PLAYEND?$CI@ DB '[Doppel'
	DB	'ganger] SetState_PLAYEND()', 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?SetState_PLAYEND@CDoubleGoerEvent@@QAEXXZ
_TEXT	SEGMENT
_pMsg$ = -8						; size = 5
?SetState_PLAYEND@CDoubleGoerEvent@@QAEXXZ PROC		; CDoubleGoerEvent::SetState_PLAYEND, COMDAT
; _this$ = ecx

; 631  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi

; 632  : 	LogAddTD("[Doppelganger] SetState_PLAYEND()");

  00007	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@DCCGPFK@?$FLDoppelganger?$FN?5SetState_PLAYEND?$CI@
  0000c	8b f1		 mov	 esi, ecx
  0000e	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 633  : 	m_iREMAIN_TIME = m_iEVENT_PLAYEND*60*1000;

  00014	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  00017	69 c0 60 ea 00
	00		 imul	 eax, 60000		; 0000ea60H
  0001d	83 c4 04	 add	 esp, 4
  00020	89 46 28	 mov	 DWORD PTR [esi+40], eax

; 634  : 	m_dwTICK_COUNT = GetTickCount();

  00023	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0

; 635  : 
; 636  : 	RemoveMonster();

  00029	8b ce		 mov	 ecx, esi
  0002b	89 46 2c	 mov	 DWORD PTR [esi+44], eax
  0002e	e8 00 00 00 00	 call	 ?RemoveMonster@CDoubleGoerEvent@@QAEXXZ ; CDoubleGoerEvent::RemoveMonster

; 637  : 
; 638  : 	PMSG_DOUBLEGOER_EVENTEND pMsg;
; 639  : 	PHeadSubSetB((LPBYTE)&pMsg,0xBF,19,sizeof(pMsg));

  00033	6a 05		 push	 5
  00035	6a 13		 push	 19			; 00000013H
  00037	8d 4d f8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  0003a	68 bf 00 00 00	 push	 191			; 000000bfH
  0003f	51		 push	 ecx
  00040	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 640  : 
; 641  : 	if(  m_iMonsterPassed < 3 && m_iPlayerCount > 0  && m_iLeaderIndex != -1 )

  00045	8b 46 38	 mov	 eax, DWORD PTR [esi+56]
  00048	83 c4 10	 add	 esp, 16			; 00000010H
  0004b	83 f8 03	 cmp	 eax, 3
  0004e	0f 8d a7 00 00
	00		 jge	 $LN2@SetState_P
  00054	83 7e 34 00	 cmp	 DWORD PTR [esi+52], 0
  00058	0f 8e 9d 00 00
	00		 jle	 $LN2@SetState_P
  0005e	83 be 80 00 00
	00 ff		 cmp	 DWORD PTR [esi+128], -1
  00065	0f 84 90 00 00
	00		 je	 $LN2@SetState_P

; 642  : 	{
; 643  : #ifdef POINTEX
; 644  : 		for(int i = 0; i < DOUBLEGOER_MAXPLAYER; i++)
; 645  : 		{
; 646  : 			int aIndex = m_PlayerInfo[i].aIndex;
; 647  : 			if(  OBJMAX_RANGE(aIndex) )
; 648  : 			{
; 649  : 				g_ShopPointEx.AddEventBonus(aIndex, ShopPointExEvent::DG);
; 650  : 			}
; 651  : 		}
; 652  : #endif
; 653  : 		
; 654  : 
; 655  : 		SummonMonster(542,m_iCurentMap,gObj[m_iLeaderIndex].X+(-1+rand()%3),gObj[m_iLeaderIndex].Y+(-1+rand()%3),m_EventLevel, m_EventReset);

  0006b	8b 96 58 02 00
	00		 mov	 edx, DWORD PTR [esi+600]
  00071	8b 86 5c 02 00
	00		 mov	 eax, DWORD PTR [esi+604]
  00077	52		 push	 edx
  00078	50		 push	 eax
  00079	e8 00 00 00 00	 call	 _rand
  0007e	99		 cdq
  0007f	b9 03 00 00 00	 mov	 ecx, 3
  00084	f7 f9		 idiv	 ecx
  00086	8b 86 80 00 00
	00		 mov	 eax, DWORD PTR [esi+128]
  0008c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00092	69 c0 40 27 00
	00		 imul	 eax, 10048		; 00002740H
  00098	0f b6 84 08 21
	01 00 00	 movzx	 eax, BYTE PTR [eax+ecx+289]
  000a0	8d 4c 02 ff	 lea	 ecx, DWORD PTR [edx+eax-1]
  000a4	51		 push	 ecx
  000a5	e8 00 00 00 00	 call	 _rand
  000aa	99		 cdq
  000ab	b9 03 00 00 00	 mov	 ecx, 3
  000b0	f7 f9		 idiv	 ecx
  000b2	8b 86 80 00 00
	00		 mov	 eax, DWORD PTR [esi+128]
  000b8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000be	69 c0 40 27 00
	00		 imul	 eax, 10048		; 00002740H
  000c4	0f b6 84 08 20
	01 00 00	 movzx	 eax, BYTE PTR [eax+ecx+288]
  000cc	8d 4c 02 ff	 lea	 ecx, DWORD PTR [edx+eax-1]
  000d0	8b 56 30	 mov	 edx, DWORD PTR [esi+48]
  000d3	51		 push	 ecx
  000d4	52		 push	 edx
  000d5	68 1e 02 00 00	 push	 542			; 0000021eH
  000da	8b ce		 mov	 ecx, esi
  000dc	e8 00 00 00 00	 call	 ?SummonMonster@CDoubleGoerEvent@@QAEHHHHHHH@Z ; CDoubleGoerEvent::SummonMonster

; 656  : 		pMsg.btResult = 0;
; 657  : 
; 658  : 		LogAddTD("[Doppelganger] Event - Success -> MonsterPassed: %d, PlayerCount: %d, LeaderIndex: %d",
; 659  : 			m_iMonsterPassed,m_iPlayerCount,m_iLeaderIndex);

  000e1	8b 86 80 00 00
	00		 mov	 eax, DWORD PTR [esi+128]
  000e7	8b 4e 34	 mov	 ecx, DWORD PTR [esi+52]
  000ea	8b 56 38	 mov	 edx, DWORD PTR [esi+56]
  000ed	50		 push	 eax
  000ee	51		 push	 ecx
  000ef	52		 push	 edx
  000f0	c6 45 fc 00	 mov	 BYTE PTR _pMsg$[ebp+4], 0
  000f4	68 00 00 00 00	 push	 OFFSET ??_C@_0FG@OHFCLCKO@?$FLDoppelganger?$FN?5Event?5?9?5Success?5?9@

; 660  : 	}
; 661  : 	else

  000f9	eb 15		 jmp	 SHORT $LN5@SetState_P
$LN2@SetState_P:

; 662  : 	{
; 663  : 		pMsg.btResult = 2;
; 664  : 		LogAddTD("[Doppelganger] Event - Fail -> MonsterPassed: %d, PlayerCount: %d, LeaderIndex: %d",
; 665  : 			m_iMonsterPassed,m_iPlayerCount,m_iLeaderIndex);

  000fb	8b 8e 80 00 00
	00		 mov	 ecx, DWORD PTR [esi+128]
  00101	8b 56 34	 mov	 edx, DWORD PTR [esi+52]
  00104	51		 push	 ecx
  00105	52		 push	 edx
  00106	50		 push	 eax
  00107	c6 45 fc 02	 mov	 BYTE PTR _pMsg$[ebp+4], 2
  0010b	68 00 00 00 00	 push	 OFFSET ??_C@_0FD@FHGNFEO@?$FLDoppelganger?$FN?5Event?5?9?5Fail?5?9?$DO?5M@
$LN5@SetState_P:
  00110	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 666  : 	}
; 667  : 
; 668  : 	SendData((LPBYTE)&pMsg,pMsg.h.size);

  00116	0f b6 45 f9	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  0011a	83 c4 10	 add	 esp, 16			; 00000010H
  0011d	50		 push	 eax
  0011e	8d 4d f8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00121	51		 push	 ecx
  00122	8b ce		 mov	 ecx, esi
  00124	e8 00 00 00 00	 call	 ?SendData@CDoubleGoerEvent@@QAEXPAEH@Z ; CDoubleGoerEvent::SendData
  00129	5e		 pop	 esi

; 669  : }

  0012a	8b e5		 mov	 esp, ebp
  0012c	5d		 pop	 ebp
  0012d	c3		 ret	 0
?SetState_PLAYEND@CDoubleGoerEvent@@QAEXXZ ENDP		; CDoubleGoerEvent::SetState_PLAYEND
_TEXT	ENDS
PUBLIC	?SendBossInfo@CDoubleGoerEvent@@QAEXH@Z		; CDoubleGoerEvent::SendBossInfo
; Function compile flags: /Ogtp
;	COMDAT ?SendBossInfo@CDoubleGoerEvent@@QAEXH@Z
_TEXT	SEGMENT
_pMsg$ = -12						; size = 6
tv204 = -4						; size = 4
tv202 = -4						; size = 4
tv210 = 8						; size = 4
_iBossIndex$ = 8					; size = 4
tv207 = 10						; size = 2
?SendBossInfo@CDoubleGoerEvent@@QAEXH@Z PROC		; CDoubleGoerEvent::SendBossInfo, COMDAT
; _this$ = ecx

; 847  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi
  00007	57		 push	 edi

; 848  : 	if( !OBJMAX_RANGE(iBossIndex) )

  00008	8b 7d 08	 mov	 edi, DWORD PTR _iBossIndex$[ebp]
  0000b	8b f1		 mov	 esi, ecx
  0000d	85 ff		 test	 edi, edi
  0000f	0f 88 b5 00 00
	00		 js	 $LN3@SendBossIn
  00015	33 c0		 xor	 eax, eax
  00017	81 ff eb 2c 00
	00		 cmp	 edi, 11499		; 00002cebH
  0001d	0f 9e c0	 setle	 al
  00020	85 c0		 test	 eax, eax
  00022	0f 84 a2 00 00
	00		 je	 $LN3@SendBossIn

; 849  : 		return;
; 850  : 
; 851  : 	PMSG_DOUBLEGOER_BOSSINFO pMsg;
; 852  : 	PHeadSubSetB((LPBYTE)&pMsg,0xBF,17,sizeof(pMsg));

  00028	6a 06		 push	 6
  0002a	6a 11		 push	 17			; 00000011H
  0002c	8d 45 f4	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0002f	68 bf 00 00 00	 push	 191			; 000000bfH
  00034	50		 push	 eax
  00035	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 853  : 
; 854  : 	if( !gObj[iBossIndex].Live )
; 855  : 		pMsg.btResult = 1;
; 856  : 
; 857  : 	pMsg.btResult = 0;
; 858  : 	pMsg.btPos = (BYTE)(CalcDistance(gObj[iBossIndex].X,gObj[iBossIndex].Y,g_DoubleGoerEvent_DefPts[m_iCurentMap-MAP_INDEX_DOUBLEGOER1].ptX,g_DoubleGoerEvent_DefPts[m_iCurentMap-MAP_INDEX_DOUBLEGOER1].ptY)/g_DoubleGoerEvent_DefPts[m_iCurentMap-MAP_INDEX_DOUBLEGOER1].distDiv);

  0003a	69 ff 40 27 00
	00		 imul	 edi, 10048		; 00002740H
  00040	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  00043	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00049	8d 84 40 3d ff
	ff ff		 lea	 eax, DWORD PTR [eax+eax*2-195]
  00050	03 c0		 add	 eax, eax
  00052	0f b6 94 00 03
	00 00 00	 movzx	 edx, BYTE PTR ?g_DoubleGoerEvent_DefPts@@3PAUDOUBLEGOER_DEFPOINTS@@A[eax+eax+3]
  0005a	03 c0		 add	 eax, eax
  0005c	0f b6 80 02 00
	00 00		 movzx	 eax, BYTE PTR ?g_DoubleGoerEvent_DefPts@@3PAUDOUBLEGOER_DEFPOINTS@@A[eax+2]
  00063	83 c4 10	 add	 esp, 16			; 00000010H
  00066	52		 push	 edx
  00067	c6 45 f8 00	 mov	 BYTE PTR _pMsg$[ebp+4], 0
  0006b	0f b6 94 39 21
	01 00 00	 movzx	 edx, BYTE PTR [ecx+edi+289]
  00073	50		 push	 eax
  00074	0f b6 84 39 20
	01 00 00	 movzx	 eax, BYTE PTR [ecx+edi+288]
  0007c	52		 push	 edx
  0007d	50		 push	 eax
  0007e	8b ce		 mov	 ecx, esi
  00080	e8 00 00 00 00	 call	 ?CalcDistance@CDoubleGoerEvent@@QAEHHHHH@Z ; CDoubleGoerEvent::CalcDistance
  00085	89 45 08	 mov	 DWORD PTR tv210[ebp], eax
  00088	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  0008b	db 45 08	 fild	 DWORD PTR tv210[ebp]
  0008e	8d 8c 40 3d ff
	ff ff		 lea	 ecx, DWORD PTR [eax+eax*2-195]
  00095	d9 7d 0a	 fnstcw	 WORD PTR tv207[ebp]
  00098	0f b7 45 0a	 movzx	 eax, WORD PTR tv207[ebp]
  0009c	d8 34 8d 04 00
	00 00		 fdiv	 DWORD PTR ?g_DoubleGoerEvent_DefPts@@3PAUDOUBLEGOER_DEFPOINTS@@A[ecx*4+4]
  000a3	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  000a8	89 45 fc	 mov	 DWORD PTR tv204[ebp], eax

; 859  : 
; 860  : 	SendData((LPBYTE)&pMsg,pMsg.h.size);

  000ab	0f b6 45 f5	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  000af	50		 push	 eax
  000b0	8d 4d f4	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  000b3	51		 push	 ecx
  000b4	8b ce		 mov	 ecx, esi
  000b6	d9 6d fc	 fldcw	 WORD PTR tv204[ebp]
  000b9	db 5d fc	 fistp	 DWORD PTR tv202[ebp]
  000bc	8a 55 fc	 mov	 dl, BYTE PTR tv202[ebp]
  000bf	88 55 f9	 mov	 BYTE PTR _pMsg$[ebp+5], dl
  000c2	d9 6d 0a	 fldcw	 WORD PTR tv207[ebp]
  000c5	e8 00 00 00 00	 call	 ?SendData@CDoubleGoerEvent@@QAEXPAEH@Z ; CDoubleGoerEvent::SendData
$LN3@SendBossIn:
  000ca	5f		 pop	 edi
  000cb	5e		 pop	 esi

; 861  : }

  000cc	8b e5		 mov	 esp, ebp
  000ce	5d		 pop	 ebp
  000cf	c2 04 00	 ret	 4
?SendBossInfo@CDoubleGoerEvent@@QAEXH@Z ENDP		; CDoubleGoerEvent::SendBossInfo
_TEXT	ENDS
PUBLIC	?SummonMonster@CDoubleGoerEvent@@QAEXXZ		; CDoubleGoerEvent::SummonMonster
EXTRN	?gParty@@3VPartyClass@@A:BYTE			; gParty
; Function compile flags: /Ogtp
;	COMDAT ?SummonMonster@CDoubleGoerEvent@@QAEXXZ
_TEXT	SEGMENT
?SummonMonster@CDoubleGoerEvent@@QAEXXZ PROC		; CDoubleGoerEvent::SummonMonster, COMDAT
; _this$ = ecx

; 925  : {

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	8b f1		 mov	 esi, ecx

; 926  : 	int result = -1;
; 927  : 
; 928  : 	if( !OBJMAX_RANGE(m_iLeaderIndex) )

  00004	8b 86 80 00 00
	00		 mov	 eax, DWORD PTR [esi+128]
  0000a	33 db		 xor	 ebx, ebx
  0000c	3b c3		 cmp	 eax, ebx
  0000e	0f 8c 00 02 00
	00		 jl	 $LN1@SummonMons@2
  00014	33 c9		 xor	 ecx, ecx
  00016	3d eb 2c 00 00	 cmp	 eax, 11499		; 00002cebH
  0001b	0f 9e c1	 setle	 cl
  0001e	3b cb		 cmp	 ecx, ebx
  00020	0f 84 ee 01 00
	00		 je	 $LN1@SummonMons@2

; 929  : 	{
; 930  : 		return;
; 931  : 	}
; 932  : 
; 933  : 	LPOBJ lpObj = &gObj[m_iLeaderIndex];

  00026	69 c0 40 27 00
	00		 imul	 eax, 10048		; 00002740H
  0002c	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 934  : 	m_iPartyCount = 1;

  00032	c7 86 84 00 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+132], 1
  0003c	8b d0		 mov	 edx, eax

; 935  : 
; 936  : 	int MaxLevel = 0;
; 937  : 	int MaxReset = 0;
; 938  : 
; 939  : 	if( lpObj->PartyNumber >= 0 )

  0003e	8b 8a 0c 06 00
	00		 mov	 ecx, DWORD PTR [edx+1548]
  00044	33 c0		 xor	 eax, eax
  00046	57		 push	 edi
  00047	3b cb		 cmp	 ecx, ebx
  00049	0f 8c 3f 01 00
	00		 jl	 $LN11@SummonMons@2

; 940  : 	{
; 941  : 		int PartyNum = lpObj->PartyNumber;
; 942  : 		m_iPartyCount = 0;
; 943  : 
; 944  : 		for(int i = 0; i < MAX_USER_IN_PARTY; i++)
; 945  : 		{
; 946  : 			int number = gParty.m_PartyS[PartyNum].Number[i];

  0004f	8b f9		 mov	 edi, ecx
  00051	c1 e7 04	 shl	 edi, 4
  00054	2b f9		 sub	 edi, ecx
  00056	03 ff		 add	 edi, edi
  00058	03 ff		 add	 edi, edi
  0005a	89 9e 84 00 00
	00		 mov	 DWORD PTR [esi+132], ebx
  00060	8b 8f 0c 00 00
	00		 mov	 ecx, DWORD PTR ?gParty@@3VPartyClass@@A[edi+12]

; 947  : 
; 948  : 			if( number >= 0 )

  00066	85 c9		 test	 ecx, ecx
  00068	78 32		 js	 SHORT $LN9@SummonMons@2

; 949  : 			{
; 950  : 				if( gObj[number].Level > MaxLevel )

  0006a	69 c9 40 27 00
	00		 imul	 ecx, 10048		; 00002740H
  00070	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00076	0f bf 91 96 00
	00 00		 movsx	 edx, WORD PTR [ecx+150]
  0007d	85 d2		 test	 edx, edx
  0007f	7e 09		 jle	 SHORT $LN6@SummonMons@2

; 951  : 				{
; 952  : 					MaxLevel = gObj[number].Level + gObj[number].MasterLevel;

  00081	0f bf 81 a8 00
	00 00		 movsx	 eax, WORD PTR [ecx+168]
  00088	03 c2		 add	 eax, edx
$LN6@SummonMons@2:

; 953  : 				}
; 954  : 
; 955  : 				if( gObj[number].iResetCount > MaxReset )

  0008a	8b 89 20 27 00
	00		 mov	 ecx, DWORD PTR [ecx+10016]
  00090	85 c9		 test	 ecx, ecx
  00092	7e 02		 jle	 SHORT $LN5@SummonMons@2

; 956  : 				{
; 957  : 					MaxReset = gObj[number].iResetCount;

  00094	8b d9		 mov	 ebx, ecx
$LN5@SummonMons@2:

; 958  : 				}
; 959  : 				m_iPartyCount++;

  00096	ff 86 84 00 00
	00		 inc	 DWORD PTR [esi+132]
$LN9@SummonMons@2:

; 940  : 	{
; 941  : 		int PartyNum = lpObj->PartyNumber;
; 942  : 		m_iPartyCount = 0;
; 943  : 
; 944  : 		for(int i = 0; i < MAX_USER_IN_PARTY; i++)
; 945  : 		{
; 946  : 			int number = gParty.m_PartyS[PartyNum].Number[i];

  0009c	8b 8f 10 00 00
	00		 mov	 ecx, DWORD PTR ?gParty@@3VPartyClass@@A[edi+16]

; 947  : 
; 948  : 			if( number >= 0 )

  000a2	85 c9		 test	 ecx, ecx
  000a4	78 32		 js	 SHORT $LN29@SummonMons@2

; 949  : 			{
; 950  : 				if( gObj[number].Level > MaxLevel )

  000a6	69 c9 40 27 00
	00		 imul	 ecx, 10048		; 00002740H
  000ac	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000b2	0f bf 91 96 00
	00 00		 movsx	 edx, WORD PTR [ecx+150]
  000b9	3b d0		 cmp	 edx, eax
  000bb	7e 09		 jle	 SHORT $LN27@SummonMons@2

; 951  : 				{
; 952  : 					MaxLevel = gObj[number].Level + gObj[number].MasterLevel;

  000bd	0f bf 81 a8 00
	00 00		 movsx	 eax, WORD PTR [ecx+168]
  000c4	03 c2		 add	 eax, edx
$LN27@SummonMons@2:

; 953  : 				}
; 954  : 
; 955  : 				if( gObj[number].iResetCount > MaxReset )

  000c6	8b 89 20 27 00
	00		 mov	 ecx, DWORD PTR [ecx+10016]
  000cc	3b cb		 cmp	 ecx, ebx
  000ce	7e 02		 jle	 SHORT $LN28@SummonMons@2

; 956  : 				{
; 957  : 					MaxReset = gObj[number].iResetCount;

  000d0	8b d9		 mov	 ebx, ecx
$LN28@SummonMons@2:

; 958  : 				}
; 959  : 				m_iPartyCount++;

  000d2	ff 86 84 00 00
	00		 inc	 DWORD PTR [esi+132]
$LN29@SummonMons@2:

; 940  : 	{
; 941  : 		int PartyNum = lpObj->PartyNumber;
; 942  : 		m_iPartyCount = 0;
; 943  : 
; 944  : 		for(int i = 0; i < MAX_USER_IN_PARTY; i++)
; 945  : 		{
; 946  : 			int number = gParty.m_PartyS[PartyNum].Number[i];

  000d8	8b 8f 14 00 00
	00		 mov	 ecx, DWORD PTR ?gParty@@3VPartyClass@@A[edi+20]

; 947  : 
; 948  : 			if( number >= 0 )

  000de	85 c9		 test	 ecx, ecx
  000e0	78 32		 js	 SHORT $LN33@SummonMons@2

; 949  : 			{
; 950  : 				if( gObj[number].Level > MaxLevel )

  000e2	69 c9 40 27 00
	00		 imul	 ecx, 10048		; 00002740H
  000e8	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000ee	0f bf 91 96 00
	00 00		 movsx	 edx, WORD PTR [ecx+150]
  000f5	3b d0		 cmp	 edx, eax
  000f7	7e 09		 jle	 SHORT $LN31@SummonMons@2

; 951  : 				{
; 952  : 					MaxLevel = gObj[number].Level + gObj[number].MasterLevel;

  000f9	0f bf 81 a8 00
	00 00		 movsx	 eax, WORD PTR [ecx+168]
  00100	03 c2		 add	 eax, edx
$LN31@SummonMons@2:

; 953  : 				}
; 954  : 
; 955  : 				if( gObj[number].iResetCount > MaxReset )

  00102	8b 89 20 27 00
	00		 mov	 ecx, DWORD PTR [ecx+10016]
  00108	3b cb		 cmp	 ecx, ebx
  0010a	7e 02		 jle	 SHORT $LN32@SummonMons@2

; 956  : 				{
; 957  : 					MaxReset = gObj[number].iResetCount;

  0010c	8b d9		 mov	 ebx, ecx
$LN32@SummonMons@2:

; 958  : 				}
; 959  : 				m_iPartyCount++;

  0010e	ff 86 84 00 00
	00		 inc	 DWORD PTR [esi+132]
$LN33@SummonMons@2:

; 940  : 	{
; 941  : 		int PartyNum = lpObj->PartyNumber;
; 942  : 		m_iPartyCount = 0;
; 943  : 
; 944  : 		for(int i = 0; i < MAX_USER_IN_PARTY; i++)
; 945  : 		{
; 946  : 			int number = gParty.m_PartyS[PartyNum].Number[i];

  00114	8b 8f 18 00 00
	00		 mov	 ecx, DWORD PTR ?gParty@@3VPartyClass@@A[edi+24]

; 947  : 
; 948  : 			if( number >= 0 )

  0011a	85 c9		 test	 ecx, ecx
  0011c	78 32		 js	 SHORT $LN37@SummonMons@2

; 949  : 			{
; 950  : 				if( gObj[number].Level > MaxLevel )

  0011e	69 c9 40 27 00
	00		 imul	 ecx, 10048		; 00002740H
  00124	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0012a	0f bf 91 96 00
	00 00		 movsx	 edx, WORD PTR [ecx+150]
  00131	3b d0		 cmp	 edx, eax
  00133	7e 09		 jle	 SHORT $LN35@SummonMons@2

; 951  : 				{
; 952  : 					MaxLevel = gObj[number].Level + gObj[number].MasterLevel;

  00135	0f bf 81 a8 00
	00 00		 movsx	 eax, WORD PTR [ecx+168]
  0013c	03 c2		 add	 eax, edx
$LN35@SummonMons@2:

; 953  : 				}
; 954  : 
; 955  : 				if( gObj[number].iResetCount > MaxReset )

  0013e	8b 89 20 27 00
	00		 mov	 ecx, DWORD PTR [ecx+10016]
  00144	3b cb		 cmp	 ecx, ebx
  00146	7e 02		 jle	 SHORT $LN36@SummonMons@2

; 956  : 				{
; 957  : 					MaxReset = gObj[number].iResetCount;

  00148	8b d9		 mov	 ebx, ecx
$LN36@SummonMons@2:

; 958  : 				}
; 959  : 				m_iPartyCount++;

  0014a	ff 86 84 00 00
	00		 inc	 DWORD PTR [esi+132]
$LN37@SummonMons@2:

; 940  : 	{
; 941  : 		int PartyNum = lpObj->PartyNumber;
; 942  : 		m_iPartyCount = 0;
; 943  : 
; 944  : 		for(int i = 0; i < MAX_USER_IN_PARTY; i++)
; 945  : 		{
; 946  : 			int number = gParty.m_PartyS[PartyNum].Number[i];

  00150	8b 8f 1c 00 00
	00		 mov	 ecx, DWORD PTR ?gParty@@3VPartyClass@@A[edi+28]

; 947  : 
; 948  : 			if( number >= 0 )

  00156	85 c9		 test	 ecx, ecx
  00158	78 4a		 js	 SHORT $LN42@SummonMons@2

; 949  : 			{
; 950  : 				if( gObj[number].Level > MaxLevel )

  0015a	69 c9 40 27 00
	00		 imul	 ecx, 10048		; 00002740H
  00160	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00166	0f bf 91 96 00
	00 00		 movsx	 edx, WORD PTR [ecx+150]
  0016d	3b d0		 cmp	 edx, eax
  0016f	7e 09		 jle	 SHORT $LN39@SummonMons@2

; 951  : 				{
; 952  : 					MaxLevel = gObj[number].Level + gObj[number].MasterLevel;

  00171	0f bf 81 a8 00
	00 00		 movsx	 eax, WORD PTR [ecx+168]
  00178	03 c2		 add	 eax, edx
$LN39@SummonMons@2:

; 953  : 				}
; 954  : 
; 955  : 				if( gObj[number].iResetCount > MaxReset )

  0017a	8b 89 20 27 00
	00		 mov	 ecx, DWORD PTR [ecx+10016]
  00180	3b cb		 cmp	 ecx, ebx
  00182	7e 02		 jle	 SHORT $LN40@SummonMons@2

; 956  : 				{
; 957  : 					MaxReset = gObj[number].iResetCount;

  00184	8b d9		 mov	 ebx, ecx
$LN40@SummonMons@2:

; 958  : 				}
; 959  : 				m_iPartyCount++;

  00186	ff 86 84 00 00
	00		 inc	 DWORD PTR [esi+132]

; 960  : 			}
; 961  : 		}
; 962  : 	}
; 963  : 	else

  0018c	eb 16		 jmp	 SHORT $LN42@SummonMons@2
$LN11@SummonMons@2:

; 964  : 	{
; 965  : 		MaxLevel = lpObj->Level + lpObj->MasterLevel;

  0018e	0f bf 82 a8 00
	00 00		 movsx	 eax, WORD PTR [edx+168]
  00195	0f bf 8a 96 00
	00 00		 movsx	 ecx, WORD PTR [edx+150]

; 966  : 		MaxReset = lpObj->iResetCount;

  0019c	8b 9a 20 27 00
	00		 mov	 ebx, DWORD PTR [edx+10016]
  001a2	03 c1		 add	 eax, ecx
$LN42@SummonMons@2:

; 967  : 	}
; 968  : 
; 969  : 	m_EventLevel = MaxLevel;
; 970  : 	m_EventReset = MaxReset;

  001a4	89 9e 58 02 00
	00		 mov	 DWORD PTR [esi+600], ebx

; 971  : 
; 972  : 	int mapIndex = m_iCurentMap-MAP_INDEX_DOUBLEGOER1;
; 973  : 
; 974  : 	for(int i = 0; i < m_iMONSTER_COUNT; i++)

  001aa	33 db		 xor	 ebx, ebx
  001ac	89 86 5c 02 00
	00		 mov	 DWORD PTR [esi+604], eax
  001b2	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  001b5	39 5e 1c	 cmp	 DWORD PTR [esi+28], ebx
  001b8	7e 59		 jle	 SHORT $LN43@SummonMons@2
  001ba	8d bc 40 3d ff
	ff ff		 lea	 edi, DWORD PTR [eax+eax*2-195]
  001c1	03 ff		 add	 edi, edi
  001c3	03 ff		 add	 edi, edi
  001c5	eb 09 8d a4 24
	00 00 00 00 8b
	ff		 npad	 11
$LL3@SummonMons@2:

; 975  : 	{
; 976  : 
; 977  : 		int sx = g_DoubleGoerEvent_DefPts[mapIndex].ptX;
; 978  : 		int sy = g_DoubleGoerEvent_DefPts[mapIndex].ptY;
; 979  : 
; 980  : 		SummonMonster(533+rand()%7,m_iCurentMap,sx,sy,m_EventLevel, m_EventReset);

  001d0	8b 96 58 02 00
	00		 mov	 edx, DWORD PTR [esi+600]
  001d6	0f b6 8f 03 00
	00 00		 movzx	 ecx, BYTE PTR ?g_DoubleGoerEvent_DefPts@@3PAUDOUBLEGOER_DEFPOINTS@@A[edi+3]
  001dd	0f b6 87 02 00
	00 00		 movzx	 eax, BYTE PTR ?g_DoubleGoerEvent_DefPts@@3PAUDOUBLEGOER_DEFPOINTS@@A[edi+2]
  001e4	52		 push	 edx
  001e5	8b 96 5c 02 00
	00		 mov	 edx, DWORD PTR [esi+604]
  001eb	52		 push	 edx
  001ec	51		 push	 ecx
  001ed	50		 push	 eax
  001ee	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  001f1	50		 push	 eax
  001f2	e8 00 00 00 00	 call	 _rand
  001f7	99		 cdq
  001f8	b9 07 00 00 00	 mov	 ecx, 7
  001fd	f7 f9		 idiv	 ecx
  001ff	8b ce		 mov	 ecx, esi
  00201	81 c2 15 02 00
	00		 add	 edx, 533		; 00000215H
  00207	52		 push	 edx
  00208	e8 00 00 00 00	 call	 ?SummonMonster@CDoubleGoerEvent@@QAEHHHHHHH@Z ; CDoubleGoerEvent::SummonMonster
  0020d	43		 inc	 ebx
  0020e	3b 5e 1c	 cmp	 ebx, DWORD PTR [esi+28]
  00211	7c bd		 jl	 SHORT $LL3@SummonMons@2
$LN43@SummonMons@2:
  00213	5f		 pop	 edi
$LN1@SummonMons@2:
  00214	5e		 pop	 esi
  00215	5b		 pop	 ebx

; 981  : 	}
; 982  : }

  00216	c3		 ret	 0
?SummonMonster@CDoubleGoerEvent@@QAEXXZ ENDP		; CDoubleGoerEvent::SummonMonster
_TEXT	ENDS
PUBLIC	??0?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QAE@XZ ; std::vector<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >::vector<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??0?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QAE@XZ PROC ; std::vector<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >::vector<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >, COMDAT
; _this$ = ecx

; 507  : 		{	// construct empty vector

  00000	8b c1		 mov	 eax, ecx
  00002	33 c9		 xor	 ecx, ecx
  00004	89 08		 mov	 DWORD PTR [eax], ecx
  00006	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00009	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 508  : 		}

  0000c	c3		 ret	 0
??0?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QAE@XZ ENDP ; std::vector<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >::vector<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >
_TEXT	ENDS
PUBLIC	??C?$_Vector_iterator@V?$_Vector_val@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@std@@QBEPAU_st_reward@CDoubleGoerEvent@@XZ ; std::_Vector_iterator<std::_Vector_val<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> > >::operator->
; Function compile flags: /Ogtp
;	COMDAT ??C?$_Vector_iterator@V?$_Vector_val@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@std@@QBEPAU_st_reward@CDoubleGoerEvent@@XZ
_TEXT	SEGMENT
??C?$_Vector_iterator@V?$_Vector_val@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@std@@QBEPAU_st_reward@CDoubleGoerEvent@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> > >::operator->, COMDAT
; _this$ = ecx

; 327  : 		return (&**this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 328  : 		}

  00002	c3		 ret	 0
??C?$_Vector_iterator@V?$_Vector_val@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@std@@QBEPAU_st_reward@CDoubleGoerEvent@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> > >::operator->
_TEXT	ENDS
PUBLIC	??E?$_Vector_iterator@V?$_Vector_val@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> > >::operator++
; Function compile flags: /Ogtp
;	COMDAT ??E?$_Vector_iterator@V?$_Vector_val@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??E?$_Vector_iterator@V?$_Vector_val@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@std@@QAE?AV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> > >::operator++, COMDAT
; _this$ = ecx

; 337  : 		{	// postincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 338  : 		_Myiter _Tmp = *this;

  00003	8b 11		 mov	 edx, DWORD PTR [ecx]
  00005	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00008	89 10		 mov	 DWORD PTR [eax], edx

; 339  : 		++*this;

  0000a	83 c2 18	 add	 edx, 24			; 00000018H
  0000d	89 11		 mov	 DWORD PTR [ecx], edx

; 340  : 		return (_Tmp);
; 341  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 08 00	 ret	 8
??E?$_Vector_iterator@V?$_Vector_val@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@std@@QAE?AV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> > >::operator++
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@V?$_Vector_val@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> > >::operator!=
; Function compile flags: /Ogtp
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@V?$_Vector_val@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> > >::operator!=, COMDAT
; _this$ = ecx

; 207  : 		{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 208  : 		return (!(*this == _Right));

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00008	33 c9		 xor	 ecx, ecx
  0000a	3b 02		 cmp	 eax, DWORD PTR [edx]
  0000c	0f 95 c0	 setne	 al

; 209  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??9?$_Vector_const_iterator@V?$_Vector_val@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> > >::operator!=
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@std@@QAE@PAU_st_reward@CDoubleGoerEvent@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> > >::_Vector_iterator<std::_Vector_val<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> > >
; Function compile flags: /Ogtp
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@std@@QAE@PAU_st_reward@CDoubleGoerEvent@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@std@@QAE@PAU_st_reward@CDoubleGoerEvent@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> > >::_Vector_iterator<std::_Vector_val<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> > >, COMDAT
; _this$ = ecx

; 304  : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 305  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_iterator@V?$_Vector_val@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@std@@QAE@PAU_st_reward@CDoubleGoerEvent@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> > >::_Vector_iterator<std::_Vector_val<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> > >
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@2@@Z ; std::vector<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >::_Make_iter
; Function compile flags: /Ogtp
;	COMDAT ?_Make_iter@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@2@@Z PROC ; std::vector<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >::_Make_iter, COMDAT
; _this$ = ecx

; 801  : 		{	// make iterator from const_iterator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 802  : 		return (iterator(_Where._Ptr, this));

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Where$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 803  : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 08 00	 ret	 8
?_Make_iter@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@2@@Z ENDP ; std::vector<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >::_Make_iter
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@QAEPAU_st_reward@CDoubleGoerEvent@@I@Z ; std::allocator<CDoubleGoerEvent::_st_reward>::allocate
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@QAEPAU_st_reward@CDoubleGoerEvent@@I@Z
_TEXT	SEGMENT
$T189187 = -12						; size = 12
$T189185 = 8						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@QAEPAU_st_reward@CDoubleGoerEvent@@I@Z PROC ; std::allocator<CDoubleGoerEvent::_st_reward>::allocate, COMDAT
; _this$ = ecx

; 186  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 187  : 		return (_Allocate(_Count, (pointer)0));

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00009	33 c0		 xor	 eax, eax
  0000b	85 c9		 test	 ecx, ecx
  0000d	74 46		 je	 SHORT $LN1@allocate
  0000f	81 f9 aa aa aa
	0a		 cmp	 ecx, 178956970		; 0aaaaaaaH
  00015	77 16		 ja	 SHORT $LN3@allocate
  00017	8d 04 49	 lea	 eax, DWORD PTR [ecx+ecx*2]
  0001a	03 c0		 add	 eax, eax
  0001c	03 c0		 add	 eax, eax
  0001e	03 c0		 add	 eax, eax
  00020	50		 push	 eax
  00021	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00026	83 c4 04	 add	 esp, 4
  00029	85 c0		 test	 eax, eax
  0002b	75 28		 jne	 SHORT $LN1@allocate
$LN3@allocate:
  0002d	8d 4d 08	 lea	 ecx, DWORD PTR $T189185[ebp]
  00030	51		 push	 ecx
  00031	8d 4d f4	 lea	 ecx, DWORD PTR $T189187[ebp]
  00034	c7 45 08 00 00
	00 00		 mov	 DWORD PTR $T189185[ebp], 0
  0003b	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00040	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00045	8d 55 f4	 lea	 edx, DWORD PTR $T189187[ebp]
  00048	52		 push	 edx
  00049	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T189187[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00050	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN13@allocate:
$LN1@allocate:

; 188  : 		}

  00055	8b e5		 mov	 esp, ebp
  00057	5d		 pop	 ebp
  00058	c2 04 00	 ret	 4
$LN12@allocate:
?allocate@?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@QAEPAU_st_reward@CDoubleGoerEvent@@I@Z ENDP ; std::allocator<CDoubleGoerEvent::_st_reward>::allocate
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@U_st_reward@CDoubleGoerEvent@@ABU34@@std@@YAXAAV?$allocator@U_st_reward@CDoubleGoerEvent@@@0@PAU_st_reward@CDoubleGoerEvent@@ABU23@@Z ; std::_Cons_val<std::allocator<CDoubleGoerEvent::_st_reward>,CDoubleGoerEvent::_st_reward,CDoubleGoerEvent::_st_reward const &>
; Function compile flags: /Ogtp
;	COMDAT ??$_Cons_val@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@U_st_reward@CDoubleGoerEvent@@ABU34@@std@@YAXAAV?$allocator@U_st_reward@CDoubleGoerEvent@@@0@PAU_st_reward@CDoubleGoerEvent@@ABU23@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@U_st_reward@CDoubleGoerEvent@@ABU34@@std@@YAXAAV?$allocator@U_st_reward@CDoubleGoerEvent@@@0@PAU_st_reward@CDoubleGoerEvent@@ABU23@@Z PROC ; std::_Cons_val<std::allocator<CDoubleGoerEvent::_st_reward>,CDoubleGoerEvent::_st_reward,CDoubleGoerEvent::_st_reward const &>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Pdest$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 25		 je	 SHORT $LN9@Cons_val@2
  0000a	8b 4d 10	 mov	 ecx, DWORD PTR __Src$[ebp]
  0000d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000f	89 10		 mov	 DWORD PTR [eax], edx
  00011	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00014	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00017	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0001a	89 50 08	 mov	 DWORD PTR [eax+8], edx
  0001d	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00020	89 50 0c	 mov	 DWORD PTR [eax+12], edx
  00023	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00026	89 50 10	 mov	 DWORD PTR [eax+16], edx
  00029	8b 49 14	 mov	 ecx, DWORD PTR [ecx+20]
  0002c	89 48 14	 mov	 DWORD PTR [eax+20], ecx
$LN9@Cons_val@2:

; 281  : 	}

  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
??$_Cons_val@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@U_st_reward@CDoubleGoerEvent@@ABU34@@std@@YAXAAV?$allocator@U_st_reward@CDoubleGoerEvent@@@0@PAU_st_reward@CDoubleGoerEvent@@ABU23@@Z ENDP ; std::_Cons_val<std::allocator<CDoubleGoerEvent::_st_reward>,CDoubleGoerEvent::_st_reward,CDoubleGoerEvent::_st_reward const &>
_TEXT	ENDS
PUBLIC	??$_Move@PAU_st_reward@CDoubleGoerEvent@@PAU12@@std@@YAPAU_st_reward@CDoubleGoerEvent@@PAU12@00@Z ; std::_Move<CDoubleGoerEvent::_st_reward *,CDoubleGoerEvent::_st_reward *>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??$_Move@PAU_st_reward@CDoubleGoerEvent@@PAU12@@std@@YAPAU_st_reward@CDoubleGoerEvent@@PAU12@00@Z
_TEXT	SEGMENT
__Cat$189247 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Move@PAU_st_reward@CDoubleGoerEvent@@PAU12@@std@@YAPAU_st_reward@CDoubleGoerEvent@@PAU12@00@Z PROC ; std::_Move<CDoubleGoerEvent::_st_reward *,CDoubleGoerEvent::_st_reward *>, COMDAT

; 2533 : 	{	// move [_First, _Last) to [_Dest, ...), unchecked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 2534 : 	return (_Move(_First, _Last,
; 2535 : 		_Dest, _Ptr_cat(_First, _Dest)));

  00004	8b 45 fc	 mov	 eax, DWORD PTR __Cat$189247[ebp]
  00007	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  0000a	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  0000d	50		 push	 eax
  0000e	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00011	51		 push	 ecx
  00012	52		 push	 edx
  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 ??$_Move@PAU_st_reward@CDoubleGoerEvent@@PAU12@@std@@YAPAU_st_reward@CDoubleGoerEvent@@PAU12@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Move<CDoubleGoerEvent::_st_reward *,CDoubleGoerEvent::_st_reward *>
  00019	83 c4 10	 add	 esp, 16			; 00000010H

; 2536 : 	}

  0001c	8b e5		 mov	 esp, ebp
  0001e	5d		 pop	 ebp
  0001f	c3		 ret	 0
??$_Move@PAU_st_reward@CDoubleGoerEvent@@PAU12@@std@@YAPAU_st_reward@CDoubleGoerEvent@@PAU12@00@Z ENDP ; std::_Move<CDoubleGoerEvent::_st_reward *,CDoubleGoerEvent::_st_reward *>
_TEXT	ENDS
PUBLIC	??$_Dest_val@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@U_st_reward@CDoubleGoerEvent@@@std@@YAXAAV?$allocator@U_st_reward@CDoubleGoerEvent@@@0@PAU_st_reward@CDoubleGoerEvent@@@Z ; std::_Dest_val<std::allocator<CDoubleGoerEvent::_st_reward>,CDoubleGoerEvent::_st_reward>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Dest_val@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@U_st_reward@CDoubleGoerEvent@@@std@@YAXAAV?$allocator@U_st_reward@CDoubleGoerEvent@@@0@PAU_st_reward@CDoubleGoerEvent@@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
??$_Dest_val@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@U_st_reward@CDoubleGoerEvent@@@std@@YAXAAV?$allocator@U_st_reward@CDoubleGoerEvent@@@0@PAU_st_reward@CDoubleGoerEvent@@@Z PROC ; std::_Dest_val<std::allocator<CDoubleGoerEvent::_st_reward>,CDoubleGoerEvent::_st_reward>, COMDAT

; 287  : 	_Alval.destroy(_Pdest);
; 288  : 	}

  00000	c3		 ret	 0
??$_Dest_val@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@U_st_reward@CDoubleGoerEvent@@@std@@YAXAAV?$allocator@U_st_reward@CDoubleGoerEvent@@@0@PAU_st_reward@CDoubleGoerEvent@@@Z ENDP ; std::_Dest_val<std::allocator<CDoubleGoerEvent::_st_reward>,CDoubleGoerEvent::_st_reward>
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@U_st_reward@CDoubleGoerEvent@@U34@@std@@YAXAAV?$allocator@U_st_reward@CDoubleGoerEvent@@@0@PAU_st_reward@CDoubleGoerEvent@@$$QAU23@@Z ; std::_Cons_val<std::allocator<CDoubleGoerEvent::_st_reward>,CDoubleGoerEvent::_st_reward,CDoubleGoerEvent::_st_reward>
; Function compile flags: /Ogtp
;	COMDAT ??$_Cons_val@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@U_st_reward@CDoubleGoerEvent@@U34@@std@@YAXAAV?$allocator@U_st_reward@CDoubleGoerEvent@@@0@PAU_st_reward@CDoubleGoerEvent@@$$QAU23@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@U_st_reward@CDoubleGoerEvent@@U34@@std@@YAXAAV?$allocator@U_st_reward@CDoubleGoerEvent@@@0@PAU_st_reward@CDoubleGoerEvent@@$$QAU23@@Z PROC ; std::_Cons_val<std::allocator<CDoubleGoerEvent::_st_reward>,CDoubleGoerEvent::_st_reward,CDoubleGoerEvent::_st_reward>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Pdest$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 25		 je	 SHORT $LN7@Cons_val@3
  0000a	8b 4d 10	 mov	 ecx, DWORD PTR __Src$[ebp]
  0000d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000f	89 10		 mov	 DWORD PTR [eax], edx
  00011	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00014	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00017	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0001a	89 50 08	 mov	 DWORD PTR [eax+8], edx
  0001d	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00020	89 50 0c	 mov	 DWORD PTR [eax+12], edx
  00023	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00026	89 50 10	 mov	 DWORD PTR [eax+16], edx
  00029	8b 49 14	 mov	 ecx, DWORD PTR [ecx+20]
  0002c	89 48 14	 mov	 DWORD PTR [eax+20], ecx
$LN7@Cons_val@3:

; 281  : 	}

  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
??$_Cons_val@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@U_st_reward@CDoubleGoerEvent@@U34@@std@@YAXAAV?$allocator@U_st_reward@CDoubleGoerEvent@@@0@PAU_st_reward@CDoubleGoerEvent@@$$QAU23@@Z ENDP ; std::_Cons_val<std::allocator<CDoubleGoerEvent::_st_reward>,CDoubleGoerEvent::_st_reward,CDoubleGoerEvent::_st_reward>
_TEXT	ENDS
PUBLIC	?SetState@CDoubleGoerEvent@@QAEXH@Z		; CDoubleGoerEvent::SetState
; Function compile flags: /Ogtp
; File c:\muserver_dev\development\mu-s8ep2-repack\gameserver\source\doublegoerevent.cpp
;	COMDAT ?SetState@CDoubleGoerEvent@@QAEXH@Z
_TEXT	SEGMENT
_iState$ = 8						; size = 4
?SetState@CDoubleGoerEvent@@QAEXH@Z PROC		; CDoubleGoerEvent::SetState, COMDAT
; _this$ = ecx

; 578  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 579  : 	switch( iState )

  00005	8b 7d 08	 mov	 edi, DWORD PTR _iState$[ebp]
  00008	8b f1		 mov	 esi, ecx
  0000a	83 ff 03	 cmp	 edi, 3
  0000d	77 36		 ja	 SHORT $LN1@SetState
  0000f	ff 24 bd 00 00
	00 00		 jmp	 DWORD PTR $LN10@SetState[edi*4]
$LN5@SetState:

; 580  : 	{
; 581  : 	case DOUBLEGOER_STATE_CLOSED:
; 582  : 		SetState_CLOSED();

  00016	e8 00 00 00 00	 call	 ?SetState_CLOSED@CDoubleGoerEvent@@QAEXXZ ; CDoubleGoerEvent::SetState_CLOSED

; 592  : 		break;
; 593  : 	default:
; 594  : 		break;
; 595  : 	}
; 596  : 
; 597  : 	m_iState = iState;

  0001b	89 7e 24	 mov	 DWORD PTR [esi+36], edi
  0001e	5f		 pop	 edi
  0001f	5e		 pop	 esi

; 598  : }

  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
$LN4@SetState:

; 583  : 		break;
; 584  : 	case DOUBLEGOER_STATE_WAITING:
; 585  : 		SetState_WAITING();

  00024	e8 00 00 00 00	 call	 ?SetState_WAITING@CDoubleGoerEvent@@QAEXXZ ; CDoubleGoerEvent::SetState_WAITING

; 592  : 		break;
; 593  : 	default:
; 594  : 		break;
; 595  : 	}
; 596  : 
; 597  : 	m_iState = iState;

  00029	89 7e 24	 mov	 DWORD PTR [esi+36], edi
  0002c	5f		 pop	 edi
  0002d	5e		 pop	 esi

; 598  : }

  0002e	5d		 pop	 ebp
  0002f	c2 04 00	 ret	 4
$LN3@SetState:

; 586  : 		break;
; 587  : 	case DOUBLEGOER_STATE_PLAYING:
; 588  : 		SetState_PLAYING();

  00032	e8 00 00 00 00	 call	 ?SetState_PLAYING@CDoubleGoerEvent@@QAEXXZ ; CDoubleGoerEvent::SetState_PLAYING

; 592  : 		break;
; 593  : 	default:
; 594  : 		break;
; 595  : 	}
; 596  : 
; 597  : 	m_iState = iState;

  00037	89 7e 24	 mov	 DWORD PTR [esi+36], edi
  0003a	5f		 pop	 edi
  0003b	5e		 pop	 esi

; 598  : }

  0003c	5d		 pop	 ebp
  0003d	c2 04 00	 ret	 4
$LN2@SetState:

; 589  : 		break;
; 590  : 	case DOUBLEGOER_STATE_PLAYEND:
; 591  : 		SetState_PLAYEND();

  00040	e8 00 00 00 00	 call	 ?SetState_PLAYEND@CDoubleGoerEvent@@QAEXXZ ; CDoubleGoerEvent::SetState_PLAYEND
$LN1@SetState:

; 592  : 		break;
; 593  : 	default:
; 594  : 		break;
; 595  : 	}
; 596  : 
; 597  : 	m_iState = iState;

  00045	89 7e 24	 mov	 DWORD PTR [esi+36], edi
  00048	5f		 pop	 edi
  00049	5e		 pop	 esi

; 598  : }

  0004a	5d		 pop	 ebp
  0004b	c2 04 00	 ret	 4
  0004e	8b ff		 npad	 2
$LN10@SetState:
  00050	00 00 00 00	 DD	 $LN5@SetState
  00054	00 00 00 00	 DD	 $LN4@SetState
  00058	00 00 00 00	 DD	 $LN3@SetState
  0005c	00 00 00 00	 DD	 $LN2@SetState
?SetState@CDoubleGoerEvent@@QAEXH@Z ENDP		; CDoubleGoerEvent::SetState
_TEXT	ENDS
PUBLIC	??_C@_0CI@DLCNGFOG@?$FLDoppelganger?$FN?5Boss?5Killed?5?9?$DO?5EV@ ; `string'
PUBLIC	?MonsterDieHandle@CDoubleGoerEvent@@QAEXPAUOBJECTSTRUCT@@@Z ; CDoubleGoerEvent::MonsterDieHandle
;	COMDAT ??_C@_0CI@DLCNGFOG@?$FLDoppelganger?$FN?5Boss?5Killed?5?9?$DO?5EV@
CONST	SEGMENT
??_C@_0CI@DLCNGFOG@?$FLDoppelganger?$FN?5Boss?5Killed?5?9?$DO?5EV@ DB '[D'
	DB	'oppelganger] Boss Killed -> EVENT_END', 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?MonsterDieHandle@CDoubleGoerEvent@@QAEXPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
?MonsterDieHandle@CDoubleGoerEvent@@QAEXPAUOBJECTSTRUCT@@@Z PROC ; CDoubleGoerEvent::MonsterDieHandle, COMDAT
; _this$ = ecx

; 1209 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 1210 : 	if( lpObj->Class == 529 || lpObj->Class == 530 )

  00005	8b 7d 08	 mov	 edi, DWORD PTR _lpObj$[ebp]
  00008	0f b7 87 90 00
	00 00		 movzx	 eax, WORD PTR [edi+144]
  0000f	8b f1		 mov	 esi, ecx
  00011	b9 11 02 00 00	 mov	 ecx, 529		; 00000211H
  00016	66 3b c1	 cmp	 ax, cx
  00019	74 3f		 je	 SHORT $LN3@MonsterDie
  0001b	ba 12 02 00 00	 mov	 edx, 530		; 00000212H
  00020	66 3b c2	 cmp	 ax, dx
  00023	74 35		 je	 SHORT $LN3@MonsterDie

; 1215 : 	}
; 1216 : 	else if( lpObj->Class == 531 )

  00025	b9 13 02 00 00	 mov	 ecx, 531		; 00000213H
  0002a	66 3b c1	 cmp	 ax, cx
  0002d	0f 85 d5 00 00
	00		 jne	 $LN1@MonsterDie

; 1217 : 	{
; 1218 : 		SetState(DOUBLEGOER_STATE_PLAYEND);

  00033	6a 03		 push	 3
  00035	8b ce		 mov	 ecx, esi
  00037	e8 00 00 00 00	 call	 ?SetState@CDoubleGoerEvent@@QAEXH@Z ; CDoubleGoerEvent::SetState

; 1219 : 		LogAddTD("[Doppelganger] Boss Killed -> EVENT_END");

  0003c	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@DLCNGFOG@?$FLDoppelganger?$FN?5Boss?5Killed?5?9?$DO?5EV@
  00041	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 1220 : 	}
; 1221 : 
; 1222 : 	DelMonster(lpObj->m_Index);

  00047	8b 07		 mov	 eax, DWORD PTR [edi]
  00049	83 c4 04	 add	 esp, 4
  0004c	50		 push	 eax
  0004d	8b ce		 mov	 ecx, esi
  0004f	e8 00 00 00 00	 call	 ?DelMonster@CDoubleGoerEvent@@QAEHH@Z ; CDoubleGoerEvent::DelMonster
  00054	5f		 pop	 edi
  00055	5e		 pop	 esi

; 1223 : }

  00056	5d		 pop	 ebp
  00057	c2 04 00	 ret	 4
$LN3@MonsterDie:

; 1211 : 	{
; 1212 : 		SummonMonster(541,m_iCurentMap,lpObj->X-1,lpObj->Y+(-1+rand()%3),m_EventLevel, m_EventReset);

  0005a	8b 96 58 02 00
	00		 mov	 edx, DWORD PTR [esi+600]
  00060	8b 86 5c 02 00
	00		 mov	 eax, DWORD PTR [esi+604]
  00066	52		 push	 edx
  00067	50		 push	 eax
  00068	e8 00 00 00 00	 call	 _rand
  0006d	99		 cdq
  0006e	b9 03 00 00 00	 mov	 ecx, 3
  00073	f7 f9		 idiv	 ecx
  00075	0f b6 87 21 01
	00 00		 movzx	 eax, BYTE PTR [edi+289]
  0007c	8d 4c 02 ff	 lea	 ecx, DWORD PTR [edx+eax-1]
  00080	0f b6 97 20 01
	00 00		 movzx	 edx, BYTE PTR [edi+288]
  00087	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  0008a	51		 push	 ecx
  0008b	4a		 dec	 edx
  0008c	52		 push	 edx
  0008d	50		 push	 eax
  0008e	68 1d 02 00 00	 push	 541			; 0000021dH
  00093	8b ce		 mov	 ecx, esi
  00095	e8 00 00 00 00	 call	 ?SummonMonster@CDoubleGoerEvent@@QAEHHHHHHH@Z ; CDoubleGoerEvent::SummonMonster

; 1213 : 		SummonMonster(541,m_iCurentMap,lpObj->X,lpObj->Y,m_EventLevel, m_EventReset);

  0009a	8b 8e 58 02 00
	00		 mov	 ecx, DWORD PTR [esi+600]
  000a0	8b 96 5c 02 00
	00		 mov	 edx, DWORD PTR [esi+604]
  000a6	0f b6 87 21 01
	00 00		 movzx	 eax, BYTE PTR [edi+289]
  000ad	51		 push	 ecx
  000ae	0f b6 8f 20 01
	00 00		 movzx	 ecx, BYTE PTR [edi+288]
  000b5	52		 push	 edx
  000b6	8b 56 30	 mov	 edx, DWORD PTR [esi+48]
  000b9	50		 push	 eax
  000ba	51		 push	 ecx
  000bb	52		 push	 edx
  000bc	68 1d 02 00 00	 push	 541			; 0000021dH
  000c1	8b ce		 mov	 ecx, esi
  000c3	e8 00 00 00 00	 call	 ?SummonMonster@CDoubleGoerEvent@@QAEHHHHHHH@Z ; CDoubleGoerEvent::SummonMonster

; 1214 : 		SummonMonster(541,m_iCurentMap,lpObj->X+(-1+rand()%3),lpObj->Y+1,m_EventLevel, m_EventReset);

  000c8	8b 86 58 02 00
	00		 mov	 eax, DWORD PTR [esi+600]
  000ce	0f b6 97 21 01
	00 00		 movzx	 edx, BYTE PTR [edi+289]
  000d5	8b 8e 5c 02 00
	00		 mov	 ecx, DWORD PTR [esi+604]
  000db	50		 push	 eax
  000dc	51		 push	 ecx
  000dd	42		 inc	 edx
  000de	52		 push	 edx
  000df	e8 00 00 00 00	 call	 _rand
  000e4	99		 cdq
  000e5	b9 03 00 00 00	 mov	 ecx, 3
  000ea	f7 f9		 idiv	 ecx
  000ec	0f b6 87 20 01
	00 00		 movzx	 eax, BYTE PTR [edi+288]
  000f3	8d 4c 02 ff	 lea	 ecx, DWORD PTR [edx+eax-1]
  000f7	8b 56 30	 mov	 edx, DWORD PTR [esi+48]
  000fa	51		 push	 ecx
  000fb	52		 push	 edx
  000fc	68 1d 02 00 00	 push	 541			; 0000021dH
  00101	8b ce		 mov	 ecx, esi
  00103	e8 00 00 00 00	 call	 ?SummonMonster@CDoubleGoerEvent@@QAEHHHHHHH@Z ; CDoubleGoerEvent::SummonMonster
$LN1@MonsterDie:

; 1220 : 	}
; 1221 : 
; 1222 : 	DelMonster(lpObj->m_Index);

  00108	8b 07		 mov	 eax, DWORD PTR [edi]
  0010a	50		 push	 eax
  0010b	8b ce		 mov	 ecx, esi
  0010d	e8 00 00 00 00	 call	 ?DelMonster@CDoubleGoerEvent@@QAEHH@Z ; CDoubleGoerEvent::DelMonster
  00112	5f		 pop	 edi
  00113	5e		 pop	 esi

; 1223 : }

  00114	5d		 pop	 ebp
  00115	c2 04 00	 ret	 4
?MonsterDieHandle@CDoubleGoerEvent@@QAEXPAUOBJECTSTRUCT@@@Z ENDP ; CDoubleGoerEvent::MonsterDieHandle
_TEXT	ENDS
PUBLIC	?begin@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@2@XZ ; std::vector<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >::begin
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?begin@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@2@XZ PROC ; std::vector<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >::begin, COMDAT
; _this$ = ecx

; 781  : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 782  : 		return (iterator(this->_Myfirst, this));

  00003	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00005	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 783  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?begin@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@2@XZ ENDP ; std::vector<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@2@XZ ; std::vector<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >::end
; Function compile flags: /Ogtp
;	COMDAT ?end@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@2@XZ PROC ; std::vector<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >::end, COMDAT
; _this$ = ecx

; 791  : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 792  : 		return (iterator(this->_Mylast, this));

  00003	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00006	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 793  : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
?end@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@2@XZ ENDP ; std::vector<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >::end
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@YAXPAU_st_reward@CDoubleGoerEvent@@0AAV?$allocator@U_st_reward@CDoubleGoerEvent@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<CDoubleGoerEvent::_st_reward> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@YAXPAU_st_reward@CDoubleGoerEvent@@0AAV?$allocator@U_st_reward@CDoubleGoerEvent@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@YAXPAU_st_reward@CDoubleGoerEvent@@0AAV?$allocator@U_st_reward@CDoubleGoerEvent@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<CDoubleGoerEvent::_st_reward> >, COMDAT

; 96   : 	for (; _First != _Last; ++_First)
; 97   : 		_Dest_val(_Al, _First);
; 98   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@YAXPAU_st_reward@CDoubleGoerEvent@@0AAV?$allocator@U_st_reward@CDoubleGoerEvent@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<CDoubleGoerEvent::_st_reward> >
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAU_st_reward@CDoubleGoerEvent@@PAU12@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@U12@@std@@YAPAU_st_reward@CDoubleGoerEvent@@PAU12@00AAV?$allocator@U_st_reward@CDoubleGoerEvent@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<CDoubleGoerEvent::_st_reward *,CDoubleGoerEvent::_st_reward *,std::allocator<CDoubleGoerEvent::_st_reward>,CDoubleGoerEvent::_st_reward>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\memory
;	COMDAT ??$_Uninit_move@PAU_st_reward@CDoubleGoerEvent@@PAU12@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@U12@@std@@YAPAU_st_reward@CDoubleGoerEvent@@PAU12@00AAV?$allocator@U_st_reward@CDoubleGoerEvent@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Uninit_move@PAU_st_reward@CDoubleGoerEvent@@PAU12@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@U12@@std@@YAPAU_st_reward@CDoubleGoerEvent@@PAU12@00AAV?$allocator@U_st_reward@CDoubleGoerEvent@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_move<CDoubleGoerEvent::_st_reward *,CDoubleGoerEvent::_st_reward *,std::allocator<CDoubleGoerEvent::_st_reward>,CDoubleGoerEvent::_st_reward>, COMDAT

; 424  : 	{	// move [_First, _Last) to raw _Dest, using _Al, arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 425  : 	_DEBUG_RANGE(_First, _Last);
; 426  : 	_DEBUG_POINTER(_Dest);
; 427  : 	_FwdIt _Next = _Dest;
; 428  : 
; 429  : 	_TRY_BEGIN
; 430  : 	for (; _First != _Last; ++_Dest, ++_First)

  00004	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  00007	56		 push	 esi
  00008	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000b	3b f3		 cmp	 esi, ebx
  0000d	74 23		 je	 SHORT $LN17@Uninit_mov
  0000f	57		 push	 edi
  00010	8b 7d 10	 mov	 edi, DWORD PTR __Dest$[ebp]
$LL6@Uninit_mov:

; 431  : 		_Cons_val(_Al, _Dest, (_Valty &&)*_First);

  00013	8b 45 14	 mov	 eax, DWORD PTR __Al$[ebp]
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@U_st_reward@CDoubleGoerEvent@@U34@@std@@YAXAAV?$allocator@U_st_reward@CDoubleGoerEvent@@@0@PAU_st_reward@CDoubleGoerEvent@@$$QAU23@@Z ; std::_Cons_val<std::allocator<CDoubleGoerEvent::_st_reward>,CDoubleGoerEvent::_st_reward,CDoubleGoerEvent::_st_reward>
  0001e	83 c6 18	 add	 esi, 24			; 00000018H
  00021	83 c4 0c	 add	 esp, 12			; 0000000cH
  00024	83 c7 18	 add	 edi, 24			; 00000018H
  00027	3b f3		 cmp	 esi, ebx
  00029	75 e8		 jne	 SHORT $LL6@Uninit_mov

; 432  : 	_CATCH_ALL
; 433  : 	for (; _Next != _Dest; ++_Next)
; 434  : 		_Dest_val(_Al, _Next);
; 435  : 	_RERAISE;
; 436  : 	_CATCH_END
; 437  : 	return (_Dest);

  0002b	8b c7		 mov	 eax, edi
  0002d	5f		 pop	 edi
  0002e	5e		 pop	 esi
  0002f	5b		 pop	 ebx

; 438  : 	}

  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
$LN17@Uninit_mov:

; 432  : 	_CATCH_ALL
; 433  : 	for (; _Next != _Dest; ++_Next)
; 434  : 		_Dest_val(_Al, _Next);
; 435  : 	_RERAISE;
; 436  : 	_CATCH_END
; 437  : 	return (_Dest);

  00032	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00035	5e		 pop	 esi
  00036	5b		 pop	 ebx

; 438  : 	}

  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
??$_Uninit_move@PAU_st_reward@CDoubleGoerEvent@@PAU12@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@U12@@std@@YAPAU_st_reward@CDoubleGoerEvent@@PAU12@00AAV?$allocator@U_st_reward@CDoubleGoerEvent@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_move<CDoubleGoerEvent::_st_reward *,CDoubleGoerEvent::_st_reward *,std::allocator<CDoubleGoerEvent::_st_reward>,CDoubleGoerEvent::_st_reward>
_TEXT	ENDS
PUBLIC	??_C@_0DK@FGCCIFBE@?$FLDoppelganger?$FN?$FLERROR?$FN?5Not?5talked@ ; `string'
PUBLIC	??_C@_0DK@BAGOCEPD@?$FLDoppelganger?$FN?$FLERROR?$FN?5Inventory?5@ ; `string'
PUBLIC	??_C@_0DM@ENOPDFGO@?$FLDoppelganger?$FN?$FL?$CFd?$FN?$CI?$CFs?$CJ?$CI?$CFs?$CJ?5Enter@ ; `string'
PUBLIC	??_C@_0EB@NOGPNGOL@?$FLDoppelganger?$FN?$FL?$CFd?$FN?$CI?$CFs?$CJ?$CI?$CFs?$CJ?5Enter@ ; `string'
PUBLIC	??_C@_0DL@MBECLFKN@?$FLDoppelganger?$FN?$FLERROR?$FN?5Inventory?5@ ; `string'
PUBLIC	?EnterRequest@CDoubleGoerEvent@@QAEXPAUPMSG_DOUBLEGOER_REQ_ENTER@@H@Z ; CDoubleGoerEvent::EnterRequest
EXTRN	?GCInventoryItemDeleteSend@@YAXHEE@Z:PROC	; GCInventoryItemDeleteSend
EXTRN	?Clear@CItem@@QAEXXZ:PROC			; CItem::Clear
EXTRN	?gObjInventoryItemSet@@YAXHHE@Z:PROC		; gObjInventoryItemSet
EXTRN	__imp__LeaveCriticalSection@4:PROC
EXTRN	__imp__EnterCriticalSection@4:PROC
EXTRN	?IsItem@CItem@@QAEHXZ:PROC			; CItem::IsItem
;	COMDAT ??_C@_0DK@FGCCIFBE@?$FLDoppelganger?$FN?$FLERROR?$FN?5Not?5talked@
; File c:\muserver_dev\development\mu-s8ep2-repack\gameserver\source\doublegoerevent.cpp
CONST	SEGMENT
??_C@_0DK@FGCCIFBE@?$FLDoppelganger?$FN?$FLERROR?$FN?5Not?5talked@ DB '[D'
	DB	'oppelganger][ERROR] Not talked with Lugard [%d](%s)(%s)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@BAGOCEPD@?$FLDoppelganger?$FN?$FLERROR?$FN?5Inventory?5@
CONST	SEGMENT
??_C@_0DK@BAGOCEPD@?$FLDoppelganger?$FN?$FLERROR?$FN?5Inventory?5@ DB '[D'
	DB	'oppelganger][ERROR] Inventory item error - [%d](%s)(%s)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@ENOPDFGO@?$FLDoppelganger?$FN?$FL?$CFd?$FN?$CI?$CFs?$CJ?$CI?$CFs?$CJ?5Enter@
CONST	SEGMENT
??_C@_0DM@ENOPDFGO@?$FLDoppelganger?$FN?$FL?$CFd?$FN?$CI?$CFs?$CJ?$CI?$CFs?$CJ?5Enter@ DB '['
	DB	'Doppelganger][%d](%s)(%s) Enter request failed - pk status', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EB@NOGPNGOL@?$FLDoppelganger?$FN?$FL?$CFd?$FN?$CI?$CFs?$CJ?$CI?$CFs?$CJ?5Enter@
CONST	SEGMENT
??_C@_0EB@NOGPNGOL@?$FLDoppelganger?$FN?$FL?$CFd?$FN?$CI?$CFs?$CJ?$CI?$CFs?$CJ?5Enter@ DB '['
	DB	'Doppelganger][%d](%s)(%s) Enter request failed - event on goi'
	DB	'ng', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@MBECLFKN@?$FLDoppelganger?$FN?$FLERROR?$FN?5Inventory?5@
CONST	SEGMENT
??_C@_0DL@MBECLFKN@?$FLDoppelganger?$FN?$FLERROR?$FN?5Inventory?5@ DB '[D'
	DB	'oppelganger][ERROR] Inventory range error - [%d](%s)(%s)', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?EnterRequest@CDoubleGoerEvent@@QAEXPAUPMSG_DOUBLEGOER_REQ_ENTER@@H@Z
_TEXT	SEGMENT
_pMsg$ = -16						; size = 5
tv256 = -8						; size = 4
_invPos$ = -4						; size = 4
tv278 = 8						; size = 4
_lpMsg$ = 8						; size = 4
tv287 = 12						; size = 4
_aIndex$ = 12						; size = 4
?EnterRequest@CDoubleGoerEvent@@QAEXPAUPMSG_DOUBLEGOER_REQ_ENTER@@H@Z PROC ; CDoubleGoerEvent::EnterRequest, COMDAT
; _this$ = ecx

; 265  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 266  : 	PMSG_DOUBLEGOER_ANS_ENTER pMsg;
; 267  : 	PHeadSubSetB((LPBYTE)&pMsg,0xBF,14,sizeof(pMsg));

  00009	6a 05		 push	 5
  0000b	6a 0e		 push	 14			; 0000000eH
  0000d	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00010	68 bf 00 00 00	 push	 191			; 000000bfH
  00015	50		 push	 eax
  00016	8b d9		 mov	 ebx, ecx
  00018	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 268  : 	pMsg.btResult = 1;
; 269  : 
; 270  : 	LPOBJ lpObj = &gObj[aIndex];

  0001d	8b 7d 0c	 mov	 edi, DWORD PTR _aIndex$[ebp]
  00020	8b f7		 mov	 esi, edi
  00022	69 f6 40 27 00
	00		 imul	 esi, 10048		; 00002740H
  00028	89 75 f8	 mov	 DWORD PTR tv256[ebp], esi
  0002b	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00031	c6 45 f4 01	 mov	 BYTE PTR _pMsg$[ebp+4], 1

; 271  : 
; 272  : 	if( lpObj->m_IfState.use == 0 || lpObj->m_IfState.type != 21 )

  00035	8b 86 b8 11 00
	00		 mov	 eax, DWORD PTR [esi+4536]
  0003b	83 c4 10	 add	 esp, 16			; 00000010H
  0003e	a8 03		 test	 al, 3
  00040	0f 84 f5 01 00
	00		 je	 $LN12@EnterReque
  00046	25 c0 ff 00 00	 and	 eax, 65472		; 0000ffc0H
  0004b	3d 40 05 00 00	 cmp	 eax, 1344		; 00000540H
  00050	0f 85 e5 01 00
	00		 jne	 $LN12@EnterReque

; 276  : 		return;
; 277  : 	}
; 278  : 
; 279  : 	int invPos = lpMsg->btPos+INVENTORY_BAG_START;

  00056	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  00059	0f b6 42 04	 movzx	 eax, BYTE PTR [edx+4]
  0005d	83 c0 0c	 add	 eax, 12			; 0000000cH
  00060	89 45 fc	 mov	 DWORD PTR _invPos$[ebp], eax

; 280  : 
; 281  : 	if( !MAIN_INVENTORY_RANGE(invPos) )

  00063	78 0e		 js	 SHORT $LN18@EnterReque
  00065	33 c9		 xor	 ecx, ecx
  00067	3d cb 00 00 00	 cmp	 eax, 203		; 000000cbH
  0006c	0f 9e c1	 setle	 cl
  0006f	85 c9		 test	 ecx, ecx
  00071	75 2f		 jne	 SHORT $LN11@EnterReque
$LN18@EnterReque:

; 282  : 	{
; 283  : 		LogAddTD("[Doppelganger][ERROR] Inventory range error - [%d](%s)(%s)",aIndex,lpObj->AccountID,lpObj->Name);

  00073	8d 46 5d	 lea	 eax, DWORD PTR [esi+93]
  00076	50		 push	 eax
  00077	83 c6 52	 add	 esi, 82			; 00000052H
  0007a	56		 push	 esi
  0007b	57		 push	 edi
  0007c	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@MBECLFKN@?$FLDoppelganger?$FN?$FLERROR?$FN?5Inventory?5@
  00081	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 284  : 		DataSend(aIndex,(LPBYTE)&pMsg,pMsg.h.size);

  00087	0f b6 4d f1	 movzx	 ecx, BYTE PTR _pMsg$[ebp+1]
  0008b	51		 push	 ecx
  0008c	8d 55 f0	 lea	 edx, DWORD PTR _pMsg$[ebp]
  0008f	52		 push	 edx
  00090	57		 push	 edi
  00091	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00096	83 c4 1c	 add	 esp, 28			; 0000001cH
  00099	5f		 pop	 edi
  0009a	5e		 pop	 esi
  0009b	5b		 pop	 ebx

; 372  : }

  0009c	8b e5		 mov	 esp, ebp
  0009e	5d		 pop	 ebp
  0009f	c2 08 00	 ret	 8
$LN11@EnterReque:

; 285  : 		return;
; 286  : 	}
; 287  : 
; 288  : 	if( lpObj->pInventory[invPos].IsItem() == FALSE || 
; 289  : 		lpObj->pInventory[invPos].m_Type != ITEMGET(14,111) )

  000a2	8b 8e c0 11 00
	00		 mov	 ecx, DWORD PTR [esi+4544]
  000a8	69 c0 d4 00 00
	00		 imul	 eax, 212		; 000000d4H
  000ae	03 c8		 add	 ecx, eax
  000b0	89 45 08	 mov	 DWORD PTR tv278[ebp], eax
  000b3	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  000b8	85 c0		 test	 eax, eax
  000ba	0f 84 6b 01 00
	00		 je	 $LN9@EnterReque
  000c0	8b 86 c0 11 00
	00		 mov	 eax, DWORD PTR [esi+4544]
  000c6	8b 55 08	 mov	 edx, DWORD PTR tv278[ebp]
  000c9	b9 6f 1c 00 00	 mov	 ecx, 7279		; 00001c6fH
  000ce	66 39 4c 02 06	 cmp	 WORD PTR [edx+eax+6], cx
  000d3	0f 85 52 01 00
	00		 jne	 $LN9@EnterReque

; 294  : 	}
; 295  : 
; 296  : 	EnterCriticalSection(&m_sCrit);

  000d9	8d 43 68	 lea	 eax, DWORD PTR [ebx+104]
  000dc	50		 push	 eax
  000dd	89 45 0c	 mov	 DWORD PTR tv287[ebp], eax
  000e0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 297  : 
; 298  : 	if( m_iState != DOUBLEGOER_STATE_CLOSED )

  000e6	8b 43 24	 mov	 eax, DWORD PTR [ebx+36]
  000e9	85 c0		 test	 eax, eax
  000eb	74 6d		 je	 SHORT $LN4@EnterReque

; 299  : 	{
; 300  : 		int bFail = TRUE;
; 301  : 
; 302  : 		if( m_iState == DOUBLEGOER_STATE_WAITING )

  000ed	83 f8 01	 cmp	 eax, 1
  000f0	75 2b		 jne	 SHORT $LN5@EnterReque

; 303  : 		{
; 304  : 			bFail = FALSE;
; 305  : 			int PartyNumber = lpObj->PartyNumber;

  000f2	8b 8e 0c 06 00
	00		 mov	 ecx, DWORD PTR [esi+1548]

; 306  : 
; 307  : 			if( PartyNumber == -1 || m_iLeaderIndex == -1 || gObj[m_iLeaderIndex].PartyNumber != PartyNumber )

  000f8	83 f9 ff	 cmp	 ecx, -1
  000fb	74 20		 je	 SHORT $LN5@EnterReque
  000fd	8b 83 80 00 00
	00		 mov	 eax, DWORD PTR [ebx+128]
  00103	83 f8 ff	 cmp	 eax, -1
  00106	74 15		 je	 SHORT $LN5@EnterReque
  00108	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0010e	69 c0 40 27 00
	00		 imul	 eax, 10048		; 00002740H
  00114	39 8c 10 0c 06
	00 00		 cmp	 DWORD PTR [eax+edx+1548], ecx
  0011b	74 3d		 je	 SHORT $LN4@EnterReque
$LN5@EnterReque:

; 308  : 			{
; 309  : 				bFail = TRUE;
; 310  : 			}
; 311  : 		}
; 312  : 
; 313  : 		if( bFail == TRUE )
; 314  : 		{
; 315  : 			LogAddTD("[Doppelganger][%d](%s)(%s) Enter request failed - event on going",aIndex,lpObj->AccountID,lpObj->Name);

  0011d	8d 46 5d	 lea	 eax, DWORD PTR [esi+93]
  00120	50		 push	 eax
  00121	83 c6 52	 add	 esi, 82			; 00000052H
  00124	56		 push	 esi
  00125	57		 push	 edi
  00126	68 00 00 00 00	 push	 OFFSET ??_C@_0EB@NOGPNGOL@?$FLDoppelganger?$FN?$FL?$CFd?$FN?$CI?$CFs?$CJ?$CI?$CFs?$CJ?5Enter@
  0012b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 316  : 			pMsg.btResult = 2;
; 317  : 			DataSend(aIndex,(LPBYTE)&pMsg,pMsg.h.size);

  00131	0f b6 4d f1	 movzx	 ecx, BYTE PTR _pMsg$[ebp+1]
  00135	51		 push	 ecx
  00136	8d 55 f0	 lea	 edx, DWORD PTR _pMsg$[ebp]
  00139	52		 push	 edx
  0013a	57		 push	 edi
  0013b	c6 45 f4 02	 mov	 BYTE PTR _pMsg$[ebp+4], 2
  0013f	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 318  : 			LeaveCriticalSection(&m_sCrit);

  00144	8b 45 0c	 mov	 eax, DWORD PTR tv287[ebp]
  00147	83 c4 1c	 add	 esp, 28			; 0000001cH
  0014a	50		 push	 eax
  0014b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  00151	5f		 pop	 edi
  00152	5e		 pop	 esi
  00153	5b		 pop	 ebx

; 372  : }

  00154	8b e5		 mov	 esp, ebp
  00156	5d		 pop	 ebp
  00157	c2 08 00	 ret	 8
$LN4@EnterReque:

; 319  : 			return;
; 320  : 		}
; 321  : 	}
; 322  : 
; 323  : 
; 324  : 	int bFail = FALSE;
; 325  : 
; 326  : #if (ENABLE_FIX_PARTYPK == 1)
; 327  : 
; 328  : 	if( lpObj->m_PK_Level >= 4 )

  0015a	80 be 19 01 00
	00 04		 cmp	 BYTE PTR [esi+281], 4
  00161	7c 3d		 jl	 SHORT $LN2@EnterReque

; 329  : 	{
; 330  : 		bFail = TRUE;
; 331  : 	}
; 332  : 
; 333  : #else
; 334  : 	if ( lpObj->PartyNumber >= 0 )
; 335  : 	{
; 336  : 		if( gParty.GetPartyPkLevel(lpObj->PartyNumber) >= 5 )
; 337  : 		{
; 338  : 			bFail = TRUE;
; 339  : 		}
; 340  : 	}
; 341  : 	else if( lpObj->m_PK_Level >= 4 )
; 342  : 	{
; 343  : 		bFail = TRUE;
; 344  : 	}
; 345  : #endif
; 346  : 
; 347  : 	if( bFail == TRUE )
; 348  : 	{
; 349  : 		LogAddTD("[Doppelganger][%d](%s)(%s) Enter request failed - pk status",aIndex,lpObj->AccountID,lpObj->Name);

  00163	8d 4e 5d	 lea	 ecx, DWORD PTR [esi+93]
  00166	51		 push	 ecx
  00167	83 c6 52	 add	 esi, 82			; 00000052H
  0016a	56		 push	 esi
  0016b	57		 push	 edi
  0016c	68 00 00 00 00	 push	 OFFSET ??_C@_0DM@ENOPDFGO@?$FLDoppelganger?$FN?$FL?$CFd?$FN?$CI?$CFs?$CJ?$CI?$CFs?$CJ?5Enter@
  00171	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 350  : 		pMsg.btResult = 3;
; 351  : 		DataSend(aIndex,(LPBYTE)&pMsg,pMsg.h.size);

  00177	0f b6 55 f1	 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  0017b	52		 push	 edx
  0017c	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0017f	50		 push	 eax
  00180	57		 push	 edi
  00181	c6 45 f4 03	 mov	 BYTE PTR _pMsg$[ebp+4], 3
  00185	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 352  : 		LeaveCriticalSection(&m_sCrit);

  0018a	8b 4d 0c	 mov	 ecx, DWORD PTR tv287[ebp]
  0018d	83 c4 1c	 add	 esp, 28			; 0000001cH
  00190	51		 push	 ecx
  00191	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  00197	5f		 pop	 edi
  00198	5e		 pop	 esi
  00199	5b		 pop	 ebx

; 372  : }

  0019a	8b e5		 mov	 esp, ebp
  0019c	5d		 pop	 ebp
  0019d	c2 08 00	 ret	 8
$LN2@EnterReque:

; 353  : 		return;
; 354  : 	}
; 355  : 
; 356  : 	lpObj->m_IfState.use = 0;
; 357  : 	lpObj->m_IfState.type = 0;
; 358  : 
; 359  : 	gObjInventoryItemSet(aIndex, invPos, -1);

  001a0	8b 55 fc	 mov	 edx, DWORD PTR _invPos$[ebp]
  001a3	81 a6 b8 11 00
	00 3c 00 ff ff	 and	 DWORD PTR [esi+4536], -65476 ; ffff003cH
  001ad	68 ff 00 00 00	 push	 255			; 000000ffH
  001b2	52		 push	 edx
  001b3	57		 push	 edi
  001b4	e8 00 00 00 00	 call	 ?gObjInventoryItemSet@@YAXHHE@Z ; gObjInventoryItemSet

; 360  : 	gObj[aIndex].pInventory[invPos].Clear();

  001b9	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001be	8b 4d f8	 mov	 ecx, DWORD PTR tv256[ebp]
  001c1	8b 8c 01 c0 11
	00 00		 mov	 ecx, DWORD PTR [ecx+eax+4544]
  001c8	03 4d 08	 add	 ecx, DWORD PTR tv278[ebp]
  001cb	83 c4 0c	 add	 esp, 12			; 0000000cH
  001ce	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 361  : 	GCInventoryItemDeleteSend(aIndex, invPos, 1);

  001d3	8b 55 fc	 mov	 edx, DWORD PTR _invPos$[ebp]
  001d6	6a 01		 push	 1
  001d8	52		 push	 edx
  001d9	57		 push	 edi
  001da	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  001df	83 c4 0c	 add	 esp, 12			; 0000000cH

; 362  : 
; 363  : 	if( m_iLeaderIndex == -1 )

  001e2	83 bb 80 00 00
	00 ff		 cmp	 DWORD PTR [ebx+128], -1
  001e9	75 11		 jne	 SHORT $LN1@EnterReque

; 364  : 	{
; 365  : 		m_iLeaderIndex = lpObj->m_Index;

  001eb	8b 06		 mov	 eax, DWORD PTR [esi]

; 366  : 		SetState(DOUBLEGOER_STATE_WAITING);

  001ed	6a 01		 push	 1
  001ef	8b cb		 mov	 ecx, ebx
  001f1	89 83 80 00 00
	00		 mov	 DWORD PTR [ebx+128], eax
  001f7	e8 00 00 00 00	 call	 ?SetState@CDoubleGoerEvent@@QAEXH@Z ; CDoubleGoerEvent::SetState
$LN1@EnterReque:

; 367  : 	}
; 368  : 
; 369  : 	AddUser(lpObj->m_Index);

  001fc	8b 0e		 mov	 ecx, DWORD PTR [esi]
  001fe	51		 push	 ecx
  001ff	8b cb		 mov	 ecx, ebx
  00201	e8 00 00 00 00	 call	 ?AddUser@CDoubleGoerEvent@@QAEHH@Z ; CDoubleGoerEvent::AddUser

; 370  : 	DataSend(aIndex,(LPBYTE)&pMsg,pMsg.h.size);

  00206	0f b6 55 f1	 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  0020a	52		 push	 edx
  0020b	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0020e	50		 push	 eax
  0020f	57		 push	 edi
  00210	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 371  : 	LeaveCriticalSection(&m_sCrit);

  00215	8b 4d 0c	 mov	 ecx, DWORD PTR tv287[ebp]
  00218	83 c4 0c	 add	 esp, 12			; 0000000cH
  0021b	51		 push	 ecx
  0021c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  00222	5f		 pop	 edi
  00223	5e		 pop	 esi
  00224	5b		 pop	 ebx

; 372  : }

  00225	8b e5		 mov	 esp, ebp
  00227	5d		 pop	 ebp
  00228	c2 08 00	 ret	 8
$LN9@EnterReque:

; 290  : 	{
; 291  : 		LogAddTD("[Doppelganger][ERROR] Inventory item error - [%d](%s)(%s)",aIndex,lpObj->AccountID,lpObj->Name);

  0022b	8d 56 5d	 lea	 edx, DWORD PTR [esi+93]
  0022e	52		 push	 edx
  0022f	83 c6 52	 add	 esi, 82			; 00000052H
  00232	56		 push	 esi
  00233	57		 push	 edi
  00234	68 00 00 00 00	 push	 OFFSET ??_C@_0DK@BAGOCEPD@?$FLDoppelganger?$FN?$FLERROR?$FN?5Inventory?5@

; 292  : 		DataSend(aIndex,(LPBYTE)&pMsg,pMsg.h.size);
; 293  : 		return;

  00239	eb 0e		 jmp	 SHORT $LN22@EnterReque
$LN12@EnterReque:

; 273  : 	{
; 274  : 		LogAddTD("[Doppelganger][ERROR] Not talked with Lugard [%d](%s)(%s)",aIndex,lpObj->AccountID,lpObj->Name);

  0023b	8d 56 5d	 lea	 edx, DWORD PTR [esi+93]
  0023e	52		 push	 edx
  0023f	83 c6 52	 add	 esi, 82			; 00000052H
  00242	56		 push	 esi
  00243	57		 push	 edi
  00244	68 00 00 00 00	 push	 OFFSET ??_C@_0DK@FGCCIFBE@?$FLDoppelganger?$FN?$FLERROR?$FN?5Not?5talked@
$LN22@EnterReque:
  00249	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 275  : 		DataSend(aIndex,(LPBYTE)&pMsg,pMsg.h.size);

  0024f	0f b6 45 f1	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00253	50		 push	 eax
  00254	8d 4d f0	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00257	51		 push	 ecx
  00258	57		 push	 edi
  00259	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0025e	83 c4 1c	 add	 esp, 28			; 0000001cH
  00261	5f		 pop	 edi
  00262	5e		 pop	 esi
  00263	5b		 pop	 ebx

; 372  : }

  00264	8b e5		 mov	 esp, ebp
  00266	5d		 pop	 ebp
  00267	c2 08 00	 ret	 8
?EnterRequest@CDoubleGoerEvent@@QAEXPAUPMSG_DOUBLEGOER_REQ_ENTER@@H@Z ENDP ; CDoubleGoerEvent::EnterRequest
_TEXT	ENDS
PUBLIC	?ProcState_WAITING@CDoubleGoerEvent@@QAEXXZ	; CDoubleGoerEvent::ProcState_WAITING
; Function compile flags: /Ogtp
;	COMDAT ?ProcState_WAITING@CDoubleGoerEvent@@QAEXXZ
_TEXT	SEGMENT
_pMsg$183737 = -4					; size = 4
?ProcState_WAITING@CDoubleGoerEvent@@QAEXXZ PROC	; CDoubleGoerEvent::ProcState_WAITING, COMDAT
; _this$ = ecx

; 438  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx

; 439  : 	DWORD dwTICK = GetTickCount() - m_dwTICK_COUNT;

  00005	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__GetTickCount@0
  0000b	56		 push	 esi
  0000c	57		 push	 edi
  0000d	8b f1		 mov	 esi, ecx
  0000f	ff d3		 call	 ebx
  00011	8b f8		 mov	 edi, eax
  00013	2b 7e 2c	 sub	 edi, DWORD PTR [esi+44]

; 440  : 
; 441  : 	if( dwTICK >= 500 )

  00016	81 ff f4 01 00
	00		 cmp	 edi, 500		; 000001f4H
  0001c	72 46		 jb	 SHORT $LN9@ProcState_

; 442  : 	{
; 443  : 		m_dwTICK_COUNT = GetTickCount();

  0001e	ff d3		 call	 ebx

; 444  : 		m_iREMAIN_TIME -= dwTICK;

  00020	29 7e 28	 sub	 DWORD PTR [esi+40], edi

; 445  : 
; 446  : 		if( m_bMSG_BEFORE_START == 0 && m_iREMAIN_TIME <= 30000 )

  00023	83 7e 44 00	 cmp	 DWORD PTR [esi+68], 0
  00027	89 46 2c	 mov	 DWORD PTR [esi+44], eax
  0002a	8b 46 28	 mov	 eax, DWORD PTR [esi+40]
  0002d	75 35		 jne	 SHORT $LN9@ProcState_
  0002f	3d 30 75 00 00	 cmp	 eax, 30000		; 00007530H
  00034	7f 2e		 jg	 SHORT $LN9@ProcState_

; 447  : 		{
; 448  : 			m_bMSG_BEFORE_START = TRUE;
; 449  : 
; 450  : 			PMSG_SET_DEVILSQUARE pMsg;
; 451  : 			PHeadSetB((LPBYTE)&pMsg, 0x92, sizeof(pMsg));

  00036	6a 04		 push	 4
  00038	8d 45 fc	 lea	 eax, DWORD PTR _pMsg$183737[ebp]
  0003b	68 92 00 00 00	 push	 146			; 00000092H
  00040	50		 push	 eax
  00041	c7 46 44 01 00
	00 00		 mov	 DWORD PTR [esi+68], 1
  00048	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 452  : 			pMsg.Type = 17;
; 453  : 
; 454  : 			SendData((LPBYTE)&pMsg,pMsg.h.size);

  0004d	0f b6 4d fd	 movzx	 ecx, BYTE PTR _pMsg$183737[ebp+1]
  00051	83 c4 0c	 add	 esp, 12			; 0000000cH
  00054	51		 push	 ecx
  00055	8d 55 fc	 lea	 edx, DWORD PTR _pMsg$183737[ebp]
  00058	52		 push	 edx
  00059	8b ce		 mov	 ecx, esi
  0005b	c6 45 ff 11	 mov	 BYTE PTR _pMsg$183737[ebp+3], 17 ; 00000011H
  0005f	e8 00 00 00 00	 call	 ?SendData@CDoubleGoerEvent@@QAEXPAEH@Z ; CDoubleGoerEvent::SendData
$LN9@ProcState_:

; 455  : 		}
; 456  : 	}
; 457  : 
; 458  : 	if( m_iREMAIN_TIME <= 0 )

  00064	83 7e 28 00	 cmp	 DWORD PTR [esi+40], 0
  00068	7f 10		 jg	 SHORT $LN4@ProcState_

; 459  : 	{
; 460  : 		SetState(DOUBLEGOER_STATE_PLAYING);

  0006a	6a 02		 push	 2

; 463  : 	{
; 464  : 		SetState(DOUBLEGOER_STATE_CLOSED);

  0006c	8b ce		 mov	 ecx, esi
  0006e	e8 00 00 00 00	 call	 ?SetState@CDoubleGoerEvent@@QAEXH@Z ; CDoubleGoerEvent::SetState
  00073	5f		 pop	 edi
  00074	5e		 pop	 esi
  00075	5b		 pop	 ebx

; 465  : 	}
; 466  : }

  00076	8b e5		 mov	 esp, ebp
  00078	5d		 pop	 ebp
  00079	c3		 ret	 0
$LN4@ProcState_:

; 461  : 	}
; 462  : 	else if( m_iPlayerCount <= 0 || m_iLeaderIndex == -1 )

  0007a	83 7e 34 00	 cmp	 DWORD PTR [esi+52], 0
  0007e	7e 09		 jle	 SHORT $LN1@ProcState_
  00080	83 be 80 00 00
	00 ff		 cmp	 DWORD PTR [esi+128], -1
  00087	75 09		 jne	 SHORT $LN2@ProcState_
$LN1@ProcState_:

; 463  : 	{
; 464  : 		SetState(DOUBLEGOER_STATE_CLOSED);

  00089	6a 00		 push	 0
  0008b	8b ce		 mov	 ecx, esi
  0008d	e8 00 00 00 00	 call	 ?SetState@CDoubleGoerEvent@@QAEXH@Z ; CDoubleGoerEvent::SetState
$LN2@ProcState_:
  00092	5f		 pop	 edi
  00093	5e		 pop	 esi
  00094	5b		 pop	 ebx

; 465  : 	}
; 466  : }

  00095	8b e5		 mov	 esp, ebp
  00097	5d		 pop	 ebp
  00098	c3		 ret	 0
?ProcState_WAITING@CDoubleGoerEvent@@QAEXXZ ENDP	; CDoubleGoerEvent::ProcState_WAITING
_TEXT	ENDS
PUBLIC	?ProcState_PLAYING@CDoubleGoerEvent@@QAEXXZ	; CDoubleGoerEvent::ProcState_PLAYING
; Function compile flags: /Ogtp
;	COMDAT ?ProcState_PLAYING@CDoubleGoerEvent@@QAEXXZ
_TEXT	SEGMENT
_pMsg$183767 = -4					; size = 4
?ProcState_PLAYING@CDoubleGoerEvent@@QAEXXZ PROC	; CDoubleGoerEvent::ProcState_PLAYING, COMDAT
; _this$ = ecx

; 469  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx

; 470  : 	DWORD dwTICK = GetTickCount() - m_dwTICK_COUNT;

  00005	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__GetTickCount@0
  0000b	56		 push	 esi
  0000c	57		 push	 edi
  0000d	8b f1		 mov	 esi, ecx
  0000f	ff d3		 call	 ebx
  00011	8b f8		 mov	 edi, eax
  00013	2b 7e 2c	 sub	 edi, DWORD PTR [esi+44]

; 471  : 
; 472  : 	if( dwTICK >= 500 )

  00016	81 ff f4 01 00
	00		 cmp	 edi, 500		; 000001f4H
  0001c	0f 82 49 02 00
	00		 jb	 $LN32@ProcState_@2

; 473  : 	{
; 474  : 		m_dwTICK_COUNT = GetTickCount();

  00022	ff d3		 call	 ebx

; 475  : 		m_iREMAIN_TIME -= dwTICK;

  00024	29 7e 28	 sub	 DWORD PTR [esi+40], edi

; 476  : 
; 477  : 		if( m_bSEND_PLAY_START == FALSE )

  00027	83 7e 54 00	 cmp	 DWORD PTR [esi+84], 0
  0002b	89 46 2c	 mov	 DWORD PTR [esi+44], eax
  0002e	75 5b		 jne	 SHORT $LN18@ProcState_@2

; 478  : 		{
; 479  : 			m_iREMAIN_TIME = m_iEVENT_TIME*60*1000;

  00030	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00033	69 c0 60 ea 00
	00		 imul	 eax, 60000		; 0000ea60H

; 480  : 
; 481  : 			SummonMonster();

  00039	8b ce		 mov	 ecx, esi
  0003b	89 46 28	 mov	 DWORD PTR [esi+40], eax
  0003e	e8 00 00 00 00	 call	 ?SummonMonster@CDoubleGoerEvent@@QAEXXZ ; CDoubleGoerEvent::SummonMonster

; 482  : 			SendStart();

  00043	8b ce		 mov	 ecx, esi
  00045	e8 00 00 00 00	 call	 ?SendStart@CDoubleGoerEvent@@QAEXXZ ; CDoubleGoerEvent::SendStart

; 483  : 			SendMonsterCount();

  0004a	8b ce		 mov	 ecx, esi
  0004c	e8 00 00 00 00	 call	 ?SendMonsterCount@CDoubleGoerEvent@@QAEXXZ ; CDoubleGoerEvent::SendMonsterCount
  00051	8d be 88 00 00
	00		 lea	 edi, DWORD PTR [esi+136]
  00057	bb 05 00 00 00	 mov	 ebx, 5
  0005c	8d 64 24 00	 npad	 4
$LL20@ProcState_@2:

; 486  : 			{
; 487  : 				if( OBJMAX_RANGE(m_PlayerInfo[i].aIndex) )

  00060	8b 07		 mov	 eax, DWORD PTR [edi]
  00062	85 c0		 test	 eax, eax
  00064	78 1f		 js	 SHORT $LN19@ProcState_@2
  00066	33 c9		 xor	 ecx, ecx
  00068	3d eb 2c 00 00	 cmp	 eax, 11499		; 00002cebH
  0006d	0f 9e c1	 setle	 cl
  00070	85 c9		 test	 ecx, ecx
  00072	74 11		 je	 SHORT $LN19@ProcState_@2

; 488  : 				{
; 489  : 					SendBlockInfo(m_PlayerInfo[i].aIndex,m_iCurentMap - MAP_INDEX_DOUBLEGOER1,1);

  00074	8b 4e 30	 mov	 ecx, DWORD PTR [esi+48]
  00077	6a 01		 push	 1
  00079	83 e9 41	 sub	 ecx, 65			; 00000041H
  0007c	51		 push	 ecx
  0007d	50		 push	 eax
  0007e	8b ce		 mov	 ecx, esi
  00080	e8 00 00 00 00	 call	 ?SendBlockInfo@CDoubleGoerEvent@@QAEXHHH@Z ; CDoubleGoerEvent::SendBlockInfo
$LN19@ProcState_@2:

; 484  : 
; 485  : 			for(int i = 0; i < DOUBLEGOER_MAXPLAYER; i++)

  00085	83 c7 08	 add	 edi, 8
  00088	4b		 dec	 ebx
  00089	75 d5		 jne	 SHORT $LL20@ProcState_@2
$LN18@ProcState_@2:

; 490  : 				}
; 491  : 			}
; 492  : 		}
; 493  : 
; 494  : 		if( m_bSEND_PLAY_START == TRUE )

  0008b	bb 01 00 00 00	 mov	 ebx, 1
  00090	39 5e 54	 cmp	 DWORD PTR [esi+84], ebx
  00093	0f 85 d2 01 00
	00		 jne	 $LN32@ProcState_@2

; 495  : 		{
; 496  : 			CalcDistance();

  00099	8b ce		 mov	 ecx, esi
  0009b	e8 00 00 00 00	 call	 ?CalcDistance@CDoubleGoerEvent@@QAEXXZ ; CDoubleGoerEvent::CalcDistance

; 497  : 			SendPlayInfo();

  000a0	8b ce		 mov	 ecx, esi
  000a2	e8 00 00 00 00	 call	 ?SendPlayInfo@CDoubleGoerEvent@@QAEXXZ ; CDoubleGoerEvent::SendPlayInfo

; 498  : 			SendWaveInfo();

  000a7	8b ce		 mov	 ecx, esi
  000a9	e8 00 00 00 00	 call	 ?SendWaveInfo@CDoubleGoerEvent@@QAEXXZ ; CDoubleGoerEvent::SendWaveInfo

; 499  : 			SendBossInfo(m_iBossIndex);

  000ae	8b 56 64	 mov	 edx, DWORD PTR [esi+100]
  000b1	52		 push	 edx
  000b2	8b ce		 mov	 ecx, esi
  000b4	e8 00 00 00 00	 call	 ?SendBossInfo@CDoubleGoerEvent@@QAEXH@Z ; CDoubleGoerEvent::SendBossInfo

; 500  : 
; 501  : 			if( m_bSUMMON_1ST_BOSS == FALSE && m_iREMAIN_TIME <= ((m_iEVENT_TIME*60*1000)-60000) )

  000b9	83 7e 58 00	 cmp	 DWORD PTR [esi+88], 0
  000bd	75 55		 jne	 SHORT $LN15@ProcState_@2
  000bf	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  000c2	69 c0 60 ea 00
	00		 imul	 eax, 60000		; 0000ea60H
  000c8	2d 60 ea 00 00	 sub	 eax, 60000		; 0000ea60H
  000cd	39 46 28	 cmp	 DWORD PTR [esi+40], eax
  000d0	7f 42		 jg	 SHORT $LN15@ProcState_@2

; 502  : 			{
; 503  : 				SummonMonster(529,m_iCurentMap,g_DoubleGoerEvent_DefPts[m_iCurentMap-MAP_INDEX_DOUBLEGOER1].ptX,g_DoubleGoerEvent_DefPts[m_iCurentMap-MAP_INDEX_DOUBLEGOER1].ptY,m_EventLevel, m_EventReset);

  000d2	8b 4e 30	 mov	 ecx, DWORD PTR [esi+48]
  000d5	8b 96 58 02 00
	00		 mov	 edx, DWORD PTR [esi+600]
  000db	52		 push	 edx
  000dc	8b 96 5c 02 00
	00		 mov	 edx, DWORD PTR [esi+604]
  000e2	8d 84 49 3d ff
	ff ff		 lea	 eax, DWORD PTR [ecx+ecx*2-195]
  000e9	03 c0		 add	 eax, eax
  000eb	52		 push	 edx
  000ec	0f b6 94 00 03
	00 00 00	 movzx	 edx, BYTE PTR ?g_DoubleGoerEvent_DefPts@@3PAUDOUBLEGOER_DEFPOINTS@@A[eax+eax+3]
  000f4	03 c0		 add	 eax, eax
  000f6	0f b6 80 02 00
	00 00		 movzx	 eax, BYTE PTR ?g_DoubleGoerEvent_DefPts@@3PAUDOUBLEGOER_DEFPOINTS@@A[eax+2]
  000fd	52		 push	 edx
  000fe	50		 push	 eax
  000ff	51		 push	 ecx
  00100	68 11 02 00 00	 push	 529			; 00000211H
  00105	8b ce		 mov	 ecx, esi
  00107	e8 00 00 00 00	 call	 ?SummonMonster@CDoubleGoerEvent@@QAEHHHHHHH@Z ; CDoubleGoerEvent::SummonMonster

; 504  : 				m_bSUMMON_1ST_BOSS = TRUE;

  0010c	89 5e 58	 mov	 DWORD PTR [esi+88], ebx
  0010f	e9 ad 00 00 00	 jmp	 $LN11@ProcState_@2
$LN15@ProcState_@2:

; 505  : 			}
; 506  : 			else if( m_bSUMMON_2ND_BOSS == FALSE && m_iREMAIN_TIME <= ((m_iEVENT_TIME*60*1000)-3*60000) )

  00114	83 7e 5c 00	 cmp	 DWORD PTR [esi+92], 0
  00118	75 50		 jne	 SHORT $LN31@ProcState_@2
  0011a	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  0011d	83 e9 03	 sub	 ecx, 3
  00120	69 c9 60 ea 00
	00		 imul	 ecx, 60000		; 0000ea60H
  00126	39 4e 28	 cmp	 DWORD PTR [esi+40], ecx
  00129	7f 3f		 jg	 SHORT $LN31@ProcState_@2

; 507  : 			{
; 508  : 				SummonMonster(530,m_iCurentMap,g_DoubleGoerEvent_DefPts[m_iCurentMap-MAP_INDEX_DOUBLEGOER1].ptX,g_DoubleGoerEvent_DefPts[m_iCurentMap-MAP_INDEX_DOUBLEGOER1].ptY,m_EventLevel, m_EventReset);

  0012b	8b 4e 30	 mov	 ecx, DWORD PTR [esi+48]
  0012e	8b 96 58 02 00
	00		 mov	 edx, DWORD PTR [esi+600]
  00134	52		 push	 edx
  00135	8b 96 5c 02 00
	00		 mov	 edx, DWORD PTR [esi+604]
  0013b	8d 84 49 3d ff
	ff ff		 lea	 eax, DWORD PTR [ecx+ecx*2-195]
  00142	03 c0		 add	 eax, eax
  00144	52		 push	 edx
  00145	0f b6 94 00 03
	00 00 00	 movzx	 edx, BYTE PTR ?g_DoubleGoerEvent_DefPts@@3PAUDOUBLEGOER_DEFPOINTS@@A[eax+eax+3]
  0014d	03 c0		 add	 eax, eax
  0014f	0f b6 80 02 00
	00 00		 movzx	 eax, BYTE PTR ?g_DoubleGoerEvent_DefPts@@3PAUDOUBLEGOER_DEFPOINTS@@A[eax+2]
  00156	52		 push	 edx
  00157	50		 push	 eax
  00158	51		 push	 ecx
  00159	68 12 02 00 00	 push	 530			; 00000212H
  0015e	8b ce		 mov	 ecx, esi
  00160	e8 00 00 00 00	 call	 ?SummonMonster@CDoubleGoerEvent@@QAEHHHHHHH@Z ; CDoubleGoerEvent::SummonMonster

; 509  : 				m_bSUMMON_2ND_BOSS = TRUE;

  00165	89 5e 5c	 mov	 DWORD PTR [esi+92], ebx
  00168	eb 57		 jmp	 SHORT $LN11@ProcState_@2
$LN31@ProcState_@2:

; 510  : 			}
; 511  : 			else if( m_bSUMMON_3RD_BOSS == FALSE && m_iREMAIN_TIME <= ((m_iEVENT_TIME*60*1000)-6*60000) )

  0016a	83 7e 60 00	 cmp	 DWORD PTR [esi+96], 0
  0016e	75 51		 jne	 SHORT $LN11@ProcState_@2
  00170	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00173	83 e9 06	 sub	 ecx, 6
  00176	69 c9 60 ea 00
	00		 imul	 ecx, 60000		; 0000ea60H
  0017c	39 4e 28	 cmp	 DWORD PTR [esi+40], ecx
  0017f	7f 40		 jg	 SHORT $LN11@ProcState_@2

; 512  : 			{
; 513  : 				m_iBossIndex = SummonMonster(531,m_iCurentMap,g_DoubleGoerEvent_DefPts[m_iCurentMap-MAP_INDEX_DOUBLEGOER1].ptX,g_DoubleGoerEvent_DefPts[m_iCurentMap-MAP_INDEX_DOUBLEGOER1].ptY,m_EventLevel, m_EventReset);

  00181	8b 4e 30	 mov	 ecx, DWORD PTR [esi+48]
  00184	8b 96 58 02 00
	00		 mov	 edx, DWORD PTR [esi+600]
  0018a	52		 push	 edx
  0018b	8b 96 5c 02 00
	00		 mov	 edx, DWORD PTR [esi+604]
  00191	8d 84 49 3d ff
	ff ff		 lea	 eax, DWORD PTR [ecx+ecx*2-195]
  00198	03 c0		 add	 eax, eax
  0019a	52		 push	 edx
  0019b	0f b6 94 00 03
	00 00 00	 movzx	 edx, BYTE PTR ?g_DoubleGoerEvent_DefPts@@3PAUDOUBLEGOER_DEFPOINTS@@A[eax+eax+3]
  001a3	03 c0		 add	 eax, eax
  001a5	0f b6 80 02 00
	00 00		 movzx	 eax, BYTE PTR ?g_DoubleGoerEvent_DefPts@@3PAUDOUBLEGOER_DEFPOINTS@@A[eax+2]
  001ac	52		 push	 edx
  001ad	50		 push	 eax
  001ae	51		 push	 ecx
  001af	68 13 02 00 00	 push	 531			; 00000213H
  001b4	8b ce		 mov	 ecx, esi
  001b6	e8 00 00 00 00	 call	 ?SummonMonster@CDoubleGoerEvent@@QAEHHHHHHH@Z ; CDoubleGoerEvent::SummonMonster
  001bb	89 46 64	 mov	 DWORD PTR [esi+100], eax

; 514  : 				m_bSUMMON_3RD_BOSS = TRUE;

  001be	89 5e 60	 mov	 DWORD PTR [esi+96], ebx
$LN11@ProcState_@2:

; 515  : 			}
; 516  : 
; 517  : 			if( m_iMONSTER_MINUTE_SPAWN != (m_iREMAIN_TIME/60000) )

  001c1	b8 73 b2 e7 45	 mov	 eax, 1172812403		; 45e7b273H
  001c6	f7 6e 28	 imul	 DWORD PTR [esi+40]
  001c9	c1 fa 0e	 sar	 edx, 14			; 0000000eH
  001cc	8b c2		 mov	 eax, edx
  001ce	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  001d1	03 c2		 add	 eax, edx
  001d3	39 46 40	 cmp	 DWORD PTR [esi+64], eax
  001d6	74 5a		 je	 SHORT $LN34@ProcState_@2

; 518  : 			{
; 519  : 				m_iMONSTER_MINUTE_SPAWN = (m_iREMAIN_TIME/60000);
; 520  : 
; 521  : 				for(int i = 0; i < m_iMONSTER_PER_MINUTE; i++)

  001d8	33 ff		 xor	 edi, edi
  001da	89 46 40	 mov	 DWORD PTR [esi+64], eax
  001dd	39 7e 20	 cmp	 DWORD PTR [esi+32], edi
  001e0	7e 50		 jle	 SHORT $LN34@ProcState_@2
$LL9@ProcState_@2:

; 522  : 				{
; 523  : 					SummonMonster(533+rand()%7,m_iCurentMap,g_DoubleGoerEvent_DefPts[m_iCurentMap-MAP_INDEX_DOUBLEGOER1].ptX,g_DoubleGoerEvent_DefPts[m_iCurentMap-MAP_INDEX_DOUBLEGOER1].ptY,m_EventLevel, m_EventReset);

  001e2	8b 4e 30	 mov	 ecx, DWORD PTR [esi+48]
  001e5	8b 96 58 02 00
	00		 mov	 edx, DWORD PTR [esi+600]
  001eb	52		 push	 edx
  001ec	8b 96 5c 02 00
	00		 mov	 edx, DWORD PTR [esi+604]
  001f2	8d 84 49 3d ff
	ff ff		 lea	 eax, DWORD PTR [ecx+ecx*2-195]
  001f9	03 c0		 add	 eax, eax
  001fb	52		 push	 edx
  001fc	0f b6 94 00 03
	00 00 00	 movzx	 edx, BYTE PTR ?g_DoubleGoerEvent_DefPts@@3PAUDOUBLEGOER_DEFPOINTS@@A[eax+eax+3]
  00204	03 c0		 add	 eax, eax
  00206	0f b6 80 02 00
	00 00		 movzx	 eax, BYTE PTR ?g_DoubleGoerEvent_DefPts@@3PAUDOUBLEGOER_DEFPOINTS@@A[eax+2]
  0020d	52		 push	 edx
  0020e	50		 push	 eax
  0020f	51		 push	 ecx
  00210	e8 00 00 00 00	 call	 _rand
  00215	99		 cdq
  00216	b9 07 00 00 00	 mov	 ecx, 7
  0021b	f7 f9		 idiv	 ecx
  0021d	8b ce		 mov	 ecx, esi
  0021f	81 c2 15 02 00
	00		 add	 edx, 533		; 00000215H
  00225	52		 push	 edx
  00226	e8 00 00 00 00	 call	 ?SummonMonster@CDoubleGoerEvent@@QAEHHHHHHH@Z ; CDoubleGoerEvent::SummonMonster
  0022b	03 fb		 add	 edi, ebx
  0022d	3b 7e 20	 cmp	 edi, DWORD PTR [esi+32]
  00230	7c b0		 jl	 SHORT $LL9@ProcState_@2
$LN34@ProcState_@2:

; 524  : 				}
; 525  : 			}
; 526  : 
; 527  : 			if( m_bMSG_BEFORE_TIMEOUT == FALSE && m_iREMAIN_TIME <= 30000 )

  00232	83 7e 4c 00	 cmp	 DWORD PTR [esi+76], 0
  00236	75 33		 jne	 SHORT $LN32@ProcState_@2
  00238	81 7e 28 30 75
	00 00		 cmp	 DWORD PTR [esi+40], 30000 ; 00007530H
  0023f	7f 2a		 jg	 SHORT $LN32@ProcState_@2

; 528  : 			{
; 529  : 				m_bMSG_BEFORE_TIMEOUT = TRUE;
; 530  : 
; 531  : 				PMSG_SET_DEVILSQUARE pMsg;
; 532  : 				PHeadSetB((LPBYTE)&pMsg, 0x92, sizeof(pMsg));

  00241	6a 04		 push	 4
  00243	8d 55 fc	 lea	 edx, DWORD PTR _pMsg$183767[ebp]
  00246	68 92 00 00 00	 push	 146			; 00000092H
  0024b	52		 push	 edx
  0024c	89 5e 4c	 mov	 DWORD PTR [esi+76], ebx
  0024f	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 533  : 				pMsg.Type = 18;
; 534  : 
; 535  : 				SendData((LPBYTE)&pMsg,pMsg.h.size);

  00254	0f b6 45 fd	 movzx	 eax, BYTE PTR _pMsg$183767[ebp+1]
  00258	83 c4 0c	 add	 esp, 12			; 0000000cH
  0025b	50		 push	 eax
  0025c	8d 4d fc	 lea	 ecx, DWORD PTR _pMsg$183767[ebp]
  0025f	51		 push	 ecx
  00260	8b ce		 mov	 ecx, esi
  00262	c6 45 ff 12	 mov	 BYTE PTR _pMsg$183767[ebp+3], 18 ; 00000012H
  00266	e8 00 00 00 00	 call	 ?SendData@CDoubleGoerEvent@@QAEXPAEH@Z ; CDoubleGoerEvent::SendData
$LN32@ProcState_@2:

; 536  : 			}
; 537  : 		}
; 538  : 	}
; 539  : 
; 540  : 	if( m_iREMAIN_TIME <= 0 || m_iMonsterPassed >= 3 )

  0026b	83 7e 28 00	 cmp	 DWORD PTR [esi+40], 0
  0026f	7e 25		 jle	 SHORT $LN35@ProcState_@2
  00271	83 7e 38 03	 cmp	 DWORD PTR [esi+56], 3
  00275	7d 1f		 jge	 SHORT $LN35@ProcState_@2

; 543  : 	}
; 544  : 	else if( m_iPlayerCount <= 0 || m_iLeaderIndex == -1 )

  00277	83 7e 34 00	 cmp	 DWORD PTR [esi+52], 0
  0027b	7e 09		 jle	 SHORT $LN1@ProcState_@2
  0027d	83 be 80 00 00
	00 ff		 cmp	 DWORD PTR [esi+128], -1
  00284	75 19		 jne	 SHORT $LN2@ProcState_@2
$LN1@ProcState_@2:

; 545  : 	{
; 546  : 		SetState(DOUBLEGOER_STATE_CLOSED);

  00286	6a 00		 push	 0
  00288	8b ce		 mov	 ecx, esi
  0028a	e8 00 00 00 00	 call	 ?SetState@CDoubleGoerEvent@@QAEXH@Z ; CDoubleGoerEvent::SetState
  0028f	5f		 pop	 edi
  00290	5e		 pop	 esi
  00291	5b		 pop	 ebx

; 547  : 	}
; 548  : }

  00292	8b e5		 mov	 esp, ebp
  00294	5d		 pop	 ebp
  00295	c3		 ret	 0
$LN35@ProcState_@2:

; 541  : 	{
; 542  : 		SetState(DOUBLEGOER_STATE_PLAYEND);

  00296	6a 03		 push	 3
  00298	8b ce		 mov	 ecx, esi
  0029a	e8 00 00 00 00	 call	 ?SetState@CDoubleGoerEvent@@QAEXH@Z ; CDoubleGoerEvent::SetState
$LN2@ProcState_@2:
  0029f	5f		 pop	 edi
  002a0	5e		 pop	 esi
  002a1	5b		 pop	 ebx

; 547  : 	}
; 548  : }

  002a2	8b e5		 mov	 esp, ebp
  002a4	5d		 pop	 ebp
  002a5	c3		 ret	 0
?ProcState_PLAYING@CDoubleGoerEvent@@QAEXXZ ENDP	; CDoubleGoerEvent::ProcState_PLAYING
_TEXT	ENDS
PUBLIC	?ProcState_PLAYEND@CDoubleGoerEvent@@QAEXXZ	; CDoubleGoerEvent::ProcState_PLAYEND
; Function compile flags: /Ogtp
;	COMDAT ?ProcState_PLAYEND@CDoubleGoerEvent@@QAEXXZ
_TEXT	SEGMENT
_pMsg$183781 = -4					; size = 4
?ProcState_PLAYEND@CDoubleGoerEvent@@QAEXXZ PROC	; CDoubleGoerEvent::ProcState_PLAYEND, COMDAT
; _this$ = ecx

; 551  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx

; 552  : 	DWORD dwTICK = GetTickCount() - m_dwTICK_COUNT;

  00005	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__GetTickCount@0
  0000b	56		 push	 esi
  0000c	57		 push	 edi
  0000d	8b f1		 mov	 esi, ecx
  0000f	ff d3		 call	 ebx
  00011	8b f8		 mov	 edi, eax
  00013	2b 7e 2c	 sub	 edi, DWORD PTR [esi+44]

; 553  : 
; 554  : 	if( dwTICK >= 1000 )

  00016	81 ff e8 03 00
	00		 cmp	 edi, 1000		; 000003e8H
  0001c	72 46		 jb	 SHORT $LN6@ProcState_@3

; 555  : 	{
; 556  : 		m_dwTICK_COUNT = GetTickCount();

  0001e	ff d3		 call	 ebx

; 557  : 		m_iREMAIN_TIME -= dwTICK;

  00020	29 7e 28	 sub	 DWORD PTR [esi+40], edi

; 558  : 
; 559  : 		if( m_bMSG_BEFORE_END == FALSE && m_iREMAIN_TIME <= 30000 )

  00023	83 7e 50 00	 cmp	 DWORD PTR [esi+80], 0
  00027	89 46 2c	 mov	 DWORD PTR [esi+44], eax
  0002a	8b 46 28	 mov	 eax, DWORD PTR [esi+40]
  0002d	75 35		 jne	 SHORT $LN6@ProcState_@3
  0002f	3d 30 75 00 00	 cmp	 eax, 30000		; 00007530H
  00034	7f 2e		 jg	 SHORT $LN6@ProcState_@3

; 560  : 		{
; 561  : 			m_bMSG_BEFORE_END = TRUE;
; 562  : 
; 563  : 			PMSG_SET_DEVILSQUARE pMsg;
; 564  : 			PHeadSetB((LPBYTE)&pMsg, 0x92, sizeof(pMsg));

  00036	6a 04		 push	 4
  00038	8d 45 fc	 lea	 eax, DWORD PTR _pMsg$183781[ebp]
  0003b	68 92 00 00 00	 push	 146			; 00000092H
  00040	50		 push	 eax
  00041	c7 46 50 01 00
	00 00		 mov	 DWORD PTR [esi+80], 1
  00048	e8 00 00 00 00	 call	 ?PHeadSetB@@YAXPAEEH@Z	; PHeadSetB

; 565  : 			pMsg.Type = 19;
; 566  : 
; 567  : 			SendData((LPBYTE)&pMsg,pMsg.h.size);

  0004d	0f b6 4d fd	 movzx	 ecx, BYTE PTR _pMsg$183781[ebp+1]
  00051	83 c4 0c	 add	 esp, 12			; 0000000cH
  00054	51		 push	 ecx
  00055	8d 55 fc	 lea	 edx, DWORD PTR _pMsg$183781[ebp]
  00058	52		 push	 edx
  00059	8b ce		 mov	 ecx, esi
  0005b	c6 45 ff 13	 mov	 BYTE PTR _pMsg$183781[ebp+3], 19 ; 00000013H
  0005f	e8 00 00 00 00	 call	 ?SendData@CDoubleGoerEvent@@QAEXPAEH@Z ; CDoubleGoerEvent::SendData
$LN6@ProcState_@3:

; 568  : 		}
; 569  : 	}
; 570  : 
; 571  : 	if( m_iREMAIN_TIME <= 0 )

  00064	83 7e 28 00	 cmp	 DWORD PTR [esi+40], 0
  00068	7f 09		 jg	 SHORT $LN1@ProcState_@3

; 572  : 	{
; 573  : 		SetState(DOUBLEGOER_STATE_CLOSED);

  0006a	6a 00		 push	 0
  0006c	8b ce		 mov	 ecx, esi
  0006e	e8 00 00 00 00	 call	 ?SetState@CDoubleGoerEvent@@QAEXH@Z ; CDoubleGoerEvent::SetState
$LN1@ProcState_@3:
  00073	5f		 pop	 edi
  00074	5e		 pop	 esi
  00075	5b		 pop	 ebx

; 574  : 	}
; 575  : }

  00076	8b e5		 mov	 esp, ebp
  00078	5d		 pop	 ebp
  00079	c3		 ret	 0
?ProcState_PLAYEND@CDoubleGoerEvent@@QAEXXZ ENDP	; CDoubleGoerEvent::ProcState_PLAYEND
_TEXT	ENDS
PUBLIC	?GetRewardBox@CDoubleGoerEvent@@QAEPAVEventItemBag@@HPAUOBJECTSTRUCT@@@Z ; CDoubleGoerEvent::GetRewardBox
; Function compile flags: /Ogtp
;	COMDAT ?GetRewardBox@CDoubleGoerEvent@@QAEPAVEventItemBag@@HPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_type$ = 8						; size = 4
_lpUser$ = 12						; size = 4
?GetRewardBox@CDoubleGoerEvent@@QAEPAVEventItemBag@@HPAUOBJECTSTRUCT@@@Z PROC ; CDoubleGoerEvent::GetRewardBox, COMDAT
; _this$ = ecx

; 1319 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1320 : 	if( this->m_vtReward.empty() )

  00003	8b 81 64 02 00
	00		 mov	 eax, DWORD PTR [ecx+612]
  00009	3b 81 68 02 00
	00		 cmp	 eax, DWORD PTR [ecx+616]
  0000f	75 06		 jne	 SHORT $LN8@GetRewardB

; 1321 : 		return NULL;

  00011	33 c0		 xor	 eax, eax

; 1343 : }

  00013	5d		 pop	 ebp
  00014	c2 08 00	 ret	 8
$LN8@GetRewardB:
  00017	56		 push	 esi
  00018	8b b1 68 02 00
	00		 mov	 esi, DWORD PTR [ecx+616]
  0001e	57		 push	 edi

; 1322 : 
; 1323 : 	vtReward::iterator _It = m_vtReward.begin();
; 1324 : 
; 1325 : 	for( ; _It != m_vtReward.end(); _It++)

  0001f	3b c6		 cmp	 eax, esi
  00021	74 2d		 je	 SHORT $LN1@GetRewardB
  00023	8b 7d 0c	 mov	 edi, DWORD PTR _lpUser$[ebp]
  00026	0f bf 97 96 00
	00 00		 movsx	 edx, WORD PTR [edi+150]
  0002d	8d 49 00	 npad	 3
$LL25@GetRewardB:

; 1326 : 	{
; 1327 : 		if( lpUser->Level >= _It->m_LevelMin &&
; 1328 : 			lpUser->Level <= _It->m_LevelMax )

  00030	3b 50 08	 cmp	 edx, DWORD PTR [eax+8]
  00033	7c 14		 jl	 SHORT $LN6@GetRewardB
  00035	3b 50 0c	 cmp	 edx, DWORD PTR [eax+12]
  00038	7f 0f		 jg	 SHORT $LN6@GetRewardB

; 1329 : 		{
; 1330 : 			if( lpUser->iResetCount >= _It->m_ResetMin &&
; 1331 : 				lpUser->iResetCount <= _It->m_ResetMax )

  0003a	8b 8f 20 27 00
	00		 mov	 ecx, DWORD PTR [edi+10016]
  00040	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00042	7c 05		 jl	 SHORT $LN6@GetRewardB
  00044	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00047	7e 0f		 jle	 SHORT $LN96@GetRewardB
$LN6@GetRewardB:

; 1322 : 
; 1323 : 	vtReward::iterator _It = m_vtReward.begin();
; 1324 : 
; 1325 : 	for( ; _It != m_vtReward.end(); _It++)

  00049	83 c0 18	 add	 eax, 24			; 00000018H
  0004c	3b c6		 cmp	 eax, esi
  0004e	75 e0		 jne	 SHORT $LL25@GetRewardB
$LN1@GetRewardB:
  00050	5f		 pop	 edi

; 1337 : 
; 1338 : 				break;
; 1339 : 			}
; 1340 : 		}
; 1341 : 	}
; 1342 : 	return NULL;

  00051	33 c0		 xor	 eax, eax
  00053	5e		 pop	 esi

; 1343 : }

  00054	5d		 pop	 ebp
  00055	c2 08 00	 ret	 8
$LN96@GetRewardB:

; 1332 : 			{
; 1333 : 				if( type == 0 )

  00058	8b 4d 08	 mov	 ecx, DWORD PTR _type$[ebp]
  0005b	85 c9		 test	 ecx, ecx
  0005d	75 09		 jne	 SHORT $LN2@GetRewardB

; 1334 : 					return _It->m_SilverBox;

  0005f	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00062	5f		 pop	 edi
  00063	5e		 pop	 esi

; 1343 : }

  00064	5d		 pop	 ebp
  00065	c2 08 00	 ret	 8
$LN2@GetRewardB:

; 1335 : 				if( type == 1 )

  00068	83 f9 01	 cmp	 ecx, 1
  0006b	75 e3		 jne	 SHORT $LN1@GetRewardB

; 1336 : 					return _It->m_GoldenBox;

  0006d	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  00070	5f		 pop	 edi
  00071	5e		 pop	 esi

; 1343 : }

  00072	5d		 pop	 ebp
  00073	c2 08 00	 ret	 8
?GetRewardBox@CDoubleGoerEvent@@QAEPAVEventItemBag@@HPAUOBJECTSTRUCT@@@Z ENDP ; CDoubleGoerEvent::GetRewardBox
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@YAXPAU_st_reward@CDoubleGoerEvent@@0AAV?$allocator@U_st_reward@CDoubleGoerEvent@@@0@@Z ; std::_Destroy_range<std::allocator<CDoubleGoerEvent::_st_reward> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@YAXPAU_st_reward@CDoubleGoerEvent@@0AAV?$allocator@U_st_reward@CDoubleGoerEvent@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@YAXPAU_st_reward@CDoubleGoerEvent@@0AAV?$allocator@U_st_reward@CDoubleGoerEvent@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CDoubleGoerEvent::_st_reward> >, COMDAT

; 88   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 89   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@YAXPAU_st_reward@CDoubleGoerEvent@@0AAV?$allocator@U_st_reward@CDoubleGoerEvent@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CDoubleGoerEvent::_st_reward> >
_TEXT	ENDS
PUBLIC	??$_Uninitialized_move@PAU_st_reward@CDoubleGoerEvent@@PAU12@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@YAPAU_st_reward@CDoubleGoerEvent@@PAU12@00AAV?$allocator@U_st_reward@CDoubleGoerEvent@@@0@@Z ; std::_Uninitialized_move<CDoubleGoerEvent::_st_reward *,CDoubleGoerEvent::_st_reward *,std::allocator<CDoubleGoerEvent::_st_reward> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\memory
;	COMDAT ??$_Uninitialized_move@PAU_st_reward@CDoubleGoerEvent@@PAU12@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@YAPAU_st_reward@CDoubleGoerEvent@@PAU12@00AAV?$allocator@U_st_reward@CDoubleGoerEvent@@@0@@Z
_TEXT	SEGMENT
__Cat$189618 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAU_st_reward@CDoubleGoerEvent@@PAU12@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@YAPAU_st_reward@CDoubleGoerEvent@@PAU12@00AAV?$allocator@U_st_reward@CDoubleGoerEvent@@@0@@Z PROC ; std::_Uninitialized_move<CDoubleGoerEvent::_st_reward *,CDoubleGoerEvent::_st_reward *,std::allocator<CDoubleGoerEvent::_st_reward> >, COMDAT

; 469  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 470  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,
; 471  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

  00004	8b 45 fc	 mov	 eax, DWORD PTR __Cat$189618[ebp]
  00007	8b 4d 14	 mov	 ecx, DWORD PTR __Al$[ebp]
  0000a	8b 55 10	 mov	 edx, DWORD PTR __Dest$[ebp]
  0000d	50		 push	 eax
  0000e	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00011	6a 00		 push	 0
  00013	51		 push	 ecx
  00014	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00017	52		 push	 edx
  00018	50		 push	 eax
  00019	51		 push	 ecx
  0001a	e8 00 00 00 00	 call	 ??$_Uninit_move@PAU_st_reward@CDoubleGoerEvent@@PAU12@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@U12@@std@@YAPAU_st_reward@CDoubleGoerEvent@@PAU12@00AAV?$allocator@U_st_reward@CDoubleGoerEvent@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<CDoubleGoerEvent::_st_reward *,CDoubleGoerEvent::_st_reward *,std::allocator<CDoubleGoerEvent::_st_reward>,CDoubleGoerEvent::_st_reward>
  0001f	83 c4 18	 add	 esp, 24			; 00000018H

; 472  : 	}

  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
??$_Uninitialized_move@PAU_st_reward@CDoubleGoerEvent@@PAU12@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@YAPAU_st_reward@CDoubleGoerEvent@@PAU12@00AAV?$allocator@U_st_reward@CDoubleGoerEvent@@@0@@Z ENDP ; std::_Uninitialized_move<CDoubleGoerEvent::_st_reward *,CDoubleGoerEvent::_st_reward *,std::allocator<CDoubleGoerEvent::_st_reward> >
_TEXT	ENDS
PUBLIC	?Run@CDoubleGoerEvent@@QAEXXZ			; CDoubleGoerEvent::Run
; Function compile flags: /Ogtp
; File c:\muserver_dev\development\mu-s8ep2-repack\gameserver\source\doublegoerevent.cpp
;	COMDAT ?Run@CDoubleGoerEvent@@QAEXXZ
_TEXT	SEGMENT
?Run@CDoubleGoerEvent@@QAEXXZ PROC			; CDoubleGoerEvent::Run, COMDAT
; _this$ = ecx

; 413  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 414  : 	if( bEnabled == FALSE || bLoaded == FALSE || m_iState == DOUBLEGOER_STATE_CLOSED )

  00003	83 7e 04 00	 cmp	 DWORD PTR [esi+4], 0
  00007	74 35		 je	 SHORT $LN7@Run
  00009	83 7e 08 00	 cmp	 DWORD PTR [esi+8], 0
  0000d	74 2f		 je	 SHORT $LN7@Run
  0000f	83 7e 24 00	 cmp	 DWORD PTR [esi+36], 0
  00013	74 29		 je	 SHORT $LN7@Run

; 415  : 	{
; 416  : 		return;
; 417  : 	}
; 418  : 
; 419  : 	CheckUser();

  00015	e8 00 00 00 00	 call	 ?CheckUser@CDoubleGoerEvent@@QAEXXZ ; CDoubleGoerEvent::CheckUser

; 420  : 
; 421  : 	switch( m_iState )

  0001a	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  0001d	48		 dec	 eax
  0001e	74 16		 je	 SHORT $LN4@Run
  00020	48		 dec	 eax
  00021	74 0b		 je	 SHORT $LN3@Run
  00023	48		 dec	 eax
  00024	75 18		 jne	 SHORT $LN7@Run

; 428  : 		break;
; 429  : 	case DOUBLEGOER_STATE_PLAYEND:
; 430  : 		ProcState_PLAYEND();

  00026	8b ce		 mov	 ecx, esi
  00028	5e		 pop	 esi
  00029	e9 00 00 00 00	 jmp	 ?ProcState_PLAYEND@CDoubleGoerEvent@@QAEXXZ ; CDoubleGoerEvent::ProcState_PLAYEND
$LN3@Run:

; 425  : 		break;
; 426  : 	case DOUBLEGOER_STATE_PLAYING:
; 427  : 		ProcState_PLAYING();

  0002e	8b ce		 mov	 ecx, esi
  00030	5e		 pop	 esi
  00031	e9 00 00 00 00	 jmp	 ?ProcState_PLAYING@CDoubleGoerEvent@@QAEXXZ ; CDoubleGoerEvent::ProcState_PLAYING
$LN4@Run:

; 422  : 	{
; 423  : 	case DOUBLEGOER_STATE_WAITING:
; 424  : 		ProcState_WAITING();

  00036	8b ce		 mov	 ecx, esi
  00038	5e		 pop	 esi
  00039	e9 00 00 00 00	 jmp	 ?ProcState_WAITING@CDoubleGoerEvent@@QAEXXZ ; CDoubleGoerEvent::ProcState_WAITING
$LN7@Run:
  0003e	5e		 pop	 esi

; 431  : 		break;
; 432  : 	default:
; 433  : 		break;
; 434  : 	}
; 435  : }

  0003f	c3		 ret	 0
?Run@CDoubleGoerEvent@@QAEXXZ ENDP			; CDoubleGoerEvent::Run
_TEXT	ENDS
PUBLIC	__real@00000000
PUBLIC	?CompensationBox@CDoubleGoerEvent@@QAEXPAUOBJECTSTRUCT@@0@Z ; CDoubleGoerEvent::CompensationBox
EXTRN	?gObjLifeCheck@@YAXPAUOBJECTSTRUCT@@0HHHHGH@Z:PROC ; gObjLifeCheck
EXTRN	?Open@EventItemBag@@QAE_NHHEE@Z:PROC		; EventItemBag::Open
EXTRN	?gObjGetRandomItemDropLocation@@YAHHAAE0HHH@Z:PROC ; gObjGetRandomItemDropLocation
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?CompensationBox@CDoubleGoerEvent@@QAEXPAUOBJECTSTRUCT@@0@Z
_TEXT	SEGMENT
tv181 = -8						; size = 4
_bReward$ = -8						; size = 4
tv203 = -4						; size = 4
_cDropX$184118 = -4					; size = 1
tv340 = 8						; size = 4
_cDropY$184119 = 8					; size = 1
_lpNpc$ = 8						; size = 4
_lpObj$ = 12						; size = 4
?CompensationBox@CDoubleGoerEvent@@QAEXPAUOBJECTSTRUCT@@0@Z PROC ; CDoubleGoerEvent::CompensationBox, COMDAT
; _this$ = ecx

; 1226 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx
  00007	56		 push	 esi

; 1227 : 	if( !lpNpc->Live )

  00008	8b 75 08	 mov	 esi, DWORD PTR _lpNpc$[ebp]
  0000b	80 7e 51 00	 cmp	 BYTE PTR [esi+81], 0
  0000f	8b d9		 mov	 ebx, ecx
  00011	0f 84 70 01 00
	00		 je	 $LN4@Compensati

; 1228 : 		return;
; 1229 : 
; 1230 : 	int bReward = FALSE;
; 1231 : 
; 1232 : 	EventItemBag* pReward = GetRewardBox(0, lpObj);

  00017	8b 45 0c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  0001a	57		 push	 edi
  0001b	50		 push	 eax
  0001c	6a 00		 push	 0
  0001e	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _bReward$[ebp], 0
  00025	e8 00 00 00 00	 call	 ?GetRewardBox@CDoubleGoerEvent@@QAEPAVEventItemBag@@HPAUOBJECTSTRUCT@@@Z ; CDoubleGoerEvent::GetRewardBox
  0002a	8b f8		 mov	 edi, eax

; 1233 : 
; 1234 : 	if( pReward != NULL )

  0002c	85 ff		 test	 edi, edi
  0002e	0f 84 8b 00 00
	00		 je	 $LN23@Compensati

; 1235 : 	{
; 1236 : 		if( rand()%3 == 0 )

  00034	e8 00 00 00 00	 call	 _rand
  00039	99		 cdq
  0003a	b9 03 00 00 00	 mov	 ecx, 3
  0003f	f7 f9		 idiv	 ecx
  00041	85 d2		 test	 edx, edx
  00043	75 7a		 jne	 SHORT $LN23@Compensati

; 1237 : 		{
; 1238 : 			for(int i = 0; i < 3; i++)

  00045	89 4d f8	 mov	 DWORD PTR tv181[ebp], ecx
  00048	eb 06 8d 9b 00
	00 00 00	 npad	 8
$LL25@Compensati:

; 1239 : 			{
; 1240 : 				BYTE cDropX = lpNpc->X;

  00050	8a 96 20 01 00
	00		 mov	 dl, BYTE PTR [esi+288]

; 1241 : 				BYTE cDropY = lpNpc->Y;

  00056	8a 86 21 01 00
	00		 mov	 al, BYTE PTR [esi+289]

; 1242 : 
; 1243 : 				if ( !gObjGetRandomItemDropLocation(lpNpc->MapNumber, cDropX, cDropY, 3, 3, 10))

  0005c	6a 0a		 push	 10			; 0000000aH
  0005e	6a 03		 push	 3
  00060	6a 03		 push	 3
  00062	8d 4d 08	 lea	 ecx, DWORD PTR _cDropY$184119[ebp]
  00065	88 55 fc	 mov	 BYTE PTR _cDropX$184118[ebp], dl
  00068	88 45 08	 mov	 BYTE PTR _cDropY$184119[ebp], al
  0006b	0f b6 86 23 01
	00 00		 movzx	 eax, BYTE PTR [esi+291]
  00072	51		 push	 ecx
  00073	8d 55 fc	 lea	 edx, DWORD PTR _cDropX$184118[ebp]
  00076	52		 push	 edx
  00077	50		 push	 eax
  00078	e8 00 00 00 00	 call	 ?gObjGetRandomItemDropLocation@@YAHHAAE0HHH@Z ; gObjGetRandomItemDropLocation
  0007d	83 c4 18	 add	 esp, 24			; 00000018H
  00080	85 c0		 test	 eax, eax
  00082	75 12		 jne	 SHORT $LN7@Compensati

; 1244 : 				{
; 1245 : 					cDropX = lpNpc->X;

  00084	8a 8e 20 01 00
	00		 mov	 cl, BYTE PTR [esi+288]

; 1246 : 					cDropY = lpNpc->Y;

  0008a	8a 96 21 01 00
	00		 mov	 dl, BYTE PTR [esi+289]
  00090	88 4d fc	 mov	 BYTE PTR _cDropX$184118[ebp], cl
  00093	88 55 08	 mov	 BYTE PTR _cDropY$184119[ebp], dl
$LN7@Compensati:

; 1247 : 				}
; 1248 : 
; 1249 : 				pReward->Open(lpObj->m_Index,lpObj->MapNumber,cDropX,cDropY);

  00096	8b 45 08	 mov	 eax, DWORD PTR _cDropY$184119[ebp]
  00099	8b 4d fc	 mov	 ecx, DWORD PTR _cDropX$184118[ebp]
  0009c	50		 push	 eax
  0009d	8b 45 0c	 mov	 eax, DWORD PTR _lpObj$[ebp]
  000a0	0f b6 90 23 01
	00 00		 movzx	 edx, BYTE PTR [eax+291]
  000a7	8b 00		 mov	 eax, DWORD PTR [eax]
  000a9	51		 push	 ecx
  000aa	52		 push	 edx
  000ab	50		 push	 eax
  000ac	8b cf		 mov	 ecx, edi
  000ae	e8 00 00 00 00	 call	 ?Open@EventItemBag@@QAE_NHHEE@Z ; EventItemBag::Open
  000b3	ff 4d f8	 dec	 DWORD PTR tv181[ebp]
  000b6	75 98		 jne	 SHORT $LL25@Compensati

; 1250 : 			}
; 1251 : 			bReward = TRUE;

  000b8	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _bReward$[ebp], 1
$LN23@Compensati:

; 1252 : 		}
; 1253 : 	}
; 1254 : 
; 1255 : 	for(int i = 0; i < DOUBLEGOER_MAXBOX; i++)

  000bf	8d 8b 40 02 00
	00		 lea	 ecx, DWORD PTR [ebx+576]
  000c5	89 4d 08	 mov	 DWORD PTR tv340[ebp], ecx
  000c8	c7 45 fc 06 00
	00 00		 mov	 DWORD PTR tv203[ebp], 6
  000cf	90		 npad	 1
$LL6@Compensati:

; 1256 : 	{
; 1257 : 		int aIndex = m_BoxInfo[i];

  000d0	8b 55 08	 mov	 edx, DWORD PTR tv340[ebp]
  000d3	8b 3a		 mov	 edi, DWORD PTR [edx]

; 1258 : 
; 1259 : 		if( OBJMAX_RANGE(aIndex) )

  000d5	85 ff		 test	 edi, edi
  000d7	0f 88 9c 00 00
	00		 js	 $LN5@Compensati
  000dd	33 c0		 xor	 eax, eax
  000df	81 ff eb 2c 00
	00		 cmp	 edi, 11499		; 00002cebH
  000e5	0f 9e c0	 setle	 al
  000e8	85 c0		 test	 eax, eax
  000ea	0f 84 89 00 00
	00		 je	 $LN5@Compensati

; 1260 : 		{
; 1261 : 			if( gObj[aIndex].Class == 541 )

  000f0	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000f5	8b f7		 mov	 esi, edi
  000f7	69 f6 40 27 00
	00		 imul	 esi, 10048		; 00002740H
  000fd	b9 1d 02 00 00	 mov	 ecx, 541		; 0000021dH
  00102	66 39 8c 06 90
	00 00 00	 cmp	 WORD PTR [esi+eax+144], cx
  0010a	75 6d		 jne	 SHORT $LN5@Compensati

; 1262 : 			{
; 1263 : 				gObj[aIndex].Life = 0.0f;

  0010c	d9 ee		 fldz

; 1264 : 				gObjLifeCheck(&gObj[aIndex],lpObj,0,1,0,0,0,0);

  0010e	8b 55 0c	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00111	6a 00		 push	 0
  00113	d9 9c 06 d8 00
	00 00		 fstp	 DWORD PTR [esi+eax+216]
  0011a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0011f	6a 00		 push	 0
  00121	6a 00		 push	 0
  00123	6a 00		 push	 0
  00125	6a 01		 push	 1
  00127	6a 00		 push	 0
  00129	52		 push	 edx
  0012a	8d 0c 06	 lea	 ecx, DWORD PTR [esi+eax]
  0012d	51		 push	 ecx
  0012e	e8 00 00 00 00	 call	 ?gObjLifeCheck@@YAXPAUOBJECTSTRUCT@@0HHHHGH@Z ; gObjLifeCheck
  00133	83 c4 20	 add	 esp, 32			; 00000020H

; 1265 : 				DelBox(aIndex);

  00136	57		 push	 edi
  00137	8b cb		 mov	 ecx, ebx
  00139	e8 00 00 00 00	 call	 ?DelBox@CDoubleGoerEvent@@QAEHH@Z ; CDoubleGoerEvent::DelBox

; 1266 : 
; 1267 : 				if( bReward == FALSE )

  0013e	83 7d f8 00	 cmp	 DWORD PTR _bReward$[ebp], 0
  00142	75 35		 jne	 SHORT $LN5@Compensati

; 1268 : 				{
; 1269 : 					SummonMonster(532,m_iCurentMap,gObj[aIndex].X,gObj[aIndex].Y,m_EventLevel, m_EventReset);

  00144	8b 93 58 02 00
	00		 mov	 edx, DWORD PTR [ebx+600]
  0014a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0014f	8b 8b 5c 02 00
	00		 mov	 ecx, DWORD PTR [ebx+604]
  00155	52		 push	 edx
  00156	0f b6 94 06 21
	01 00 00	 movzx	 edx, BYTE PTR [esi+eax+289]
  0015e	0f b6 84 06 20
	01 00 00	 movzx	 eax, BYTE PTR [esi+eax+288]
  00166	51		 push	 ecx
  00167	8b 4b 30	 mov	 ecx, DWORD PTR [ebx+48]
  0016a	52		 push	 edx
  0016b	50		 push	 eax
  0016c	51		 push	 ecx
  0016d	68 14 02 00 00	 push	 532			; 00000214H
  00172	8b cb		 mov	 ecx, ebx
  00174	e8 00 00 00 00	 call	 ?SummonMonster@CDoubleGoerEvent@@QAEHHHHHHH@Z ; CDoubleGoerEvent::SummonMonster
$LN5@Compensati:

; 1252 : 		}
; 1253 : 	}
; 1254 : 
; 1255 : 	for(int i = 0; i < DOUBLEGOER_MAXBOX; i++)

  00179	83 45 08 04	 add	 DWORD PTR tv340[ebp], 4
  0017d	ff 4d fc	 dec	 DWORD PTR tv203[ebp]
  00180	0f 85 4a ff ff
	ff		 jne	 $LL6@Compensati
  00186	5f		 pop	 edi
$LN4@Compensati:
  00187	5e		 pop	 esi
  00188	5b		 pop	 ebx

; 1270 : 				}
; 1271 : 			}
; 1272 : 		}
; 1273 : 	}
; 1274 : }

  00189	8b e5		 mov	 esp, ebp
  0018b	5d		 pop	 ebp
  0018c	c2 08 00	 ret	 8
?CompensationBox@CDoubleGoerEvent@@QAEXPAUOBJECTSTRUCT@@0@Z ENDP ; CDoubleGoerEvent::CompensationBox
_TEXT	ENDS
PUBLIC	?GoldCompensationBox@CDoubleGoerEvent@@QAEXPAUOBJECTSTRUCT@@0@Z ; CDoubleGoerEvent::GoldCompensationBox
; Function compile flags: /Ogtp
;	COMDAT ?GoldCompensationBox@CDoubleGoerEvent@@QAEXPAUOBJECTSTRUCT@@0@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv129 = -4						; size = 4
tv279 = 8						; size = 4
_cDropY$184142 = 8					; size = 1
_lpNpc$ = 8						; size = 4
tv289 = 12						; size = 4
_cDropX$184141 = 12					; size = 1
_lpObj$ = 12						; size = 4
?GoldCompensationBox@CDoubleGoerEvent@@QAEXPAUOBJECTSTRUCT@@0@Z PROC ; CDoubleGoerEvent::GoldCompensationBox, COMDAT
; _this$ = ecx

; 1277 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi

; 1278 : 	if( !lpNpc->Live )

  00007	8b 75 08	 mov	 esi, DWORD PTR _lpNpc$[ebp]
  0000a	80 7e 51 00	 cmp	 BYTE PTR [esi+81], 0
  0000e	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00011	0f 84 06 01 00
	00		 je	 $LN3@GoldCompen

; 1279 : 		return;
; 1280 : 
; 1281 : 	int i;
; 1282 : 
; 1283 : 	EventItemBag* pReward = GetRewardBox(1, lpObj);

  00017	53		 push	 ebx
  00018	57		 push	 edi
  00019	8b 7d 0c	 mov	 edi, DWORD PTR _lpObj$[ebp]
  0001c	57		 push	 edi
  0001d	6a 01		 push	 1
  0001f	e8 00 00 00 00	 call	 ?GetRewardBox@CDoubleGoerEvent@@QAEPAVEventItemBag@@HPAUOBJECTSTRUCT@@@Z ; CDoubleGoerEvent::GetRewardBox
  00024	8b d8		 mov	 ebx, eax

; 1284 : 
; 1285 : 	if( pReward != NULL )

  00026	85 db		 test	 ebx, ebx
  00028	74 6c		 je	 SHORT $LN7@GoldCompen

; 1286 : 	{
; 1287 : 		for(i = 0; i < 10; i++)

  0002a	c7 45 fc 0a 00
	00 00		 mov	 DWORD PTR tv129[ebp], 10 ; 0000000aH
$LL20@GoldCompen:

; 1288 : 		{
; 1289 : 			BYTE cDropX = lpNpc->X;

  00031	8a 86 20 01 00
	00		 mov	 al, BYTE PTR [esi+288]

; 1290 : 			BYTE cDropY = lpNpc->Y;

  00037	8a 8e 21 01 00
	00		 mov	 cl, BYTE PTR [esi+289]

; 1291 : 
; 1292 : 			if ( !gObjGetRandomItemDropLocation(lpNpc->MapNumber, cDropX, cDropY, 3, 3, 10))

  0003d	6a 0a		 push	 10			; 0000000aH
  0003f	6a 03		 push	 3
  00041	6a 03		 push	 3
  00043	8d 55 08	 lea	 edx, DWORD PTR _cDropY$184142[ebp]
  00046	88 45 0c	 mov	 BYTE PTR _cDropX$184141[ebp], al
  00049	88 4d 08	 mov	 BYTE PTR _cDropY$184142[ebp], cl
  0004c	0f b6 8e 23 01
	00 00		 movzx	 ecx, BYTE PTR [esi+291]
  00053	52		 push	 edx
  00054	8d 45 0c	 lea	 eax, DWORD PTR _cDropX$184141[ebp]
  00057	50		 push	 eax
  00058	51		 push	 ecx
  00059	e8 00 00 00 00	 call	 ?gObjGetRandomItemDropLocation@@YAHHAAE0HHH@Z ; gObjGetRandomItemDropLocation
  0005e	83 c4 18	 add	 esp, 24			; 00000018H
  00061	85 c0		 test	 eax, eax
  00063	75 12		 jne	 SHORT $LN6@GoldCompen

; 1293 : 			{
; 1294 : 				cDropX = lpNpc->X;

  00065	8a 96 20 01 00
	00		 mov	 dl, BYTE PTR [esi+288]

; 1295 : 				cDropY = lpNpc->Y;

  0006b	8a 86 21 01 00
	00		 mov	 al, BYTE PTR [esi+289]
  00071	88 55 0c	 mov	 BYTE PTR _cDropX$184141[ebp], dl
  00074	88 45 08	 mov	 BYTE PTR _cDropY$184142[ebp], al
$LN6@GoldCompen:

; 1296 : 			}
; 1297 : 
; 1298 : 			pReward->Open(lpObj->m_Index,lpObj->MapNumber,cDropX,cDropY);

  00077	8b 4d 08	 mov	 ecx, DWORD PTR _cDropY$184142[ebp]
  0007a	8b 55 0c	 mov	 edx, DWORD PTR _cDropX$184141[ebp]
  0007d	0f b6 87 23 01
	00 00		 movzx	 eax, BYTE PTR [edi+291]
  00084	51		 push	 ecx
  00085	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00087	52		 push	 edx
  00088	50		 push	 eax
  00089	51		 push	 ecx
  0008a	8b cb		 mov	 ecx, ebx
  0008c	e8 00 00 00 00	 call	 ?Open@EventItemBag@@QAE_NHHEE@Z ; EventItemBag::Open
  00091	ff 4d fc	 dec	 DWORD PTR tv129[ebp]
  00094	75 9b		 jne	 SHORT $LL20@GoldCompen
$LN7@GoldCompen:

; 1299 : 		}
; 1300 : 	}
; 1301 : 
; 1302 : 	for(i = 0; i < DOUBLEGOER_MAXBOX; i++)

  00096	8b 5d f8	 mov	 ebx, DWORD PTR _this$[ebp]
  00099	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0009f	8d 93 40 02 00
	00		 lea	 edx, DWORD PTR [ebx+576]
  000a5	89 55 08	 mov	 DWORD PTR tv279[ebp], edx
  000a8	c7 45 0c 06 00
	00 00		 mov	 DWORD PTR tv289[ebp], 6
  000af	90		 npad	 1
$LL5@GoldCompen:

; 1303 : 	{
; 1304 : 		int aIndex = m_BoxInfo[i];

  000b0	8b 45 08	 mov	 eax, DWORD PTR tv279[ebp]
  000b3	8b 30		 mov	 esi, DWORD PTR [eax]

; 1305 : 
; 1306 : 		if( OBJMAX_RANGE(aIndex) )

  000b5	85 f6		 test	 esi, esi
  000b7	78 59		 js	 SHORT $LN4@GoldCompen
  000b9	33 c0		 xor	 eax, eax
  000bb	81 fe eb 2c 00
	00		 cmp	 esi, 11499		; 00002cebH
  000c1	0f 9e c0	 setle	 al
  000c4	85 c0		 test	 eax, eax
  000c6	74 4a		 je	 SHORT $LN4@GoldCompen

; 1307 : 		{
; 1308 : 			if( gObj[aIndex].Class == 542 )

  000c8	8b c6		 mov	 eax, esi
  000ca	69 c0 40 27 00
	00		 imul	 eax, 10048		; 00002740H
  000d0	ba 1e 02 00 00	 mov	 edx, 542		; 0000021eH
  000d5	66 39 94 08 90
	00 00 00	 cmp	 WORD PTR [eax+ecx+144], dx
  000dd	75 33		 jne	 SHORT $LN4@GoldCompen

; 1309 : 			{
; 1310 : 				gObj[aIndex].Life = 0.0f;

  000df	d9 ee		 fldz

; 1311 : 				gObjLifeCheck(&gObj[aIndex],lpObj,0,1,0,0,0,0);

  000e1	6a 00		 push	 0
  000e3	6a 00		 push	 0
  000e5	d9 9c 08 d8 00
	00 00		 fstp	 DWORD PTR [eax+ecx+216]
  000ec	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000f2	6a 00		 push	 0
  000f4	6a 00		 push	 0
  000f6	6a 01		 push	 1
  000f8	6a 00		 push	 0
  000fa	57		 push	 edi
  000fb	50		 push	 eax
  000fc	e8 00 00 00 00	 call	 ?gObjLifeCheck@@YAXPAUOBJECTSTRUCT@@0HHHHGH@Z ; gObjLifeCheck
  00101	83 c4 20	 add	 esp, 32			; 00000020H

; 1312 : 				DelBox(aIndex);

  00104	56		 push	 esi
  00105	8b cb		 mov	 ecx, ebx
  00107	e8 00 00 00 00	 call	 ?DelBox@CDoubleGoerEvent@@QAEHH@Z ; CDoubleGoerEvent::DelBox
  0010c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
$LN4@GoldCompen:

; 1299 : 		}
; 1300 : 	}
; 1301 : 
; 1302 : 	for(i = 0; i < DOUBLEGOER_MAXBOX; i++)

  00112	83 45 08 04	 add	 DWORD PTR tv279[ebp], 4
  00116	ff 4d 0c	 dec	 DWORD PTR tv289[ebp]
  00119	75 95		 jne	 SHORT $LL5@GoldCompen
  0011b	5f		 pop	 edi
  0011c	5b		 pop	 ebx
$LN3@GoldCompen:
  0011d	5e		 pop	 esi

; 1313 : 			}
; 1314 : 		}
; 1315 : 	}
; 1316 : }

  0011e	8b e5		 mov	 esp, ebp
  00120	5d		 pop	 ebp
  00121	c2 08 00	 ret	 8
?GoldCompensationBox@CDoubleGoerEvent@@QAEXPAUOBJECTSTRUCT@@0@Z ENDP ; CDoubleGoerEvent::GoldCompensationBox
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@IAEXPAU_st_reward@CDoubleGoerEvent@@0@Z ; std::vector<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >::_Destroy
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?_Destroy@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@IAEXPAU_st_reward@CDoubleGoerEvent@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@IAEXPAU_st_reward@CDoubleGoerEvent@@0@Z PROC ; std::vector<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >::_Destroy, COMDAT
; _this$ = ecx

; 1270 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1271 : 		}

  00000	c2 08 00	 ret	 8
?_Destroy@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@IAEXPAU_st_reward@CDoubleGoerEvent@@0@Z ENDP ; std::vector<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >::_Destroy
_TEXT	ENDS
PUBLIC	??$_Umove@PAU_st_reward@CDoubleGoerEvent@@@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@IAEPAU_st_reward@CDoubleGoerEvent@@PAU23@00@Z ; std::vector<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >::_Umove<CDoubleGoerEvent::_st_reward *>
; Function compile flags: /Ogtp
;	COMDAT ??$_Umove@PAU_st_reward@CDoubleGoerEvent@@@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@IAEPAU_st_reward@CDoubleGoerEvent@@PAU23@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$189671 = 16					; size = 1
__Ptr$ = 16						; size = 4
??$_Umove@PAU_st_reward@CDoubleGoerEvent@@@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@IAEPAU_st_reward@CDoubleGoerEvent@@PAU23@00@Z PROC ; std::vector<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >::_Umove<CDoubleGoerEvent::_st_reward *>, COMDAT
; _this$ = ecx

; 1322 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1323 : 		{	// move initializing [_First, _Last), using allocator
; 1324 : 		return (_Uninitialized_move(_First, _Last,
; 1325 : 			_Ptr, this->_Alval));

  00003	8b 45 10	 mov	 eax, DWORD PTR __Cat$189671[ebp]
  00006	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  00009	50		 push	 eax
  0000a	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0000d	6a 00		 push	 0
  0000f	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00012	51		 push	 ecx
  00013	8b 4d 10	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00016	51		 push	 ecx
  00017	52		 push	 edx
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 ??$_Uninit_move@PAU_st_reward@CDoubleGoerEvent@@PAU12@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@U12@@std@@YAPAU_st_reward@CDoubleGoerEvent@@PAU12@00AAV?$allocator@U_st_reward@CDoubleGoerEvent@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<CDoubleGoerEvent::_st_reward *,CDoubleGoerEvent::_st_reward *,std::allocator<CDoubleGoerEvent::_st_reward>,CDoubleGoerEvent::_st_reward>
  0001e	83 c4 18	 add	 esp, 24			; 00000018H

; 1326 : 		}

  00021	5d		 pop	 ebp
  00022	c2 0c 00	 ret	 12			; 0000000cH
??$_Umove@PAU_st_reward@CDoubleGoerEvent@@@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@IAEPAU_st_reward@CDoubleGoerEvent@@PAU23@00@Z ENDP ; std::vector<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >::_Umove<CDoubleGoerEvent::_st_reward *>
_TEXT	ENDS
PUBLIC	?erase@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@2@0@Z ; std::vector<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >::erase
; Function compile flags: /Ogtp
;	COMDAT ?erase@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@2@0@Z
_TEXT	SEGMENT
__Cat$189750 = 8					; size = 1
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@2@0@Z PROC ; std::vector<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >::erase, COMDAT
; _this$ = ecx

; 1190 : 		{	// erase [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1191 : 		iterator _First = _Make_iter(_First_arg);

  00003	8b 45 0c	 mov	 eax, DWORD PTR __First_arg$[ebp]

; 1192 : 		iterator _Last = _Make_iter(_Last_arg);
; 1193 : 
; 1194 : 		if (_First != _Last)

  00006	8b 55 10	 mov	 edx, DWORD PTR __Last_arg$[ebp]
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	8b f1		 mov	 esi, ecx
  0000d	8b f8		 mov	 edi, eax
  0000f	3b c2		 cmp	 eax, edx
  00011	74 17		 je	 SHORT $LN38@erase

; 1195 : 			{	// worth doing, copy down over hole
; 1196 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1197 : 			if (_Last < _First || _VICONT(_First) != this
; 1198 : 				|| _VIPTR(_First) < this->_Myfirst
; 1199 : 				|| this->_Mylast < _VIPTR(_Last))
; 1200 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1201 : 			pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1202 : 				_VIPTR(_First));
; 1203 : 			_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1204 : 
; 1205 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1206 : 			pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1207 : 				_VIPTR(_First));

  00013	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00016	53		 push	 ebx
  00017	8b 5d 08	 mov	 ebx, DWORD PTR __Cat$189750[ebp]
  0001a	53		 push	 ebx
  0001b	50		 push	 eax
  0001c	51		 push	 ecx
  0001d	52		 push	 edx
  0001e	e8 00 00 00 00	 call	 ??$_Move@PAU_st_reward@CDoubleGoerEvent@@PAU12@@std@@YAPAU_st_reward@CDoubleGoerEvent@@PAU12@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Move<CDoubleGoerEvent::_st_reward *,CDoubleGoerEvent::_st_reward *>
  00023	83 c4 10	 add	 esp, 16			; 00000010H

; 1208 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1209 : 
; 1210 : 			_Destroy(_Ptr, this->_Mylast);
; 1211 : 			this->_Mylast = _Ptr;

  00026	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00029	5b		 pop	 ebx
$LN38@erase:

; 1212 : 			}
; 1213 : 		return (_Make_iter(_First));

  0002a	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0002d	89 38		 mov	 DWORD PTR [eax], edi
  0002f	5f		 pop	 edi
  00030	5e		 pop	 esi

; 1214 : 		}

  00031	5d		 pop	 ebp
  00032	c2 0c 00	 ret	 12			; 0000000cH
?erase@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@@2@0@Z ENDP ; std::vector<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >::erase
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@IAEXXZ ; std::vector<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >::_Tidy
; Function compile flags: /Ogtp
;	COMDAT ?_Tidy@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@IAEXXZ PROC ; std::vector<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >::_Tidy, COMDAT
; _this$ = ecx

; 1301 : 		{	// free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1302 : 		if (this->_Myfirst != 0)

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 09		 je	 SHORT $LN6@Tidy

; 1303 : 			{	// something to free, destroy and deallocate it
; 1304 : 			this->_Orphan_all();
; 1305 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1306 : 			this->_Alval.deallocate(this->_Myfirst,
; 1307 : 				this->_Myend - this->_Myfirst);

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
$LN6@Tidy:

; 1308 : 			}
; 1309 : 		this->_Myfirst = 0;

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1310 : 		this->_Mylast = 0;

  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1311 : 		this->_Myend = 0;

  0001f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00026	5e		 pop	 esi

; 1312 : 		}

  00027	c3		 ret	 0
?_Tidy@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@IAEXXZ ENDP ; std::vector<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >::_Tidy
_TEXT	ENDS
PUBLIC	?reserve@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QAEXI@Z ; std::vector<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >::reserve
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
xdata$x	SEGMENT
__catchsym$?reserve@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QAEXI@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?reserve@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QAEXI@Z$0
__unwindtable$?reserve@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?reserve@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QAEXI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?reserve@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QAEXI@Z$2
__ehfuncinfo$?reserve@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?reserve@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?reserve@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?reserve@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
__Ptr$185335 = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Cat$189844 = 8					; size = 1
__Count$ = 8						; size = 4
?reserve@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QAEXI@Z PROC ; std::vector<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >::reserve, COMDAT
; _this$ = ecx

; 746  : 		{	// determine new minimum length of allocated storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?reserve@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QAEXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b f1		 mov	 esi, ecx

; 747  : 		if (max_size() < _Count)

  0002d	8b 5d 08	 mov	 ebx, DWORD PTR __Count$[ebp]
  00030	81 fb aa aa aa
	0a		 cmp	 ebx, 178956970		; 0aaaaaaaH
  00036	76 0a		 jbe	 SHORT $LN5@reserve

; 748  : 			_Xlen();	// result too long

  00038	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  0003d	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN42@reserve:
$LN5@reserve:

; 749  : 		else if (capacity() < _Count)

  00042	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00045	2b 0e		 sub	 ecx, DWORD PTR [esi]
  00047	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0004c	f7 e9		 imul	 ecx
  0004e	c1 fa 02	 sar	 edx, 2
  00051	8b c2		 mov	 eax, edx
  00053	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00056	03 c2		 add	 eax, edx
  00058	3b c3		 cmp	 eax, ebx
  0005a	73 6b		 jae	 SHORT $LN3@reserve

; 750  : 			{	// not enough room, reallocate
; 751  : 			pointer _Ptr = this->_Alval.allocate(_Count);

  0005c	8d 7e 0c	 lea	 edi, DWORD PTR [esi+12]
  0005f	53		 push	 ebx
  00060	8b cf		 mov	 ecx, edi
  00062	e8 00 00 00 00	 call	 ?allocate@?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@QAEPAU_st_reward@CDoubleGoerEvent@@I@Z ; std::allocator<CDoubleGoerEvent::_st_reward>::allocate

; 752  : 
; 753  : 			_TRY_BEGIN
; 754  : 			_Umove(this->_Myfirst, this->_Mylast, _Ptr);

  00067	8b 5d 08	 mov	 ebx, DWORD PTR __Cat$189844[ebp]
  0006a	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0006d	8b 16		 mov	 edx, DWORD PTR [esi]
  0006f	53		 push	 ebx
  00070	6a 00		 push	 0
  00072	57		 push	 edi
  00073	50		 push	 eax
  00074	51		 push	 ecx
  00075	52		 push	 edx
  00076	89 45 ec	 mov	 DWORD PTR __Ptr$185335[ebp], eax
  00079	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00080	e8 00 00 00 00	 call	 ??$_Uninit_move@PAU_st_reward@CDoubleGoerEvent@@PAU12@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@U12@@std@@YAPAU_st_reward@CDoubleGoerEvent@@PAU12@00AAV?$allocator@U_st_reward@CDoubleGoerEvent@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<CDoubleGoerEvent::_st_reward *,CDoubleGoerEvent::_st_reward *,std::allocator<CDoubleGoerEvent::_st_reward>,CDoubleGoerEvent::_st_reward>

; 758  : 			_CATCH_END
; 759  : 
; 760  : 			size_type _Size = size();

  00085	8b 1e		 mov	 ebx, DWORD PTR [esi]
  00087	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0008a	2b cb		 sub	 ecx, ebx
  0008c	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00091	f7 e9		 imul	 ecx
  00093	c1 fa 02	 sar	 edx, 2
  00096	8b fa		 mov	 edi, edx
  00098	c1 ef 1f	 shr	 edi, 31			; 0000001fH
  0009b	83 c4 18	 add	 esp, 24			; 00000018H
  0009e	03 fa		 add	 edi, edx

; 761  : 			if (this->_Myfirst != 0)

  000a0	85 db		 test	 ebx, ebx
  000a2	74 09		 je	 SHORT $LN35@reserve

; 762  : 				{	// destroy and deallocate old array
; 763  : 				_Destroy(this->_Myfirst, this->_Mylast);
; 764  : 				this->_Alval.deallocate(this->_Myfirst,
; 765  : 					this->_Myend - this->_Myfirst);

  000a4	53		 push	 ebx
  000a5	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000aa	83 c4 04	 add	 esp, 4
$LN35@reserve:

; 766  : 				}
; 767  : 
; 768  : 			this->_Orphan_all();
; 769  : 			this->_Myend = _Ptr + _Count;

  000ad	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  000b0	8d 0c 40	 lea	 ecx, DWORD PTR [eax+eax*2]
  000b3	8b 45 ec	 mov	 eax, DWORD PTR __Ptr$185335[ebp]
  000b6	8d 14 c8	 lea	 edx, DWORD PTR [eax+ecx*8]

; 770  : 			this->_Mylast = _Ptr + _Size;

  000b9	8d 0c 7f	 lea	 ecx, DWORD PTR [edi+edi*2]
  000bc	89 56 08	 mov	 DWORD PTR [esi+8], edx
  000bf	8d 14 c8	 lea	 edx, DWORD PTR [eax+ecx*8]
  000c2	89 56 04	 mov	 DWORD PTR [esi+4], edx

; 771  : 			this->_Myfirst = _Ptr;

  000c5	89 06		 mov	 DWORD PTR [esi], eax
$LN3@reserve:

; 772  : 			}
; 773  : 		}

  000c7	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000ca	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000d1	59		 pop	 ecx
  000d2	5f		 pop	 edi
  000d3	5e		 pop	 esi
  000d4	5b		 pop	 ebx
  000d5	8b e5		 mov	 esp, ebp
  000d7	5d		 pop	 ebp
  000d8	c2 04 00	 ret	 4
__catch$?reserve@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QAEXI@Z$0:

; 755  : 			_CATCH_ALL
; 756  : 			this->_Alval.deallocate(_Ptr, _Count);

  000db	8b 45 ec	 mov	 eax, DWORD PTR __Ptr$185335[ebp]
  000de	50		 push	 eax
  000df	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000e4	83 c4 04	 add	 esp, 4

; 757  : 			_RERAISE;

  000e7	6a 00		 push	 0
  000e9	6a 00		 push	 0
  000eb	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN43@reserve:
$LN41@reserve:
  000f0	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?reserve@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QAEXI@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?reserve@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QAEXI@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?reserve@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QAEXI@Z ENDP ; std::vector<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >::reserve
PUBLIC	??1?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QAE@XZ ; std::vector<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >::~vector<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >
; Function compile flags: /Ogtp
;	COMDAT ??1?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QAE@XZ PROC ; std::vector<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >::~vector<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >, COMDAT
; _this$ = ecx

; 704  : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 705  : 		_Tidy();

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 09		 je	 SHORT $LN8@vector@2
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
$LN8@vector@2:
  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0001f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00026	5e		 pop	 esi

; 706  : 		}

  00027	c3		 ret	 0
??1?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QAE@XZ ENDP ; std::vector<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >::~vector<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >
_TEXT	ENDS
PUBLIC	?clear@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QAEXXZ ; std::vector<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >::clear
; Function compile flags: /Ogtp
;	COMDAT ?clear@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__Cat$190087 = -4					; size = 1
?clear@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QAEXXZ PROC ; std::vector<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >::clear, COMDAT
; _this$ = ecx

; 1217 : 		{	// erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx

; 1218 : 		erase(begin(), end());

  00007	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0000a	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0000c	3b c8		 cmp	 ecx, eax
  0000e	74 12		 je	 SHORT $LN19@clear
  00010	8b 55 fc	 mov	 edx, DWORD PTR __Cat$190087[ebp]
  00013	52		 push	 edx
  00014	51		 push	 ecx
  00015	50		 push	 eax
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ??$_Move@PAU_st_reward@CDoubleGoerEvent@@PAU12@@std@@YAPAU_st_reward@CDoubleGoerEvent@@PAU12@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Move<CDoubleGoerEvent::_st_reward *,CDoubleGoerEvent::_st_reward *>
  0001c	83 c4 10	 add	 esp, 16			; 00000010H
  0001f	89 46 04	 mov	 DWORD PTR [esi+4], eax
$LN19@clear:
  00022	5e		 pop	 esi

; 1219 : 		}

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
?clear@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QAEXXZ ENDP ; std::vector<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >::clear
_TEXT	ENDS
PUBLIC	?_Reserve@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@IAEXI@Z ; std::vector<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >::_Reserve
; Function compile flags: /Ogtp
;	COMDAT ?_Reserve@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Reserve@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@IAEXI@Z PROC ; std::vector<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >::_Reserve, COMDAT
; _this$ = ecx

; 1290 : 		{	// ensure room for _Count new elements, grow exponentially

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1291 : 		size_type _Size = size();

  00003	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	8b 39		 mov	 edi, DWORD PTR [ecx]
  0000a	2b d7		 sub	 edx, edi
  0000c	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00011	f7 ea		 imul	 edx

; 1292 : 		if (max_size() - _Count < _Size)

  00013	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00016	c1 fa 02	 sar	 edx, 2
  00019	8b f2		 mov	 esi, edx
  0001b	c1 ee 1f	 shr	 esi, 31			; 0000001fH
  0001e	03 f2		 add	 esi, edx
  00020	ba aa aa aa 0a	 mov	 edx, 178956970		; 0aaaaaaaH
  00025	2b d0		 sub	 edx, eax
  00027	3b d6		 cmp	 edx, esi
  00029	73 0a		 jae	 SHORT $LN4@Reserve

; 1293 : 			_Xlen();

  0002b	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00030	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN34@Reserve:
$LN4@Reserve:

; 1294 : 		else if ((_Size += _Count) <= capacity())

  00035	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00038	03 f0		 add	 esi, eax
  0003a	2b d7		 sub	 edx, edi
  0003c	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00041	f7 ea		 imul	 edx
  00043	c1 fa 02	 sar	 edx, 2
  00046	8b c2		 mov	 eax, edx
  00048	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0004b	03 c2		 add	 eax, edx
  0004d	3b f0		 cmp	 esi, eax
  0004f	76 21		 jbe	 SHORT $LN1@Reserve

; 1295 : 			;
; 1296 : 		else
; 1297 : 			reserve(_Grow_to(_Size));

  00051	8b d0		 mov	 edx, eax
  00053	d1 ea		 shr	 edx, 1
  00055	bf aa aa aa 0a	 mov	 edi, 178956970		; 0aaaaaaaH
  0005a	2b fa		 sub	 edi, edx
  0005c	3b f8		 cmp	 edi, eax
  0005e	73 04		 jae	 SHORT $LN23@Reserve
  00060	33 c0		 xor	 eax, eax
  00062	eb 02		 jmp	 SHORT $LN24@Reserve
$LN23@Reserve:
  00064	03 c2		 add	 eax, edx
$LN24@Reserve:
  00066	3b c6		 cmp	 eax, esi
  00068	73 02		 jae	 SHORT $LN20@Reserve
  0006a	8b c6		 mov	 eax, esi
$LN20@Reserve:
  0006c	50		 push	 eax
  0006d	e8 00 00 00 00	 call	 ?reserve@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QAEXI@Z ; std::vector<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >::reserve
$LN1@Reserve:
  00072	5f		 pop	 edi
  00073	5e		 pop	 esi

; 1298 : 		}

  00074	5d		 pop	 ebp
  00075	c2 04 00	 ret	 4
$LN33@Reserve:
?_Reserve@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@IAEXI@Z ENDP ; std::vector<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >::_Reserve
_TEXT	ENDS
PUBLIC	??_7CDoubleGoerEvent@@6B@			; CDoubleGoerEvent::`vftable'
PUBLIC	??0CDoubleGoerEvent@@QAE@XZ			; CDoubleGoerEvent::CDoubleGoerEvent
PUBLIC	??_R4CDoubleGoerEvent@@6B@			; CDoubleGoerEvent::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCDoubleGoerEvent@@@8			; CDoubleGoerEvent `RTTI Type Descriptor'
PUBLIC	??_R3CDoubleGoerEvent@@8			; CDoubleGoerEvent::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CDoubleGoerEvent@@8			; CDoubleGoerEvent::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CDoubleGoerEvent@@8		; CDoubleGoerEvent::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	__imp__InitializeCriticalSection@4:PROC
EXTRN	??_ECDoubleGoerEvent@@UAEPAXI@Z:PROC		; CDoubleGoerEvent::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@CDoubleGoerEvent@@8
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
rdata$r	SEGMENT
??_R1A@?0A@EA@CDoubleGoerEvent@@8 DD FLAT:??_R0?AVCDoubleGoerEvent@@@8 ; CDoubleGoerEvent::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CDoubleGoerEvent@@8
rdata$r	ENDS
;	COMDAT ??_R2CDoubleGoerEvent@@8
rdata$r	SEGMENT
??_R2CDoubleGoerEvent@@8 DD FLAT:??_R1A@?0A@EA@CDoubleGoerEvent@@8 ; CDoubleGoerEvent::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CDoubleGoerEvent@@8
rdata$r	SEGMENT
??_R3CDoubleGoerEvent@@8 DD 00H				; CDoubleGoerEvent::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CDoubleGoerEvent@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCDoubleGoerEvent@@@8
_DATA	SEGMENT
??_R0?AVCDoubleGoerEvent@@@8 DD FLAT:??_7type_info@@6B@	; CDoubleGoerEvent `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCDoubleGoerEvent@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CDoubleGoerEvent@@6B@
rdata$r	SEGMENT
??_R4CDoubleGoerEvent@@6B@ DD 00H			; CDoubleGoerEvent::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCDoubleGoerEvent@@@8
	DD	FLAT:??_R3CDoubleGoerEvent@@8
rdata$r	ENDS
;	COMDAT ??_7CDoubleGoerEvent@@6B@
CONST	SEGMENT
??_7CDoubleGoerEvent@@6B@ DD FLAT:??_R4CDoubleGoerEvent@@6B@ ; CDoubleGoerEvent::`vftable'
	DD	FLAT:??_ECDoubleGoerEvent@@UAEPAXI@Z
; Function compile flags: /Ogtp
; File c:\muserver_dev\development\mu-s8ep2-repack\gameserver\source\doublegoerevent.cpp
CONST	ENDS
;	COMDAT ??0CDoubleGoerEvent@@QAE@XZ
_TEXT	SEGMENT
??0CDoubleGoerEvent@@QAE@XZ PROC			; CDoubleGoerEvent::CDoubleGoerEvent, COMDAT
; _this$ = ecx

; 61   : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	33 c0		 xor	 eax, eax
  00005	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7CDoubleGoerEvent@@6B@
  0000b	89 86 64 02 00
	00		 mov	 DWORD PTR [esi+612], eax
  00011	89 86 68 02 00
	00		 mov	 DWORD PTR [esi+616], eax
  00017	89 86 6c 02 00
	00		 mov	 DWORD PTR [esi+620], eax

; 62   : 	Init();

  0001d	e8 00 00 00 00	 call	 ?Init@CDoubleGoerEvent@@QAEXXZ ; CDoubleGoerEvent::Init

; 63   : 	InitializeCriticalSection(&m_sCrit);

  00022	8d 46 68	 lea	 eax, DWORD PTR [esi+104]
  00025	50		 push	 eax
  00026	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InitializeCriticalSection@4

; 64   : }

  0002c	8b c6		 mov	 eax, esi
  0002e	5e		 pop	 esi
  0002f	c3		 ret	 0
??0CDoubleGoerEvent@@QAE@XZ ENDP			; CDoubleGoerEvent::CDoubleGoerEvent
_TEXT	ENDS
PUBLIC	??1CDoubleGoerEvent@@UAE@XZ			; CDoubleGoerEvent::~CDoubleGoerEvent
EXTRN	__imp__DeleteCriticalSection@4:PROC
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
xdata$x	SEGMENT
__unwindtable$??1CDoubleGoerEvent@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CDoubleGoerEvent@@UAE@XZ$0
__ehfuncinfo$??1CDoubleGoerEvent@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1CDoubleGoerEvent@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\muserver_dev\development\mu-s8ep2-repack\gameserver\source\doublegoerevent.cpp
xdata$x	ENDS
;	COMDAT ??1CDoubleGoerEvent@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CDoubleGoerEvent@@UAE@XZ PROC			; CDoubleGoerEvent::~CDoubleGoerEvent, COMDAT
; _this$ = ecx

; 67   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1CDoubleGoerEvent@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	53		 push	 ebx
  00013	56		 push	 esi
  00014	57		 push	 edi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00026	8b f9		 mov	 edi, ecx
  00028	89 7d f0	 mov	 DWORD PTR _this$[ebp], edi
  0002b	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7CDoubleGoerEvent@@6B@

; 68   : 
; 69   : 	if( !m_vtReward.empty() )

  00031	8b 87 64 02 00
	00		 mov	 eax, DWORD PTR [edi+612]
  00037	33 db		 xor	 ebx, ebx
  00039	89 5d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], ebx
  0003c	3b 87 68 02 00
	00		 cmp	 eax, DWORD PTR [edi+616]
  00042	74 35		 je	 SHORT $LN3@CDoubleGoe

; 70   : 	{
; 71   : 		vtReward::iterator _It = m_vtReward.begin();

  00044	8b f0		 mov	 esi, eax

; 72   : 
; 73   : 		for( ; _It != m_vtReward.end(); _It++)

  00046	3b b7 68 02 00
	00		 cmp	 esi, DWORD PTR [edi+616]
  0004c	74 2b		 je	 SHORT $LN3@CDoubleGoe
  0004e	8b ff		 npad	 2
$LL28@CDoubleGoe:

; 74   : 		{
; 75   : 			if( _It->m_SilverBox != NULL )

  00050	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00053	3b cb		 cmp	 ecx, ebx
  00055	74 08		 je	 SHORT $LN68@CDoubleGoe

; 76   : 				delete _It->m_SilverBox;

  00057	8b 11		 mov	 edx, DWORD PTR [ecx]
  00059	8b 02		 mov	 eax, DWORD PTR [edx]
  0005b	6a 01		 push	 1
  0005d	ff d0		 call	 eax

; 77   : 
; 78   : 			if( _It->m_GoldenBox != NULL )

$LN68@CDoubleGoe:
  0005f	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00062	3b cb		 cmp	 ecx, ebx
  00064	74 08		 je	 SHORT $LN4@CDoubleGoe

; 79   : 				delete _It->m_GoldenBox;

  00066	8b 11		 mov	 edx, DWORD PTR [ecx]
  00068	8b 02		 mov	 eax, DWORD PTR [edx]
  0006a	6a 01		 push	 1
  0006c	ff d0		 call	 eax
$LN4@CDoubleGoe:

; 72   : 
; 73   : 		for( ; _It != m_vtReward.end(); _It++)

  0006e	83 c6 18	 add	 esi, 24			; 00000018H
  00071	3b b7 68 02 00
	00		 cmp	 esi, DWORD PTR [edi+616]
  00077	75 d7		 jne	 SHORT $LL28@CDoubleGoe
$LN3@CDoubleGoe:

; 80   : 		}
; 81   : 	}
; 82   : 
; 83   : 	DeleteCriticalSection(&m_sCrit);

  00079	8d 4f 68	 lea	 ecx, DWORD PTR [edi+104]
  0007c	51		 push	 ecx
  0007d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteCriticalSection@4

; 84   : }

  00083	8b 87 64 02 00
	00		 mov	 eax, DWORD PTR [edi+612]
  00089	3b c3		 cmp	 eax, ebx
  0008b	74 09		 je	 SHORT $LN87@CDoubleGoe
  0008d	50		 push	 eax
  0008e	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00093	83 c4 04	 add	 esp, 4
$LN87@CDoubleGoe:
  00096	89 9f 64 02 00
	00		 mov	 DWORD PTR [edi+612], ebx
  0009c	89 9f 68 02 00
	00		 mov	 DWORD PTR [edi+616], ebx
  000a2	89 9f 6c 02 00
	00		 mov	 DWORD PTR [edi+620], ebx
  000a8	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000ab	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000b2	59		 pop	 ecx
  000b3	5f		 pop	 edi
  000b4	5e		 pop	 esi
  000b5	5b		 pop	 ebx
  000b6	8b e5		 mov	 esp, ebp
  000b8	5d		 pop	 ebp
  000b9	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CDoubleGoerEvent@@UAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	81 c1 64 02 00
	00		 add	 ecx, 612		; 00000264H
  00009	e9 00 00 00 00	 jmp	 ??1?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QAE@XZ ; std::vector<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >::~vector<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >
__ehhandler$??1CDoubleGoerEvent@@UAE@XZ:
  0000e	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00012	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00015	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00018	33 c8		 xor	 ecx, eax
  0001a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001f	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1CDoubleGoerEvent@@UAE@XZ
  00024	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1CDoubleGoerEvent@@UAE@XZ ENDP			; CDoubleGoerEvent::~CDoubleGoerEvent
PUBLIC	?push_back@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QAEXABU_st_reward@CDoubleGoerEvent@@@Z ; std::vector<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >::push_back
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?push_back@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QAEXABU_st_reward@CDoubleGoerEvent@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QAEXABU_st_reward@CDoubleGoerEvent@@@Z PROC ; std::vector<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >::push_back, COMDAT
; _this$ = ecx

; 976  : 		{	// insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 977  : 		if (_Inside(_STD addressof(_Val)))

  00006	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00009	57		 push	 edi
  0000a	8b 7d 08	 mov	 edi, DWORD PTR __Val$[ebp]
  0000d	3b f9		 cmp	 edi, ecx
  0000f	73 4a		 jae	 SHORT $LN4@push_back
  00011	8b 06		 mov	 eax, DWORD PTR [esi]
  00013	3b c7		 cmp	 eax, edi
  00015	77 44		 ja	 SHORT $LN4@push_back

; 978  : 			{	// push back an element
; 979  : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;

  00017	2b f8		 sub	 edi, eax
  00019	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0001e	f7 ef		 imul	 edi
  00020	c1 fa 02	 sar	 edx, 2
  00023	8b fa		 mov	 edi, edx
  00025	c1 ef 1f	 shr	 edi, 31			; 0000001fH
  00028	03 fa		 add	 edi, edx

; 980  : 			if (this->_Mylast == this->_Myend)

  0002a	3b 4e 08	 cmp	 ecx, DWORD PTR [esi+8]
  0002d	75 09		 jne	 SHORT $LN3@push_back

; 981  : 				_Reserve(1);

  0002f	6a 01		 push	 1
  00031	8b ce		 mov	 ecx, esi
  00033	e8 00 00 00 00	 call	 ?_Reserve@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@IAEXI@Z ; std::vector<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >::_Reserve
$LN3@push_back:

; 982  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 983  : 			_Cons_val(this->_Alval,
; 984  : 				this->_Mylast,
; 985  : 				this->_Myfirst[_Idx]);

  00038	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0003a	8d 04 7f	 lea	 eax, DWORD PTR [edi+edi*2]
  0003d	8d 14 c1	 lea	 edx, DWORD PTR [ecx+eax*8]
  00040	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00043	52		 push	 edx
  00044	50		 push	 eax
  00045	8d 4e 0c	 lea	 ecx, DWORD PTR [esi+12]
  00048	51		 push	 ecx
  00049	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@U_st_reward@CDoubleGoerEvent@@AAU34@@std@@YAXAAV?$allocator@U_st_reward@CDoubleGoerEvent@@@0@PAU_st_reward@CDoubleGoerEvent@@AAU23@@Z ; std::_Cons_val<std::allocator<CDoubleGoerEvent::_st_reward>,CDoubleGoerEvent::_st_reward,CDoubleGoerEvent::_st_reward &>

; 992  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 993  : 			_Cons_val(this->_Alval,
; 994  : 				this->_Mylast,
; 995  : 				_Val);

  0004e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 996  : 			++this->_Mylast;

  00051	83 46 04 18	 add	 DWORD PTR [esi+4], 24	; 00000018H
  00055	5f		 pop	 edi
  00056	5e		 pop	 esi

; 997  : 			}
; 998  : 		}

  00057	5d		 pop	 ebp
  00058	c2 04 00	 ret	 4
$LN4@push_back:

; 986  : 			++this->_Mylast;
; 987  : 			}
; 988  : 		else
; 989  : 			{	// push back a non-element
; 990  : 			if (this->_Mylast == this->_Myend)

  0005b	3b 4e 08	 cmp	 ecx, DWORD PTR [esi+8]
  0005e	75 09		 jne	 SHORT $LN1@push_back

; 991  : 				_Reserve(1);

  00060	6a 01		 push	 1
  00062	8b ce		 mov	 ecx, esi
  00064	e8 00 00 00 00	 call	 ?_Reserve@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@IAEXI@Z ; std::vector<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >::_Reserve
$LN1@push_back:

; 992  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 993  : 			_Cons_val(this->_Alval,
; 994  : 				this->_Mylast,
; 995  : 				_Val);

  00069	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0006c	57		 push	 edi
  0006d	52		 push	 edx
  0006e	8d 46 0c	 lea	 eax, DWORD PTR [esi+12]
  00071	50		 push	 eax
  00072	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@U_st_reward@CDoubleGoerEvent@@ABU34@@std@@YAXAAV?$allocator@U_st_reward@CDoubleGoerEvent@@@0@PAU_st_reward@CDoubleGoerEvent@@ABU23@@Z ; std::_Cons_val<std::allocator<CDoubleGoerEvent::_st_reward>,CDoubleGoerEvent::_st_reward,CDoubleGoerEvent::_st_reward const &>
  00077	83 c4 0c	 add	 esp, 12			; 0000000cH

; 996  : 			++this->_Mylast;

  0007a	83 46 04 18	 add	 DWORD PTR [esi+4], 24	; 00000018H
  0007e	5f		 pop	 edi
  0007f	5e		 pop	 esi

; 997  : 			}
; 998  : 		}

  00080	5d		 pop	 ebp
  00081	c2 04 00	 ret	 4
?push_back@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QAEXABU_st_reward@CDoubleGoerEvent@@@Z ENDP ; std::vector<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >::push_back
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??_GCDoubleGoerEvent@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCDoubleGoerEvent@@UAEPAXI@Z PROC			; CDoubleGoerEvent::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1CDoubleGoerEvent@@UAE@XZ ; CDoubleGoerEvent::~CDoubleGoerEvent
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 09		 je	 SHORT $LN4@scalar@2
  00011	56		 push	 esi
  00012	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00017	83 c4 04	 add	 esp, 4
$LN4@scalar@2:
  0001a	8b c6		 mov	 eax, esi
  0001c	5e		 pop	 esi
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
??_GCDoubleGoerEvent@@UAEPAXI@Z ENDP			; CDoubleGoerEvent::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_C@_0CB@IKMIMFMN@?$FLDoppelganger?$FN?5File?5loaded?$CB?5?$CI?$CFs?$CJ@ ; `string'
PUBLIC	??_C@_0BD@OCBGMAON@MirrorMarkDropRate?$AA@	; `string'
PUBLIC	??_C@_0P@EMJDPFDH@GameServerInfo?$AA@		; `string'
PUBLIC	??_C@_0BD@CJDCIJOM@DoubleGoerEventRun?$AA@	; `string'
PUBLIC	??_C@_0BB@COIIOJMI@CommonServer?4cfg?$AA@	; `string'
PUBLIC	??_C@_0CM@FHCDMICJ@?$FLDoppelganger?$FN?5LevelInfo?5loaded?5@ ; `string'
PUBLIC	??_C@_0DF@EDENJKPK@?$FLDoppelganger?$FN?5?9?5Loading?5Excepti@ ; `string'
PUBLIC	??_C@_0CK@DEJPFHMP@?$FLDoppelganger?$FN?5Failed?5to?5init?5go@ ; `string'
PUBLIC	??_C@_0CK@PBHMNHEC@?$FLDoppelganger?$FN?5Failed?5to?5init?5si@ ; `string'
PUBLIC	??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@		; `string'
PUBLIC	??_C@_0BL@LIHHGBKD@EventItemBag?2Doppelganger?2?$AA@ ; `string'
PUBLIC	??_C@_03JBJLGPFL@end?$AA@			; `string'
PUBLIC	??_C@_0CE@NPGGBMKD@?$FLDoppelganger?$FN?5Load?5File?5failed?$CI@ ; `string'
PUBLIC	_lpszFileName$GSCopy$
PUBLIC	_this$GSCopy$
PUBLIC	??_C@_01KDCPPGHE@r?$AA@				; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?LoadData@CDoubleGoerEvent@@QAEXPAD@Z		; CDoubleGoerEvent::LoadData
PUBLIC	??_R0K@8					; unsigned long `RTTI Type Descriptor'
EXTRN	__imp__GetPrivateProfileIntA@16:PROC
EXTRN	?Read@EventItemBag@@QAEXPAD@Z:PROC		; EventItemBag::Read
EXTRN	?GetNewPath@CDirPath@@QAEPADPAD@Z:PROC		; CDirPath::GetNewPath
EXTRN	?gDirPath@@3VCDirPath@@A:BYTE			; gDirPath
EXTRN	_sprintf:PROC
EXTRN	??0EventItemBag@@QAE@XZ:PROC			; EventItemBag::EventItemBag
EXTRN	?MsgBox@@YAXPADZZ:PROC				; MsgBox
EXTRN	_fopen:PROC
;	COMDAT ??_R0K@8
; File c:\muserver_dev\development\mu-s8ep2-repack\gameserver\source\doublegoerevent.h
_DATA	SEGMENT
??_R0K@8 DD	FLAT:??_7type_info@@6B@			; unsigned long `RTTI Type Descriptor'
	DD	00H
	DB	'.K', 00H
_DATA	ENDS
;	COMDAT ??_C@_0CB@IKMIMFMN@?$FLDoppelganger?$FN?5File?5loaded?$CB?5?$CI?$CFs?$CJ@
CONST	SEGMENT
??_C@_0CB@IKMIMFMN@?$FLDoppelganger?$FN?5File?5loaded?$CB?5?$CI?$CFs?$CJ@ DB '['
	DB	'Doppelganger] File loaded! (%s)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@OCBGMAON@MirrorMarkDropRate?$AA@
CONST	SEGMENT
??_C@_0BD@OCBGMAON@MirrorMarkDropRate?$AA@ DB 'MirrorMarkDropRate', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@EMJDPFDH@GameServerInfo?$AA@
CONST	SEGMENT
??_C@_0P@EMJDPFDH@GameServerInfo?$AA@ DB 'GameServerInfo', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@CJDCIJOM@DoubleGoerEventRun?$AA@
CONST	SEGMENT
??_C@_0BD@CJDCIJOM@DoubleGoerEventRun?$AA@ DB 'DoubleGoerEventRun', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@COIIOJMI@CommonServer?4cfg?$AA@
CONST	SEGMENT
??_C@_0BB@COIIOJMI@CommonServer?4cfg?$AA@ DB 'CommonServer.cfg', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@FHCDMICJ@?$FLDoppelganger?$FN?5LevelInfo?5loaded?5@
CONST	SEGMENT
??_C@_0CM@FHCDMICJ@?$FLDoppelganger?$FN?5LevelInfo?5loaded?5@ DB '[Doppel'
	DB	'ganger] LevelInfo loaded [%d] levels', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@EDENJKPK@?$FLDoppelganger?$FN?5?9?5Loading?5Excepti@
CONST	SEGMENT
??_C@_0DF@EDENJKPK@?$FLDoppelganger?$FN?5?9?5Loading?5Excepti@ DB '[Doppe'
	DB	'lganger] - Loading Exception Error (%s) File. ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@DEJPFHMP@?$FLDoppelganger?$FN?5Failed?5to?5init?5go@
CONST	SEGMENT
??_C@_0CK@DEJPFHMP@?$FLDoppelganger?$FN?5Failed?5to?5init?5go@ DB '[Doppe'
	DB	'lganger] Failed to init golden box!', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@PBHMNHEC@?$FLDoppelganger?$FN?5Failed?5to?5init?5si@
CONST	SEGMENT
??_C@_0CK@PBHMNHEC@?$FLDoppelganger?$FN?5Failed?5to?5init?5si@ DB '[Doppe'
	DB	'lganger] Failed to init silver box!', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@
CONST	SEGMENT
??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@ DB '%s%s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@LIHHGBKD@EventItemBag?2Doppelganger?2?$AA@
CONST	SEGMENT
??_C@_0BL@LIHHGBKD@EventItemBag?2Doppelganger?2?$AA@ DB 'EventItemBag\Dop'
	DB	'pelganger\', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_03JBJLGPFL@end?$AA@
CONST	SEGMENT
??_C@_03JBJLGPFL@end?$AA@ DB 'end', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@NPGGBMKD@?$FLDoppelganger?$FN?5Load?5File?5failed?$CI@
CONST	SEGMENT
??_C@_0CE@NPGGBMKD@?$FLDoppelganger?$FN?5Load?5File?5failed?$CI@ DB '[Dop'
	DB	'pelganger] Load File failed(%s)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01KDCPPGHE@r?$AA@
CONST	SEGMENT
??_C@_01KDCPPGHE@r?$AA@ DB 'r', 00H			; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?LoadData@CDoubleGoerEvent@@QAEXPAD@Z$4 DD 00H
	DD	FLAT:??_R0K@8
	DD	00H
	DD	FLAT:__catch$?LoadData@CDoubleGoerEvent@@QAEXPAD@Z$0
__tryblocktable$?LoadData@CDoubleGoerEvent@@QAEXPAD@Z DD 00H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?LoadData@CDoubleGoerEvent@@QAEXPAD@Z$4
__unwindtable$?LoadData@CDoubleGoerEvent@@QAEXPAD@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$?LoadData@CDoubleGoerEvent@@QAEXPAD@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$?LoadData@CDoubleGoerEvent@@QAEXPAD@Z$3
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?LoadData@CDoubleGoerEvent@@QAEXPAD@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?LoadData@CDoubleGoerEvent@@QAEXPAD@Z
	DD	01H
	DD	FLAT:__tryblocktable$?LoadData@CDoubleGoerEvent@@QAEXPAD@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\muserver_dev\development\mu-s8ep2-repack\gameserver\source\doublegoerevent.cpp
xdata$x	ENDS
;	COMDAT ?LoadData@CDoubleGoerEvent@@QAEXPAD@Z
_TEXT	SEGMENT
_pTmp$183634 = -580					; size = 24
_Index$183611 = -556					; size = 4
$T190477 = -552						; size = 4
$T190473 = -552						; size = 4
_lpszFileName$GSCopy$ = -548				; size = 4
__Cat$190919 = -544					; size = 1
_this$GSCopy$ = -544					; size = 4
_Path$183650 = -540					; size = 260
_Path$183640 = -280					; size = 260
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
_lpszFileName$ = 8					; size = 4
?LoadData@CDoubleGoerEvent@@QAEXPAD@Z PROC		; CDoubleGoerEvent::LoadData, COMDAT
; _this$ = ecx

; 126  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?LoadData@CDoubleGoerEvent@@QAEXPAD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 38 02 00
	00		 sub	 esp, 568		; 00000238H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00031	8b 75 08	 mov	 esi, DWORD PTR _lpszFileName$[ebp]
  00034	8b f9		 mov	 edi, ecx

; 127  : 	SMDFile = fopen(lpszFileName,"r");

  00036	68 00 00 00 00	 push	 OFFSET ??_C@_01KDCPPGHE@r?$AA@
  0003b	56		 push	 esi
  0003c	89 bd e0 fd ff
	ff		 mov	 DWORD PTR _this$GSCopy$[ebp], edi
  00042	89 b5 dc fd ff
	ff		 mov	 DWORD PTR _lpszFileName$GSCopy$[ebp], esi
  00048	e8 00 00 00 00	 call	 _fopen

; 128  : 
; 129  : 	if( SMDFile == NULL )

  0004d	33 db		 xor	 ebx, ebx
  0004f	83 c4 08	 add	 esp, 8
  00052	a3 00 00 00 00	 mov	 DWORD PTR _SMDFile, eax
  00057	3b c3		 cmp	 eax, ebx
  00059	75 10		 jne	 SHORT $LN25@LoadData

; 130  : 	{
; 131  : 		MsgBox("[Doppelganger] Load File failed(%s)",lpszFileName);

  0005b	56		 push	 esi
  0005c	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@NPGGBMKD@?$FLDoppelganger?$FN?5Load?5File?5failed?$CI@
  00061	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox

; 132  : 		return;

  00066	e9 1c 04 00 00	 jmp	 $LN189@LoadData
$LN25@LoadData:

; 133  : 	}
; 134  : 
; 135  : 	m_iLoadedInfo = 0;

  0006b	89 9f 60 02 00
	00		 mov	 DWORD PTR [edi+608], ebx

; 136  : 
; 137  : 	if( !m_vtReward.empty() )

  00071	8b 87 64 02 00
	00		 mov	 eax, DWORD PTR [edi+612]
  00077	3b 87 68 02 00
	00		 cmp	 eax, DWORD PTR [edi+616]
  0007d	74 3a		 je	 SHORT $LN21@LoadData

; 138  : 	{
; 139  : 		vtReward::iterator _It = m_vtReward.begin();

  0007f	8b f0		 mov	 esi, eax

; 140  : 
; 141  : 		for( ; _It != m_vtReward.end(); _It++)

  00081	3b b7 68 02 00
	00		 cmp	 esi, DWORD PTR [edi+616]
  00087	74 30		 je	 SHORT $LN21@LoadData
  00089	8d a4 24 00 00
	00 00		 npad	 7
$LL56@LoadData:

; 142  : 		{
; 143  : 			if( _It->m_SilverBox != NULL )

  00090	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00093	3b cb		 cmp	 ecx, ebx
  00095	74 08		 je	 SHORT $LN96@LoadData

; 144  : 				delete _It->m_SilverBox;

  00097	8b 11		 mov	 edx, DWORD PTR [ecx]
  00099	8b 02		 mov	 eax, DWORD PTR [edx]
  0009b	6a 01		 push	 1
  0009d	ff d0		 call	 eax

; 145  : 
; 146  : 			if( _It->m_GoldenBox != NULL )

$LN96@LoadData:
  0009f	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  000a2	3b cb		 cmp	 ecx, ebx
  000a4	74 08		 je	 SHORT $LN22@LoadData

; 147  : 				delete _It->m_GoldenBox;

  000a6	8b 11		 mov	 edx, DWORD PTR [ecx]
  000a8	8b 02		 mov	 eax, DWORD PTR [edx]
  000aa	6a 01		 push	 1
  000ac	ff d0		 call	 eax
$LN22@LoadData:

; 140  : 
; 141  : 		for( ; _It != m_vtReward.end(); _It++)

  000ae	83 c6 18	 add	 esi, 24			; 00000018H
  000b1	3b b7 68 02 00
	00		 cmp	 esi, DWORD PTR [edi+616]
  000b7	75 d7		 jne	 SHORT $LL56@LoadData
$LN21@LoadData:

; 148  : 		}
; 149  : 	}
; 150  : 
; 151  : 	m_vtReward.clear();

  000b9	8b 87 68 02 00
	00		 mov	 eax, DWORD PTR [edi+616]
  000bf	8b 8f 64 02 00
	00		 mov	 ecx, DWORD PTR [edi+612]
  000c5	3b c8		 cmp	 ecx, eax
  000c7	74 18		 je	 SHORT $LN126@LoadData
  000c9	8b 95 e0 fd ff
	ff		 mov	 edx, DWORD PTR __Cat$190919[ebp]
  000cf	52		 push	 edx
  000d0	51		 push	 ecx
  000d1	50		 push	 eax
  000d2	50		 push	 eax
  000d3	e8 00 00 00 00	 call	 ??$_Move@PAU_st_reward@CDoubleGoerEvent@@PAU12@@std@@YAPAU_st_reward@CDoubleGoerEvent@@PAU12@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Move<CDoubleGoerEvent::_st_reward *,CDoubleGoerEvent::_st_reward *>
  000d8	83 c4 10	 add	 esp, 16			; 00000010H
  000db	89 87 68 02 00
	00		 mov	 DWORD PTR [edi+616], eax
$LN126@LoadData:

; 152  : 
; 153  : 	try
; 154  : 	{

  000e1	89 5d fc	 mov	 DWORD PTR __$EHRec$[ebp+12], ebx
$LL17@LoadData:

; 155  : 		int Token,Index;
; 156  : 
; 157  : 		while( TRUE )
; 158  : 		{
; 159  : 			Token = GetToken();

  000e4	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 160  : 
; 161  : 			if( Token == END )

  000e9	83 f8 02	 cmp	 eax, 2
  000ec	75 0c		 jne	 SHORT $LN15@LoadData
  000ee	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  000f5	e9 18 03 00 00	 jmp	 $LN41@LoadData
$LN15@LoadData:

; 162  : 				break;
; 163  : 
; 164  : 			Index = (int)TokenNumber;

  000fa	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00100	e8 00 00 00 00	 call	 __ftol2_sse
  00105	8b f0		 mov	 esi, eax
  00107	89 b5 d4 fd ff
	ff		 mov	 DWORD PTR _Index$183611[ebp], esi
  0010d	8d 49 00	 npad	 3
$LL14@LoadData:

; 165  : 
; 166  : 			while( TRUE )
; 167  : 			{
; 168  : 				if( Index == 0 )

  00110	3b f3		 cmp	 esi, ebx
  00112	75 74		 jne	 SHORT $LN12@LoadData

; 169  : 				{
; 170  : 					Token = GetToken();

  00114	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 171  : 
; 172  : 					if( strcmp("end",TokenString) == NULL )

  00119	b9 00 00 00 00	 mov	 ecx, OFFSET _TokenString
  0011e	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_03JBJLGPFL@end?$AA@
$LL172@LoadData:
  00123	8a 10		 mov	 dl, BYTE PTR [eax]
  00125	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00127	75 1a		 jne	 SHORT $LN173@LoadData
  00129	3a d3		 cmp	 dl, bl
  0012b	74 12		 je	 SHORT $LN174@LoadData
  0012d	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  00130	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00133	75 0e		 jne	 SHORT $LN173@LoadData
  00135	83 c0 02	 add	 eax, 2
  00138	83 c1 02	 add	 ecx, 2
  0013b	3a d3		 cmp	 dl, bl
  0013d	75 e4		 jne	 SHORT $LL172@LoadData
$LN174@LoadData:
  0013f	33 c0		 xor	 eax, eax
  00141	eb 05		 jmp	 SHORT $LN175@LoadData
$LN173@LoadData:
  00143	1b c0		 sbb	 eax, eax
  00145	83 d8 ff	 sbb	 eax, -1
$LN175@LoadData:
  00148	3b c3		 cmp	 eax, ebx
  0014a	74 98		 je	 SHORT $LL17@LoadData

; 173  : 						break;
; 174  : 
; 175  : 					m_iEVENT_WAIT = (int)TokenNumber;

  0014c	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00152	e8 00 00 00 00	 call	 __ftol2_sse
  00157	89 47 10	 mov	 DWORD PTR [edi+16], eax

; 176  : 
; 177  : 					Token = GetToken();

  0015a	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 178  : 					m_iEVENT_TIME = (int)TokenNumber;

  0015f	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00165	e8 00 00 00 00	 call	 __ftol2_sse
  0016a	89 47 14	 mov	 DWORD PTR [edi+20], eax

; 179  : 
; 180  : 					Token = GetToken();

  0016d	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 181  : 					m_iEVENT_PLAYEND = (int)TokenNumber;

  00172	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00178	e8 00 00 00 00	 call	 __ftol2_sse
  0017d	89 47 18	 mov	 DWORD PTR [edi+24], eax

; 182  : 
; 183  : 					m_iMONSTER_MINUTE_SPAWN = m_iEVENT_TIME;

  00180	8b 47 14	 mov	 eax, DWORD PTR [edi+20]
  00183	89 47 40	 mov	 DWORD PTR [edi+64], eax
  00186	eb 88		 jmp	 SHORT $LL14@LoadData
$LN12@LoadData:

; 184  : 				}
; 185  : 				else if( Index == 1 )

  00188	83 fe 01	 cmp	 esi, 1
  0018b	75 66		 jne	 SHORT $LN9@LoadData

; 186  : 				{
; 187  : 					Token = GetToken();

  0018d	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 188  : 
; 189  : 					if( strcmp("end",TokenString) == NULL )

  00192	b9 00 00 00 00	 mov	 ecx, OFFSET _TokenString
  00197	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_03JBJLGPFL@end?$AA@
  0019c	8d 64 24 00	 npad	 4
$LL176@LoadData:
  001a0	8a 10		 mov	 dl, BYTE PTR [eax]
  001a2	3a 11		 cmp	 dl, BYTE PTR [ecx]
  001a4	75 1a		 jne	 SHORT $LN177@LoadData
  001a6	3a d3		 cmp	 dl, bl
  001a8	74 12		 je	 SHORT $LN178@LoadData
  001aa	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  001ad	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  001b0	75 0e		 jne	 SHORT $LN177@LoadData
  001b2	83 c0 02	 add	 eax, 2
  001b5	83 c1 02	 add	 ecx, 2
  001b8	3a d3		 cmp	 dl, bl
  001ba	75 e4		 jne	 SHORT $LL176@LoadData
$LN178@LoadData:
  001bc	33 c0		 xor	 eax, eax
  001be	eb 05		 jmp	 SHORT $LN179@LoadData
$LN177@LoadData:
  001c0	1b c0		 sbb	 eax, eax
  001c2	83 d8 ff	 sbb	 eax, -1
$LN179@LoadData:
  001c5	3b c3		 cmp	 eax, ebx
  001c7	0f 84 17 ff ff
	ff		 je	 $LL17@LoadData

; 190  : 						break;
; 191  : 
; 192  : 					m_iMONSTER_COUNT = (int)TokenNumber;

  001cd	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  001d3	e8 00 00 00 00	 call	 __ftol2_sse
  001d8	89 47 1c	 mov	 DWORD PTR [edi+28], eax

; 193  : 
; 194  : 					Token = GetToken();

  001db	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 195  : 					m_iMONSTER_PER_MINUTE = (int)TokenNumber;

  001e0	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  001e6	e8 00 00 00 00	 call	 __ftol2_sse
  001eb	89 47 20	 mov	 DWORD PTR [edi+32], eax
  001ee	e9 1d ff ff ff	 jmp	 $LL14@LoadData
$LN9@LoadData:

; 196  : 				}
; 197  : 				else if( Index == 2 )

  001f3	83 fe 02	 cmp	 esi, 2
  001f6	0f 85 14 ff ff
	ff		 jne	 $LL14@LoadData

; 198  : 				{
; 199  : 					Token = GetToken();

  001fc	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 200  : 
; 201  : 					if( strcmp("end",TokenString) == NULL )

  00201	b9 00 00 00 00	 mov	 ecx, OFFSET _TokenString
  00206	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_03JBJLGPFL@end?$AA@
  0020b	eb 03 8d 49 00	 npad	 5
$LL180@LoadData:
  00210	8a 10		 mov	 dl, BYTE PTR [eax]
  00212	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00214	75 1a		 jne	 SHORT $LN181@LoadData
  00216	3a d3		 cmp	 dl, bl
  00218	74 12		 je	 SHORT $LN182@LoadData
  0021a	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0021d	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00220	75 0e		 jne	 SHORT $LN181@LoadData
  00222	83 c0 02	 add	 eax, 2
  00225	83 c1 02	 add	 ecx, 2
  00228	3a d3		 cmp	 dl, bl
  0022a	75 e4		 jne	 SHORT $LL180@LoadData
$LN182@LoadData:
  0022c	33 c0		 xor	 eax, eax
  0022e	eb 05		 jmp	 SHORT $LN183@LoadData
$LN181@LoadData:
  00230	1b c0		 sbb	 eax, eax
  00232	83 d8 ff	 sbb	 eax, -1
$LN183@LoadData:
  00235	3b c3		 cmp	 eax, ebx

; 245  : 				}
; 246  : 			}
; 247  : 		}

  00237	0f 84 a7 fe ff
	ff		 je	 $LL17@LoadData

; 202  : 						break;
; 203  : 
; 204  : 					_st_reward pTmp;

  0023d	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00243	89 9d cc fd ff
	ff		 mov	 DWORD PTR _pTmp$183634[ebp+16], ebx
  00249	89 9d d0 fd ff
	ff		 mov	 DWORD PTR _pTmp$183634[ebp+20], ebx

; 205  : 
; 206  : 					pTmp.m_ResetMin = TokenNumber;

  0024f	e8 00 00 00 00	 call	 __ftol2_sse
  00254	89 85 bc fd ff
	ff		 mov	 DWORD PTR _pTmp$183634[ebp], eax

; 207  : 
; 208  : 					Token = GetToken();

  0025a	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 209  : 					pTmp.m_ResetMax = TokenNumber;

  0025f	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00265	e8 00 00 00 00	 call	 __ftol2_sse
  0026a	89 85 c0 fd ff
	ff		 mov	 DWORD PTR _pTmp$183634[ebp+4], eax

; 210  : 
; 211  : 					Token = GetToken();

  00270	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 212  : 					pTmp.m_LevelMin = TokenNumber;

  00275	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  0027b	e8 00 00 00 00	 call	 __ftol2_sse
  00280	89 85 c4 fd ff
	ff		 mov	 DWORD PTR _pTmp$183634[ebp+8], eax

; 213  : 
; 214  : 					Token = GetToken();

  00286	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 215  : 					pTmp.m_LevelMax = TokenNumber;

  0028b	d9 05 00 00 00
	00		 fld	 DWORD PTR _TokenNumber
  00291	e8 00 00 00 00	 call	 __ftol2_sse
  00296	89 85 c8 fd ff
	ff		 mov	 DWORD PTR _pTmp$183634[ebp+12], eax

; 216  : 
; 217  : 					Token = GetToken();

  0029c	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 218  : 					pTmp.m_SilverBox = new EventItemBag;

  002a1	68 54 02 00 00	 push	 596			; 00000254H
  002a6	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  002ab	83 c4 04	 add	 esp, 4
  002ae	89 85 d8 fd ff
	ff		 mov	 DWORD PTR $T190473[ebp], eax
  002b4	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1
  002b8	3b c3		 cmp	 eax, ebx
  002ba	74 0b		 je	 SHORT $LN32@LoadData
  002bc	8b c8		 mov	 ecx, eax
  002be	e8 00 00 00 00	 call	 ??0EventItemBag@@QAE@XZ	; EventItemBag::EventItemBag
  002c3	8b f0		 mov	 esi, eax
  002c5	eb 02		 jmp	 SHORT $LN33@LoadData
$LN32@LoadData:
  002c7	33 f6		 xor	 esi, esi
$LN33@LoadData:
  002c9	88 5d fc	 mov	 BYTE PTR __$EHRec$[ebp+12], bl
  002cc	89 b5 cc fd ff
	ff		 mov	 DWORD PTR _pTmp$183634[ebp+16], esi

; 219  : 					if( pTmp.m_SilverBox != NULL )

  002d2	3b f3		 cmp	 esi, ebx
  002d4	74 51		 je	 SHORT $LN4@LoadData

; 220  : 					{
; 221  : 						char Path[MAX_PATH] = { 0 };

  002d6	68 03 01 00 00	 push	 259			; 00000103H
  002db	8d 8d e9 fe ff
	ff		 lea	 ecx, DWORD PTR _Path$183640[ebp+1]
  002e1	53		 push	 ebx
  002e2	51		 push	 ecx
  002e3	88 9d e8 fe ff
	ff		 mov	 BYTE PTR _Path$183640[ebp], bl
  002e9	e8 00 00 00 00	 call	 _memset

; 222  : 						sprintf(Path, "%s%s", PATH_EVENTBAG_DOPPELGANGER, TokenString);

  002ee	68 00 00 00 00	 push	 OFFSET _TokenString
  002f3	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@LIHHGBKD@EventItemBag?2Doppelganger?2?$AA@
  002f8	8d 95 e8 fe ff
	ff		 lea	 edx, DWORD PTR _Path$183640[ebp]
  002fe	68 00 00 00 00	 push	 OFFSET ??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@
  00303	52		 push	 edx
  00304	e8 00 00 00 00	 call	 _sprintf
  00309	83 c4 1c	 add	 esp, 28			; 0000001cH

; 223  : 						pTmp.m_SilverBox->Read(gDirPath.GetNewPath(Path));

  0030c	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _Path$183640[ebp]
  00312	50		 push	 eax
  00313	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDirPath@@3VCDirPath@@A ; gDirPath
  00318	e8 00 00 00 00	 call	 ?GetNewPath@CDirPath@@QAEPADPAD@Z ; CDirPath::GetNewPath
  0031d	50		 push	 eax
  0031e	8b ce		 mov	 ecx, esi
  00320	e8 00 00 00 00	 call	 ?Read@EventItemBag@@QAEXPAD@Z ; EventItemBag::Read

; 224  : 					}
; 225  : 					else

  00325	eb 0d		 jmp	 SHORT $LN3@LoadData
$LN4@LoadData:

; 226  : 					{
; 227  : 						MsgBox("[Doppelganger] Failed to init silver box!");

  00327	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@PBHMNHEC@?$FLDoppelganger?$FN?5Failed?5to?5init?5si@
  0032c	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  00331	83 c4 04	 add	 esp, 4
$LN3@LoadData:

; 228  : 					}
; 229  : 
; 230  : 
; 231  : 					Token = GetToken();

  00334	e8 00 00 00 00	 call	 ?GetToken@@YA?AW4SMDToken@@XZ ; GetToken

; 232  : 					pTmp.m_GoldenBox = new EventItemBag;

  00339	68 54 02 00 00	 push	 596			; 00000254H
  0033e	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00343	83 c4 04	 add	 esp, 4
  00346	89 85 d8 fd ff
	ff		 mov	 DWORD PTR $T190477[ebp], eax
  0034c	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2
  00350	3b c3		 cmp	 eax, ebx
  00352	74 0b		 je	 SHORT $LN34@LoadData
  00354	8b c8		 mov	 ecx, eax
  00356	e8 00 00 00 00	 call	 ??0EventItemBag@@QAE@XZ	; EventItemBag::EventItemBag
  0035b	8b f0		 mov	 esi, eax
  0035d	eb 02		 jmp	 SHORT $LN35@LoadData
$LN34@LoadData:
  0035f	33 f6		 xor	 esi, esi
$LN35@LoadData:
  00361	88 5d fc	 mov	 BYTE PTR __$EHRec$[ebp+12], bl
  00364	89 b5 d0 fd ff
	ff		 mov	 DWORD PTR _pTmp$183634[ebp+20], esi

; 233  : 					if( pTmp.m_GoldenBox != NULL )

  0036a	3b f3		 cmp	 esi, ebx
  0036c	74 51		 je	 SHORT $LN2@LoadData

; 234  : 					{
; 235  : 						char Path[MAX_PATH] = { 0 };

  0036e	68 03 01 00 00	 push	 259			; 00000103H
  00373	8d 8d e5 fd ff
	ff		 lea	 ecx, DWORD PTR _Path$183650[ebp+1]
  00379	53		 push	 ebx
  0037a	51		 push	 ecx
  0037b	88 9d e4 fd ff
	ff		 mov	 BYTE PTR _Path$183650[ebp], bl
  00381	e8 00 00 00 00	 call	 _memset

; 236  : 						sprintf(Path, "%s%s", PATH_EVENTBAG_DOPPELGANGER, TokenString);

  00386	68 00 00 00 00	 push	 OFFSET _TokenString
  0038b	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@LIHHGBKD@EventItemBag?2Doppelganger?2?$AA@
  00390	8d 95 e4 fd ff
	ff		 lea	 edx, DWORD PTR _Path$183650[ebp]
  00396	68 00 00 00 00	 push	 OFFSET ??_C@_04HDOCAJNK@?$CFs?$CFs?$AA@
  0039b	52		 push	 edx
  0039c	e8 00 00 00 00	 call	 _sprintf
  003a1	83 c4 1c	 add	 esp, 28			; 0000001cH

; 237  : 						pTmp.m_GoldenBox->Read(gDirPath.GetNewPath(Path));

  003a4	8d 85 e4 fd ff
	ff		 lea	 eax, DWORD PTR _Path$183650[ebp]
  003aa	50		 push	 eax
  003ab	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDirPath@@3VCDirPath@@A ; gDirPath
  003b0	e8 00 00 00 00	 call	 ?GetNewPath@CDirPath@@QAEPADPAD@Z ; CDirPath::GetNewPath
  003b5	50		 push	 eax
  003b6	8b ce		 mov	 ecx, esi
  003b8	e8 00 00 00 00	 call	 ?Read@EventItemBag@@QAEXPAD@Z ; EventItemBag::Read

; 238  : 					}
; 239  : 					else

  003bd	eb 0d		 jmp	 SHORT $LN1@LoadData
$LN2@LoadData:

; 240  : 					{
; 241  : 						MsgBox("[Doppelganger] Failed to init golden box!");

  003bf	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@DEJPFHMP@?$FLDoppelganger?$FN?5Failed?5to?5init?5go@
  003c4	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  003c9	83 c4 04	 add	 esp, 4
$LN1@LoadData:

; 242  : 					}
; 243  : 
; 244  : 					m_vtReward.push_back(pTmp);

  003cc	8d 95 bc fd ff
	ff		 lea	 edx, DWORD PTR _pTmp$183634[ebp]
  003d2	8d 8f 64 02 00
	00		 lea	 ecx, DWORD PTR [edi+612]
  003d8	52		 push	 edx
  003d9	e8 00 00 00 00	 call	 ?push_back@?$vector@U_st_reward@CDoubleGoerEvent@@V?$allocator@U_st_reward@CDoubleGoerEvent@@@std@@@std@@QAEXABU_st_reward@CDoubleGoerEvent@@@Z ; std::vector<CDoubleGoerEvent::_st_reward,std::allocator<CDoubleGoerEvent::_st_reward> >::push_back
  003de	8b b5 d4 fd ff
	ff		 mov	 esi, DWORD PTR _Index$183611[ebp]
  003e4	e9 27 fd ff ff	 jmp	 $LL14@LoadData
__catch$?LoadData@CDoubleGoerEvent@@QAEXPAD@Z$0:

; 248  : 
; 249  : 	}
; 250  : 	catch( DWORD )
; 251  : 	{
; 252  : 		MsgBox("[Doppelganger] - Loading Exception Error (%s) File. ", lpszFileName);

  003e9	8b 85 dc fd ff
	ff		 mov	 eax, DWORD PTR _lpszFileName$GSCopy$[ebp]
  003ef	50		 push	 eax
  003f0	68 00 00 00 00	 push	 OFFSET ??_C@_0DF@EDENJKPK@?$FLDoppelganger?$FN?5?9?5Loading?5Excepti@
  003f5	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  003fa	83 c4 08	 add	 esp, 8

; 253  : 	}

  003fd	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  00404	b8 00 00 00 00	 mov	 eax, $LN186@LoadData
  00409	c3		 ret	 0
$LN186@LoadData:
  0040a	8b bd e0 fd ff
	ff		 mov	 edi, DWORD PTR _this$GSCopy$[ebp]
  00410	33 db		 xor	 ebx, ebx
$LN41@LoadData:

; 254  : 
; 255  : 	LogAddTD("[Doppelganger] LevelInfo loaded [%d] levels",m_iLoadedInfo);

  00412	8b 8f 60 02 00
	00		 mov	 ecx, DWORD PTR [edi+608]
  00418	51		 push	 ecx
  00419	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@FHCDMICJ@?$FLDoppelganger?$FN?5LevelInfo?5loaded?5@
  0041e	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00424	83 c4 08	 add	 esp, 8

; 256  : 
; 257  : 	bLoaded = TRUE;
; 258  : 	bEnabled = GetPrivateProfileInt("GameServerInfo","DoubleGoerEventRun",0, gDirPath.GetNewPath(FILE_SERVER_COMMON));

  00427	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@COIIOJMI@CommonServer?4cfg?$AA@
  0042c	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDirPath@@3VCDirPath@@A ; gDirPath
  00431	c7 47 08 01 00
	00 00		 mov	 DWORD PTR [edi+8], 1
  00438	e8 00 00 00 00	 call	 ?GetNewPath@CDirPath@@QAEPADPAD@Z ; CDirPath::GetNewPath
  0043d	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__GetPrivateProfileIntA@16
  00443	50		 push	 eax
  00444	53		 push	 ebx
  00445	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@CJDCIJOM@DoubleGoerEventRun?$AA@
  0044a	68 00 00 00 00	 push	 OFFSET ??_C@_0P@EMJDPFDH@GameServerInfo?$AA@
  0044f	ff d6		 call	 esi

; 259  : 	m_iMirrorDropRate = GetPrivateProfileInt("GameServerInfo","MirrorMarkDropRate",100, gDirPath.GetNewPath(FILE_SERVER_COMMON));

  00451	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@COIIOJMI@CommonServer?4cfg?$AA@
  00456	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDirPath@@3VCDirPath@@A ; gDirPath
  0045b	89 47 04	 mov	 DWORD PTR [edi+4], eax
  0045e	e8 00 00 00 00	 call	 ?GetNewPath@CDirPath@@QAEPADPAD@Z ; CDirPath::GetNewPath
  00463	50		 push	 eax
  00464	6a 64		 push	 100			; 00000064H
  00466	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OCBGMAON@MirrorMarkDropRate?$AA@
  0046b	68 00 00 00 00	 push	 OFFSET ??_C@_0P@EMJDPFDH@GameServerInfo?$AA@
  00470	ff d6		 call	 esi

; 260  : 
; 261  : 	LogAddTD("[Doppelganger] File loaded! (%s)",lpszFileName);

  00472	8b 95 dc fd ff
	ff		 mov	 edx, DWORD PTR _lpszFileName$GSCopy$[ebp]
  00478	52		 push	 edx
  00479	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@IKMIMFMN@?$FLDoppelganger?$FN?5File?5loaded?$CB?5?$CI?$CFs?$CJ@
  0047e	89 47 0c	 mov	 DWORD PTR [edi+12], eax
  00481	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
$LN189@LoadData:
  00487	83 c4 08	 add	 esp, 8

; 262  : }

  0048a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0048d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00494	59		 pop	 ecx
  00495	5f		 pop	 edi
  00496	5e		 pop	 esi
  00497	5b		 pop	 ebx
  00498	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0049b	33 cd		 xor	 ecx, ebp
  0049d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  004a2	8b e5		 mov	 esp, ebp
  004a4	5d		 pop	 ebp
  004a5	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LoadData@CDoubleGoerEvent@@QAEXPAD@Z$2:
  00000	8b 85 d8 fd ff
	ff		 mov	 eax, DWORD PTR $T190473[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000c	59		 pop	 ecx
  0000d	c3		 ret	 0
__unwindfunclet$?LoadData@CDoubleGoerEvent@@QAEXPAD@Z$3:
  0000e	8b 85 d8 fd ff
	ff		 mov	 eax, DWORD PTR $T190477[ebp]
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0001a	59		 pop	 ecx
  0001b	c3		 ret	 0
__ehhandler$?LoadData@CDoubleGoerEvent@@QAEXPAD@Z:
  0001c	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00020	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00023	8b 8a b8 fd ff
	ff		 mov	 ecx, DWORD PTR [edx-584]
  00029	33 c8		 xor	 ecx, eax
  0002b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00030	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00033	33 c8		 xor	 ecx, eax
  00035	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?LoadData@CDoubleGoerEvent@@QAEXPAD@Z
  0003f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?LoadData@CDoubleGoerEvent@@QAEXPAD@Z ENDP		; CDoubleGoerEvent::LoadData
EXTRN	_atexit:PROC
; Function compile flags: /Ogtp
;	COMDAT ??__EgDoubleGoer@@YAXXZ
text$yc	SEGMENT
??__EgDoubleGoer@@YAXXZ PROC				; `dynamic initializer for 'gDoubleGoer'', COMDAT

; 58   : CDoubleGoerEvent gDoubleGoer;

  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDoubleGoer@@3VCDoubleGoerEvent@@A ; gDoubleGoer
  00005	e8 00 00 00 00	 call	 ??0CDoubleGoerEvent@@QAE@XZ ; CDoubleGoerEvent::CDoubleGoerEvent
  0000a	68 00 00 00 00	 push	 OFFSET ??__FgDoubleGoer@@YAXXZ ; `dynamic atexit destructor for 'gDoubleGoer''
  0000f	e8 00 00 00 00	 call	 _atexit
  00014	59		 pop	 ecx
  00015	c3		 ret	 0
??__EgDoubleGoer@@YAXXZ ENDP				; `dynamic initializer for 'gDoubleGoer''
; Function compile flags: /Ogtp
text$yc	ENDS
;	COMDAT ??__FgDoubleGoer@@YAXXZ
text$yd	SEGMENT
??__FgDoubleGoer@@YAXXZ PROC				; `dynamic atexit destructor for 'gDoubleGoer'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDoubleGoer@@3VCDoubleGoerEvent@@A ; gDoubleGoer
  00005	e9 00 00 00 00	 jmp	 ??1CDoubleGoerEvent@@UAE@XZ ; CDoubleGoerEvent::~CDoubleGoerEvent
??__FgDoubleGoer@@YAXXZ ENDP				; `dynamic atexit destructor for 'gDoubleGoer''
text$yd	ENDS
PUBLIC	?gDoubleGoer@@3VCDoubleGoerEvent@@A		; gDoubleGoer
_BSS	SEGMENT
?gDoubleGoer@@3VCDoubleGoerEvent@@A DB 0274H DUP (?)	; gDoubleGoer
_BSS	ENDS
CRT$XCU	SEGMENT
_gDoubleGoer$initializer$ DD FLAT:??__EgDoubleGoer@@YAXXZ
CRT$XCU	ENDS
END
