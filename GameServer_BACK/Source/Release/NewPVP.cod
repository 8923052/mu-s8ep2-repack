; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	C:\muserver_dev\development\MU-S8EP2-Repack\GameServer\Source\NewPVP.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?BLOCKSIZE@?$FixedBlockSize@$07@CryptoPP@@2HB	; CryptoPP::FixedBlockSize<8>::BLOCKSIZE
PUBLIC	?KEYLENGTH@?$FixedKeyLength@$07$03$0A@@CryptoPP@@2HB ; CryptoPP::FixedKeyLength<8,4,0>::KEYLENGTH
PUBLIC	?MIN_KEYLENGTH@?$FixedKeyLength@$07$03$0A@@CryptoPP@@2HB ; CryptoPP::FixedKeyLength<8,4,0>::MIN_KEYLENGTH
PUBLIC	?MAX_KEYLENGTH@?$FixedKeyLength@$07$03$0A@@CryptoPP@@2HB ; CryptoPP::FixedKeyLength<8,4,0>::MAX_KEYLENGTH
PUBLIC	?DEFAULT_KEYLENGTH@?$FixedKeyLength@$07$03$0A@@CryptoPP@@2HB ; CryptoPP::FixedKeyLength<8,4,0>::DEFAULT_KEYLENGTH
PUBLIC	?IV_REQUIREMENT@?$FixedKeyLength@$07$03$0A@@CryptoPP@@2HB ; CryptoPP::FixedKeyLength<8,4,0>::IV_REQUIREMENT
PUBLIC	?IV_LENGTH@?$FixedKeyLength@$07$03$0A@@CryptoPP@@2HB ; CryptoPP::FixedKeyLength<8,4,0>::IV_LENGTH
PUBLIC	?KEYLENGTH@?$FixedKeyLength@$0BA@$03$0A@@CryptoPP@@2HB ; CryptoPP::FixedKeyLength<16,4,0>::KEYLENGTH
PUBLIC	?MIN_KEYLENGTH@?$FixedKeyLength@$0BA@$03$0A@@CryptoPP@@2HB ; CryptoPP::FixedKeyLength<16,4,0>::MIN_KEYLENGTH
PUBLIC	?MAX_KEYLENGTH@?$FixedKeyLength@$0BA@$03$0A@@CryptoPP@@2HB ; CryptoPP::FixedKeyLength<16,4,0>::MAX_KEYLENGTH
PUBLIC	?DEFAULT_KEYLENGTH@?$FixedKeyLength@$0BA@$03$0A@@CryptoPP@@2HB ; CryptoPP::FixedKeyLength<16,4,0>::DEFAULT_KEYLENGTH
PUBLIC	?IV_REQUIREMENT@?$FixedKeyLength@$0BA@$03$0A@@CryptoPP@@2HB ; CryptoPP::FixedKeyLength<16,4,0>::IV_REQUIREMENT
PUBLIC	?IV_LENGTH@?$FixedKeyLength@$0BA@$03$0A@@CryptoPP@@2HB ; CryptoPP::FixedKeyLength<16,4,0>::IV_LENGTH
PUBLIC	?KEYLENGTH@?$FixedKeyLength@$0BI@$03$0A@@CryptoPP@@2HB ; CryptoPP::FixedKeyLength<24,4,0>::KEYLENGTH
PUBLIC	?MIN_KEYLENGTH@?$FixedKeyLength@$0BI@$03$0A@@CryptoPP@@2HB ; CryptoPP::FixedKeyLength<24,4,0>::MIN_KEYLENGTH
PUBLIC	?MAX_KEYLENGTH@?$FixedKeyLength@$0BI@$03$0A@@CryptoPP@@2HB ; CryptoPP::FixedKeyLength<24,4,0>::MAX_KEYLENGTH
PUBLIC	?DEFAULT_KEYLENGTH@?$FixedKeyLength@$0BI@$03$0A@@CryptoPP@@2HB ; CryptoPP::FixedKeyLength<24,4,0>::DEFAULT_KEYLENGTH
PUBLIC	?IV_REQUIREMENT@?$FixedKeyLength@$0BI@$03$0A@@CryptoPP@@2HB ; CryptoPP::FixedKeyLength<24,4,0>::IV_REQUIREMENT
PUBLIC	?IV_LENGTH@?$FixedKeyLength@$0BI@$03$0A@@CryptoPP@@2HB ; CryptoPP::FixedKeyLength<24,4,0>::IV_LENGTH
_DATA	SEGMENT
_g_sttBLOODCASTLE_LEVEL DD 0fH
	DD	050H
	DD	0aH
	DD	03cH
	DD	051H
	DD	082H
	DD	03dH
	DD	06eH
	DD	083H
	DD	0b4H
	DD	06fH
	DD	0a0H
	DD	0b5H
	DD	0e6H
	DD	0a1H
	DD	0d2H
	DD	0e7H
	DD	0118H
	DD	0d3H
	DD	0104H
	DD	0119H
	DD	014aH
	DD	0105H
	DD	0136H
	DD	014bH
	DD	0190H
	DD	0137H
	DD	0190H
	DD	00H
	DD	0190H
	DD	00H
	DD	0190H
_g_sttCHAOSCASTLE_LEVEL DD 0aH
	DD	031H
	DD	0aH
	DD	01dH
	DD	032H
	DD	077H
	DD	01eH
	DD	063H
	DD	078H
	DD	0b3H
	DD	064H
	DD	09fH
	DD	0b4H
	DD	0efH
	DD	0a0H
	DD	0dbH
	DD	0f0H
	DD	012bH
	DD	0dcH
	DD	0117H
	DD	012cH
	DD	0190H
	DD	0118H
	DD	0190H
	DD	00H
	DD	0190H
	DD	00H
	DD	0190H
_g_iChaosCastle_BlowOutDistance DD 03H
	DD	04H
	DD	03H
	DD	04H
	DD	02H
	DD	03H
	DD	00H
	DD	01H
_g_iChaosCastle_BlowOutDamage DD 0fH
	DD	0fH
	DD	0aH
	DD	05H
_g_iChaosCastle_EnterCost DD 061a8H
	DD	013880H
	DD	0249f0H
	DD	03d090H
	DD	061a80H
	DD	09eb10H
	DD	0f4240H
_g_iChaosCastle_GuardSetValue DD 09c4H
	DD	09c4H
	DD	09c4H
	DD	09c4H
	DD	09c4H
	DD	09c4H
	DD	09c4H
_g_iChaosCastle_MonsterItems DD 01c0dH
	DD	01H
	DD	01c0eH
	DD	01H
	DD	01c0dH
	DD	01H
	DD	01c0eH
	DD	01H
	DD	01c0dH
	DD	01H
	DD	01c0eH
	DD	01H
	DD	01c0dH
	DD	01H
	DD	01c0eH
	DD	01H
	DD	01c0dH
	DD	01H
	DD	01c0eH
	DD	02H
	DD	01c0dH
	DD	01H
	DD	01c0eH
	DD	02H
	DD	01c0dH
	DD	01H
	DD	01c0eH
	DD	02H
_g_iChaosCastle_GroundAxis DD 017H
	DD	04bH
	DD	02cH
	DD	06cH
_g_iChaosCastle_DamageAxis DD 017H
	DD	04bH
	DD	02cH
	DD	06cH
	DD	019H
	DD	04dH
	DD	02aH
	DD	06aH
	DD	01bH
	DD	04fH
	DD	028H
	DD	068H
	DD	01dH
	DD	051H
	DD	026H
	DD	066H
_g_iChaosCastle_MapHollowZone DD 017H
	DD	04bH
	DD	02cH
	DD	04cH
	DD	02bH
	DD	04dH
	DD	02cH
	DD	06cH
	DD	017H
	DD	06bH
	DD	02aH
	DD	06cH
	DD	017H
	DD	04dH
	DD	018H
	DD	06aH
	DD	017H
	DD	04bH
	DD	02cH
	DD	04cH
	DD	02bH
	DD	04dH
	DD	02cH
	DD	06cH
	DD	017H
	DD	06bH
	DD	02aH
	DD	06cH
	DD	017H
	DD	04dH
	DD	018H
	DD	06aH
	DD	019H
	DD	04dH
	DD	02aH
	DD	04eH
	DD	029H
	DD	04fH
	DD	02aH
	DD	06aH
	DD	019H
	DD	069H
	DD	028H
	DD	06aH
	DD	019H
	DD	04fH
	DD	01aH
	DD	068H
	DD	01bH
	DD	04fH
	DD	028H
	DD	050H
	DD	027H
	DD	051H
	DD	028H
	DD	068H
	DD	01bH
	DD	067H
	DD	026H
	DD	068H
	DD	01bH
	DD	051H
	DD	01cH
	DD	066H
_g_sttDEVILSQUARE_LEVEL DD 0fH
	DD	082H
	DD	0aH
	DD	06eH
	DD	03aH
	DD	083H
	DD	0b4H
	DD	06fH
	DD	0a0H
	DD	03bH
	DD	0b5H
	DD	0e6H
	DD	0a1H
	DD	0d2H
	DD	03cH
	DD	0e7H
	DD	0118H
	DD	0d3H
	DD	0104H
	DD	03dH
	DD	0119H
	DD	014aH
	DD	0105H
	DD	0136H
	DD	06fH
	DD	014bH
	DD	0190H
	DD	0137H
	DD	0190H
	DD	070H
	DD	00H
	DD	0190H
	DD	00H
	DD	0190H
	DD	010eH
_g_GateObserver DD 012fH
	DD	0130H
	DD	0131H
	DD	0132H
_g_GateRequester DD 0127H
	DD	0129H
	DD	012bH
	DD	012dH
_g_GateResponsor DD 0128H
	DD	012aH
	DD	012cH
	DD	012eH
_DATA	ENDS
;	COMDAT ?IV_LENGTH@?$FixedKeyLength@$0BI@$03$0A@@CryptoPP@@2HB
CONST	SEGMENT
?IV_LENGTH@?$FixedKeyLength@$0BI@$03$0A@@CryptoPP@@2HB DD 00H ; CryptoPP::FixedKeyLength<24,4,0>::IV_LENGTH
CONST	ENDS
;	COMDAT ?IV_REQUIREMENT@?$FixedKeyLength@$0BI@$03$0A@@CryptoPP@@2HB
CONST	SEGMENT
?IV_REQUIREMENT@?$FixedKeyLength@$0BI@$03$0A@@CryptoPP@@2HB DD 04H ; CryptoPP::FixedKeyLength<24,4,0>::IV_REQUIREMENT
CONST	ENDS
;	COMDAT ?DEFAULT_KEYLENGTH@?$FixedKeyLength@$0BI@$03$0A@@CryptoPP@@2HB
CONST	SEGMENT
?DEFAULT_KEYLENGTH@?$FixedKeyLength@$0BI@$03$0A@@CryptoPP@@2HB DD 018H ; CryptoPP::FixedKeyLength<24,4,0>::DEFAULT_KEYLENGTH
CONST	ENDS
;	COMDAT ?MAX_KEYLENGTH@?$FixedKeyLength@$0BI@$03$0A@@CryptoPP@@2HB
CONST	SEGMENT
?MAX_KEYLENGTH@?$FixedKeyLength@$0BI@$03$0A@@CryptoPP@@2HB DD 018H ; CryptoPP::FixedKeyLength<24,4,0>::MAX_KEYLENGTH
CONST	ENDS
;	COMDAT ?MIN_KEYLENGTH@?$FixedKeyLength@$0BI@$03$0A@@CryptoPP@@2HB
CONST	SEGMENT
?MIN_KEYLENGTH@?$FixedKeyLength@$0BI@$03$0A@@CryptoPP@@2HB DD 018H ; CryptoPP::FixedKeyLength<24,4,0>::MIN_KEYLENGTH
CONST	ENDS
;	COMDAT ?KEYLENGTH@?$FixedKeyLength@$0BI@$03$0A@@CryptoPP@@2HB
CONST	SEGMENT
?KEYLENGTH@?$FixedKeyLength@$0BI@$03$0A@@CryptoPP@@2HB DD 018H ; CryptoPP::FixedKeyLength<24,4,0>::KEYLENGTH
CONST	ENDS
;	COMDAT ?IV_LENGTH@?$FixedKeyLength@$0BA@$03$0A@@CryptoPP@@2HB
CONST	SEGMENT
?IV_LENGTH@?$FixedKeyLength@$0BA@$03$0A@@CryptoPP@@2HB DD 00H ; CryptoPP::FixedKeyLength<16,4,0>::IV_LENGTH
CONST	ENDS
;	COMDAT ?IV_REQUIREMENT@?$FixedKeyLength@$0BA@$03$0A@@CryptoPP@@2HB
CONST	SEGMENT
?IV_REQUIREMENT@?$FixedKeyLength@$0BA@$03$0A@@CryptoPP@@2HB DD 04H ; CryptoPP::FixedKeyLength<16,4,0>::IV_REQUIREMENT
CONST	ENDS
;	COMDAT ?DEFAULT_KEYLENGTH@?$FixedKeyLength@$0BA@$03$0A@@CryptoPP@@2HB
CONST	SEGMENT
?DEFAULT_KEYLENGTH@?$FixedKeyLength@$0BA@$03$0A@@CryptoPP@@2HB DD 010H ; CryptoPP::FixedKeyLength<16,4,0>::DEFAULT_KEYLENGTH
CONST	ENDS
;	COMDAT ?MAX_KEYLENGTH@?$FixedKeyLength@$0BA@$03$0A@@CryptoPP@@2HB
CONST	SEGMENT
?MAX_KEYLENGTH@?$FixedKeyLength@$0BA@$03$0A@@CryptoPP@@2HB DD 010H ; CryptoPP::FixedKeyLength<16,4,0>::MAX_KEYLENGTH
CONST	ENDS
;	COMDAT ?MIN_KEYLENGTH@?$FixedKeyLength@$0BA@$03$0A@@CryptoPP@@2HB
CONST	SEGMENT
?MIN_KEYLENGTH@?$FixedKeyLength@$0BA@$03$0A@@CryptoPP@@2HB DD 010H ; CryptoPP::FixedKeyLength<16,4,0>::MIN_KEYLENGTH
CONST	ENDS
;	COMDAT ?KEYLENGTH@?$FixedKeyLength@$0BA@$03$0A@@CryptoPP@@2HB
CONST	SEGMENT
?KEYLENGTH@?$FixedKeyLength@$0BA@$03$0A@@CryptoPP@@2HB DD 010H ; CryptoPP::FixedKeyLength<16,4,0>::KEYLENGTH
CONST	ENDS
;	COMDAT ?IV_LENGTH@?$FixedKeyLength@$07$03$0A@@CryptoPP@@2HB
CONST	SEGMENT
?IV_LENGTH@?$FixedKeyLength@$07$03$0A@@CryptoPP@@2HB DD 00H ; CryptoPP::FixedKeyLength<8,4,0>::IV_LENGTH
CONST	ENDS
;	COMDAT ?IV_REQUIREMENT@?$FixedKeyLength@$07$03$0A@@CryptoPP@@2HB
CONST	SEGMENT
?IV_REQUIREMENT@?$FixedKeyLength@$07$03$0A@@CryptoPP@@2HB DD 04H ; CryptoPP::FixedKeyLength<8,4,0>::IV_REQUIREMENT
CONST	ENDS
;	COMDAT ?DEFAULT_KEYLENGTH@?$FixedKeyLength@$07$03$0A@@CryptoPP@@2HB
CONST	SEGMENT
?DEFAULT_KEYLENGTH@?$FixedKeyLength@$07$03$0A@@CryptoPP@@2HB DD 08H ; CryptoPP::FixedKeyLength<8,4,0>::DEFAULT_KEYLENGTH
CONST	ENDS
;	COMDAT ?MAX_KEYLENGTH@?$FixedKeyLength@$07$03$0A@@CryptoPP@@2HB
CONST	SEGMENT
?MAX_KEYLENGTH@?$FixedKeyLength@$07$03$0A@@CryptoPP@@2HB DD 08H ; CryptoPP::FixedKeyLength<8,4,0>::MAX_KEYLENGTH
CONST	ENDS
;	COMDAT ?MIN_KEYLENGTH@?$FixedKeyLength@$07$03$0A@@CryptoPP@@2HB
CONST	SEGMENT
?MIN_KEYLENGTH@?$FixedKeyLength@$07$03$0A@@CryptoPP@@2HB DD 08H ; CryptoPP::FixedKeyLength<8,4,0>::MIN_KEYLENGTH
CONST	ENDS
;	COMDAT ?KEYLENGTH@?$FixedKeyLength@$07$03$0A@@CryptoPP@@2HB
CONST	SEGMENT
?KEYLENGTH@?$FixedKeyLength@$07$03$0A@@CryptoPP@@2HB DD 08H ; CryptoPP::FixedKeyLength<8,4,0>::KEYLENGTH
CONST	ENDS
;	COMDAT ?BLOCKSIZE@?$FixedBlockSize@$07@CryptoPP@@2HB
CONST	SEGMENT
?BLOCKSIZE@?$FixedBlockSize@$07@CryptoPP@@2HB DD 08H	; CryptoPP::FixedBlockSize<8>::BLOCKSIZE
CONST	ENDS
PUBLIC	??2@YAPAXIPAX@Z					; operator new
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\new.h
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 81   :         {return (_Where); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]
  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
PUBLIC	??3@YAXPAX0@Z					; operator delete
; Function compile flags: /Ogtp
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 83   :         {return; }

  00000	c3		 ret	 0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?DebugLog@@YAXPADZZ				; DebugLog
EXTRN	_vsprintf:PROC
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_memset:PROC
; Function compile flags: /Ogtp
; File c:\muserver_dev\development\mu-s8ep2-repack\gameserver\source\itemsystemfor380.h
;	COMDAT ?DebugLog@@YAXPADZZ
_TEXT	SEGMENT
_szBuffer$ = -516					; size = 512
__$ArrayPad$ = -4					; size = 4
_szLog$ = 8						; size = 4
?DebugLog@@YAXPADZZ PROC				; DebugLog, COMDAT

; 92   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 04 02 00
	00		 sub	 esp, 516		; 00000204H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 93   : 	char szBuffer[512] = "";

  00013	68 ff 01 00 00	 push	 511			; 000001ffH
  00018	8d 85 fd fd ff
	ff		 lea	 eax, DWORD PTR _szBuffer$[ebp+1]
  0001e	6a 00		 push	 0
  00020	50		 push	 eax
  00021	c6 85 fc fd ff
	ff 00		 mov	 BYTE PTR _szBuffer$[ebp], 0
  00028	e8 00 00 00 00	 call	 _memset

; 94   : 	va_list pArguments;
; 95   : 
; 96   : 	va_start(pArguments, szLog);
; 97   : 	vsprintf(szBuffer, szLog, pArguments);

  0002d	8b 55 08	 mov	 edx, DWORD PTR _szLog$[ebp]
  00030	8d 4d 0c	 lea	 ecx, DWORD PTR _szLog$[ebp+4]
  00033	51		 push	 ecx
  00034	52		 push	 edx
  00035	8d 85 fc fd ff
	ff		 lea	 eax, DWORD PTR _szBuffer$[ebp]
  0003b	50		 push	 eax
  0003c	e8 00 00 00 00	 call	 _vsprintf

; 98   : 	va_end(pArguments);
; 99   : 
; 100  : //	OutputDebugString(szBuffer);
; 101  : }

  00041	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00044	33 cd		 xor	 ecx, ebp
  00046	83 c4 18	 add	 esp, 24			; 00000018H
  00049	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0004e	8b e5		 mov	 esp, ebp
  00050	5d		 pop	 ebp
  00051	c3		 ret	 0
?DebugLog@@YAXPADZZ ENDP				; DebugLog
_TEXT	ENDS
PUBLIC	??1OBJECTSTRUCT@@QAE@XZ				; OBJECTSTRUCT::~OBJECTSTRUCT
EXTRN	??1CSkillDelay@@UAE@XZ:PROC			; CSkillDelay::~CSkillDelay
EXTRN	??1TMonsterAIAgro@@UAE@XZ:PROC			; TMonsterAIAgro::~TMonsterAIAgro
EXTRN	___CxxFrameHandler3:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1OBJECTSTRUCT@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1OBJECTSTRUCT@@QAE@XZ$0
__ehfuncinfo$??1OBJECTSTRUCT@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1OBJECTSTRUCT@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
xdata$x	ENDS
;	COMDAT ??1OBJECTSTRUCT@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1OBJECTSTRUCT@@QAE@XZ PROC				; OBJECTSTRUCT::~OBJECTSTRUCT, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1OBJECTSTRUCT@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b f1		 mov	 esi, ecx
  00026	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  00029	8d 8e ec 20 00
	00		 lea	 ecx, DWORD PTR [esi+8428]
  0002f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00036	e8 00 00 00 00	 call	 ??1TMonsterAIAgro@@UAE@XZ ; TMonsterAIAgro::~TMonsterAIAgro
  0003b	8d 8e 0c 16 00
	00		 lea	 ecx, DWORD PTR [esi+5644]
  00041	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00048	e8 00 00 00 00	 call	 ??1CSkillDelay@@UAE@XZ	; CSkillDelay::~CSkillDelay
  0004d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00050	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00057	59		 pop	 ecx
  00058	5e		 pop	 esi
  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1OBJECTSTRUCT@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	81 c1 0c 16 00
	00		 add	 ecx, 5644		; 0000160cH
  00009	e9 00 00 00 00	 jmp	 ??1CSkillDelay@@UAE@XZ	; CSkillDelay::~CSkillDelay
__ehhandler$??1OBJECTSTRUCT@@QAE@XZ:
  0000e	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00012	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00015	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00018	33 c8		 xor	 ecx, eax
  0001a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001f	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1OBJECTSTRUCT@@QAE@XZ
  00024	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1OBJECTSTRUCT@@QAE@XZ ENDP				; OBJECTSTRUCT::~OBJECTSTRUCT
PUBLIC	?IsDuelRequested@CNewPVP@@QAEHAAUOBJECTSTRUCT@@@Z ; CNewPVP::IsDuelRequested
; Function compile flags: /Ogtp
; File c:\muserver_dev\development\mu-s8ep2-repack\gameserver\source\newpvp.h
;	COMDAT ?IsDuelRequested@CNewPVP@@QAEHAAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_obj$ = 8						; size = 4
?IsDuelRequested@CNewPVP@@QAEHAAUOBJECTSTRUCT@@@Z PROC	; CNewPVP::IsDuelRequested, COMDAT
; _this$ = ecx

; 277  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 278  : 		return CHECK_LIMIT(obj.m_iDuelUserRequested, OBJMAX);

  00003	8b 45 08	 mov	 eax, DWORD PTR _obj$[ebp]
  00006	8b 80 4c 12 00
	00		 mov	 eax, DWORD PTR [eax+4684]
  0000c	85 c0		 test	 eax, eax
  0000e	79 06		 jns	 SHORT $LN3@IsDuelRequ
  00010	33 c0		 xor	 eax, eax

; 279  : 	}

  00012	5d		 pop	 ebp
  00013	c2 04 00	 ret	 4
$LN3@IsDuelRequ:

; 278  : 		return CHECK_LIMIT(obj.m_iDuelUserRequested, OBJMAX);

  00016	33 c9		 xor	 ecx, ecx
  00018	3d eb 2c 00 00	 cmp	 eax, 11499		; 00002cebH
  0001d	0f 9e c1	 setle	 cl
  00020	8b c1		 mov	 eax, ecx

; 279  : 	}

  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
?IsDuelRequested@CNewPVP@@QAEHAAUOBJECTSTRUCT@@@Z ENDP	; CNewPVP::IsDuelRequested
_TEXT	ENDS
PUBLIC	?IsDuelReserved@CNewPVP@@QAEHAAUOBJECTSTRUCT@@@Z ; CNewPVP::IsDuelReserved
; Function compile flags: /Ogtp
;	COMDAT ?IsDuelReserved@CNewPVP@@QAEHAAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_obj$ = 8						; size = 4
?IsDuelReserved@CNewPVP@@QAEHAAUOBJECTSTRUCT@@@Z PROC	; CNewPVP::IsDuelReserved, COMDAT
; _this$ = ecx

; 282  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 283  : 		return CHECK_LIMIT(obj.m_iDuelUserReserved, OBJMAX);

  00003	8b 45 08	 mov	 eax, DWORD PTR _obj$[ebp]
  00006	8b 80 48 12 00
	00		 mov	 eax, DWORD PTR [eax+4680]
  0000c	85 c0		 test	 eax, eax
  0000e	79 06		 jns	 SHORT $LN3@IsDuelRese
  00010	33 c0		 xor	 eax, eax

; 284  : 	}

  00012	5d		 pop	 ebp
  00013	c2 04 00	 ret	 4
$LN3@IsDuelRese:

; 283  : 		return CHECK_LIMIT(obj.m_iDuelUserReserved, OBJMAX);

  00016	33 c9		 xor	 ecx, ecx
  00018	3d eb 2c 00 00	 cmp	 eax, 11499		; 00002cebH
  0001d	0f 9e c1	 setle	 cl
  00020	8b c1		 mov	 eax, ecx

; 284  : 	}

  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
?IsDuelReserved@CNewPVP@@QAEHAAUOBJECTSTRUCT@@@Z ENDP	; CNewPVP::IsDuelReserved
_TEXT	ENDS
PUBLIC	?IsDuel@CNewPVP@@QAEHAAUOBJECTSTRUCT@@@Z	; CNewPVP::IsDuel
; Function compile flags: /Ogtp
;	COMDAT ?IsDuel@CNewPVP@@QAEHAAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_obj$ = 8						; size = 4
?IsDuel@CNewPVP@@QAEHAAUOBJECTSTRUCT@@@Z PROC		; CNewPVP::IsDuel, COMDAT
; _this$ = ecx

; 296  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 297  : 		return CHECK_LIMIT(obj.m_iDuelUser, OBJMAX);

  00003	8b 45 08	 mov	 eax, DWORD PTR _obj$[ebp]
  00006	8b 80 50 12 00
	00		 mov	 eax, DWORD PTR [eax+4688]
  0000c	85 c0		 test	 eax, eax
  0000e	79 06		 jns	 SHORT $LN3@IsDuel
  00010	33 c0		 xor	 eax, eax

; 298  : 	}

  00012	5d		 pop	 ebp
  00013	c2 04 00	 ret	 4
$LN3@IsDuel:

; 297  : 		return CHECK_LIMIT(obj.m_iDuelUser, OBJMAX);

  00016	33 c9		 xor	 ecx, ecx
  00018	3d eb 2c 00 00	 cmp	 eax, 11499		; 00002cebH
  0001d	0f 9e c1	 setle	 cl
  00020	8b c1		 mov	 eax, ecx

; 298  : 	}

  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
?IsDuel@CNewPVP@@QAEHAAUOBJECTSTRUCT@@@Z ENDP		; CNewPVP::IsDuel
_TEXT	ENDS
PUBLIC	?IsVulcanusMap@CNewPVP@@QAEHH@Z			; CNewPVP::IsVulcanusMap
; Function compile flags: /Ogtp
;	COMDAT ?IsVulcanusMap@CNewPVP@@QAEHH@Z
_TEXT	SEGMENT
_nMapNumber$ = 8					; size = 4
?IsVulcanusMap@CNewPVP@@QAEHH@Z PROC			; CNewPVP::IsVulcanusMap, COMDAT
; _this$ = ecx

; 307  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 308  : 		return nMapNumber == MAP_INDEX_VULCANUS;

  00003	33 c0		 xor	 eax, eax
  00005	83 7d 08 3f	 cmp	 DWORD PTR _nMapNumber$[ebp], 63 ; 0000003fH
  00009	0f 94 c0	 sete	 al

; 309  : 	}

  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
?IsVulcanusMap@CNewPVP@@QAEHH@Z ENDP			; CNewPVP::IsVulcanusMap
_TEXT	ENDS
PUBLIC	?IsPKFieldMap@CNewPVP@@QAEHH@Z			; CNewPVP::IsPKFieldMap
; Function compile flags: /Ogtp
;	COMDAT ?IsPKFieldMap@CNewPVP@@QAEHH@Z
_TEXT	SEGMENT
_nMapNumber$ = 8					; size = 4
?IsPKFieldMap@CNewPVP@@QAEHH@Z PROC			; CNewPVP::IsPKFieldMap, COMDAT
; _this$ = ecx

; 312  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 313  : 		return nMapNumber == MAP_INDEX_PKFIELD;

  00003	33 c0		 xor	 eax, eax
  00005	83 7d 08 40	 cmp	 DWORD PTR _nMapNumber$[ebp], 64 ; 00000040H
  00009	0f 94 c0	 sete	 al

; 314  : 	}

  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
?IsPKFieldMap@CNewPVP@@QAEHH@Z ENDP			; CNewPVP::IsPKFieldMap
_TEXT	ENDS
PUBLIC	?GetDuelStatus@CNewPVP@@AAEHAAUOBJECTSTRUCT@@@Z	; CNewPVP::GetDuelStatus
; Function compile flags: /Ogtp
;	COMDAT ?GetDuelStatus@CNewPVP@@AAEHAAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_obj$ = 8						; size = 4
?GetDuelStatus@CNewPVP@@AAEHAAUOBJECTSTRUCT@@@Z PROC	; CNewPVP::GetDuelStatus, COMDAT
; _this$ = ecx

; 337  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 338  : 		if(CHECK_LIMIT(obj.m_iDuelUserRequested, OBJMAX))

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _obj$[ebp]
  00006	8b 81 4c 12 00
	00		 mov	 eax, DWORD PTR [ecx+4684]
  0000c	85 c0		 test	 eax, eax
  0000e	78 19		 js	 SHORT $LN3@GetDuelSta
  00010	33 d2		 xor	 edx, edx
  00012	3d eb 2c 00 00	 cmp	 eax, 11499		; 00002cebH
  00017	0f 9e c2	 setle	 dl
  0001a	8b c2		 mov	 eax, edx
  0001c	85 c0		 test	 eax, eax
  0001e	74 09		 je	 SHORT $LN3@GetDuelSta

; 339  : 		{
; 340  : 			return ENEWPVP::E_ALREADY_DUELREQUESTED;

  00020	b8 12 00 00 00	 mov	 eax, 18			; 00000012H

; 354  : 	};

  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
$LN3@GetDuelSta:

; 341  : 		}
; 342  : 
; 343  : 		if(CHECK_LIMIT(obj.m_iDuelUserReserved, OBJMAX))

  00029	8b 81 48 12 00
	00		 mov	 eax, DWORD PTR [ecx+4680]
  0002f	85 c0		 test	 eax, eax
  00031	78 19		 js	 SHORT $LN2@GetDuelSta
  00033	33 d2		 xor	 edx, edx
  00035	3d eb 2c 00 00	 cmp	 eax, 11499		; 00002cebH
  0003a	0f 9e c2	 setle	 dl
  0003d	8b c2		 mov	 eax, edx
  0003f	85 c0		 test	 eax, eax
  00041	74 09		 je	 SHORT $LN2@GetDuelSta

; 344  : 		{
; 345  : 			return ENEWPVP::E_ALREADY_DUELRESERVED;

  00043	b8 13 00 00 00	 mov	 eax, 19			; 00000013H

; 354  : 	};

  00048	5d		 pop	 ebp
  00049	c2 04 00	 ret	 4
$LN2@GetDuelSta:

; 346  : 		}
; 347  : 
; 348  : 		if(CHECK_LIMIT(obj.m_iDuelUser, OBJMAX))

  0004c	8b 81 50 12 00
	00		 mov	 eax, DWORD PTR [ecx+4688]
  00052	85 c0		 test	 eax, eax
  00054	78 19		 js	 SHORT $LN1@GetDuelSta
  00056	33 c9		 xor	 ecx, ecx
  00058	3d eb 2c 00 00	 cmp	 eax, 11499		; 00002cebH
  0005d	0f 9e c1	 setle	 cl
  00060	8b c1		 mov	 eax, ecx
  00062	85 c0		 test	 eax, eax
  00064	74 09		 je	 SHORT $LN1@GetDuelSta

; 349  : 		{
; 350  : 			return ENEWPVP::E_ALREADY_DUELLING;

  00066	b8 14 00 00 00	 mov	 eax, 20			; 00000014H

; 354  : 	};

  0006b	5d		 pop	 ebp
  0006c	c2 04 00	 ret	 4
$LN1@GetDuelSta:

; 351  : 		}
; 352  : 
; 353  : 		return 0;

  0006f	33 c0		 xor	 eax, eax

; 354  : 	};

  00071	5d		 pop	 ebp
  00072	c2 04 00	 ret	 4
?GetDuelStatus@CNewPVP@@AAEHAAUOBJECTSTRUCT@@@Z ENDP	; CNewPVP::GetDuelStatus
_TEXT	ENDS
PUBLIC	?GetDuelStatusByResponsor@CNewPVP@@AAEHAAUOBJECTSTRUCT@@@Z ; CNewPVP::GetDuelStatusByResponsor
; Function compile flags: /Ogtp
;	COMDAT ?GetDuelStatusByResponsor@CNewPVP@@AAEHAAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_obj$ = 8						; size = 4
?GetDuelStatusByResponsor@CNewPVP@@AAEHAAUOBJECTSTRUCT@@@Z PROC ; CNewPVP::GetDuelStatusByResponsor, COMDAT
; _this$ = ecx

; 357  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 358  : 		if(CHECK_LIMIT(obj.m_iDuelUserRequested, OBJMAX))

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _obj$[ebp]
  00006	8b 81 4c 12 00
	00		 mov	 eax, DWORD PTR [ecx+4684]
  0000c	85 c0		 test	 eax, eax
  0000e	78 19		 js	 SHORT $LN3@GetDuelSta@2
  00010	33 d2		 xor	 edx, edx
  00012	3d eb 2c 00 00	 cmp	 eax, 11499		; 00002cebH
  00017	0f 9e c2	 setle	 dl
  0001a	8b c2		 mov	 eax, edx
  0001c	85 c0		 test	 eax, eax
  0001e	74 09		 je	 SHORT $LN3@GetDuelSta@2

; 359  : 		{
; 360  : 			return ENEWPVP::E_ALREADY_DUELREQUESTED_1;

  00020	b8 15 00 00 00	 mov	 eax, 21			; 00000015H

; 374  : 	};

  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
$LN3@GetDuelSta@2:

; 361  : 		}
; 362  : 
; 363  : 		if(CHECK_LIMIT(obj.m_iDuelUserReserved, OBJMAX))

  00029	8b 81 48 12 00
	00		 mov	 eax, DWORD PTR [ecx+4680]
  0002f	85 c0		 test	 eax, eax
  00031	78 19		 js	 SHORT $LN2@GetDuelSta@2
  00033	33 d2		 xor	 edx, edx
  00035	3d eb 2c 00 00	 cmp	 eax, 11499		; 00002cebH
  0003a	0f 9e c2	 setle	 dl
  0003d	8b c2		 mov	 eax, edx
  0003f	85 c0		 test	 eax, eax
  00041	74 09		 je	 SHORT $LN2@GetDuelSta@2

; 364  : 		{
; 365  : 			return ENEWPVP::E_ALREADY_DUELRESERVED_1;

  00043	b8 16 00 00 00	 mov	 eax, 22			; 00000016H

; 374  : 	};

  00048	5d		 pop	 ebp
  00049	c2 04 00	 ret	 4
$LN2@GetDuelSta@2:

; 366  : 		}
; 367  : 
; 368  : 		if(CHECK_LIMIT(obj.m_iDuelUser, OBJMAX))

  0004c	8b 81 50 12 00
	00		 mov	 eax, DWORD PTR [ecx+4688]
  00052	85 c0		 test	 eax, eax
  00054	78 19		 js	 SHORT $LN1@GetDuelSta@2
  00056	33 c9		 xor	 ecx, ecx
  00058	3d eb 2c 00 00	 cmp	 eax, 11499		; 00002cebH
  0005d	0f 9e c1	 setle	 cl
  00060	8b c1		 mov	 eax, ecx
  00062	85 c0		 test	 eax, eax
  00064	74 09		 je	 SHORT $LN1@GetDuelSta@2

; 369  : 		{
; 370  : 			return ENEWPVP::E_ALREADY_DUELLING_1;

  00066	b8 17 00 00 00	 mov	 eax, 23			; 00000017H

; 374  : 	};

  0006b	5d		 pop	 ebp
  0006c	c2 04 00	 ret	 4
$LN1@GetDuelSta@2:

; 371  : 		}
; 372  : 
; 373  : 		return 0;

  0006f	33 c0		 xor	 eax, eax

; 374  : 	};

  00071	5d		 pop	 ebp
  00072	c2 04 00	 ret	 4
?GetDuelStatusByResponsor@CNewPVP@@AAEHAAUOBJECTSTRUCT@@@Z ENDP ; CNewPVP::GetDuelStatusByResponsor
_TEXT	ENDS
PUBLIC	?LoadData@CNewPVP@@QAEXXZ			; CNewPVP::LoadData
; Function compile flags: /Ogtp
; File c:\muserver_dev\development\mu-s8ep2-repack\gameserver\source\newpvp.cpp
;	COMDAT ?LoadData@CNewPVP@@QAEXXZ
_TEXT	SEGMENT
?LoadData@CNewPVP@@QAEXXZ PROC				; CNewPVP::LoadData, COMDAT
; _this$ = ecx

; 48   : 	//
; 49   : }

  00000	c3		 ret	 0
?LoadData@CNewPVP@@QAEXXZ ENDP				; CNewPVP::LoadData
_TEXT	ENDS
PUBLIC	?GetDuelChannelId@CNewPVP@@AAEHXZ		; CNewPVP::GetDuelChannelId
; Function compile flags: /Ogtp
;	COMDAT ?GetDuelChannelId@CNewPVP@@AAEHXZ
_TEXT	SEGMENT
?GetDuelChannelId@CNewPVP@@AAEHXZ PROC			; CNewPVP::GetDuelChannelId, COMDAT
; _this$ = ecx

; 156  : 	for(int i = 0;i < DUEL_CHANNEL_MAX;i++)

  00000	33 c0		 xor	 eax, eax
  00002	81 c1 86 00 00
	00		 add	 ecx, 134		; 00000086H
$LL4@GetDuelCha:

; 157  : 	{
; 158  : 		if( m_DuelChannel[i].nStatus == DC_IDLE)

  00008	80 39 00	 cmp	 BYTE PTR [ecx], 0
  0000b	74 0c		 je	 SHORT $LN5@GetDuelCha

; 156  : 	for(int i = 0;i < DUEL_CHANNEL_MAX;i++)

  0000d	40		 inc	 eax
  0000e	83 c1 2c	 add	 ecx, 44			; 0000002cH
  00011	83 f8 04	 cmp	 eax, 4
  00014	7c f2		 jl	 SHORT $LL4@GetDuelCha

; 159  : 		{
; 160  : 			return i;
; 161  : 		}
; 162  : 	}
; 163  : 
; 164  : 	return -1;

  00016	83 c8 ff	 or	 eax, -1
$LN5@GetDuelCha:

; 165  : }

  00019	c3		 ret	 0
?GetDuelChannelId@CNewPVP@@AAEHXZ ENDP			; CNewPVP::GetDuelChannelId
_TEXT	ENDS
PUBLIC	?GetDuelChannelId@CNewPVP@@AAEHH@Z		; CNewPVP::GetDuelChannelId
; Function compile flags: /Ogtp
;	COMDAT ?GetDuelChannelId@CNewPVP@@AAEHH@Z
_TEXT	SEGMENT
_nIndex$ = 8						; size = 4
?GetDuelChannelId@CNewPVP@@AAEHH@Z PROC			; CNewPVP::GetDuelChannelId, COMDAT
; _this$ = ecx

; 169  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 170  : 	for( int i = 0; i < DUEL_CHANNEL_MAX; i++ )

  00003	8b 55 08	 mov	 edx, DWORD PTR _nIndex$[ebp]
  00006	33 c0		 xor	 eax, eax
  00008	83 c1 6c	 add	 ecx, 108		; 0000006cH
  0000b	eb 03 8d 49 00	 npad	 5
$LL5@GetDuelCha@2:

; 171  : 	{
; 172  : 		if( m_DuelChannel[i].nIndex1 == nIndex || 
; 173  : 			m_DuelChannel[i].nIndex2 == nIndex )

  00010	39 51 fc	 cmp	 DWORD PTR [ecx-4], edx
  00013	74 10		 je	 SHORT $LN6@GetDuelCha@2
  00015	39 11		 cmp	 DWORD PTR [ecx], edx
  00017	74 0c		 je	 SHORT $LN6@GetDuelCha@2

; 170  : 	for( int i = 0; i < DUEL_CHANNEL_MAX; i++ )

  00019	40		 inc	 eax
  0001a	83 c1 2c	 add	 ecx, 44			; 0000002cH
  0001d	83 f8 04	 cmp	 eax, 4
  00020	7c ee		 jl	 SHORT $LL5@GetDuelCha@2

; 174  : 		{
; 175  : 			return i;
; 176  : 		}
; 177  : 	}
; 178  : 
; 179  : 	return -1;

  00022	83 c8 ff	 or	 eax, -1
$LN6@GetDuelCha@2:

; 180  : }

  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
?GetDuelChannelId@CNewPVP@@AAEHH@Z ENDP			; CNewPVP::GetDuelChannelId
_TEXT	ENDS
PUBLIC	?GetDuelChannelId@CNewPVP@@AAEHPAD@Z		; CNewPVP::GetDuelChannelId
; Function compile flags: /Ogtp
;	COMDAT ?GetDuelChannelId@CNewPVP@@AAEHPAD@Z
_TEXT	SEGMENT
_lpszName$ = 8						; size = 4
?GetDuelChannelId@CNewPVP@@AAEHPAD@Z PROC		; CNewPVP::GetDuelChannelId, COMDAT
; _this$ = ecx

; 184  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	57		 push	 edi

; 185  : 	for( int i = 0; i < DUEL_CHANNEL_MAX; i++ )

  00006	8b 7d 08	 mov	 edi, DWORD PTR _lpszName$[ebp]
  00009	33 c0		 xor	 eax, eax
  0000b	8d 71 7b	 lea	 esi, DWORD PTR [ecx+123]
  0000e	8b ff		 npad	 2
$LL5@GetDuelCha@3:

; 186  : 	{
; 187  : 		if( strcmp(m_DuelChannel[i].szName1, lpszName) == 0|| 
; 188  : 			strcmp(m_DuelChannel[i].szName2, lpszName) == 0)

  00010	8b d7		 mov	 edx, edi
  00012	8d 4e f5	 lea	 ecx, DWORD PTR [esi-11]
$LL11@GetDuelCha@3:
  00015	8a 19		 mov	 bl, BYTE PTR [ecx]
  00017	3a 1a		 cmp	 bl, BYTE PTR [edx]
  00019	75 1a		 jne	 SHORT $LN12@GetDuelCha@3
  0001b	84 db		 test	 bl, bl
  0001d	74 12		 je	 SHORT $LN13@GetDuelCha@3
  0001f	8a 59 01	 mov	 bl, BYTE PTR [ecx+1]
  00022	3a 5a 01	 cmp	 bl, BYTE PTR [edx+1]
  00025	75 0e		 jne	 SHORT $LN12@GetDuelCha@3
  00027	83 c1 02	 add	 ecx, 2
  0002a	83 c2 02	 add	 edx, 2
  0002d	84 db		 test	 bl, bl
  0002f	75 e4		 jne	 SHORT $LL11@GetDuelCha@3
$LN13@GetDuelCha@3:
  00031	33 c9		 xor	 ecx, ecx
  00033	eb 05		 jmp	 SHORT $LN14@GetDuelCha@3
$LN12@GetDuelCha@3:
  00035	1b c9		 sbb	 ecx, ecx
  00037	83 d9 ff	 sbb	 ecx, -1
$LN14@GetDuelCha@3:
  0003a	85 c9		 test	 ecx, ecx
  0003c	74 39		 je	 SHORT $LN6@GetDuelCha@3
  0003e	8b d7		 mov	 edx, edi
  00040	8b ce		 mov	 ecx, esi
$LL15@GetDuelCha@3:
  00042	8a 19		 mov	 bl, BYTE PTR [ecx]
  00044	3a 1a		 cmp	 bl, BYTE PTR [edx]
  00046	75 1a		 jne	 SHORT $LN16@GetDuelCha@3
  00048	84 db		 test	 bl, bl
  0004a	74 12		 je	 SHORT $LN17@GetDuelCha@3
  0004c	8a 59 01	 mov	 bl, BYTE PTR [ecx+1]
  0004f	3a 5a 01	 cmp	 bl, BYTE PTR [edx+1]
  00052	75 0e		 jne	 SHORT $LN16@GetDuelCha@3
  00054	83 c1 02	 add	 ecx, 2
  00057	83 c2 02	 add	 edx, 2
  0005a	84 db		 test	 bl, bl
  0005c	75 e4		 jne	 SHORT $LL15@GetDuelCha@3
$LN17@GetDuelCha@3:
  0005e	33 c9		 xor	 ecx, ecx
  00060	eb 05		 jmp	 SHORT $LN18@GetDuelCha@3
$LN16@GetDuelCha@3:
  00062	1b c9		 sbb	 ecx, ecx
  00064	83 d9 ff	 sbb	 ecx, -1
$LN18@GetDuelCha@3:
  00067	85 c9		 test	 ecx, ecx
  00069	74 0c		 je	 SHORT $LN6@GetDuelCha@3

; 185  : 	for( int i = 0; i < DUEL_CHANNEL_MAX; i++ )

  0006b	40		 inc	 eax
  0006c	83 c6 2c	 add	 esi, 44			; 0000002cH
  0006f	83 f8 04	 cmp	 eax, 4
  00072	7c 9c		 jl	 SHORT $LL5@GetDuelCha@3

; 189  : 		{
; 190  : 			return i;
; 191  : 		}
; 192  : 	}
; 193  : 	
; 194  : 	return -1;

  00074	83 c8 ff	 or	 eax, -1
$LN6@GetDuelCha@3:
  00077	5f		 pop	 edi
  00078	5e		 pop	 esi
  00079	5b		 pop	 ebx

; 195  : }

  0007a	5d		 pop	 ebp
  0007b	c2 04 00	 ret	 4
?GetDuelChannelId@CNewPVP@@AAEHPAD@Z ENDP		; CNewPVP::GetDuelChannelId
_TEXT	ENDS
PUBLIC	?GetDuelChannel@CNewPVP@@AAEPAU_tagDUEL_CHANNEL@@XZ ; CNewPVP::GetDuelChannel
; Function compile flags: /Ogtp
;	COMDAT ?GetDuelChannel@CNewPVP@@AAEPAU_tagDUEL_CHANNEL@@XZ
_TEXT	SEGMENT
?GetDuelChannel@CNewPVP@@AAEPAU_tagDUEL_CHANNEL@@XZ PROC ; CNewPVP::GetDuelChannel, COMDAT
; _this$ = ecx

; 200  : 	for( int i = 0; i < DUEL_CHANNEL_MAX; i++ )

  00000	33 c0		 xor	 eax, eax
  00002	8d 91 86 00 00
	00		 lea	 edx, DWORD PTR [ecx+134]
$LL4@GetDuelCha@4:

; 201  : 	{
; 202  : 		if( m_DuelChannel[i].nStatus == DC_IDLE )

  00008	80 3a 00	 cmp	 BYTE PTR [edx], 0
  0000b	74 0c		 je	 SHORT $LN8@GetDuelCha@4

; 200  : 	for( int i = 0; i < DUEL_CHANNEL_MAX; i++ )

  0000d	40		 inc	 eax
  0000e	83 c2 2c	 add	 edx, 44			; 0000002cH
  00011	83 f8 04	 cmp	 eax, 4
  00014	7c f2		 jl	 SHORT $LL4@GetDuelCha@4

; 205  : 		}
; 206  : 	}
; 207  : 
; 208  : 	return NULL;

  00016	33 c0		 xor	 eax, eax

; 209  : }

  00018	c3		 ret	 0
$LN8@GetDuelCha@4:

; 203  : 		{
; 204  : 			return &m_DuelChannel[i];

  00019	6b c0 2c	 imul	 eax, 44			; 0000002cH
  0001c	8d 44 08 64	 lea	 eax, DWORD PTR [eax+ecx+100]

; 209  : }

  00020	c3		 ret	 0
?GetDuelChannel@CNewPVP@@AAEPAU_tagDUEL_CHANNEL@@XZ ENDP ; CNewPVP::GetDuelChannel
_TEXT	ENDS
PUBLIC	?GetDuelChannel@CNewPVP@@AAEPAU_tagDUEL_CHANNEL@@PAD@Z ; CNewPVP::GetDuelChannel
; Function compile flags: /Ogtp
;	COMDAT ?GetDuelChannel@CNewPVP@@AAEPAU_tagDUEL_CHANNEL@@PAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_lpszName$ = 8						; size = 4
?GetDuelChannel@CNewPVP@@AAEPAU_tagDUEL_CHANNEL@@PAD@Z PROC ; CNewPVP::GetDuelChannel, COMDAT
; _this$ = ecx

; 213  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi
  00006	57		 push	 edi
  00007	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 214  : 	for( int i = 0; i < DUEL_CHANNEL_MAX; i++ )

  0000a	8d 71 7b	 lea	 esi, DWORD PTR [ecx+123]
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR _lpszName$[ebp]
  00010	33 ff		 xor	 edi, edi
$LL5@GetDuelCha@5:

; 215  : 	{
; 216  : 		if( strcmp(m_DuelChannel[i].szName1, lpszName) == 0 || 
; 217  : 			strcmp(m_DuelChannel[i].szName2, lpszName) == 0)

  00012	8b d1		 mov	 edx, ecx
  00014	8d 46 f5	 lea	 eax, DWORD PTR [esi-11]
$LL11@GetDuelCha@5:
  00017	8a 18		 mov	 bl, BYTE PTR [eax]
  00019	3a 1a		 cmp	 bl, BYTE PTR [edx]
  0001b	75 1a		 jne	 SHORT $LN12@GetDuelCha@5
  0001d	84 db		 test	 bl, bl
  0001f	74 12		 je	 SHORT $LN13@GetDuelCha@5
  00021	8a 58 01	 mov	 bl, BYTE PTR [eax+1]
  00024	3a 5a 01	 cmp	 bl, BYTE PTR [edx+1]
  00027	75 0e		 jne	 SHORT $LN12@GetDuelCha@5
  00029	83 c0 02	 add	 eax, 2
  0002c	83 c2 02	 add	 edx, 2
  0002f	84 db		 test	 bl, bl
  00031	75 e4		 jne	 SHORT $LL11@GetDuelCha@5
$LN13@GetDuelCha@5:
  00033	33 c0		 xor	 eax, eax
  00035	eb 05		 jmp	 SHORT $LN14@GetDuelCha@5
$LN12@GetDuelCha@5:
  00037	1b c0		 sbb	 eax, eax
  00039	83 d8 ff	 sbb	 eax, -1
$LN14@GetDuelCha@5:
  0003c	85 c0		 test	 eax, eax
  0003e	74 41		 je	 SHORT $LN9@GetDuelCha@5
  00040	8b d1		 mov	 edx, ecx
  00042	8b c6		 mov	 eax, esi
$LL15@GetDuelCha@5:
  00044	8a 18		 mov	 bl, BYTE PTR [eax]
  00046	3a 1a		 cmp	 bl, BYTE PTR [edx]
  00048	75 1a		 jne	 SHORT $LN16@GetDuelCha@5
  0004a	84 db		 test	 bl, bl
  0004c	74 12		 je	 SHORT $LN17@GetDuelCha@5
  0004e	8a 58 01	 mov	 bl, BYTE PTR [eax+1]
  00051	3a 5a 01	 cmp	 bl, BYTE PTR [edx+1]
  00054	75 0e		 jne	 SHORT $LN16@GetDuelCha@5
  00056	83 c0 02	 add	 eax, 2
  00059	83 c2 02	 add	 edx, 2
  0005c	84 db		 test	 bl, bl
  0005e	75 e4		 jne	 SHORT $LL15@GetDuelCha@5
$LN17@GetDuelCha@5:
  00060	33 c0		 xor	 eax, eax
  00062	eb 05		 jmp	 SHORT $LN18@GetDuelCha@5
$LN16@GetDuelCha@5:
  00064	1b c0		 sbb	 eax, eax
  00066	83 d8 ff	 sbb	 eax, -1
$LN18@GetDuelCha@5:
  00069	85 c0		 test	 eax, eax
  0006b	74 14		 je	 SHORT $LN9@GetDuelCha@5

; 214  : 	for( int i = 0; i < DUEL_CHANNEL_MAX; i++ )

  0006d	47		 inc	 edi
  0006e	83 c6 2c	 add	 esi, 44			; 0000002cH
  00071	83 ff 04	 cmp	 edi, 4
  00074	7c 9c		 jl	 SHORT $LL5@GetDuelCha@5

; 220  : 		}
; 221  : 	}
; 222  : 
; 223  : 	return 0;

  00076	5f		 pop	 edi
  00077	5e		 pop	 esi
  00078	33 c0		 xor	 eax, eax
  0007a	5b		 pop	 ebx

; 224  : }

  0007b	8b e5		 mov	 esp, ebp
  0007d	5d		 pop	 ebp
  0007e	c2 04 00	 ret	 4
$LN9@GetDuelCha@5:

; 218  : 		{
; 219  : 			return &m_DuelChannel[i];

  00081	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00084	6b ff 2c	 imul	 edi, 44			; 0000002cH
  00087	8d 44 07 64	 lea	 eax, DWORD PTR [edi+eax+100]
  0008b	5f		 pop	 edi
  0008c	5e		 pop	 esi
  0008d	5b		 pop	 ebx

; 224  : }

  0008e	8b e5		 mov	 esp, ebp
  00090	5d		 pop	 ebp
  00091	c2 04 00	 ret	 4
?GetDuelChannel@CNewPVP@@AAEPAU_tagDUEL_CHANNEL@@PAD@Z ENDP ; CNewPVP::GetDuelChannel
_TEXT	ENDS
PUBLIC	?SetDuelStatus@CNewPVP@@AAEXAAUOBJECTSTRUCT@@0H@Z ; CNewPVP::SetDuelStatus
EXTRN	__imp__GetTickCount@0:PROC
; Function compile flags: /Ogtp
;	COMDAT ?SetDuelStatus@CNewPVP@@AAEXAAUOBJECTSTRUCT@@0H@Z
_TEXT	SEGMENT
_requester$ = 8						; size = 4
_responsor$ = 12					; size = 4
_nStatus$ = 16						; size = 4
?SetDuelStatus@CNewPVP@@AAEXAAUOBJECTSTRUCT@@0H@Z PROC	; CNewPVP::SetDuelStatus, COMDAT
; _this$ = ecx

; 286  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 287  : 	switch(nStatus)

  00003	8b 45 10	 mov	 eax, DWORD PTR _nStatus$[ebp]
  00006	83 e8 00	 sub	 eax, 0
  00009	53		 push	 ebx
  0000a	0f 84 88 00 00
	00		 je	 $LN3@SetDuelSta
  00010	48		 dec	 eax
  00011	74 60		 je	 SHORT $LN2@SetDuelSta
  00013	48		 dec	 eax
  00014	0f 85 ab 00 00
	00		 jne	 $LN4@SetDuelSta

; 303  : 		break;
; 304  : 	case 2:
; 305  : 		requester.m_iDuelUserReserved = -1;
; 306  :         requester.m_btDuelScore = 0;
; 307  :         requester.m_iDuelUser = responsor.m_Index;

  0001a	56		 push	 esi
  0001b	8b 75 0c	 mov	 esi, DWORD PTR _responsor$[ebp]
  0001e	57		 push	 edi
  0001f	8b 7d 08	 mov	 edi, DWORD PTR _requester$[ebp]
  00022	83 cb ff	 or	 ebx, -1
  00025	89 9f 48 12 00
	00		 mov	 DWORD PTR [edi+4680], ebx
  0002b	88 87 54 12 00
	00		 mov	 BYTE PTR [edi+4692], al
  00031	8b 06		 mov	 eax, DWORD PTR [esi]
  00033	89 87 50 12 00
	00		 mov	 DWORD PTR [edi+4688], eax

; 308  :         requester.m_iDuelTickCount = GetTickCount();

  00039	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0003f	89 87 58 12 00
	00		 mov	 DWORD PTR [edi+4696], eax

; 309  :         
; 310  : 		responsor.m_iDuelUserRequested = -1;

  00045	89 9e 4c 12 00
	00		 mov	 DWORD PTR [esi+4684], ebx

; 311  :         responsor.m_iDuelUserReserved = -1;

  0004b	89 9e 48 12 00
	00		 mov	 DWORD PTR [esi+4680], ebx

; 312  :         responsor.m_btDuelScore = 0;

  00051	c6 86 54 12 00
	00 00		 mov	 BYTE PTR [esi+4692], 0

; 313  :         responsor.m_iDuelUser = requester.m_Index;

  00058	8b 0f		 mov	 ecx, DWORD PTR [edi]
  0005a	89 8e 50 12 00
	00		 mov	 DWORD PTR [esi+4688], ecx

; 314  :         responsor.m_iDuelTickCount = GetTickCount();

  00060	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00066	5f		 pop	 edi
  00067	89 86 58 12 00
	00		 mov	 DWORD PTR [esi+4696], eax
  0006d	5e		 pop	 esi
  0006e	5b		 pop	 ebx

; 315  : 		break;
; 316  : 	}
; 317  : }

  0006f	5d		 pop	 ebp
  00070	c2 0c 00	 ret	 12			; 0000000cH
$LN2@SetDuelSta:

; 297  : 		break;
; 298  : 	case 1:
; 299  : 		requester.m_iDuelUserReserved = responsor.m_Index;

  00073	8b 4d 0c	 mov	 ecx, DWORD PTR _responsor$[ebp]
  00076	8b 45 08	 mov	 eax, DWORD PTR _requester$[ebp]
  00079	8b 11		 mov	 edx, DWORD PTR [ecx]
  0007b	89 90 48 12 00
	00		 mov	 DWORD PTR [eax+4680], edx

; 300  : 		requester.m_iDuelUser = -1;

  00081	c7 80 50 12 00
	00 ff ff ff ff	 mov	 DWORD PTR [eax+4688], -1

; 301  : 		
; 302  : 		responsor.m_iDuelUserRequested = requester.m_Index;

  0008b	8b 00		 mov	 eax, DWORD PTR [eax]
  0008d	89 81 4c 12 00
	00		 mov	 DWORD PTR [ecx+4684], eax
  00093	5b		 pop	 ebx

; 315  : 		break;
; 316  : 	}
; 317  : }

  00094	5d		 pop	 ebp
  00095	c2 0c 00	 ret	 12			; 0000000cH
$LN3@SetDuelSta:

; 288  : 	{
; 289  : 	case DC_IDLE:
; 290  : 		requester.m_iDuelUser = -1;

  00098	8b 45 08	 mov	 eax, DWORD PTR _requester$[ebp]
  0009b	83 cb ff	 or	 ebx, -1
  0009e	89 98 50 12 00
	00		 mov	 DWORD PTR [eax+4688], ebx

; 291  : 		requester.m_iDuelUserRequested = -1;

  000a4	89 98 4c 12 00
	00		 mov	 DWORD PTR [eax+4684], ebx

; 292  : 		requester.m_iDuelUserReserved = -1;

  000aa	89 98 48 12 00
	00		 mov	 DWORD PTR [eax+4680], ebx

; 293  : 		
; 294  : 		responsor.m_iDuelUser = -1;

  000b0	8b 45 0c	 mov	 eax, DWORD PTR _responsor$[ebp]
  000b3	89 98 50 12 00
	00		 mov	 DWORD PTR [eax+4688], ebx

; 295  : 		responsor.m_iDuelUserRequested = -1;

  000b9	89 98 4c 12 00
	00		 mov	 DWORD PTR [eax+4684], ebx

; 296  : 		responsor.m_iDuelUserReserved = -1;

  000bf	89 98 48 12 00
	00		 mov	 DWORD PTR [eax+4680], ebx
$LN4@SetDuelSta:
  000c5	5b		 pop	 ebx

; 315  : 		break;
; 316  : 	}
; 317  : }

  000c6	5d		 pop	 ebp
  000c7	c2 0c 00	 ret	 12			; 0000000cH
?SetDuelStatus@CNewPVP@@AAEXAAUOBJECTSTRUCT@@0H@Z ENDP	; CNewPVP::SetDuelStatus
_TEXT	ENDS
PUBLIC	??_C@_0P@ENJPCMFP@?$CFs?7?$CFs?7?$CFs?7?$CFs?7?$CFd?$AA@ ; `string'
PUBLIC	??_C@_0BP@OMAPJGHA@nId?$DO?$DN0?5?$CG?$CG?5nId?$DMDUEL_CHANNEL_MAX?$AA@ ; `string'
PUBLIC	??_C@_0FB@CPAGFMCM@IS_START?$CIm_DuelChannel?$FLnId?$FN?4nSta@ ; `string'
PUBLIC	??_C@_01GBGANLPD@0?$AA@				; `string'
PUBLIC	??_C@_04HIBGFPH@NULL?$AA@			; `string'
PUBLIC	??_C@_0L@IGELOCEA@NewPVP?4cpp?$AA@		; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?Leave@CNewPVP@@AAEXAAUOBJECTSTRUCT@@0@Z	; CNewPVP::Leave
EXTRN	?LogAddTD@@3P6AXPADZZA:DWORD			; LogAddTD
EXTRN	?gObjMoveGate@@YAHHH@Z:PROC			; gObjMoveGate
EXTRN	?DataSend@@YAHHPAEK@Z:PROC			; DataSend
EXTRN	?gObjIsConnected@@YAHPAUOBJECTSTRUCT@@@Z:PROC	; gObjIsConnected
;	COMDAT ??_C@_0P@ENJPCMFP@?$CFs?7?$CFs?7?$CFs?7?$CFs?7?$CFd?$AA@
; File c:\muserver_dev\development\mu-s8ep2-repack\gameserver\source\newpvp.h
CONST	SEGMENT
??_C@_0P@ENJPCMFP@?$CFs?7?$CFs?7?$CFs?7?$CFs?7?$CFd?$AA@ DB '%s', 09H, '%'
	DB	's', 09H, '%s', 09H, '%s', 09H, '%d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@OMAPJGHA@nId?$DO?$DN0?5?$CG?$CG?5nId?$DMDUEL_CHANNEL_MAX?$AA@
CONST	SEGMENT
??_C@_0BP@OMAPJGHA@nId?$DO?$DN0?5?$CG?$CG?5nId?$DMDUEL_CHANNEL_MAX?$AA@ DB 'n'
	DB	'Id>=0 && nId<DUEL_CHANNEL_MAX', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0FB@CPAGFMCM@IS_START?$CIm_DuelChannel?$FLnId?$FN?4nSta@
CONST	SEGMENT
??_C@_0FB@CPAGFMCM@IS_START?$CIm_DuelChannel?$FLnId?$FN?4nSta@ DB 'IS_STA'
	DB	'RT(m_DuelChannel[nId].nStatus)||m_DuelChannel[nId].nStatus==D'
	DB	'C_RESERVEDEND', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_01GBGANLPD@0?$AA@
CONST	SEGMENT
??_C@_01GBGANLPD@0?$AA@ DB '0', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04HIBGFPH@NULL?$AA@
CONST	SEGMENT
??_C@_04HIBGFPH@NULL?$AA@ DB 'NULL', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@IGELOCEA@NewPVP?4cpp?$AA@
CONST	SEGMENT
??_C@_0L@IGELOCEA@NewPVP?4cpp?$AA@ DB 'NewPVP.cpp', 00H	; `string'
; Function compile flags: /Ogtp
; File c:\muserver_dev\development\mu-s8ep2-repack\gameserver\source\newpvp.cpp
CONST	ENDS
;	COMDAT ?Leave@CNewPVP@@AAEXAAUOBJECTSTRUCT@@0@Z
_TEXT	SEGMENT
_res$ = -24						; size = 17
__$ArrayPad$ = -4					; size = 4
_requester$ = 8						; size = 4
_responsor$ = 12					; size = 4
?Leave@CNewPVP@@AAEXAAUOBJECTSTRUCT@@0@Z PROC		; CNewPVP::Leave, COMDAT
; _this$ = ecx

; 488  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	8b 75 08	 mov	 esi, DWORD PTR _requester$[ebp]

; 489  : 	int nId = GetDuelChannelId(requester.m_Index);

  00015	8b 06		 mov	 eax, DWORD PTR [esi]
  00017	57		 push	 edi
  00018	8b 7d 0c	 mov	 edi, DWORD PTR _responsor$[ebp]
  0001b	50		 push	 eax
  0001c	8b d9		 mov	 ebx, ecx
  0001e	e8 00 00 00 00	 call	 ?GetDuelChannelId@CNewPVP@@AAEHH@Z ; CNewPVP::GetDuelChannelId

; 490  : 	if(nId < 0 || nId >= DUEL_CHANNEL_MAX){ LogAddTD("%s\t%s\t%s\t%s\t%d","nId>=0 && nId<DUEL_CHANNEL_MAX","0","NULL",__FILE__, __LINE__); return; }

  00023	83 f8 03	 cmp	 eax, 3
  00026	0f 87 23 01 00
	00		 ja	 $LN7@Leave

; 491  : 	if( !IS_START(m_DuelChannel[nId].nStatus) && m_DuelChannel[nId].nStatus != DC_RESERVEDEND ){ LogAddTD("%s\t%s\t%s\t%s\t%d","IS_START(m_DuelChannel[nId].nStatus)||m_DuelChannel[nId].nStatus==DC_RESERVEDEND", "0","NULL",__FILE__, __LINE__); return; }	

  0002c	6b c0 2c	 imul	 eax, 44			; 0000002cH
  0002f	8a 84 18 86 00
	00 00		 mov	 al, BYTE PTR [eax+ebx+134]
  00036	3c 02		 cmp	 al, 2
  00038	72 04		 jb	 SHORT $LN5@Leave
  0003a	3c 04		 cmp	 al, 4
  0003c	76 22		 jbe	 SHORT $LN6@Leave
$LN5@Leave:
  0003e	3c 05		 cmp	 al, 5
  00040	74 1e		 je	 SHORT $LN6@Leave
  00042	68 eb 01 00 00	 push	 491			; 000001ebH
  00047	68 00 00 00 00	 push	 OFFSET ??_C@_0L@IGELOCEA@NewPVP?4cpp?$AA@
  0004c	68 00 00 00 00	 push	 OFFSET ??_C@_04HIBGFPH@NULL?$AA@
  00051	68 00 00 00 00	 push	 OFFSET ??_C@_01GBGANLPD@0?$AA@
  00056	68 00 00 00 00	 push	 OFFSET ??_C@_0FB@CPAGFMCM@IS_START?$CIm_DuelChannel?$FLnId?$FN?4nSta@
  0005b	e9 08 01 00 00	 jmp	 $LN15@Leave
$LN6@Leave:

; 492  : 
; 493  : 	PMSG_ANS_DUEL_EXIT res = {0};

  00060	33 c0		 xor	 eax, eax
  00062	89 45 e9	 mov	 DWORD PTR _res$[ebp+1], eax

; 494  : 	res.h.c = PMHC_BYTE;
; 495  :     res.h.headcode = 0xAA;
; 496  :     res.h.subcode = 0x03;
; 497  :     res.h.size = sizeof(PMSG_ANS_DUEL_EXIT);
; 498  :     res.nResult = 0x00;
; 499  : 
; 500  : 	if( gObjIsConnected(&requester) )

  00065	56		 push	 esi
  00066	89 45 ed	 mov	 DWORD PTR _res$[ebp+5], eax
  00069	89 45 f1	 mov	 DWORD PTR _res$[ebp+9], eax
  0006c	89 45 f5	 mov	 DWORD PTR _res$[ebp+13], eax
  0006f	c7 45 e8 c1 11
	aa 03		 mov	 DWORD PTR _res$[ebp], 61477313 ; 03aa11c1H
  00076	88 45 ec	 mov	 BYTE PTR _res$[ebp+4], al
  00079	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHPAUOBJECTSTRUCT@@@Z ; gObjIsConnected
  0007e	83 c4 04	 add	 esp, 4
  00081	b3 40		 mov	 bl, 64			; 00000040H
  00083	85 c0		 test	 eax, eax
  00085	74 52		 je	 SHORT $LN3@Leave

; 501  :     {
; 502  : 		requester.m_iDuelUser = -1;

  00087	c7 86 50 12 00
	00 ff ff ff ff	 mov	 DWORD PTR [esi+4688], -1

; 503  :         res.NumberH = HIBYTE(responsor.m_Index);
; 504  :         res.NumberL = LOBYTE(responsor.m_Index);
; 505  :         memcpy(res.szName, responsor.Name, MAX_IDSTRING);

  00091	8b 47 5d	 mov	 eax, DWORD PTR [edi+93]
  00094	8a 4f 01	 mov	 cl, BYTE PTR [edi+1]
  00097	8a 17		 mov	 dl, BYTE PTR [edi]
  00099	88 4d ed	 mov	 BYTE PTR _res$[ebp+5], cl
  0009c	8b 4f 61	 mov	 ecx, DWORD PTR [edi+97]
  0009f	89 45 ef	 mov	 DWORD PTR _res$[ebp+7], eax

; 506  : 
; 507  :         DataSend(requester.m_Index, (LPBYTE)&res, res.h.size);

  000a2	0f b6 45 e9	 movzx	 eax, BYTE PTR _res$[ebp+1]
  000a6	88 55 ee	 mov	 BYTE PTR _res$[ebp+6], dl
  000a9	66 8b 57 65	 mov	 dx, WORD PTR [edi+101]
  000ad	89 4d f3	 mov	 DWORD PTR _res$[ebp+11], ecx
  000b0	50		 push	 eax
  000b1	8d 4d e8	 lea	 ecx, DWORD PTR _res$[ebp]
  000b4	66 89 55 f7	 mov	 WORD PTR _res$[ebp+15], dx
  000b8	8b 16		 mov	 edx, DWORD PTR [esi]
  000ba	51		 push	 ecx
  000bb	52		 push	 edx
  000bc	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  000c1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 508  :         
; 509  : 		if( IsPKFieldMap(requester.MapNumber) )

  000c4	38 9e 23 01 00
	00		 cmp	 BYTE PTR [esi+291], bl
  000ca	75 0d		 jne	 SHORT $LN3@Leave

; 510  : 		{
; 511  : 			gObjMoveGate(requester.m_Index, 17);

  000cc	8b 06		 mov	 eax, DWORD PTR [esi]
  000ce	6a 11		 push	 17			; 00000011H
  000d0	50		 push	 eax
  000d1	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  000d6	83 c4 08	 add	 esp, 8
$LN3@Leave:

; 512  : 		}
; 513  :     }
; 514  : 	
; 515  : 	if( gObjIsConnected(&responsor) )

  000d9	57		 push	 edi
  000da	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHPAUOBJECTSTRUCT@@@Z ; gObjIsConnected
  000df	83 c4 04	 add	 esp, 4
  000e2	85 c0		 test	 eax, eax
  000e4	0f 84 8c 00 00
	00		 je	 $LN1@Leave

; 516  : 	{
; 517  :         responsor.m_iDuelUser = -1;
; 518  :         res.NumberH = HIBYTE(responsor.m_Index);

  000ea	8a 4f 01	 mov	 cl, BYTE PTR [edi+1]

; 519  :         res.NumberL = LOBYTE(responsor.m_Index);

  000ed	8a 17		 mov	 dl, BYTE PTR [edi]
  000ef	c7 87 50 12 00
	00 ff ff ff ff	 mov	 DWORD PTR [edi+4688], -1

; 520  :         memcpy(res.szName, requester.Name, MAX_IDSTRING);

  000f9	8b 46 5d	 mov	 eax, DWORD PTR [esi+93]
  000fc	88 4d ed	 mov	 BYTE PTR _res$[ebp+5], cl
  000ff	8b 4e 61	 mov	 ecx, DWORD PTR [esi+97]
  00102	89 45 ef	 mov	 DWORD PTR _res$[ebp+7], eax

; 521  :         
; 522  : 		DataSend(responsor.m_Index, (LPBYTE)&res, res.h.size);

  00105	0f b6 45 e9	 movzx	 eax, BYTE PTR _res$[ebp+1]
  00109	88 55 ee	 mov	 BYTE PTR _res$[ebp+6], dl
  0010c	66 8b 56 65	 mov	 dx, WORD PTR [esi+101]
  00110	89 4d f3	 mov	 DWORD PTR _res$[ebp+11], ecx
  00113	50		 push	 eax
  00114	8d 4d e8	 lea	 ecx, DWORD PTR _res$[ebp]
  00117	66 89 55 f7	 mov	 WORD PTR _res$[ebp+15], dx
  0011b	8b 17		 mov	 edx, DWORD PTR [edi]
  0011d	51		 push	 ecx
  0011e	52		 push	 edx
  0011f	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00124	83 c4 0c	 add	 esp, 12			; 0000000cH

; 523  :         
; 524  : 		if( IsPKFieldMap(responsor.MapNumber) )

  00127	38 9f 23 01 00
	00		 cmp	 BYTE PTR [edi+291], bl
  0012d	75 47		 jne	 SHORT $LN1@Leave

; 525  : 		{
; 526  : 			gObjMoveGate(responsor.m_Index, 17);

  0012f	8b 07		 mov	 eax, DWORD PTR [edi]
  00131	6a 11		 push	 17			; 00000011H
  00133	50		 push	 eax
  00134	e8 00 00 00 00	 call	 ?gObjMoveGate@@YAHHH@Z	; gObjMoveGate
  00139	83 c4 08	 add	 esp, 8
  0013c	5f		 pop	 edi
  0013d	5e		 pop	 esi
  0013e	5b		 pop	 ebx

; 527  : 		}
; 528  :     }
; 529  : }

  0013f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00142	33 cd		 xor	 ecx, ebp
  00144	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00149	8b e5		 mov	 esp, ebp
  0014b	5d		 pop	 ebp
  0014c	c2 08 00	 ret	 8
$LN7@Leave:

; 490  : 	if(nId < 0 || nId >= DUEL_CHANNEL_MAX){ LogAddTD("%s\t%s\t%s\t%s\t%d","nId>=0 && nId<DUEL_CHANNEL_MAX","0","NULL",__FILE__, __LINE__); return; }

  0014f	68 ea 01 00 00	 push	 490			; 000001eaH
  00154	68 00 00 00 00	 push	 OFFSET ??_C@_0L@IGELOCEA@NewPVP?4cpp?$AA@
  00159	68 00 00 00 00	 push	 OFFSET ??_C@_04HIBGFPH@NULL?$AA@
  0015e	68 00 00 00 00	 push	 OFFSET ??_C@_01GBGANLPD@0?$AA@
  00163	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@OMAPJGHA@nId?$DO?$DN0?5?$CG?$CG?5nId?$DMDUEL_CHANNEL_MAX?$AA@
$LN15@Leave:
  00168	68 00 00 00 00	 push	 OFFSET ??_C@_0P@ENJPCMFP@?$CFs?7?$CFs?7?$CFs?7?$CFs?7?$CFd?$AA@
  0016d	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00173	83 c4 18	 add	 esp, 24			; 00000018H
$LN1@Leave:

; 527  : 		}
; 528  :     }
; 529  : }

  00176	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00179	5f		 pop	 edi
  0017a	5e		 pop	 esi
  0017b	33 cd		 xor	 ecx, ebp
  0017d	5b		 pop	 ebx
  0017e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00183	8b e5		 mov	 esp, ebp
  00185	5d		 pop	 ebp
  00186	c2 08 00	 ret	 8
?Leave@CNewPVP@@AAEXAAUOBJECTSTRUCT@@0@Z ENDP		; CNewPVP::Leave
_TEXT	ENDS
PUBLIC	??_C@_0CF@CINMDLEF@IS_START?$CIm_DuelChannel?$FLnId?$FN?4nSta@ ; `string'
PUBLIC	?SetScore@CNewPVP@@QAEXAAUOBJECTSTRUCT@@@Z	; CNewPVP::SetScore
;	COMDAT ??_C@_0CF@CINMDLEF@IS_START?$CIm_DuelChannel?$FLnId?$FN?4nSta@
CONST	SEGMENT
??_C@_0CF@CINMDLEF@IS_START?$CIm_DuelChannel?$FLnId?$FN?4nSta@ DB 'IS_STA'
	DB	'RT(m_DuelChannel[nId].nStatus)', 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?SetScore@CNewPVP@@QAEXAAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_obj$ = 8						; size = 4
?SetScore@CNewPVP@@QAEXAAUOBJECTSTRUCT@@@Z PROC		; CNewPVP::SetScore, COMDAT
; _this$ = ecx

; 533  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 534  : 	int nId = GetDuelChannelId(obj.m_Index);

  00005	8b 7d 08	 mov	 edi, DWORD PTR _obj$[ebp]
  00008	8b 07		 mov	 eax, DWORD PTR [edi]
  0000a	50		 push	 eax
  0000b	8b f1		 mov	 esi, ecx
  0000d	e8 00 00 00 00	 call	 ?GetDuelChannelId@CNewPVP@@AAEHH@Z ; CNewPVP::GetDuelChannelId

; 535  : 	if(nId < 0 || nId >= DUEL_CHANNEL_MAX) { LogAddTD("%s\t%s\t%s\t%s\t%d","nId>=0 && nId<DUEL_CHANNEL_MAX","0","NULL",__FILE__, __LINE__); return;	}

  00012	83 f8 03	 cmp	 eax, 3
  00015	77 4b		 ja	 SHORT $LN3@SetScore

; 536  : 	if( !IS_START(m_DuelChannel[nId].nStatus) ) { LogAddTD("%s\t%s\t%s\t%s\t%d","IS_START(m_DuelChannel[nId].nStatus)", "0","NULL",__FILE__, __LINE__); return; }

  00017	6b c0 2c	 imul	 eax, 44			; 0000002cH
  0001a	8a 84 30 86 00
	00 00		 mov	 al, BYTE PTR [eax+esi+134]
  00021	3c 02		 cmp	 al, 2
  00023	72 10		 jb	 SHORT $LN1@SetScore
  00025	3c 04		 cmp	 al, 4
  00027	77 0c		 ja	 SHORT $LN1@SetScore

; 537  :     obj.m_btDuelScore++;

  00029	fe 87 54 12 00
	00		 inc	 BYTE PTR [edi+4692]
  0002f	5f		 pop	 edi
  00030	5e		 pop	 esi

; 538  : }

  00031	5d		 pop	 ebp
  00032	c2 04 00	 ret	 4
$LN1@SetScore:

; 536  : 	if( !IS_START(m_DuelChannel[nId].nStatus) ) { LogAddTD("%s\t%s\t%s\t%s\t%d","IS_START(m_DuelChannel[nId].nStatus)", "0","NULL",__FILE__, __LINE__); return; }

  00035	68 18 02 00 00	 push	 536			; 00000218H
  0003a	68 00 00 00 00	 push	 OFFSET ??_C@_0L@IGELOCEA@NewPVP?4cpp?$AA@
  0003f	68 00 00 00 00	 push	 OFFSET ??_C@_04HIBGFPH@NULL?$AA@
  00044	68 00 00 00 00	 push	 OFFSET ??_C@_01GBGANLPD@0?$AA@
  00049	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@CINMDLEF@IS_START?$CIm_DuelChannel?$FLnId?$FN?4nSta@
  0004e	68 00 00 00 00	 push	 OFFSET ??_C@_0P@ENJPCMFP@?$CFs?7?$CFs?7?$CFs?7?$CFs?7?$CFd?$AA@
  00053	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00059	83 c4 18	 add	 esp, 24			; 00000018H
  0005c	5f		 pop	 edi
  0005d	5e		 pop	 esi

; 538  : }

  0005e	5d		 pop	 ebp
  0005f	c2 04 00	 ret	 4
$LN3@SetScore:

; 535  : 	if(nId < 0 || nId >= DUEL_CHANNEL_MAX) { LogAddTD("%s\t%s\t%s\t%s\t%d","nId>=0 && nId<DUEL_CHANNEL_MAX","0","NULL",__FILE__, __LINE__); return;	}

  00062	68 17 02 00 00	 push	 535			; 00000217H
  00067	68 00 00 00 00	 push	 OFFSET ??_C@_0L@IGELOCEA@NewPVP?4cpp?$AA@
  0006c	68 00 00 00 00	 push	 OFFSET ??_C@_04HIBGFPH@NULL?$AA@
  00071	68 00 00 00 00	 push	 OFFSET ??_C@_01GBGANLPD@0?$AA@
  00076	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@OMAPJGHA@nId?$DO?$DN0?5?$CG?$CG?5nId?$DMDUEL_CHANNEL_MAX?$AA@
  0007b	68 00 00 00 00	 push	 OFFSET ??_C@_0P@ENJPCMFP@?$CFs?7?$CFs?7?$CFs?7?$CFs?7?$CFd?$AA@
  00080	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00086	83 c4 18	 add	 esp, 24			; 00000018H
  00089	5f		 pop	 edi
  0008a	5e		 pop	 esi

; 538  : }

  0008b	5d		 pop	 ebp
  0008c	c2 04 00	 ret	 4
?SetScore@CNewPVP@@QAEXAAUOBJECTSTRUCT@@@Z ENDP		; CNewPVP::SetScore
_TEXT	ENDS
PUBLIC	??_C@_0BG@IOFGAKKG@gObjIsConnected?$CI?$CGobj?$CJ?$AA@ ; `string'
PUBLIC	?ReFill@CNewPVP@@AAEXAAUOBJECTSTRUCT@@@Z	; CNewPVP::ReFill
EXTRN	?GCReFillSend@@YAXHGEEG@Z:PROC			; GCReFillSend
EXTRN	?GCManaSend@@YAXHFEEG@Z:PROC			; GCManaSend
EXTRN	__fltused:DWORD
EXTRN	__ftol2_sse:PROC
;	COMDAT ??_C@_0BG@IOFGAKKG@gObjIsConnected?$CI?$CGobj?$CJ?$AA@
CONST	SEGMENT
??_C@_0BG@IOFGAKKG@gObjIsConnected?$CI?$CGobj?$CJ?$AA@ DB 'gObjIsConnecte'
	DB	'd(&obj)', 00H				; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?ReFill@CNewPVP@@AAEXAAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
tv197 = -4						; size = 4
tv195 = -4						; size = 4
tv199 = 8						; size = 4
tv180 = 8						; size = 4
_obj$ = 8						; size = 4
tv201 = 10						; size = 2
?ReFill@CNewPVP@@AAEXAAUOBJECTSTRUCT@@@Z PROC		; CNewPVP::ReFill, COMDAT
; _this$ = ecx

; 574  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi

; 575  : 	if( !gObjIsConnected(&obj) ){ LogAddTD("%s\t%s\t%s\t%s\t%d","gObjIsConnected(&obj)","0","NULL", __FILE__, __LINE__); return; }

  00005	8b 75 08	 mov	 esi, DWORD PTR _obj$[ebp]
  00008	56		 push	 esi
  00009	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHPAUOBJECTSTRUCT@@@Z ; gObjIsConnected
  0000e	83 c4 04	 add	 esp, 4
  00011	85 c0		 test	 eax, eax
  00013	75 2e		 jne	 SHORT $LN1@ReFill
  00015	68 3f 02 00 00	 push	 575			; 0000023fH
  0001a	68 00 00 00 00	 push	 OFFSET ??_C@_0L@IGELOCEA@NewPVP?4cpp?$AA@
  0001f	68 00 00 00 00	 push	 OFFSET ??_C@_04HIBGFPH@NULL?$AA@
  00024	68 00 00 00 00	 push	 OFFSET ??_C@_01GBGANLPD@0?$AA@
  00029	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@IOFGAKKG@gObjIsConnected?$CI?$CGobj?$CJ?$AA@
  0002e	68 00 00 00 00	 push	 OFFSET ??_C@_0P@ENJPCMFP@?$CFs?7?$CFs?7?$CFs?7?$CFs?7?$CFd?$AA@
  00033	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00039	83 c4 18	 add	 esp, 24			; 00000018H
  0003c	5e		 pop	 esi

; 584  : }

  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c2 04 00	 ret	 4
$LN1@ReFill:

; 576  : 
; 577  : 	obj.BP = obj.MaxBP + obj.AddBP;

  00043	8b 86 0c 01 00
	00		 mov	 eax, DWORD PTR [esi+268]

; 578  : 	obj.Mana = obj.MaxMana + obj.AddMana;

  00049	db 86 28 01 00
	00		 fild	 DWORD PTR [esi+296]
  0004f	03 86 08 01 00
	00		 add	 eax, DWORD PTR [esi+264]
  00055	d8 86 f0 00 00
	00		 fadd	 DWORD PTR [esi+240]

; 579  : 	GCManaSend(obj.m_Index, (int)obj.Mana, 0xFF, 0, (int)obj.BP);

  0005b	0f b7 c8	 movzx	 ecx, ax
  0005e	51		 push	 ecx
  0005f	6a 00		 push	 0
  00061	d9 5d 08	 fstp	 DWORD PTR tv180[ebp]
  00064	68 ff 00 00 00	 push	 255			; 000000ffH
  00069	d9 45 08	 fld	 DWORD PTR tv180[ebp]
  0006c	89 86 04 01 00
	00		 mov	 DWORD PTR [esi+260], eax
  00072	d9 96 ec 00 00
	00		 fst	 DWORD PTR [esi+236]
  00078	e8 00 00 00 00	 call	 __ftol2_sse
  0007d	0f b7 d0	 movzx	 edx, ax
  00080	8b 06		 mov	 eax, DWORD PTR [esi]
  00082	52		 push	 edx
  00083	50		 push	 eax
  00084	e8 00 00 00 00	 call	 ?GCManaSend@@YAXHFEEG@Z	; GCManaSend

; 580  : 
; 581  : 	obj.Life = obj.MaxLife + obj.AddLife;
; 582  : 	obj.iShield = obj.iMaxShield + obj.iAddShield;

  00089	8b 8e 34 01 00
	00		 mov	 ecx, DWORD PTR [esi+308]
  0008f	db 86 24 01 00
	00		 fild	 DWORD PTR [esi+292]
  00095	03 8e 30 01 00
	00		 add	 ecx, DWORD PTR [esi+304]
  0009b	d8 86 dc 00 00
	00		 fadd	 DWORD PTR [esi+220]

; 583  : 	GCReFillSend(obj.m_Index, (int)obj.Life, 0xFF, 0, (int)obj.iShield);

  000a1	0f b7 d1	 movzx	 edx, cx
  000a4	52		 push	 edx
  000a5	8b 16		 mov	 edx, DWORD PTR [esi]
  000a7	d9 5d 08	 fstp	 DWORD PTR tv199[ebp]
  000aa	89 8e 2c 01 00
	00		 mov	 DWORD PTR [esi+300], ecx
  000b0	d9 45 08	 fld	 DWORD PTR tv199[ebp]
  000b3	6a 00		 push	 0
  000b5	d9 7d 0a	 fnstcw	 WORD PTR tv201[ebp]
  000b8	0f b7 45 0a	 movzx	 eax, WORD PTR tv201[ebp]
  000bc	d9 96 d8 00 00
	00		 fst	 DWORD PTR [esi+216]
  000c2	0d 00 0c 00 00	 or	 eax, 3072		; 00000c00H
  000c7	89 45 fc	 mov	 DWORD PTR tv197[ebp], eax
  000ca	68 ff 00 00 00	 push	 255			; 000000ffH
  000cf	d9 6d fc	 fldcw	 WORD PTR tv197[ebp]
  000d2	db 5d fc	 fistp	 DWORD PTR tv195[ebp]
  000d5	66 8b 45 fc	 mov	 ax, WORD PTR tv195[ebp]
  000d9	0f b7 c8	 movzx	 ecx, ax
  000dc	51		 push	 ecx
  000dd	d9 6d 0a	 fldcw	 WORD PTR tv201[ebp]
  000e0	52		 push	 edx
  000e1	e8 00 00 00 00	 call	 ?GCReFillSend@@YAXHGEEG@Z ; GCReFillSend
  000e6	83 c4 28	 add	 esp, 40			; 00000028H
  000e9	5e		 pop	 esi

; 584  : }

  000ea	8b e5		 mov	 esp, ebp
  000ec	5d		 pop	 ebp
  000ed	c2 04 00	 ret	 4
?ReFill@CNewPVP@@AAEXAAUOBJECTSTRUCT@@@Z ENDP		; CNewPVP::ReFill
_TEXT	ENDS
PUBLIC	?MoveGate@CNewPVP@@AAEHHH@Z			; CNewPVP::MoveGate
EXTRN	?gObjViewportListProtocolCreate@@YAXPAUOBJECTSTRUCT@@@Z:PROC ; gObjViewportListProtocolCreate
EXTRN	?gObj@@3PAUOBJECTSTRUCT@@A:DWORD		; gObj
EXTRN	?gObjTeleport@@YAXHHHH@Z:PROC			; gObjTeleport
EXTRN	?GetGate@CGate@@QAEHHAAE000AAF@Z:PROC		; CGate::GetGate
EXTRN	?gGateC@@3VCGate@@A:BYTE			; gGateC
; Function compile flags: /Ogtp
;	COMDAT ?MoveGate@CNewPVP@@AAEHHH@Z
_TEXT	SEGMENT
_sLevel$ = -8						; size = 2
_btDir$ = -3						; size = 1
_sX$ = -2						; size = 1
_btMapNum$ = -1						; size = 1
_nIndex$ = 8						; size = 4
_nGateNum$ = 12						; size = 4
_sY$ = 15						; size = 1
?MoveGate@CNewPVP@@AAEHHH@Z PROC			; CNewPVP::MoveGate, COMDAT
; _this$ = ecx

; 588  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 589  : 	BYTE btMapNum = MAP_INDEX_PKFIELD;
; 590  : 	BYTE btDir;
; 591  : 	BYTE sX;
; 592  : 	BYTE sY;
; 593  : 	short sLevel;
; 594  : 	int nMapNumber;
; 595  : 
; 596  : 	nMapNumber =  gGateC.GetGate(nGateNum, sX, sY, btMapNum, btDir, sLevel);

  00006	8d 45 f8	 lea	 eax, DWORD PTR _sLevel$[ebp]
  00009	50		 push	 eax
  0000a	8d 4d fd	 lea	 ecx, DWORD PTR _btDir$[ebp]
  0000d	51		 push	 ecx
  0000e	8d 55 ff	 lea	 edx, DWORD PTR _btMapNum$[ebp]
  00011	52		 push	 edx
  00012	8b 55 0c	 mov	 edx, DWORD PTR _nGateNum$[ebp]
  00015	8d 45 0f	 lea	 eax, DWORD PTR _sY$[ebp]
  00018	50		 push	 eax
  00019	8d 4d fe	 lea	 ecx, DWORD PTR _sX$[ebp]
  0001c	51		 push	 ecx
  0001d	52		 push	 edx
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET ?gGateC@@3VCGate@@A ; gGateC
  00023	c6 45 ff 40	 mov	 BYTE PTR _btMapNum$[ebp], 64 ; 00000040H
  00027	e8 00 00 00 00	 call	 ?GetGate@CGate@@QAEHHAAE000AAF@Z ; CGate::GetGate

; 597  : 	if( nMapNumber < 0)	return FALSE;

  0002c	85 c0		 test	 eax, eax
  0002e	79 08		 jns	 SHORT $LN1@MoveGate
  00030	33 c0		 xor	 eax, eax

; 603  : }

  00032	8b e5		 mov	 esp, ebp
  00034	5d		 pop	 ebp
  00035	c2 08 00	 ret	 8
$LN1@MoveGate:

; 598  : 
; 599  : 	gObjTeleport(nIndex, btMapNum, sX, sY);

  00038	0f b6 45 0f	 movzx	 eax, BYTE PTR _sY$[ebp]
  0003c	0f b6 4d fe	 movzx	 ecx, BYTE PTR _sX$[ebp]
  00040	0f b6 55 ff	 movzx	 edx, BYTE PTR _btMapNum$[ebp]
  00044	56		 push	 esi
  00045	8b 75 08	 mov	 esi, DWORD PTR _nIndex$[ebp]
  00048	50		 push	 eax
  00049	51		 push	 ecx
  0004a	52		 push	 edx
  0004b	56		 push	 esi
  0004c	e8 00 00 00 00	 call	 ?gObjTeleport@@YAXHHHH@Z ; gObjTeleport

; 600  : 	//temp disabled, bcz have some bug
; 601  : 	gObjViewportListProtocolCreate(&gObj[nIndex]);

  00051	69 f6 40 27 00
	00		 imul	 esi, 10048		; 00002740H
  00057	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0005d	56		 push	 esi
  0005e	e8 00 00 00 00	 call	 ?gObjViewportListProtocolCreate@@YAXPAUOBJECTSTRUCT@@@Z ; gObjViewportListProtocolCreate
  00063	83 c4 14	 add	 esp, 20			; 00000014H

; 602  : 	return TRUE;

  00066	b8 01 00 00 00	 mov	 eax, 1
  0006b	5e		 pop	 esi

; 603  : }

  0006c	8b e5		 mov	 esp, ebp
  0006e	5d		 pop	 ebp
  0006f	c2 08 00	 ret	 8
?MoveGate@CNewPVP@@AAEHHH@Z ENDP			; CNewPVP::MoveGate
_TEXT	ENDS
PUBLIC	?CheckLimitLevel@CNewPVP@@AAEHHH@Z		; CNewPVP::CheckLimitLevel
; Function compile flags: /Ogtp
;	COMDAT ?CheckLimitLevel@CNewPVP@@AAEHHH@Z
_TEXT	SEGMENT
_sLevel$ = -8						; size = 2
_sX$ = -3						; size = 1
_sY$ = -2						; size = 1
_btMapNum$ = -1						; size = 1
_nIndex$ = 8						; size = 4
_nGateNum$ = 12						; size = 4
_btDir$ = 15						; size = 1
?CheckLimitLevel@CNewPVP@@AAEHHH@Z PROC			; CNewPVP::CheckLimitLevel, COMDAT
; _this$ = ecx

; 607  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 608  : 	BYTE btMapNum = MAP_INDEX_PKFIELD;
; 609  : 	BYTE btDir;
; 610  : 	BYTE sX;
; 611  : 	BYTE sY;
; 612  : 	short sLevel;
; 613  : 
; 614  : 	int nMapNumber =  gGateC.GetGate(nGateNum, sX, sY, btMapNum, btDir, sLevel);

  00006	8d 45 f8	 lea	 eax, DWORD PTR _sLevel$[ebp]
  00009	50		 push	 eax
  0000a	8d 4d 0f	 lea	 ecx, DWORD PTR _btDir$[ebp]
  0000d	51		 push	 ecx
  0000e	8d 55 ff	 lea	 edx, DWORD PTR _btMapNum$[ebp]
  00011	52		 push	 edx
  00012	8b 55 0c	 mov	 edx, DWORD PTR _nGateNum$[ebp]
  00015	8d 45 fe	 lea	 eax, DWORD PTR _sY$[ebp]
  00018	50		 push	 eax
  00019	8d 4d fd	 lea	 ecx, DWORD PTR _sX$[ebp]
  0001c	51		 push	 ecx
  0001d	52		 push	 edx
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET ?gGateC@@3VCGate@@A ; gGateC
  00023	c6 45 ff 40	 mov	 BYTE PTR _btMapNum$[ebp], 64 ; 00000040H
  00027	e8 00 00 00 00	 call	 ?GetGate@CGate@@QAEHHAAE000AAF@Z ; CGate::GetGate

; 615  : 	if( nMapNumber < 0)	return FALSE;

  0002c	85 c0		 test	 eax, eax
  0002e	79 08		 jns	 SHORT $LN2@CheckLimit
  00030	33 c0		 xor	 eax, eax

; 618  : 	return TRUE;
; 619  : }

  00032	8b e5		 mov	 esp, ebp
  00034	5d		 pop	 ebp
  00035	c2 08 00	 ret	 8
$LN2@CheckLimit:

; 616  : 
; 617  : 	if(gObj[nIndex].Level < sLevel)	return FALSE;

  00038	8b 45 08	 mov	 eax, DWORD PTR _nIndex$[ebp]
  0003b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00041	69 c0 40 27 00
	00		 imul	 eax, 10048		; 00002740H
  00047	66 8b 84 10 96
	00 00 00	 mov	 ax, WORD PTR [eax+edx+150]
  0004f	33 c9		 xor	 ecx, ecx
  00051	66 3b 45 f8	 cmp	 ax, WORD PTR _sLevel$[ebp]
  00055	0f 9d c1	 setge	 cl
  00058	8b c1		 mov	 eax, ecx

; 618  : 	return TRUE;
; 619  : }

  0005a	8b e5		 mov	 esp, ebp
  0005c	5d		 pop	 ebp
  0005d	c2 08 00	 ret	 8
?CheckLimitLevel@CNewPVP@@AAEHHH@Z ENDP			; CNewPVP::CheckLimitLevel
_TEXT	ENDS
PUBLIC	?SetBuff@CNewPVP@@QAEXAAUOBJECTSTRUCT@@H@Z	; CNewPVP::SetBuff
EXTRN	?gObjRemoveBuffEffect@@YA_NPAUOBJECTSTRUCT@@H@Z:PROC ; gObjRemoveBuffEffect
EXTRN	?gObjViewportListProtocolDestroy@@YAXPAUOBJECTSTRUCT@@@Z:PROC ; gObjViewportListProtocolDestroy
EXTRN	?gObjAddBuffEffect@@YA_NPAUOBJECTSTRUCT@@HEHEHH@Z:PROC ; gObjAddBuffEffect
; Function compile flags: /Ogtp
;	COMDAT ?SetBuff@CNewPVP@@QAEXAAUOBJECTSTRUCT@@H@Z
_TEXT	SEGMENT
_obj$ = 8						; size = 4
_bUse$ = 12						; size = 4
?SetBuff@CNewPVP@@QAEXAAUOBJECTSTRUCT@@H@Z PROC		; CNewPVP::SetBuff, COMDAT
; _this$ = ecx

; 623  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 624  : 	if( bUse )

  00003	83 7d 0c 00	 cmp	 DWORD PTR _bUse$[ebp], 0
  00007	56		 push	 esi

; 625  : 	{
; 626  : 		gObjAddBuffEffect(&obj, 18, 0, 0, 0, 0, -10);

  00008	8b 75 08	 mov	 esi, DWORD PTR _obj$[ebp]
  0000b	74 32		 je	 SHORT $LN1@SetBuff
  0000d	6a f6		 push	 -10			; fffffff6H
  0000f	6a 00		 push	 0
  00011	6a 00		 push	 0
  00013	6a 00		 push	 0
  00015	6a 00		 push	 0
  00017	6a 12		 push	 18			; 00000012H
  00019	56		 push	 esi
  0001a	e8 00 00 00 00	 call	 ?gObjAddBuffEffect@@YA_NPAUOBJECTSTRUCT@@HEHEHH@Z ; gObjAddBuffEffect

; 627  : 		gObjAddBuffEffect(&obj, 98, 0, 0, 0, 0, -10);

  0001f	6a f6		 push	 -10			; fffffff6H
  00021	6a 00		 push	 0
  00023	6a 00		 push	 0
  00025	6a 00		 push	 0
  00027	6a 00		 push	 0
  00029	6a 62		 push	 98			; 00000062H
  0002b	56		 push	 esi
  0002c	e8 00 00 00 00	 call	 ?gObjAddBuffEffect@@YA_NPAUOBJECTSTRUCT@@HEHEHH@Z ; gObjAddBuffEffect

; 628  : 		gObjViewportListProtocolDestroy(&obj);

  00031	56		 push	 esi
  00032	e8 00 00 00 00	 call	 ?gObjViewportListProtocolDestroy@@YAXPAUOBJECTSTRUCT@@@Z ; gObjViewportListProtocolDestroy
  00037	83 c4 3c	 add	 esp, 60			; 0000003cH
  0003a	5e		 pop	 esi

; 635  : }

  0003b	5d		 pop	 ebp
  0003c	c2 08 00	 ret	 8
$LN1@SetBuff:

; 629  : 		return;
; 630  : 	}
; 631  : 
; 632  : 	gObjRemoveBuffEffect(&obj, 18);

  0003f	6a 12		 push	 18			; 00000012H
  00041	56		 push	 esi
  00042	e8 00 00 00 00	 call	 ?gObjRemoveBuffEffect@@YA_NPAUOBJECTSTRUCT@@H@Z ; gObjRemoveBuffEffect

; 633  : 	gObjRemoveBuffEffect(&obj, 98);

  00047	6a 62		 push	 98			; 00000062H
  00049	56		 push	 esi
  0004a	e8 00 00 00 00	 call	 ?gObjRemoveBuffEffect@@YA_NPAUOBJECTSTRUCT@@H@Z ; gObjRemoveBuffEffect

; 634  : 	gObjViewportListProtocolCreate(&obj);

  0004f	56		 push	 esi
  00050	e8 00 00 00 00	 call	 ?gObjViewportListProtocolCreate@@YAXPAUOBJECTSTRUCT@@@Z ; gObjViewportListProtocolCreate
  00055	83 c4 14	 add	 esp, 20			; 00000014H
  00058	5e		 pop	 esi

; 635  : }

  00059	5d		 pop	 ebp
  0005a	c2 08 00	 ret	 8
?SetBuff@CNewPVP@@QAEXAAUOBJECTSTRUCT@@H@Z ENDP		; CNewPVP::SetBuff
_TEXT	ENDS
PUBLIC	?SendChannelList@CNewPVP@@QAEHAAUOBJECTSTRUCT@@0@Z ; CNewPVP::SendChannelList
; Function compile flags: /Ogtp
;	COMDAT ?SendChannelList@CNewPVP@@QAEHAAUOBJECTSTRUCT@@0@Z
_TEXT	SEGMENT
_npc$ = 8						; size = 4
_obj$ = 12						; size = 4
?SendChannelList@CNewPVP@@QAEHAAUOBJECTSTRUCT@@0@Z PROC	; CNewPVP::SendChannelList, COMDAT
; _this$ = ecx

; 639  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 640  : 	DataSend(obj.m_Index, (LPBYTE)&m_DuelChannelList, m_DuelChannelList.h.size);

  00003	0f b6 41 09	 movzx	 eax, BYTE PTR [ecx+9]
  00007	50		 push	 eax
  00008	83 c1 08	 add	 ecx, 8
  0000b	51		 push	 ecx
  0000c	8b 4d 0c	 mov	 ecx, DWORD PTR _obj$[ebp]
  0000f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00011	52		 push	 edx
  00012	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00017	83 c4 0c	 add	 esp, 12			; 0000000cH

; 641  : 	return FALSE;

  0001a	33 c0		 xor	 eax, eax

; 642  : }

  0001c	5d		 pop	 ebp
  0001d	c2 08 00	 ret	 8
?SendChannelList@CNewPVP@@QAEHAAUOBJECTSTRUCT@@0@Z ENDP	; CNewPVP::SendChannelList
_TEXT	ENDS
PUBLIC	?GetChannelStatus@CNewPVP@@QAEHAAUOBJECTSTRUCT@@@Z ; CNewPVP::GetChannelStatus
; Function compile flags: /Ogtp
;	COMDAT ?GetChannelStatus@CNewPVP@@QAEHAAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_obj$ = 8						; size = 4
?GetChannelStatus@CNewPVP@@QAEHAAUOBJECTSTRUCT@@@Z PROC	; CNewPVP::GetChannelStatus, COMDAT
; _this$ = ecx

; 646  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 647  : 	DUEL_CHANNEL * lpChannel = GetDuelChannel(obj.Name);

  00003	8b 45 08	 mov	 eax, DWORD PTR _obj$[ebp]
  00006	83 c0 5d	 add	 eax, 93			; 0000005dH
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ?GetDuelChannel@CNewPVP@@AAEPAU_tagDUEL_CHANNEL@@PAD@Z ; CNewPVP::GetDuelChannel

; 648  : 	if(lpChannel != NULL)	return lpChannel->nStatus;

  0000f	85 c0		 test	 eax, eax
  00011	74 08		 je	 SHORT $LN1@GetChannel
  00013	0f b6 40 22	 movzx	 eax, BYTE PTR [eax+34]

; 650  : }

  00017	5d		 pop	 ebp
  00018	c2 04 00	 ret	 4
$LN1@GetChannel:

; 649  : 	return 0;

  0001b	33 c0		 xor	 eax, eax

; 650  : }

  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
?GetChannelStatus@CNewPVP@@QAEHAAUOBJECTSTRUCT@@@Z ENDP	; CNewPVP::GetChannelStatus
_TEXT	ENDS
PUBLIC	?IsSafeState@CNewPVP@@QAEHAAUOBJECTSTRUCT@@@Z	; CNewPVP::IsSafeState
; Function compile flags: /Ogtp
;	COMDAT ?IsSafeState@CNewPVP@@QAEHAAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_obj$ = 8						; size = 4
?IsSafeState@CNewPVP@@QAEHAAUOBJECTSTRUCT@@@Z PROC	; CNewPVP::IsSafeState, COMDAT
; _this$ = ecx

; 654  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 655  : 	DUEL_CHANNEL * lpChannel = GetDuelChannel(obj.Name);

  00003	8b 45 08	 mov	 eax, DWORD PTR _obj$[ebp]
  00006	83 c0 5d	 add	 eax, 93			; 0000005dH
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ?GetDuelChannel@CNewPVP@@AAEPAU_tagDUEL_CHANNEL@@PAD@Z ; CNewPVP::GetDuelChannel

; 656  : 	if(lpChannel == NULL)	return TRUE;

  0000f	85 c0		 test	 eax, eax
  00011	74 15		 je	 SHORT $LN1@IsSafeStat

; 657  : 	
; 658  : 	if( lpChannel->nStatus == 2 || 
; 659  : 		lpChannel->nStatus == 4 || 
; 660  : 		lpChannel->nStatus == DC_RESERVEDEND )

  00013	8a 40 22	 mov	 al, BYTE PTR [eax+34]
  00016	3c 02		 cmp	 al, 2
  00018	74 0e		 je	 SHORT $LN1@IsSafeStat
  0001a	3c 04		 cmp	 al, 4
  0001c	74 0a		 je	 SHORT $LN1@IsSafeStat
  0001e	3c 05		 cmp	 al, 5
  00020	74 06		 je	 SHORT $LN1@IsSafeStat

; 663  : 	}
; 664  : 
; 665  : 	return FALSE;

  00022	33 c0		 xor	 eax, eax

; 666  : }

  00024	5d		 pop	 ebp
  00025	c2 04 00	 ret	 4
$LN1@IsSafeStat:

; 661  : 	{
; 662  : 		return TRUE;

  00028	b8 01 00 00 00	 mov	 eax, 1

; 666  : }

  0002d	5d		 pop	 ebp
  0002e	c2 04 00	 ret	 4
?IsSafeState@CNewPVP@@QAEHAAUOBJECTSTRUCT@@@Z ENDP	; CNewPVP::IsSafeState
_TEXT	ENDS
PUBLIC	?IsObserver@CNewPVP@@QAEHAAUOBJECTSTRUCT@@@Z	; CNewPVP::IsObserver
EXTRN	?gObjCheckUsedBuffEffect@@YA_NPAUOBJECTSTRUCT@@H@Z:PROC ; gObjCheckUsedBuffEffect
; Function compile flags: /Ogtp
;	COMDAT ?IsObserver@CNewPVP@@QAEHAAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_obj$ = 8						; size = 4
?IsObserver@CNewPVP@@QAEHAAUOBJECTSTRUCT@@@Z PROC	; CNewPVP::IsObserver, COMDAT
; _this$ = ecx

; 670  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 671  : 	return gObjCheckUsedBuffEffect(&obj, 98);

  00003	8b 45 08	 mov	 eax, DWORD PTR _obj$[ebp]
  00006	6a 62		 push	 98			; 00000062H
  00008	50		 push	 eax
  00009	e8 00 00 00 00	 call	 ?gObjCheckUsedBuffEffect@@YA_NPAUOBJECTSTRUCT@@H@Z ; gObjCheckUsedBuffEffect
  0000e	83 c4 08	 add	 esp, 8
  00011	0f b6 c0	 movzx	 eax, al

; 672  : }

  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
?IsObserver@CNewPVP@@QAEHAAUOBJECTSTRUCT@@@Z ENDP	; CNewPVP::IsObserver
_TEXT	ENDS
PUBLIC	?CheckChannelListInfo@CNewPVP@@AAEXH@Z		; CNewPVP::CheckChannelListInfo
; Function compile flags: /Ogtp
;	COMDAT ?CheckChannelListInfo@CNewPVP@@AAEXH@Z
_TEXT	SEGMENT
_nId$ = 8						; size = 4
?CheckChannelListInfo@CNewPVP@@AAEXH@Z PROC		; CNewPVP::CheckChannelListInfo, COMDAT
; _this$ = ecx

; 893  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 894  : 	if( nId < 0 || nId >= DUEL_CHANNEL_MAX )	return;	

  00003	8b 45 08	 mov	 eax, DWORD PTR _nId$[ebp]
  00006	83 f8 03	 cmp	 eax, 3
  00009	77 08		 ja	 SHORT $LN1@CheckChann

; 895  : 	m_DuelChannelList.channel[nId].bWatch = 1;

  0000b	6b c0 16	 imul	 eax, 22			; 00000016H
  0000e	c6 44 08 21 01	 mov	 BYTE PTR [eax+ecx+33], 1
$LN1@CheckChann:

; 896  : }

  00013	5d		 pop	 ebp
  00014	c2 04 00	 ret	 4
?CheckChannelListInfo@CNewPVP@@AAEXH@Z ENDP		; CNewPVP::CheckChannelListInfo
_TEXT	ENDS
PUBLIC	?CheckPKPenalty@CNewPVP@@QAEHPAUOBJECTSTRUCT@@@Z ; CNewPVP::CheckPKPenalty
EXTRN	?GetPartyPkLevel@PartyClass@@QAEDH@Z:PROC	; PartyClass::GetPartyPkLevel
EXTRN	?gParty@@3VPartyClass@@A:BYTE			; gParty
EXTRN	?gPkLimitFree@@3HA:DWORD			; gPkLimitFree
; Function compile flags: /Ogtp
;	COMDAT ?CheckPKPenalty@CNewPVP@@QAEHPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
?CheckPKPenalty@CNewPVP@@QAEHPAUOBJECTSTRUCT@@@Z PROC	; CNewPVP::CheckPKPenalty, COMDAT
; _this$ = ecx

; 1135 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1136 : 	if( !gPkLimitFree )

  00003	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gPkLimitFree@@3HA, 0 ; gPkLimitFree
  0000a	75 37		 jne	 SHORT $LN1@CheckPKPen

; 1137 : 	{
; 1138 : 		if( lpObj->PartyNumber >= 0 )

  0000c	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  0000f	8b 81 0c 06 00
	00		 mov	 eax, DWORD PTR [ecx+1548]
  00015	85 c0		 test	 eax, eax
  00017	78 18		 js	 SHORT $LN4@CheckPKPen

; 1139 : 		{
; 1140 : 			if( gParty.GetPartyPkLevel( lpObj->PartyNumber) >= 6 )

  00019	50		 push	 eax
  0001a	b9 00 00 00 00	 mov	 ecx, OFFSET ?gParty@@3VPartyClass@@A ; gParty
  0001f	e8 00 00 00 00	 call	 ?GetPartyPkLevel@PartyClass@@QAEDH@Z ; PartyClass::GetPartyPkLevel
  00024	3c 06		 cmp	 al, 6
  00026	7c 1b		 jl	 SHORT $LN1@CheckPKPen

; 1141 : 			{
; 1142 : 				return TRUE;

  00028	b8 01 00 00 00	 mov	 eax, 1

; 1151 : }

  0002d	5d		 pop	 ebp
  0002e	c2 04 00	 ret	 4
$LN4@CheckPKPen:

; 1143 : 			}
; 1144 : 		}
; 1145 : 		else if( lpObj->m_PK_Level >= 6 )

  00031	80 b9 19 01 00
	00 06		 cmp	 BYTE PTR [ecx+281], 6
  00038	7c 09		 jl	 SHORT $LN1@CheckPKPen

; 1146 : 		{
; 1147 : 			 return TRUE;

  0003a	b8 01 00 00 00	 mov	 eax, 1

; 1151 : }

  0003f	5d		 pop	 ebp
  00040	c2 04 00	 ret	 4
$LN1@CheckPKPen:

; 1148 : 		}
; 1149 :     }
; 1150 : 	return FALSE;

  00043	33 c0		 xor	 eax, eax

; 1151 : }

  00045	5d		 pop	 ebp
  00046	c2 04 00	 ret	 4
?CheckPKPenalty@CNewPVP@@QAEHPAUOBJECTSTRUCT@@@Z ENDP	; CNewPVP::CheckPKPenalty
_TEXT	ENDS
PUBLIC	?IsSelfDefense@CNewPVP@@QAEHPAUOBJECTSTRUCT@@@Z	; CNewPVP::IsSelfDefense
; Function compile flags: /Ogtp
;	COMDAT ?IsSelfDefense@CNewPVP@@QAEHPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
?IsSelfDefense@CNewPVP@@QAEHPAUOBJECTSTRUCT@@@Z PROC	; CNewPVP::IsSelfDefense, COMDAT
; _this$ = ecx

; 1155 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1156 : 	BOOL bRetVal = FALSE;

  00003	8b 55 08	 mov	 edx, DWORD PTR _lpObj$[ebp]
  00006	33 c0		 xor	 eax, eax

; 1157 : 	for ( int i = 0; i < 7; i++ )

  00008	33 c9		 xor	 ecx, ecx
  0000a	81 c2 c4 05 00
	00		 add	 edx, 1476		; 000005c4H
$LL4@IsSelfDefe:

; 1158 : 	{
; 1159 : 		if( lpObj->SelfDefense[i] >= 0 )

  00010	39 02		 cmp	 DWORD PTR [edx], eax
  00012	7d 0d		 jge	 SHORT $LN8@IsSelfDefe

; 1157 : 	for ( int i = 0; i < 7; i++ )

  00014	41		 inc	 ecx
  00015	83 c2 04	 add	 edx, 4
  00018	83 f9 07	 cmp	 ecx, 7
  0001b	7c f3		 jl	 SHORT $LL4@IsSelfDefe

; 1162 : 			break;
; 1163 : 		}
; 1164 : 	}
; 1165 : 	return bRetVal;
; 1166 : }

  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
$LN8@IsSelfDefe:

; 1160 : 		{
; 1161 : 			bRetVal = TRUE;

  00021	b8 01 00 00 00	 mov	 eax, 1

; 1162 : 			break;
; 1163 : 		}
; 1164 : 	}
; 1165 : 	return bRetVal;
; 1166 : }

  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
?IsSelfDefense@CNewPVP@@QAEHPAUOBJECTSTRUCT@@@Z ENDP	; CNewPVP::IsSelfDefense
_TEXT	ENDS
PUBLIC	?IsGuildWar@CNewPVP@@QAEHPAUOBJECTSTRUCT@@@Z	; CNewPVP::IsGuildWar
; Function compile flags: /Ogtp
;	COMDAT ?IsGuildWar@CNewPVP@@QAEHPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
?IsGuildWar@CNewPVP@@QAEHPAUOBJECTSTRUCT@@@Z PROC	; CNewPVP::IsGuildWar, COMDAT
; _this$ = ecx

; 1170 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1171 : 	if( lpObj->lpGuild && 
; 1172 : 		lpObj->lpGuild->WarState == 1)

  00003	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00006	8b 80 18 06 00
	00		 mov	 eax, DWORD PTR [eax+1560]
  0000c	85 c0		 test	 eax, eax
  0000e	74 12		 je	 SHORT $LN1@IsGuildWar
  00010	80 b8 91 05 00
	00 01		 cmp	 BYTE PTR [eax+1425], 1
  00017	75 09		 jne	 SHORT $LN1@IsGuildWar

; 1173 : 	{
; 1174 : 		return TRUE;

  00019	b8 01 00 00 00	 mov	 eax, 1

; 1177 : }

  0001e	5d		 pop	 ebp
  0001f	c2 04 00	 ret	 4
$LN1@IsGuildWar:

; 1175 : 	}
; 1176 : 	return FALSE;

  00022	33 c0		 xor	 eax, eax

; 1177 : }

  00024	5d		 pop	 ebp
  00025	c2 04 00	 ret	 4
?IsGuildWar@CNewPVP@@QAEHPAUOBJECTSTRUCT@@@Z ENDP	; CNewPVP::IsGuildWar
_TEXT	ENDS
PUBLIC	??_C@_0BA@GDKKLCIG@m_bNewPVP?$DN?$DNTRUE?$AA@	; `string'
PUBLIC	??_C@_0CA@BKIKBOHB@IsVulcanusMap?$CIlpObj?9?$DOMapNumber?$CJ?$AA@ ; `string'
PUBLIC	??_C@_05MAJJAKPI@FALSE?$AA@			; `string'
PUBLIC	?DropItem@CNewPVP@@QAEHPAUOBJECTSTRUCT@@EEEH@Z	; CNewPVP::DropItem
EXTRN	?OpenSpecial@EventItemBagManager@@QAEEEHHEE@Z:PROC ; EventItemBagManager::OpenSpecial
EXTRN	?g_EventItemBagManager@@3VEventItemBagManager@@A:BYTE ; g_EventItemBagManager
EXTRN	?gObjGetTotalValueOfEffect@@YAHPAUOBJECTSTRUCT@@H@Z:PROC ; gObjGetTotalValueOfEffect
;	COMDAT ??_C@_0BA@GDKKLCIG@m_bNewPVP?$DN?$DNTRUE?$AA@
; File c:\muserver_dev\development\mu-s8ep2-repack\gameserver\source\newpvp.h
CONST	SEGMENT
??_C@_0BA@GDKKLCIG@m_bNewPVP?$DN?$DNTRUE?$AA@ DB 'm_bNewPVP==TRUE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@BKIKBOHB@IsVulcanusMap?$CIlpObj?9?$DOMapNumber?$CJ?$AA@
CONST	SEGMENT
??_C@_0CA@BKIKBOHB@IsVulcanusMap?$CIlpObj?9?$DOMapNumber?$CJ?$AA@ DB 'IsV'
	DB	'ulcanusMap(lpObj->MapNumber)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05MAJJAKPI@FALSE?$AA@
CONST	SEGMENT
??_C@_05MAJJAKPI@FALSE?$AA@ DB 'FALSE', 00H		; `string'
; Function compile flags: /Ogtp
; File c:\muserver_dev\development\mu-s8ep2-repack\gameserver\source\newpvp.cpp
CONST	ENDS
;	COMDAT ?DropItem@CNewPVP@@QAEHPAUOBJECTSTRUCT@@EEEH@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
_btMapNumber$ = 12					; size = 1
_cX$ = 16						; size = 1
_cY$ = 20						; size = 1
_nMaxHitUser$ = 24					; size = 4
?DropItem@CNewPVP@@QAEHPAUOBJECTSTRUCT@@EEEH@Z PROC	; CNewPVP::DropItem, COMDAT
; _this$ = ecx

; 1181 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1182 : 	if( !IsVulcanusMap(lpObj->MapNumber) ){ LogAddTD("%s\t%s\t%s\t%s\t%d","IsVulcanusMap(lpObj->MapNumber)","FALSE","NULL",__FILE__,  __LINE__); return FALSE; }

  00004	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]
  00007	80 be 23 01 00
	00 3f		 cmp	 BYTE PTR [esi+291], 63	; 0000003fH
  0000e	74 2e		 je	 SHORT $LN4@DropItem
  00010	68 9e 04 00 00	 push	 1182			; 0000049eH
  00015	68 00 00 00 00	 push	 OFFSET ??_C@_0L@IGELOCEA@NewPVP?4cpp?$AA@
  0001a	68 00 00 00 00	 push	 OFFSET ??_C@_04HIBGFPH@NULL?$AA@
  0001f	68 00 00 00 00	 push	 OFFSET ??_C@_05MAJJAKPI@FALSE?$AA@
  00024	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@BKIKBOHB@IsVulcanusMap?$CIlpObj?9?$DOMapNumber?$CJ?$AA@
$LN9@DropItem:
  00029	68 00 00 00 00	 push	 OFFSET ??_C@_0P@ENJPCMFP@?$CFs?7?$CFs?7?$CFs?7?$CFs?7?$CFd?$AA@
  0002e	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00034	83 c4 18	 add	 esp, 24			; 00000018H
$LN10@DropItem:
  00037	33 c0		 xor	 eax, eax
  00039	5e		 pop	 esi

; 1189 : }

  0003a	5d		 pop	 ebp
  0003b	c2 14 00	 ret	 20			; 00000014H
$LN4@DropItem:

; 1183 : 	if(m_bNewPVP != TRUE){ LogAddTD("%s\t%s\t%s\t%s\t%d","m_bNewPVP==TRUE","FALSE","NULL", __FILE__,  __LINE__); return FALSE; }

  0003e	83 79 04 01	 cmp	 DWORD PTR [ecx+4], 1
  00042	74 1b		 je	 SHORT $LN3@DropItem
  00044	68 9f 04 00 00	 push	 1183			; 0000049fH
  00049	68 00 00 00 00	 push	 OFFSET ??_C@_0L@IGELOCEA@NewPVP?4cpp?$AA@
  0004e	68 00 00 00 00	 push	 OFFSET ??_C@_04HIBGFPH@NULL?$AA@
  00053	68 00 00 00 00	 push	 OFFSET ??_C@_05MAJJAKPI@FALSE?$AA@
  00058	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@GDKKLCIG@m_bNewPVP?$DN?$DNTRUE?$AA@
  0005d	eb ca		 jmp	 SHORT $LN9@DropItem
$LN3@DropItem:

; 1184 : 	if( !gObjCheckUsedBuffEffect(lpObj, 103) )	return FALSE;

  0005f	6a 67		 push	 103			; 00000067H
  00061	56		 push	 esi
  00062	e8 00 00 00 00	 call	 ?gObjCheckUsedBuffEffect@@YA_NPAUOBJECTSTRUCT@@H@Z ; gObjCheckUsedBuffEffect
  00067	83 c4 08	 add	 esp, 8
  0006a	84 c0		 test	 al, al
  0006c	74 c9		 je	 SHORT $LN10@DropItem

; 1185 : 	if( !gObjGetTotalValueOfEffect(lpObj, 60) )	return FALSE;

  0006e	6a 3c		 push	 60			; 0000003cH
  00070	56		 push	 esi
  00071	e8 00 00 00 00	 call	 ?gObjGetTotalValueOfEffect@@YAHPAUOBJECTSTRUCT@@H@Z ; gObjGetTotalValueOfEffect
  00076	83 c4 08	 add	 esp, 8
  00079	85 c0		 test	 eax, eax
  0007b	74 ba		 je	 SHORT $LN10@DropItem

; 1186 : 
; 1187 : 	g_EventItemBagManager.OpenSpecial(EventBagSpecial::DuelArena, lpObj->m_Index, btMapNumber, cX, cY);

  0007d	8b 45 14	 mov	 eax, DWORD PTR _cY$[ebp]
  00080	8b 4d 10	 mov	 ecx, DWORD PTR _cX$[ebp]
  00083	0f b6 55 0c	 movzx	 edx, BYTE PTR _btMapNumber$[ebp]
  00087	50		 push	 eax
  00088	8b 06		 mov	 eax, DWORD PTR [esi]
  0008a	51		 push	 ecx
  0008b	52		 push	 edx
  0008c	50		 push	 eax
  0008d	6a 1e		 push	 30			; 0000001eH
  0008f	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_EventItemBagManager@@3VEventItemBagManager@@A ; g_EventItemBagManager
  00094	e8 00 00 00 00	 call	 ?OpenSpecial@EventItemBagManager@@QAEEEHHEE@Z ; EventItemBagManager::OpenSpecial

; 1188 : 	return TRUE;

  00099	b8 01 00 00 00	 mov	 eax, 1
  0009e	5e		 pop	 esi

; 1189 : }

  0009f	5d		 pop	 ebp
  000a0	c2 14 00	 ret	 20			; 00000014H
?DropItem@CNewPVP@@QAEHPAUOBJECTSTRUCT@@EEEH@Z ENDP	; CNewPVP::DropItem
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GCServerMsgStringSendEx@@YAXHEPADZZ		; GCServerMsgStringSendEx
EXTRN	?GCServerMsgStringSend@@YAXPADHE@Z:PROC		; GCServerMsgStringSend
; Function compile flags: /Ogtp
;	COMDAT ?GCServerMsgStringSendEx@@YAXHEPADZZ
_TEXT	SEGMENT
_szTmp$ = -516						; size = 512
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_type$ = 12						; size = 1
_szFormat$ = 16						; size = 4
?GCServerMsgStringSendEx@@YAXHEPADZZ PROC		; GCServerMsgStringSendEx, COMDAT

; 1192 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 04 02 00
	00		 sub	 esp, 516		; 00000204H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 1193 : 	char szTmp[512];
; 1194 : 
; 1195 : 	va_list arglist;
; 1196 : 	va_start(arglist, szFormat);
; 1197 : 	vsprintf(szTmp, szFormat, arglist);

  00013	8b 4d 10	 mov	 ecx, DWORD PTR _szFormat$[ebp]
  00016	8d 45 14	 lea	 eax, DWORD PTR _szFormat$[ebp+4]
  00019	50		 push	 eax
  0001a	51		 push	 ecx
  0001b	8d 95 fc fd ff
	ff		 lea	 edx, DWORD PTR _szTmp$[ebp]
  00021	52		 push	 edx
  00022	e8 00 00 00 00	 call	 _vsprintf

; 1198 : 	va_end(arglist);
; 1199 : 
; 1200 : 	GCServerMsgStringSend(szTmp, aIndex, type);

  00027	8b 45 0c	 mov	 eax, DWORD PTR _type$[ebp]
  0002a	8b 4d 08	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  0002d	50		 push	 eax
  0002e	51		 push	 ecx
  0002f	8d 95 fc fd ff
	ff		 lea	 edx, DWORD PTR _szTmp$[ebp]
  00035	52		 push	 edx
  00036	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend

; 1201 : }

  0003b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0003e	33 cd		 xor	 ecx, ebp
  00040	83 c4 18	 add	 esp, 24			; 00000018H
  00043	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c3		 ret	 0
?GCServerMsgStringSendEx@@YAXHEPADZZ ENDP		; GCServerMsgStringSendEx
_TEXT	ENDS
PUBLIC	??8?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> > >::operator==
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??8?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> > >::operator==, COMDAT
; _this$ = ecx

; 316  : 		{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 317  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 318  : 		if (this->_Getcont() == 0
; 319  : 			|| this->_Getcont() != _Right._Getcont())
; 320  : 			{	// report error
; 321  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 322  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 323  : 			}
; 324  : 
; 325  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 326  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 327  : 			&& this->_Getcont() == _Right._Getcont());
; 328  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 329  : 
; 330  : 		return (this->_Ptr == _Right._Ptr);

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00008	33 c9		 xor	 ecx, ecx
  0000a	3b 02		 cmp	 eax, DWORD PTR [edx]
  0000c	0f 94 c0	 sete	 al

; 331  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??8?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> > >::operator==
_TEXT	ENDS
PUBLIC	??9?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> > >::operator!=
; Function compile flags: /Ogtp
;	COMDAT ??9?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> > >::operator!=, COMDAT
; _this$ = ecx

; 334  : 		{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 335  : 		return (!(*this == _Right));

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00008	33 c9		 xor	 ecx, ecx
  0000a	3b 02		 cmp	 eax, DWORD PTR [edx]
  0000c	0f 95 c0	 setne	 al

; 336  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??9?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> > >::operator!=
_TEXT	ENDS
PUBLIC	??R?$less@H@std@@QBE_NABH0@Z			; std::less<int>::operator()
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xfunctional
;	COMDAT ??R?$less@H@std@@QBE_NABH0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??R?$less@H@std@@QBE_NABH0@Z PROC			; std::less<int>::operator(), COMDAT
; _this$ = ecx

; 124  : 		{	// apply operator< to operands

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 125  : 		return (_Left < _Right);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  00006	8b 08		 mov	 ecx, DWORD PTR [eax]
  00008	8b 55 0c	 mov	 edx, DWORD PTR __Right$[ebp]
  0000b	33 c0		 xor	 eax, eax
  0000d	3b 0a		 cmp	 ecx, DWORD PTR [edx]
  0000f	0f 9c c0	 setl	 al

; 126  : 		}

  00012	5d		 pop	 ebp
  00013	c2 08 00	 ret	 8
??R?$less@H@std@@QBE_NABH0@Z ENDP			; std::less<int>::operator()
_TEXT	ENDS
PUBLIC	?_Color@?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::_Color
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ?_Color@?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Color@?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::_Color, COMDAT

; 606  : 		{	// return reference to color in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 607  : 		return ((char&)(*_Pnode)._Color);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 20	 add	 eax, 32			; 00000020H

; 608  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Color@?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::_Color
_TEXT	ENDS
PUBLIC	?_Isnil@?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::_Isnil
; Function compile flags: /Ogtp
;	COMDAT ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Isnil@?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::_Isnil, COMDAT

; 611  : 		{	// return reference to nil flag in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 612  : 		return ((char&)(*_Pnode)._Isnil);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 21	 add	 eax, 33			; 00000021H

; 613  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Isnil@?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::_Isnil
_TEXT	ENDS
PUBLIC	?_Left@?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::_Left
; Function compile flags: /Ogtp
;	COMDAT ?_Left@?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Left@?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::_Left, COMDAT

; 621  : 		{	// return reference to left pointer in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 622  : 		return ((_Nodepref)(*_Pnode)._Left);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]

; 623  : 		}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
?_Left@?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::_Left
_TEXT	ENDS
PUBLIC	?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::_Parent
; Function compile flags: /Ogtp
;	COMDAT ?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::_Parent, COMDAT

; 626  : 		{	// return reference to parent pointer in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 627  : 		return ((_Nodepref)(*_Pnode)._Parent);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 04	 add	 eax, 4

; 628  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::_Parent
_TEXT	ENDS
PUBLIC	?_Right@?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::_Right
; Function compile flags: /Ogtp
;	COMDAT ?_Right@?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Right@?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::_Right, COMDAT

; 631  : 		{	// return reference to right pointer in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 632  : 		return ((_Nodepref)(*_Pnode)._Right);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 08	 add	 eax, 8

; 633  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Right@?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::_Right
_TEXT	ENDS
PUBLIC	?_Myval@?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@SAAAU?$pair@$$CBHU_tagWaiting@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::_Myval
; Function compile flags: /Ogtp
;	COMDAT ?_Myval@?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@SAAAU?$pair@$$CBHU_tagWaiting@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Myval@?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@SAAAU?$pair@$$CBHU_tagWaiting@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::_Myval, COMDAT

; 636  : 		{	// return reference to value in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 637  : 		return ((reference)(*_Pnode)._Myval);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 0c	 add	 eax, 12			; 0000000cH

; 638  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Myval@?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@SAAAU?$pair@$$CBHU_tagWaiting@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::_Myval
_TEXT	ENDS
PUBLIC	?_Max@?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::_Max
; Function compile flags: /Ogtp
;	COMDAT ?_Max@?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Max@?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::_Max, COMDAT

; 641  : 		{	// return rightmost node in subtree at _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 642  : 		while (!_Isnil(_Right(_Pnode)))

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00009	80 79 21 00	 cmp	 BYTE PTR [ecx+33], 0
  0000d	75 0c		 jne	 SHORT $LN1@Max
  0000f	90		 npad	 1
$LL2@Max:

; 643  : 			_Pnode = _Right(_Pnode);

  00010	8b c1		 mov	 eax, ecx
  00012	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00015	80 79 21 00	 cmp	 BYTE PTR [ecx+33], 0
  00019	74 f5		 je	 SHORT $LL2@Max
$LN1@Max:

; 644  : 		return (_Pnode);
; 645  : 		}

  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
?_Max@?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::_Max
_TEXT	ENDS
PUBLIC	?_Min@?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::_Min
; Function compile flags: /Ogtp
;	COMDAT ?_Min@?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Min@?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::_Min, COMDAT

; 648  : 		{	// return leftmost node in subtree at _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 649  : 		while (!_Isnil(_Left(_Pnode)))

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	8b 08		 mov	 ecx, DWORD PTR [eax]
  00008	80 79 21 00	 cmp	 BYTE PTR [ecx+33], 0
  0000c	75 0c		 jne	 SHORT $LN1@Min
  0000e	8b ff		 npad	 2
$LL2@Min:

; 650  : 			_Pnode = _Left(_Pnode);

  00010	8b c1		 mov	 eax, ecx
  00012	8b 08		 mov	 ecx, DWORD PTR [eax]
  00014	80 79 21 00	 cmp	 BYTE PTR [ecx+33], 0
  00018	74 f6		 je	 SHORT $LL2@Min
$LN1@Min:

; 651  : 		return (_Pnode);
; 652  : 		}

  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
?_Min@?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::_Min
_TEXT	ENDS
PUBLIC	??0?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@std@@QAE@XZ ; std::allocator<std::pair<int const ,_tagWaiting> >::allocator<std::pair<int const ,_tagWaiting> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??0?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@std@@QAE@XZ PROC ; std::allocator<std::pair<int const ,_tagWaiting> >::allocator<std::pair<int const ,_tagWaiting> >, COMDAT
; _this$ = ecx

; 161  : 	_ALLOCATOR() _THROW0()

  00000	8b c1		 mov	 eax, ecx

; 162  : 		{	// construct default allocator (do nothing)
; 163  : 		}

  00002	c3		 ret	 0
??0?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@std@@QAE@XZ ENDP ; std::allocator<std::pair<int const ,_tagWaiting> >::allocator<std::pair<int const ,_tagWaiting> >
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::_Node>::deallocate
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Ogtp
;	COMDAT ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@2@I@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::_Node>::deallocate, COMDAT
; _this$ = ecx

; 181  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 182  : 		::operator delete(_Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000c	83 c4 04	 add	 esp, 4

; 183  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 08 00	 ret	 8
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::_Node>::deallocate
_TEXT	ENDS
PUBLIC	?_Color@?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::_Color
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ?_Color@?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Color@?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::_Color, COMDAT

; 606  : 		{	// return reference to color in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 607  : 		return ((char&)(*_Pnode)._Color);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 24	 add	 eax, 36			; 00000024H

; 608  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Color@?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::_Color
_TEXT	ENDS
PUBLIC	?_Isnil@?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::_Isnil
; Function compile flags: /Ogtp
;	COMDAT ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Isnil@?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::_Isnil, COMDAT

; 611  : 		{	// return reference to nil flag in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 612  : 		return ((char&)(*_Pnode)._Isnil);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 25	 add	 eax, 37			; 00000025H

; 613  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Isnil@?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::_Isnil
_TEXT	ENDS
PUBLIC	?_Left@?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::_Left
; Function compile flags: /Ogtp
;	COMDAT ?_Left@?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Left@?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::_Left, COMDAT

; 621  : 		{	// return reference to left pointer in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 622  : 		return ((_Nodepref)(*_Pnode)._Left);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]

; 623  : 		}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
?_Left@?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::_Left
_TEXT	ENDS
PUBLIC	?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::_Parent
; Function compile flags: /Ogtp
;	COMDAT ?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::_Parent, COMDAT

; 626  : 		{	// return reference to parent pointer in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 627  : 		return ((_Nodepref)(*_Pnode)._Parent);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 04	 add	 eax, 4

; 628  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Parent@?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::_Parent
_TEXT	ENDS
PUBLIC	?_Right@?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::_Right
; Function compile flags: /Ogtp
;	COMDAT ?_Right@?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Right@?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::_Right, COMDAT

; 631  : 		{	// return reference to right pointer in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 632  : 		return ((_Nodepref)(*_Pnode)._Right);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 08	 add	 eax, 8

; 633  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Right@?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::_Right
_TEXT	ENDS
PUBLIC	?_Myval@?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@SAAAU?$pair@$$CBHU_tagObserverInfo@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::_Myval
; Function compile flags: /Ogtp
;	COMDAT ?_Myval@?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@SAAAU?$pair@$$CBHU_tagObserverInfo@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Myval@?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@SAAAU?$pair@$$CBHU_tagObserverInfo@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::_Myval, COMDAT

; 636  : 		{	// return reference to value in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 637  : 		return ((reference)(*_Pnode)._Myval);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 0c	 add	 eax, 12			; 0000000cH

; 638  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Myval@?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@SAAAU?$pair@$$CBHU_tagObserverInfo@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::_Myval
_TEXT	ENDS
PUBLIC	?_Max@?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::_Max
; Function compile flags: /Ogtp
;	COMDAT ?_Max@?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Max@?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::_Max, COMDAT

; 641  : 		{	// return rightmost node in subtree at _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 642  : 		while (!_Isnil(_Right(_Pnode)))

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00009	80 79 25 00	 cmp	 BYTE PTR [ecx+37], 0
  0000d	75 0c		 jne	 SHORT $LN1@Max@2
  0000f	90		 npad	 1
$LL2@Max@2:

; 643  : 			_Pnode = _Right(_Pnode);

  00010	8b c1		 mov	 eax, ecx
  00012	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00015	80 79 25 00	 cmp	 BYTE PTR [ecx+37], 0
  00019	74 f5		 je	 SHORT $LL2@Max@2
$LN1@Max@2:

; 644  : 		return (_Pnode);
; 645  : 		}

  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
?_Max@?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::_Max
_TEXT	ENDS
PUBLIC	?_Min@?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::_Min
; Function compile flags: /Ogtp
;	COMDAT ?_Min@?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Min@?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::_Min, COMDAT

; 648  : 		{	// return leftmost node in subtree at _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 649  : 		while (!_Isnil(_Left(_Pnode)))

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	8b 08		 mov	 ecx, DWORD PTR [eax]
  00008	80 79 25 00	 cmp	 BYTE PTR [ecx+37], 0
  0000c	75 0c		 jne	 SHORT $LN1@Min@2
  0000e	8b ff		 npad	 2
$LL2@Min@2:

; 650  : 			_Pnode = _Left(_Pnode);

  00010	8b c1		 mov	 eax, ecx
  00012	8b 08		 mov	 ecx, DWORD PTR [eax]
  00014	80 79 25 00	 cmp	 BYTE PTR [ecx+37], 0
  00018	74 f6		 je	 SHORT $LL2@Min@2
$LN1@Min@2:

; 651  : 		return (_Pnode);
; 652  : 		}

  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
?_Min@?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::_Min
_TEXT	ENDS
PUBLIC	??0?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@std@@QAE@XZ ; std::allocator<std::pair<int const ,_tagObserverInfo> >::allocator<std::pair<int const ,_tagObserverInfo> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??0?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@std@@QAE@XZ PROC ; std::allocator<std::pair<int const ,_tagObserverInfo> >::allocator<std::pair<int const ,_tagObserverInfo> >, COMDAT
; _this$ = ecx

; 161  : 	_ALLOCATOR() _THROW0()

  00000	8b c1		 mov	 eax, ecx

; 162  : 		{	// construct default allocator (do nothing)
; 163  : 		}

  00002	c3		 ret	 0
??0?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@std@@QAE@XZ ENDP ; std::allocator<std::pair<int const ,_tagObserverInfo> >::allocator<std::pair<int const ,_tagObserverInfo> >
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::_Node>::deallocate
; Function compile flags: /Ogtp
;	COMDAT ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@2@I@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::_Node>::deallocate, COMDAT
; _this$ = ecx

; 181  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 182  : 		::operator delete(_Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000c	83 c4 04	 add	 esp, 4

; 183  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 08 00	 ret	 8
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::_Node>::deallocate
_TEXT	ENDS
PUBLIC	??8?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> > >::operator==
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??8?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> > >::operator==, COMDAT
; _this$ = ecx

; 316  : 		{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 317  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 318  : 		if (this->_Getcont() == 0
; 319  : 			|| this->_Getcont() != _Right._Getcont())
; 320  : 			{	// report error
; 321  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 322  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 323  : 			}
; 324  : 
; 325  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 326  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 327  : 			&& this->_Getcont() == _Right._Getcont());
; 328  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 329  : 
; 330  : 		return (this->_Ptr == _Right._Ptr);

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00008	33 c9		 xor	 ecx, ecx
  0000a	3b 02		 cmp	 eax, DWORD PTR [edx]
  0000c	0f 94 c0	 sete	 al

; 331  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??8?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> > >::operator==
_TEXT	ENDS
PUBLIC	?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >,std::_Iterator_base0>::_Mynode
; Function compile flags: /Ogtp
;	COMDAT ?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@2@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >,std::_Iterator_base0>::_Mynode, COMDAT
; _this$ = ecx

; 122  : 		return (_Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 123  : 		}

  00002	c3		 ret	 0
?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >,std::_Iterator_base0>::_Mynode
_TEXT	ENDS
PUBLIC	?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >,std::_Iterator_base0>::_Mynode
; Function compile flags: /Ogtp
;	COMDAT ?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@2@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >,std::_Iterator_base0>::_Mynode, COMDAT
; _this$ = ecx

; 122  : 		return (_Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 123  : 		}

  00002	c3		 ret	 0
?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >,std::_Iterator_base0>::_Mynode
_TEXT	ENDS
PUBLIC	??0?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<int const ,_tagWaiting> >::allocator<std::pair<int const ,_tagWaiting> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??0?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@std@@QAE@ABV01@@Z PROC ; std::allocator<std::pair<int const ,_tagWaiting> >::allocator<std::pair<int const ,_tagWaiting> >, COMDAT
; _this$ = ecx

; 165  : 	_ALLOCATOR(const _ALLOCATOR<_Ty>&) _THROW0()

  00000	8b c1		 mov	 eax, ecx

; 166  : 		{	// construct by copying (do nothing)
; 167  : 		}

  00002	c2 04 00	 ret	 4
??0?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<std::pair<int const ,_tagWaiting> >::allocator<std::pair<int const ,_tagWaiting> >
_TEXT	ENDS
PUBLIC	??0?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<int const ,_tagObserverInfo> >::allocator<std::pair<int const ,_tagObserverInfo> >
; Function compile flags: /Ogtp
;	COMDAT ??0?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@std@@QAE@ABV01@@Z PROC ; std::allocator<std::pair<int const ,_tagObserverInfo> >::allocator<std::pair<int const ,_tagObserverInfo> >, COMDAT
; _this$ = ecx

; 165  : 	_ALLOCATOR(const _ALLOCATOR<_Ty>&) _THROW0()

  00000	8b c1		 mov	 eax, ecx

; 166  : 		{	// construct by copying (do nothing)
; 167  : 		}

  00002	c2 04 00	 ret	 4
??0?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<std::pair<int const ,_tagObserverInfo> >::allocator<std::pair<int const ,_tagObserverInfo> >
_TEXT	ENDS
PUBLIC	??D?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@std@@QBEABU?$pair@$$CBHU_tagWaiting@@@1@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> > >::operator*
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??D?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@std@@QBEABU?$pair@$$CBHU_tagWaiting@@@1@XZ
_TEXT	SEGMENT
??D?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@std@@QBEABU?$pair@$$CBHU_tagWaiting@@@1@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> > >::operator*, COMDAT
; _this$ = ecx

; 231  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 232  : 		if (this->_Getcont() == 0
; 233  : 			|| this->_Ptr == 0
; 234  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 235  : 			{	// report error
; 236  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 237  : 			_SCL_SECURE_OUT_OF_RANGE;
; 238  : 			}
; 239  : 
; 240  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 241  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 242  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 243  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 244  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 245  : 
; 246  : 		return (_Mytree::_Myval(this->_Ptr));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 0c	 add	 eax, 12			; 0000000cH

; 247  : 		}

  00005	c3		 ret	 0
??D?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@std@@QBEABU?$pair@$$CBHU_tagWaiting@@@1@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> > >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >,std::_Iterator_base0>::operator++
; Function compile flags: /Ogtp
;	COMDAT ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >,std::_Iterator_base0>::operator++, COMDAT
; _this$ = ecx

; 58   : 		{	// preincrement

  00000	8b c1		 mov	 eax, ecx

; 59   : 		if (_Mytree::_Isnil(_Ptr))

  00002	8b 10		 mov	 edx, DWORD PTR [eax]
  00004	80 7a 21 00	 cmp	 BYTE PTR [edx+33], 0
  00008	75 40		 jne	 SHORT $LN3@operator

; 60   : 			;	// end() shouldn't be incremented, don't move
; 61   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))

  0000a	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  0000d	80 79 21 00	 cmp	 BYTE PTR [ecx+33], 0
  00011	75 1a		 jne	 SHORT $LN34@operator

; 62   : 			_Ptr = _Mytree::_Min(
; 63   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree

  00013	8b 11		 mov	 edx, DWORD PTR [ecx]
  00015	80 7a 21 00	 cmp	 BYTE PTR [edx+33], 0
  00019	75 0f		 jne	 SHORT $LN17@operator
  0001b	eb 03 8d 49 00	 npad	 5
$LL18@operator:
  00020	8b ca		 mov	 ecx, edx
  00022	8b 11		 mov	 edx, DWORD PTR [ecx]
  00024	80 7a 21 00	 cmp	 BYTE PTR [edx+33], 0
  00028	74 f6		 je	 SHORT $LL18@operator
$LN17@operator:
  0002a	89 08		 mov	 DWORD PTR [eax], ecx

; 71   : 			}
; 72   : 		return (*this);
; 73   : 		}

  0002c	c3		 ret	 0
$LN34@operator:

; 64   : 		else
; 65   : 			{	// climb looking for right subtree
; 66   : 			_Nodeptr _Pnode;
; 67   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 68   : 				&& _Ptr == _Mytree::_Right(_Pnode))

  0002d	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  00030	80 7a 21 00	 cmp	 BYTE PTR [edx+33], 0
  00034	75 12		 jne	 SHORT $LN1@operator
$LL2@operator:
  00036	8b 08		 mov	 ecx, DWORD PTR [eax]
  00038	3b 4a 08	 cmp	 ecx, DWORD PTR [edx+8]
  0003b	75 0b		 jne	 SHORT $LN1@operator

; 69   : 				_Ptr = _Pnode;	// ==> parent while right subtree

  0003d	89 10		 mov	 DWORD PTR [eax], edx
  0003f	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  00042	80 7a 21 00	 cmp	 BYTE PTR [edx+33], 0
  00046	74 ee		 je	 SHORT $LL2@operator
$LN1@operator:

; 70   : 			_Ptr = _Pnode;	// ==> parent (head if end())

  00048	89 10		 mov	 DWORD PTR [eax], edx
$LN3@operator:

; 71   : 			}
; 72   : 		return (*this);
; 73   : 		}

  0004a	c3		 ret	 0
??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >,std::_Iterator_base0>::operator++
_TEXT	ENDS
PUBLIC	??D?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@std@@QBEABU?$pair@$$CBHU_tagObserverInfo@@@1@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> > >::operator*
; Function compile flags: /Ogtp
;	COMDAT ??D?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@std@@QBEABU?$pair@$$CBHU_tagObserverInfo@@@1@XZ
_TEXT	SEGMENT
??D?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@std@@QBEABU?$pair@$$CBHU_tagObserverInfo@@@1@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> > >::operator*, COMDAT
; _this$ = ecx

; 231  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 232  : 		if (this->_Getcont() == 0
; 233  : 			|| this->_Ptr == 0
; 234  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 235  : 			{	// report error
; 236  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 237  : 			_SCL_SECURE_OUT_OF_RANGE;
; 238  : 			}
; 239  : 
; 240  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 241  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 242  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 243  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 244  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 245  : 
; 246  : 		return (_Mytree::_Myval(this->_Ptr));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 0c	 add	 eax, 12			; 0000000cH

; 247  : 		}

  00005	c3		 ret	 0
??D?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@std@@QBEABU?$pair@$$CBHU_tagObserverInfo@@@1@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> > >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >,std::_Iterator_base0>::operator++
; Function compile flags: /Ogtp
;	COMDAT ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >,std::_Iterator_base0>::operator++, COMDAT
; _this$ = ecx

; 58   : 		{	// preincrement

  00000	8b c1		 mov	 eax, ecx

; 59   : 		if (_Mytree::_Isnil(_Ptr))

  00002	8b 10		 mov	 edx, DWORD PTR [eax]
  00004	80 7a 25 00	 cmp	 BYTE PTR [edx+37], 0
  00008	75 40		 jne	 SHORT $LN3@operator@2

; 60   : 			;	// end() shouldn't be incremented, don't move
; 61   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))

  0000a	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  0000d	80 79 25 00	 cmp	 BYTE PTR [ecx+37], 0
  00011	75 1a		 jne	 SHORT $LN34@operator@2

; 62   : 			_Ptr = _Mytree::_Min(
; 63   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree

  00013	8b 11		 mov	 edx, DWORD PTR [ecx]
  00015	80 7a 25 00	 cmp	 BYTE PTR [edx+37], 0
  00019	75 0f		 jne	 SHORT $LN17@operator@2
  0001b	eb 03 8d 49 00	 npad	 5
$LL18@operator@2:
  00020	8b ca		 mov	 ecx, edx
  00022	8b 11		 mov	 edx, DWORD PTR [ecx]
  00024	80 7a 25 00	 cmp	 BYTE PTR [edx+37], 0
  00028	74 f6		 je	 SHORT $LL18@operator@2
$LN17@operator@2:
  0002a	89 08		 mov	 DWORD PTR [eax], ecx

; 71   : 			}
; 72   : 		return (*this);
; 73   : 		}

  0002c	c3		 ret	 0
$LN34@operator@2:

; 64   : 		else
; 65   : 			{	// climb looking for right subtree
; 66   : 			_Nodeptr _Pnode;
; 67   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 68   : 				&& _Ptr == _Mytree::_Right(_Pnode))

  0002d	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  00030	80 7a 25 00	 cmp	 BYTE PTR [edx+37], 0
  00034	75 12		 jne	 SHORT $LN1@operator@2
$LL2@operator@2:
  00036	8b 08		 mov	 ecx, DWORD PTR [eax]
  00038	3b 4a 08	 cmp	 ecx, DWORD PTR [edx+8]
  0003b	75 0b		 jne	 SHORT $LN1@operator@2

; 69   : 				_Ptr = _Pnode;	// ==> parent while right subtree

  0003d	89 10		 mov	 DWORD PTR [eax], edx
  0003f	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  00042	80 7a 25 00	 cmp	 BYTE PTR [edx+37], 0
  00046	74 ee		 je	 SHORT $LL2@operator@2
$LN1@operator@2:

; 70   : 			_Ptr = _Pnode;	// ==> parent (head if end())

  00048	89 10		 mov	 DWORD PTR [eax], edx
$LN3@operator@2:

; 71   : 			}
; 72   : 		return (*this);
; 73   : 		}

  0004a	c3		 ret	 0
??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >,std::_Iterator_base0>::operator++
_TEXT	ENDS
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??0bad_alloc@std@@QAE@PBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
EXTRN	??0exception@std@@QAE@ABQBD@Z:PROC		; std::exception::exception
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R2exception@std@@8
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\exception
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@PBD@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0bad_alloc@std@@QAE@PBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 345  : 		{	// construct from message string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8d 45 08	 lea	 eax, DWORD PTR __Message$[ebp]
  00007	50		 push	 eax
  00008	8b f1		 mov	 esi, ecx
  0000a	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  0000f	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@

; 346  : 		}

  00015	8b c6		 mov	 eax, esi
  00017	5e		 pop	 esi
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@PBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
EXTRN	??1exception@std@@UAE@XZ:PROC			; std::exception::~exception
; Function compile flags: /Ogtp
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 354  : 		{	// destroy the object

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@

; 355  : 		}

  00006	e9 00 00 00 00	 jmp	 ??1exception@std@@UAE@XZ ; std::exception::~exception
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
  0000c	e8 00 00 00 00	 call	 ??1exception@std@@UAE@XZ ; std::exception::~exception
  00011	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00015	74 09		 je	 SHORT $LN6@scalar
  00017	56		 push	 esi
  00018	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0001d	83 c4 04	 add	 esp, 4
$LN6@scalar:
  00020	8b c6		 mov	 eax, esi
  00022	5e		 pop	 esi
  00023	5d		 pop	 ebp
  00024	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??0?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@QAE@U?$less@H@1@@Z ; std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0>::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\map
;	COMDAT ??0?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@QAE@U?$less@H@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 1
??0?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@QAE@U?$less@H@1@@Z PROC ; std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0>::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0>, COMDAT
; _this$ = ecx

; 40   : 		{	// construct with specified comparator

  00000	8b c1		 mov	 eax, ecx

; 41   : 		}

  00002	c2 04 00	 ret	 4
??0?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@QAE@U?$less@H@1@@Z ENDP ; std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0>::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0>
_TEXT	ENDS
PUBLIC	??0?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@QAE@U?$less@H@1@@Z ; std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0>::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0>
; Function compile flags: /Ogtp
;	COMDAT ??0?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@QAE@U?$less@H@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 1
??0?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@QAE@U?$less@H@1@@Z PROC ; std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0>::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0>, COMDAT
; _this$ = ecx

; 40   : 		{	// construct with specified comparator

  00000	8b c1		 mov	 eax, ecx

; 41   : 		}

  00002	c2 04 00	 ret	 4
??0?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@QAE@U?$less@H@1@@Z ENDP ; std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0>::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0>
_TEXT	ENDS
PUBLIC	??$addressof@U?$pair@$$CBHU_tagWaiting@@@std@@@std@@YAPAU?$pair@$$CBHU_tagWaiting@@@0@AAU10@@Z ; std::addressof<std::pair<int const ,_tagWaiting> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$addressof@U?$pair@$$CBHU_tagWaiting@@@std@@@std@@YAPAU?$pair@$$CBHU_tagWaiting@@@0@AAU10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@U?$pair@$$CBHU_tagWaiting@@@std@@@std@@YAPAU?$pair@$$CBHU_tagWaiting@@@0@AAU10@@Z PROC ; std::addressof<std::pair<int const ,_tagWaiting> >, COMDAT

; 110  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 111  : 	return ((_Ty *) &(char&)_Val);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 112  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@U?$pair@$$CBHU_tagWaiting@@@std@@@std@@YAPAU?$pair@$$CBHU_tagWaiting@@@0@AAU10@@Z ENDP ; std::addressof<std::pair<int const ,_tagWaiting> >
_TEXT	ENDS
PUBLIC	??$addressof@U?$pair@$$CBHU_tagObserverInfo@@@std@@@std@@YAPAU?$pair@$$CBHU_tagObserverInfo@@@0@AAU10@@Z ; std::addressof<std::pair<int const ,_tagObserverInfo> >
; Function compile flags: /Ogtp
;	COMDAT ??$addressof@U?$pair@$$CBHU_tagObserverInfo@@@std@@@std@@YAPAU?$pair@$$CBHU_tagObserverInfo@@@0@AAU10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@U?$pair@$$CBHU_tagObserverInfo@@@std@@@std@@YAPAU?$pair@$$CBHU_tagObserverInfo@@@0@AAU10@@Z PROC ; std::addressof<std::pair<int const ,_tagObserverInfo> >, COMDAT

; 110  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 111  : 	return ((_Ty *) &(char&)_Val);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 112  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@U?$pair@$$CBHU_tagObserverInfo@@@std@@@std@@YAPAU?$pair@$$CBHU_tagObserverInfo@@@0@AAU10@@Z ENDP ; std::addressof<std::pair<int const ,_tagObserverInfo> >
_TEXT	ENDS
PUBLIC	??$_Kfn@$$CBHU_tagWaiting@@@?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@SAABHABU?$pair@$$CBHU_tagWaiting@@@1@@Z ; std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0>::_Kfn<int const ,_tagWaiting>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\map
;	COMDAT ??$_Kfn@$$CBHU_tagWaiting@@@?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@SAABHABU?$pair@$$CBHU_tagWaiting@@@1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$_Kfn@$$CBHU_tagWaiting@@@?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@SAABHABU?$pair@$$CBHU_tagWaiting@@@1@@Z PROC ; std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0>::_Kfn<int const ,_tagWaiting>, COMDAT

; 66   : 		static const _Kty& _Kfn(const _STD pair<_Ty1, _Ty2>& _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 67   : 		{	// extract key from element value
; 68   : 		return (_Val.first);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 69   : 		}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Kfn@$$CBHU_tagWaiting@@@?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@SAABHABU?$pair@$$CBHU_tagWaiting@@@1@@Z ENDP ; std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0>::_Kfn<int const ,_tagWaiting>
_TEXT	ENDS
PUBLIC	??$_Kfn@$$CBHU_tagObserverInfo@@@?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@SAABHABU?$pair@$$CBHU_tagObserverInfo@@@1@@Z ; std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0>::_Kfn<int const ,_tagObserverInfo>
; Function compile flags: /Ogtp
;	COMDAT ??$_Kfn@$$CBHU_tagObserverInfo@@@?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@SAABHABU?$pair@$$CBHU_tagObserverInfo@@@1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$_Kfn@$$CBHU_tagObserverInfo@@@?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@SAABHABU?$pair@$$CBHU_tagObserverInfo@@@1@@Z PROC ; std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0>::_Kfn<int const ,_tagObserverInfo>, COMDAT

; 66   : 		static const _Kty& _Kfn(const _STD pair<_Ty1, _Ty2>& _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 67   : 		{	// extract key from element value
; 68   : 		return (_Val.first);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 69   : 		}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Kfn@$$CBHU_tagObserverInfo@@@?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@SAABHABU?$pair@$$CBHU_tagObserverInfo@@@1@@Z ENDP ; std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0>::_Kfn<int const ,_tagObserverInfo>
_TEXT	ENDS
PUBLIC	??$?0U?$pair@$$CBHU_tagWaiting@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::_Node><std::pair<int const ,_tagWaiting> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$?0U?$pair@$$CBHU_tagWaiting@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$?0U?$pair@$$CBHU_tagWaiting@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@1@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::_Node><std::pair<int const ,_tagWaiting> >, COMDAT
; _this$ = ecx

; 170  : 		_ALLOCATOR(const _ALLOCATOR<_Other>&) _THROW0()

  00000	8b c1		 mov	 eax, ecx

; 171  : 		{	// construct from a related allocator (do nothing)
; 172  : 		}

  00002	c2 04 00	 ret	 4
??$?0U?$pair@$$CBHU_tagWaiting@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@1@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::_Node><std::pair<int const ,_tagWaiting> >
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::_Node>
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	__CxxThrowException@8:PROC
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\exception
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@0@IPAU120@@Z
_TEXT	SEGMENT
$T194496 = -12						; size = 12
$T194501 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@0@IPAU120@@Z PROC ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::_Node>, COMDAT

; 30   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 31   : 	void *_Ptr = 0;
; 32   : 
; 33   : 	if (_Count <= 0)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00009	33 c0		 xor	 eax, eax
  0000b	85 c9		 test	 ecx, ecx

; 34   : 		_Count = 0;
; 35   : 	else if (((_SIZT)(-1) / sizeof (_Ty) < _Count)

  0000d	74 44		 je	 SHORT $LN5@Allocate

; 36   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000f	81 f9 c7 71 1c
	07		 cmp	 ecx, 119304647		; 071c71c7H
  00015	77 14		 ja	 SHORT $LN1@Allocate
  00017	8d 04 c9	 lea	 eax, DWORD PTR [ecx+ecx*8]
  0001a	03 c0		 add	 eax, eax
  0001c	03 c0		 add	 eax, eax
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00024	83 c4 04	 add	 esp, 4
  00027	85 c0		 test	 eax, eax

; 38   : 
; 39   : 	return ((_Ty _FARQ *)_Ptr);

  00029	75 28		 jne	 SHORT $LN5@Allocate
$LN1@Allocate:

; 37   : 		_THROW_NCEE(bad_alloc, 0);

  0002b	8d 4d 08	 lea	 ecx, DWORD PTR $T194501[ebp]
  0002e	51		 push	 ecx
  0002f	8d 4d f4	 lea	 ecx, DWORD PTR $T194496[ebp]
  00032	c7 45 08 00 00
	00 00		 mov	 DWORD PTR $T194501[ebp], 0
  00039	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  0003e	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00043	8d 55 f4	 lea	 edx, DWORD PTR $T194496[ebp]
  00046	52		 push	 edx
  00047	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T194496[ebp], OFFSET ??_7bad_alloc@std@@6B@
  0004e	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN10@Allocate:
$LN5@Allocate:

; 40   : 	}

  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c3		 ret	 0
$LN9@Allocate:
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@0@IPAU120@@Z ENDP ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::_Node>
_TEXT	ENDS
PUBLIC	??$?0U?$pair@$$CBHU_tagObserverInfo@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::_Node><std::pair<int const ,_tagObserverInfo> >
; Function compile flags: /Ogtp
;	COMDAT ??$?0U?$pair@$$CBHU_tagObserverInfo@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$?0U?$pair@$$CBHU_tagObserverInfo@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@1@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::_Node><std::pair<int const ,_tagObserverInfo> >, COMDAT
; _this$ = ecx

; 170  : 		_ALLOCATOR(const _ALLOCATOR<_Other>&) _THROW0()

  00000	8b c1		 mov	 eax, ecx

; 171  : 		{	// construct from a related allocator (do nothing)
; 172  : 		}

  00002	c2 04 00	 ret	 4
??$?0U?$pair@$$CBHU_tagObserverInfo@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@1@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::_Node><std::pair<int const ,_tagObserverInfo> >
_TEXT	ENDS
PUBLIC	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::_Node>
; Function compile flags: /Ogtp
;	COMDAT ??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@0@IPAU120@@Z
_TEXT	SEGMENT
$T194509 = -12						; size = 12
$T194513 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@0@IPAU120@@Z PROC ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::_Node>, COMDAT

; 30   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 31   : 	void *_Ptr = 0;
; 32   : 
; 33   : 	if (_Count <= 0)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00009	33 c0		 xor	 eax, eax
  0000b	85 c9		 test	 ecx, ecx

; 34   : 		_Count = 0;
; 35   : 	else if (((_SIZT)(-1) / sizeof (_Ty) < _Count)

  0000d	74 46		 je	 SHORT $LN5@Allocate@2

; 36   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000f	81 f9 66 66 66
	06		 cmp	 ecx, 107374182		; 06666666H
  00015	77 16		 ja	 SHORT $LN1@Allocate@2
  00017	8d 04 89	 lea	 eax, DWORD PTR [ecx+ecx*4]
  0001a	03 c0		 add	 eax, eax
  0001c	03 c0		 add	 eax, eax
  0001e	03 c0		 add	 eax, eax
  00020	50		 push	 eax
  00021	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00026	83 c4 04	 add	 esp, 4
  00029	85 c0		 test	 eax, eax

; 38   : 
; 39   : 	return ((_Ty _FARQ *)_Ptr);

  0002b	75 28		 jne	 SHORT $LN5@Allocate@2
$LN1@Allocate@2:

; 37   : 		_THROW_NCEE(bad_alloc, 0);

  0002d	8d 4d 08	 lea	 ecx, DWORD PTR $T194513[ebp]
  00030	51		 push	 ecx
  00031	8d 4d f4	 lea	 ecx, DWORD PTR $T194509[ebp]
  00034	c7 45 08 00 00
	00 00		 mov	 DWORD PTR $T194513[ebp], 0
  0003b	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00040	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00045	8d 55 f4	 lea	 edx, DWORD PTR $T194509[ebp]
  00048	52		 push	 edx
  00049	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T194509[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00050	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN10@Allocate@2:
$LN5@Allocate@2:

; 40   : 	}

  00055	8b e5		 mov	 esp, ebp
  00057	5d		 pop	 ebp
  00058	c3		 ret	 0
$LN9@Allocate@2:
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@0@IPAU120@@Z ENDP ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::_Node>
_TEXT	ENDS
PUBLIC	?_Adopt@_Iterator_base0@std@@QAEXPBX@Z		; std::_Iterator_base0::_Adopt
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z PROC		; std::_Iterator_base0::_Adopt, COMDAT
; _this$ = ecx

; 49   : 		}

  00000	c2 04 00	 ret	 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ENDP		; std::_Iterator_base0::_Adopt
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@std@@QBEIXZ ; std::allocator<std::pair<int const ,_tagWaiting> >::max_size
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?max_size@?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@std@@QBEIXZ PROC ; std::allocator<std::pair<int const ,_tagWaiting> >::max_size, COMDAT
; _this$ = ecx

; 218  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 219  : 		return (0 < _Count ? _Count : 1);

  00000	b8 cc cc cc 0c	 mov	 eax, 214748364		; 0cccccccH

; 220  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@std@@QBEIXZ ENDP ; std::allocator<std::pair<int const ,_tagWaiting> >::max_size
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@std@@QBEIXZ ; std::allocator<std::pair<int const ,_tagObserverInfo> >::max_size
; Function compile flags: /Ogtp
;	COMDAT ?max_size@?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@std@@QBEIXZ PROC ; std::allocator<std::pair<int const ,_tagObserverInfo> >::max_size, COMDAT
; _this$ = ecx

; 218  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 219  : 		return (0 < _Count ? _Count : 1);

  00000	b8 aa aa aa 0a	 mov	 eax, 178956970		; 0aaaaaaaH

; 220  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@std@@QBEIXZ ENDP ; std::allocator<std::pair<int const ,_tagObserverInfo> >::max_size
_TEXT	ENDS
PUBLIC	??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >,std::_Iterator_base0>::operator--
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >,std::_Iterator_base0>::operator--, COMDAT
; _this$ = ecx

; 83   : 		{	// predecrement

  00000	8b c1		 mov	 eax, ecx

; 84   : 		if (_Mytree::_Isnil(_Ptr))

  00002	8b 08		 mov	 ecx, DWORD PTR [eax]
  00004	80 79 21 00	 cmp	 BYTE PTR [ecx+33], 0
  00008	74 06		 je	 SHORT $LN8@operator@3

; 85   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost

  0000a	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx

; 99   : 			}
; 100  : 		return (*this);
; 101  : 		}

  0000f	c3		 ret	 0
$LN8@operator@3:

; 86   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))

  00010	8b 11		 mov	 edx, DWORD PTR [ecx]
  00012	80 7a 21 00	 cmp	 BYTE PTR [edx+33], 0
  00016	75 17		 jne	 SHORT $LN40@operator@3

; 87   : 			_Ptr = _Mytree::_Max(
; 88   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree

  00018	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  0001b	80 79 21 00	 cmp	 BYTE PTR [ecx+33], 0
  0001f	75 30		 jne	 SHORT $LN21@operator@3
$LL22@operator@3:
  00021	8b d1		 mov	 edx, ecx
  00023	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  00026	80 79 21 00	 cmp	 BYTE PTR [ecx+33], 0
  0002a	74 f5		 je	 SHORT $LL22@operator@3

; 96   : 				;	// begin() shouldn't be decremented, don't move
; 97   : 			else
; 98   : 				_Ptr = _Pnode;	// ==> parent if not head

  0002c	89 10		 mov	 DWORD PTR [eax], edx

; 99   : 			}
; 100  : 		return (*this);
; 101  : 		}

  0002e	c3		 ret	 0
$LN40@operator@3:

; 89   : 		else
; 90   : 			{	// climb looking for left subtree
; 91   : 			_Nodeptr _Pnode;
; 92   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 93   : 				&& _Ptr == _Mytree::_Left(_Pnode))

  0002f	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00032	80 7a 21 00	 cmp	 BYTE PTR [edx+33], 0
  00036	75 11		 jne	 SHORT $LN3@operator@3
$LL4@operator@3:
  00038	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003a	3b 0a		 cmp	 ecx, DWORD PTR [edx]
  0003c	75 0b		 jne	 SHORT $LN3@operator@3

; 94   : 				_Ptr = _Pnode;	// ==> parent while left subtree

  0003e	89 10		 mov	 DWORD PTR [eax], edx
  00040	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  00043	80 7a 21 00	 cmp	 BYTE PTR [edx+33], 0
  00047	74 ef		 je	 SHORT $LL4@operator@3
$LN3@operator@3:

; 95   : 			if (_Mytree::_Isnil(_Ptr))

  00049	8b 08		 mov	 ecx, DWORD PTR [eax]
  0004b	80 79 21 00	 cmp	 BYTE PTR [ecx+33], 0
  0004f	75 02		 jne	 SHORT $LN1@operator@3

; 87   : 			_Ptr = _Mytree::_Max(
; 88   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree

$LN21@operator@3:

; 96   : 				;	// begin() shouldn't be decremented, don't move
; 97   : 			else
; 98   : 				_Ptr = _Pnode;	// ==> parent if not head

  00051	89 10		 mov	 DWORD PTR [eax], edx
$LN1@operator@3:

; 99   : 			}
; 100  : 		return (*this);
; 101  : 		}

  00053	c3		 ret	 0
??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >,std::_Iterator_base0>::operator--
_TEXT	ENDS
PUBLIC	??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >,std::_Iterator_base0>::operator--
; Function compile flags: /Ogtp
;	COMDAT ??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >,std::_Iterator_base0>::operator--, COMDAT
; _this$ = ecx

; 83   : 		{	// predecrement

  00000	8b c1		 mov	 eax, ecx

; 84   : 		if (_Mytree::_Isnil(_Ptr))

  00002	8b 08		 mov	 ecx, DWORD PTR [eax]
  00004	80 79 25 00	 cmp	 BYTE PTR [ecx+37], 0
  00008	74 06		 je	 SHORT $LN8@operator@4

; 85   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost

  0000a	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx

; 99   : 			}
; 100  : 		return (*this);
; 101  : 		}

  0000f	c3		 ret	 0
$LN8@operator@4:

; 86   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))

  00010	8b 11		 mov	 edx, DWORD PTR [ecx]
  00012	80 7a 25 00	 cmp	 BYTE PTR [edx+37], 0
  00016	75 17		 jne	 SHORT $LN40@operator@4

; 87   : 			_Ptr = _Mytree::_Max(
; 88   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree

  00018	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  0001b	80 79 25 00	 cmp	 BYTE PTR [ecx+37], 0
  0001f	75 30		 jne	 SHORT $LN21@operator@4
$LL22@operator@4:
  00021	8b d1		 mov	 edx, ecx
  00023	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  00026	80 79 25 00	 cmp	 BYTE PTR [ecx+37], 0
  0002a	74 f5		 je	 SHORT $LL22@operator@4

; 96   : 				;	// begin() shouldn't be decremented, don't move
; 97   : 			else
; 98   : 				_Ptr = _Pnode;	// ==> parent if not head

  0002c	89 10		 mov	 DWORD PTR [eax], edx

; 99   : 			}
; 100  : 		return (*this);
; 101  : 		}

  0002e	c3		 ret	 0
$LN40@operator@4:

; 89   : 		else
; 90   : 			{	// climb looking for left subtree
; 91   : 			_Nodeptr _Pnode;
; 92   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 93   : 				&& _Ptr == _Mytree::_Left(_Pnode))

  0002f	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00032	80 7a 25 00	 cmp	 BYTE PTR [edx+37], 0
  00036	75 11		 jne	 SHORT $LN3@operator@4
$LL4@operator@4:
  00038	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003a	3b 0a		 cmp	 ecx, DWORD PTR [edx]
  0003c	75 0b		 jne	 SHORT $LN3@operator@4

; 94   : 				_Ptr = _Pnode;	// ==> parent while left subtree

  0003e	89 10		 mov	 DWORD PTR [eax], edx
  00040	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  00043	80 7a 25 00	 cmp	 BYTE PTR [edx+37], 0
  00047	74 ef		 je	 SHORT $LL4@operator@4
$LN3@operator@4:

; 95   : 			if (_Mytree::_Isnil(_Ptr))

  00049	8b 08		 mov	 ecx, DWORD PTR [eax]
  0004b	80 79 25 00	 cmp	 BYTE PTR [ecx+37], 0
  0004f	75 02		 jne	 SHORT $LN1@operator@4

; 87   : 			_Ptr = _Mytree::_Max(
; 88   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree

$LN21@operator@4:

; 96   : 				;	// begin() shouldn't be decremented, don't move
; 97   : 			else
; 98   : 				_Ptr = _Pnode;	// ==> parent if not head

  00051	89 10		 mov	 DWORD PTR [eax], edx
$LN1@operator@4:

; 99   : 			}
; 100  : 		return (*this);
; 101  : 		}

  00053	c3		 ret	 0
??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >,std::_Iterator_base0>::operator--
_TEXT	ENDS
PUBLIC	??$forward@AAH@std@@YAAAHAAH@Z			; std::forward<int &>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$forward@AAH@std@@YAAAHAAH@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAH@std@@YAAAHAAH@Z PROC			; std::forward<int &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAH@std@@YAAAHAAH@Z ENDP			; std::forward<int &>
_TEXT	ENDS
PUBLIC	??$forward@AAU_tagWaiting@@@std@@YAAAU_tagWaiting@@AAU1@@Z ; std::forward<_tagWaiting &>
; Function compile flags: /Ogtp
;	COMDAT ??$forward@AAU_tagWaiting@@@std@@YAAAU_tagWaiting@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAU_tagWaiting@@@std@@YAAAU_tagWaiting@@AAU1@@Z PROC ; std::forward<_tagWaiting &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAU_tagWaiting@@@std@@YAAAU_tagWaiting@@AAU1@@Z ENDP ; std::forward<_tagWaiting &>
_TEXT	ENDS
PUBLIC	??$forward@U?$pair@HU_tagWaiting@@@std@@@std@@YA$$QAU?$pair@HU_tagWaiting@@@0@AAU10@@Z ; std::forward<std::pair<int,_tagWaiting> >
; Function compile flags: /Ogtp
;	COMDAT ??$forward@U?$pair@HU_tagWaiting@@@std@@@std@@YA$$QAU?$pair@HU_tagWaiting@@@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@U?$pair@HU_tagWaiting@@@std@@@std@@YA$$QAU?$pair@HU_tagWaiting@@@0@AAU10@@Z PROC ; std::forward<std::pair<int,_tagWaiting> >, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@U?$pair@HU_tagWaiting@@@std@@@std@@YA$$QAU?$pair@HU_tagWaiting@@@0@AAU10@@Z ENDP ; std::forward<std::pair<int,_tagWaiting> >
_TEXT	ENDS
PUBLIC	??$forward@AAU_tagObserverInfo@@@std@@YAAAU_tagObserverInfo@@AAU1@@Z ; std::forward<_tagObserverInfo &>
; Function compile flags: /Ogtp
;	COMDAT ??$forward@AAU_tagObserverInfo@@@std@@YAAAU_tagObserverInfo@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAU_tagObserverInfo@@@std@@YAAAU_tagObserverInfo@@AAU1@@Z PROC ; std::forward<_tagObserverInfo &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAU_tagObserverInfo@@@std@@YAAAU_tagObserverInfo@@AAU1@@Z ENDP ; std::forward<_tagObserverInfo &>
_TEXT	ENDS
PUBLIC	??$forward@U?$pair@HU_tagObserverInfo@@@std@@@std@@YA$$QAU?$pair@HU_tagObserverInfo@@@0@AAU10@@Z ; std::forward<std::pair<int,_tagObserverInfo> >
; Function compile flags: /Ogtp
;	COMDAT ??$forward@U?$pair@HU_tagObserverInfo@@@std@@@std@@YA$$QAU?$pair@HU_tagObserverInfo@@@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@U?$pair@HU_tagObserverInfo@@@std@@@std@@YA$$QAU?$pair@HU_tagObserverInfo@@@0@AAU10@@Z PROC ; std::forward<std::pair<int,_tagObserverInfo> >, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@U?$pair@HU_tagObserverInfo@@@std@@@std@@YA$$QAU?$pair@HU_tagObserverInfo@@@0@AAU10@@Z ENDP ; std::forward<std::pair<int,_tagObserverInfo> >
_TEXT	ENDS
PUBLIC	??$_Move@AAD@std@@YA$$QADAAD@Z			; std::_Move<char &>
; Function compile flags: /Ogtp
;	COMDAT ??$_Move@AAD@std@@YA$$QADAAD@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$_Move@AAD@std@@YA$$QADAAD@Z PROC			; std::_Move<char &>, COMDAT

; 94   : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 95   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 96   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Move@AAD@std@@YA$$QADAAD@Z ENDP			; std::_Move<char &>
_TEXT	ENDS
PUBLIC	??$_Destroy@U?$pair@$$CBHU_tagWaiting@@@std@@@std@@YAXPAU?$pair@$$CBHU_tagWaiting@@@0@@Z ; std::_Destroy<std::pair<int const ,_tagWaiting> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Destroy@U?$pair@$$CBHU_tagWaiting@@@std@@@std@@YAXPAU?$pair@$$CBHU_tagWaiting@@@0@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@U?$pair@$$CBHU_tagWaiting@@@std@@@std@@YAXPAU?$pair@$$CBHU_tagWaiting@@@0@@Z PROC ; std::_Destroy<std::pair<int const ,_tagWaiting> >, COMDAT

; 63   : 	_Ptr->~_Ty();
; 64   : 	}

  00000	c3		 ret	 0
??$_Destroy@U?$pair@$$CBHU_tagWaiting@@@std@@@std@@YAXPAU?$pair@$$CBHU_tagWaiting@@@0@@Z ENDP ; std::_Destroy<std::pair<int const ,_tagWaiting> >
_TEXT	ENDS
PUBLIC	??$_Destroy@U?$pair@$$CBHU_tagObserverInfo@@@std@@@std@@YAXPAU?$pair@$$CBHU_tagObserverInfo@@@0@@Z ; std::_Destroy<std::pair<int const ,_tagObserverInfo> >
; Function compile flags: /Ogtp
;	COMDAT ??$_Destroy@U?$pair@$$CBHU_tagObserverInfo@@@std@@@std@@YAXPAU?$pair@$$CBHU_tagObserverInfo@@@0@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@U?$pair@$$CBHU_tagObserverInfo@@@std@@@std@@YAXPAU?$pair@$$CBHU_tagObserverInfo@@@0@@Z PROC ; std::_Destroy<std::pair<int const ,_tagObserverInfo> >, COMDAT

; 63   : 	_Ptr->~_Ty();
; 64   : 	}

  00000	c3		 ret	 0
??$_Destroy@U?$pair@$$CBHU_tagObserverInfo@@@std@@@std@@YAXPAU?$pair@$$CBHU_tagObserverInfo@@@0@@Z ENDP ; std::_Destroy<std::pair<int const ,_tagObserverInfo> >
_TEXT	ENDS
PUBLIC	??$move@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@0@AAV10@@Z ; std::move<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> > > &>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$move@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@0@AAV10@@Z PROC ; std::move<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> > > &>, COMDAT

; 86   : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 87   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 88   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@0@AAV10@@Z ENDP ; std::move<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> > > &>
_TEXT	ENDS
PUBLIC	??$move@AA_N@std@@YA$$QA_NAA_N@Z		; std::move<bool &>
; Function compile flags: /Ogtp
;	COMDAT ??$move@AA_N@std@@YA$$QA_NAA_N@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AA_N@std@@YA$$QA_NAA_N@Z PROC			; std::move<bool &>, COMDAT

; 86   : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 87   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 88   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AA_N@std@@YA$$QA_NAA_N@Z ENDP			; std::move<bool &>
_TEXT	ENDS
PUBLIC	??$move@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@0@AAV10@@Z ; std::move<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> > > &>
; Function compile flags: /Ogtp
;	COMDAT ??$move@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@0@AAV10@@Z PROC ; std::move<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> > > &>, COMDAT

; 86   : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 87   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 88   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@0@AAV10@@Z ENDP ; std::move<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> > > &>
_TEXT	ENDS
PUBLIC	??$?0AAHAAU_tagWaiting@@@?$_Pair_base@HU_tagWaiting@@@std@@QAE@AAHAAU_tagWaiting@@@Z ; std::_Pair_base<int,_tagWaiting>::_Pair_base<int,_tagWaiting><int &,_tagWaiting &>
; Function compile flags: /Ogtp
;	COMDAT ??$?0AAHAAU_tagWaiting@@@?$_Pair_base@HU_tagWaiting@@@std@@QAE@AAHAAU_tagWaiting@@@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAHAAU_tagWaiting@@@?$_Pair_base@HU_tagWaiting@@@std@@QAE@AAHAAU_tagWaiting@@@Z PROC ; std::_Pair_base<int,_tagWaiting>::_Pair_base<int,_tagWaiting><int &,_tagWaiting &>, COMDAT
; _this$ = ecx

; 163  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Val1$[ebp]
  00008	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Val2$[ebp]
  0000d	89 10		 mov	 DWORD PTR [eax], edx
  0000f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00011	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00014	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00017	89 50 08	 mov	 DWORD PTR [eax+8], edx
  0001a	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0001d	89 50 0c	 mov	 DWORD PTR [eax+12], edx
  00020	8b 49 0c	 mov	 ecx, DWORD PTR [ecx+12]
  00023	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 164  : 		}

  00026	5d		 pop	 ebp
  00027	c2 08 00	 ret	 8
??$?0AAHAAU_tagWaiting@@@?$_Pair_base@HU_tagWaiting@@@std@@QAE@AAHAAU_tagWaiting@@@Z ENDP ; std::_Pair_base<int,_tagWaiting>::_Pair_base<int,_tagWaiting><int &,_tagWaiting &>
_TEXT	ENDS
PUBLIC	??$?0AAHAAU_tagObserverInfo@@@?$_Pair_base@HU_tagObserverInfo@@@std@@QAE@AAHAAU_tagObserverInfo@@@Z ; std::_Pair_base<int,_tagObserverInfo>::_Pair_base<int,_tagObserverInfo><int &,_tagObserverInfo &>
; Function compile flags: /Ogtp
;	COMDAT ??$?0AAHAAU_tagObserverInfo@@@?$_Pair_base@HU_tagObserverInfo@@@std@@QAE@AAHAAU_tagObserverInfo@@@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAHAAU_tagObserverInfo@@@?$_Pair_base@HU_tagObserverInfo@@@std@@QAE@AAHAAU_tagObserverInfo@@@Z PROC ; std::_Pair_base<int,_tagObserverInfo>::_Pair_base<int,_tagObserverInfo><int &,_tagObserverInfo &>, COMDAT
; _this$ = ecx

; 163  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Val1$[ebp]
  00008	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Val2$[ebp]
  0000d	89 10		 mov	 DWORD PTR [eax], edx
  0000f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00011	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00014	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00017	89 50 08	 mov	 DWORD PTR [eax+8], edx
  0001a	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0001d	89 50 0c	 mov	 DWORD PTR [eax+12], edx
  00020	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00023	89 50 10	 mov	 DWORD PTR [eax+16], edx
  00026	8b 49 10	 mov	 ecx, DWORD PTR [ecx+16]
  00029	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 164  : 		}

  0002c	5d		 pop	 ebp
  0002d	c2 08 00	 ret	 8
??$?0AAHAAU_tagObserverInfo@@@?$_Pair_base@HU_tagObserverInfo@@@std@@QAE@AAHAAU_tagObserverInfo@@@Z ENDP ; std::_Pair_base<int,_tagObserverInfo>::_Pair_base<int,_tagObserverInfo><int &,_tagObserverInfo &>
_TEXT	ENDS
PUBLIC	??$forward@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@0@AAV10@@Z ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> > > &>
; Function compile flags: /Ogtp
;	COMDAT ??$forward@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@0@AAV10@@Z PROC ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> > > &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@0@AAV10@@Z ENDP ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> > > &>
_TEXT	ENDS
PUBLIC	??$forward@_N@std@@YA$$QA_NAA_N@Z		; std::forward<bool>
; Function compile flags: /Ogtp
;	COMDAT ??$forward@_N@std@@YA$$QA_NAA_N@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@_N@std@@YA$$QA_NAA_N@Z PROC			; std::forward<bool>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@_N@std@@YA$$QA_NAA_N@Z ENDP			; std::forward<bool>
_TEXT	ENDS
PUBLIC	??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@std@@_N@?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> > > &,bool>
; Function compile flags: /Ogtp
;	COMDAT ??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@std@@_N@?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@std@@_N@?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z PROC ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> > > &,bool>, COMDAT
; _this$ = ecx

; 163  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Val1$[ebp]
  00008	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Val2$[ebp]
  0000d	89 10		 mov	 DWORD PTR [eax], edx
  0000f	8a 11		 mov	 dl, BYTE PTR [ecx]
  00011	88 50 04	 mov	 BYTE PTR [eax+4], dl

; 164  : 		}

  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@std@@_N@?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z ENDP ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> > > &,bool>
_TEXT	ENDS
PUBLIC	??$forward@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@0@AAV10@@Z ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> > > &>
; Function compile flags: /Ogtp
;	COMDAT ??$forward@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@0@AAV10@@Z PROC ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> > > &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@0@AAV10@@Z ENDP ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> > > &>
_TEXT	ENDS
PUBLIC	??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@std@@_N@?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> > > &,bool>
; Function compile flags: /Ogtp
;	COMDAT ??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@std@@_N@?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@std@@_N@?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z PROC ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> > > &,bool>, COMDAT
; _this$ = ecx

; 163  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Val1$[ebp]
  00008	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Val2$[ebp]
  0000d	89 10		 mov	 DWORD PTR [eax], edx
  0000f	8a 11		 mov	 dl, BYTE PTR [ecx]
  00011	88 50 04	 mov	 BYTE PTR [eax+4], dl

; 164  : 		}

  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@std@@_N@?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z ENDP ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> > > &,bool>
_TEXT	ENDS
PUBLIC	??$forward@H@std@@YA$$QAHAAH@Z			; std::forward<int>
; Function compile flags: /Ogtp
;	COMDAT ??$forward@H@std@@YA$$QAHAAH@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@H@std@@YA$$QAHAAH@Z PROC			; std::forward<int>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@H@std@@YA$$QAHAAH@Z ENDP			; std::forward<int>
_TEXT	ENDS
PUBLIC	??$forward@U_tagWaiting@@@std@@YA$$QAU_tagWaiting@@AAU1@@Z ; std::forward<_tagWaiting>
; Function compile flags: /Ogtp
;	COMDAT ??$forward@U_tagWaiting@@@std@@YA$$QAU_tagWaiting@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@U_tagWaiting@@@std@@YA$$QAU_tagWaiting@@AAU1@@Z PROC ; std::forward<_tagWaiting>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@U_tagWaiting@@@std@@YA$$QAU_tagWaiting@@AAU1@@Z ENDP ; std::forward<_tagWaiting>
_TEXT	ENDS
PUBLIC	??$?0HU_tagWaiting@@@?$_Pair_base@$$CBHU_tagWaiting@@@std@@QAE@$$QAH$$QAU_tagWaiting@@@Z ; std::_Pair_base<int const ,_tagWaiting>::_Pair_base<int const ,_tagWaiting><int,_tagWaiting>
; Function compile flags: /Ogtp
;	COMDAT ??$?0HU_tagWaiting@@@?$_Pair_base@$$CBHU_tagWaiting@@@std@@QAE@$$QAH$$QAU_tagWaiting@@@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0HU_tagWaiting@@@?$_Pair_base@$$CBHU_tagWaiting@@@std@@QAE@$$QAH$$QAU_tagWaiting@@@Z PROC ; std::_Pair_base<int const ,_tagWaiting>::_Pair_base<int const ,_tagWaiting><int,_tagWaiting>, COMDAT
; _this$ = ecx

; 163  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Val1$[ebp]
  00008	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Val2$[ebp]
  0000d	89 10		 mov	 DWORD PTR [eax], edx
  0000f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00011	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00014	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00017	89 50 08	 mov	 DWORD PTR [eax+8], edx
  0001a	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0001d	89 50 0c	 mov	 DWORD PTR [eax+12], edx
  00020	8b 49 0c	 mov	 ecx, DWORD PTR [ecx+12]
  00023	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 164  : 		}

  00026	5d		 pop	 ebp
  00027	c2 08 00	 ret	 8
??$?0HU_tagWaiting@@@?$_Pair_base@$$CBHU_tagWaiting@@@std@@QAE@$$QAH$$QAU_tagWaiting@@@Z ENDP ; std::_Pair_base<int const ,_tagWaiting>::_Pair_base<int const ,_tagWaiting><int,_tagWaiting>
_TEXT	ENDS
PUBLIC	??$forward@U_tagObserverInfo@@@std@@YA$$QAU_tagObserverInfo@@AAU1@@Z ; std::forward<_tagObserverInfo>
; Function compile flags: /Ogtp
;	COMDAT ??$forward@U_tagObserverInfo@@@std@@YA$$QAU_tagObserverInfo@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@U_tagObserverInfo@@@std@@YA$$QAU_tagObserverInfo@@AAU1@@Z PROC ; std::forward<_tagObserverInfo>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@U_tagObserverInfo@@@std@@YA$$QAU_tagObserverInfo@@AAU1@@Z ENDP ; std::forward<_tagObserverInfo>
_TEXT	ENDS
PUBLIC	??$?0HU_tagObserverInfo@@@?$_Pair_base@$$CBHU_tagObserverInfo@@@std@@QAE@$$QAH$$QAU_tagObserverInfo@@@Z ; std::_Pair_base<int const ,_tagObserverInfo>::_Pair_base<int const ,_tagObserverInfo><int,_tagObserverInfo>
; Function compile flags: /Ogtp
;	COMDAT ??$?0HU_tagObserverInfo@@@?$_Pair_base@$$CBHU_tagObserverInfo@@@std@@QAE@$$QAH$$QAU_tagObserverInfo@@@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0HU_tagObserverInfo@@@?$_Pair_base@$$CBHU_tagObserverInfo@@@std@@QAE@$$QAH$$QAU_tagObserverInfo@@@Z PROC ; std::_Pair_base<int const ,_tagObserverInfo>::_Pair_base<int const ,_tagObserverInfo><int,_tagObserverInfo>, COMDAT
; _this$ = ecx

; 163  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Val1$[ebp]
  00008	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Val2$[ebp]
  0000d	89 10		 mov	 DWORD PTR [eax], edx
  0000f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00011	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00014	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00017	89 50 08	 mov	 DWORD PTR [eax+8], edx
  0001a	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0001d	89 50 0c	 mov	 DWORD PTR [eax+12], edx
  00020	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00023	89 50 10	 mov	 DWORD PTR [eax+16], edx
  00026	8b 49 10	 mov	 ecx, DWORD PTR [ecx+16]
  00029	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 164  : 		}

  0002c	5d		 pop	 ebp
  0002d	c2 08 00	 ret	 8
??$?0HU_tagObserverInfo@@@?$_Pair_base@$$CBHU_tagObserverInfo@@@std@@QAE@$$QAH$$QAU_tagObserverInfo@@@Z ENDP ; std::_Pair_base<int const ,_tagObserverInfo>::_Pair_base<int const ,_tagObserverInfo><int,_tagObserverInfo>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  00006	56		 push	 esi
  00007	50		 push	 eax
  00008	8b f1		 mov	 esi, ecx
  0000a	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  0000f	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
  00015	8b c6		 mov	 eax, esi
  00017	5e		 pop	 esi
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	??_EOBJECTSTRUCT@@QAEPAXI@Z			; OBJECTSTRUCT::`vector deleting destructor'
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	??_M@YGXPAXIHP6EX0@Z@Z:PROC			; `eh vector destructor iterator'
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??_EOBJECTSTRUCT@@QAEPAXI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??_EOBJECTSTRUCT@@QAEPAXI@Z$0
__ehfuncinfo$??_EOBJECTSTRUCT@@QAEPAXI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??_EOBJECTSTRUCT@@QAEPAXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
xdata$x	ENDS
;	COMDAT ??_EOBJECTSTRUCT@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_EOBJECTSTRUCT@@QAEPAXI@Z PROC			; OBJECTSTRUCT::`vector deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??_EOBJECTSTRUCT@@QAEPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	53		 push	 ebx
  00013	56		 push	 esi
  00014	57		 push	 edi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00026	8b f1		 mov	 esi, ecx
  00028	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  0002b	8a 5d 08	 mov	 bl, BYTE PTR ___flags$[ebp]
  0002e	f6 c3 02	 test	 bl, 2
  00031	74 3b		 je	 SHORT $LN3@vector
  00033	8b 46 fc	 mov	 eax, DWORD PTR [esi-4]
  00036	68 00 00 00 00	 push	 OFFSET ??1OBJECTSTRUCT@@QAE@XZ
  0003b	8d 7e fc	 lea	 edi, DWORD PTR [esi-4]
  0003e	50		 push	 eax
  0003f	68 40 27 00 00	 push	 10048			; 00002740H
  00044	56		 push	 esi
  00045	e8 00 00 00 00	 call	 ??_M@YGXPAXIHP6EX0@Z@Z
  0004a	f6 c3 01	 test	 bl, 1
  0004d	74 09		 je	 SHORT $LN2@vector
  0004f	57		 push	 edi
  00050	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00055	83 c4 04	 add	 esp, 4
$LN2@vector:
  00058	8b c7		 mov	 eax, edi
  0005a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0005d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00064	59		 pop	 ecx
  00065	5f		 pop	 edi
  00066	5e		 pop	 esi
  00067	5b		 pop	 ebx
  00068	8b e5		 mov	 esp, ebp
  0006a	5d		 pop	 ebp
  0006b	c2 04 00	 ret	 4
$LN3@vector:
  0006e	8d 8e ec 20 00
	00		 lea	 ecx, DWORD PTR [esi+8428]
  00074	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0007b	e8 00 00 00 00	 call	 ??1TMonsterAIAgro@@UAE@XZ ; TMonsterAIAgro::~TMonsterAIAgro
  00080	8d 8e 0c 16 00
	00		 lea	 ecx, DWORD PTR [esi+5644]
  00086	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0008d	e8 00 00 00 00	 call	 ??1CSkillDelay@@UAE@XZ	; CSkillDelay::~CSkillDelay
  00092	f6 c3 01	 test	 bl, 1
  00095	74 09		 je	 SHORT $LN1@vector
  00097	56		 push	 esi
  00098	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0009d	83 c4 04	 add	 esp, 4
$LN1@vector:
  000a0	8b c6		 mov	 eax, esi
  000a2	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000a5	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000ac	59		 pop	 ecx
  000ad	5f		 pop	 edi
  000ae	5e		 pop	 esi
  000af	5b		 pop	 ebx
  000b0	8b e5		 mov	 esp, ebp
  000b2	5d		 pop	 ebp
  000b3	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??_EOBJECTSTRUCT@@QAEPAXI@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	81 c1 0c 16 00
	00		 add	 ecx, 5644		; 0000160cH
  00009	e9 00 00 00 00	 jmp	 ??1CSkillDelay@@UAE@XZ	; CSkillDelay::~CSkillDelay
__ehhandler$??_EOBJECTSTRUCT@@QAEPAXI@Z:
  0000e	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00012	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00015	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00018	33 c8		 xor	 ecx, eax
  0001a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001f	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??_EOBJECTSTRUCT@@QAEPAXI@Z
  00024	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??_EOBJECTSTRUCT@@QAEPAXI@Z ENDP			; OBJECTSTRUCT::`vector deleting destructor'
PUBLIC	?SetStatus@CNewPVP@@AAEXHHAAUOBJECTSTRUCT@@0@Z	; CNewPVP::SetStatus
; Function compile flags: /Ogtp
; File c:\muserver_dev\development\mu-s8ep2-repack\gameserver\source\newpvp.cpp
;	COMDAT ?SetStatus@CNewPVP@@AAEXHHAAUOBJECTSTRUCT@@0@Z
_TEXT	SEGMENT
_nStatus$ = 8						; size = 4
_nId$ = 12						; size = 4
_requester$ = 16					; size = 4
_responsor$ = 20					; size = 4
?SetStatus@CNewPVP@@AAEXHHAAUOBJECTSTRUCT@@0@Z PROC	; CNewPVP::SetStatus, COMDAT
; _this$ = ecx

; 228  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	57		 push	 edi

; 229  : 	LPDUEL_CHANNEL lpDuelChannel = &m_DuelChannel[nId];

  00006	8b 7d 0c	 mov	 edi, DWORD PTR _nId$[ebp]
  00009	8b c7		 mov	 eax, edi
  0000b	6b c0 2c	 imul	 eax, 44			; 0000002cH
  0000e	8b d9		 mov	 ebx, ecx
  00010	8d 74 18 64	 lea	 esi, DWORD PTR [eax+ebx+100]

; 230  : 
; 231  : 	switch ( nStatus )

  00014	8b 45 08	 mov	 eax, DWORD PTR _nStatus$[ebp]
  00017	83 f8 05	 cmp	 eax, 5
  0001a	0f 87 20 01 00
	00		 ja	 $LN6@SetStatus
  00020	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN11@SetStatus[eax*4]
$LN5@SetStatus:

; 232  : 	{		
; 233  : 	case DC_IDLE:
; 234  : 		lpDuelChannel->nStatus = nStatus;

  00027	33 c9		 xor	 ecx, ecx

; 235  : 		lpDuelChannel->dwTime = 0;
; 236  : 
; 237  : 		lpDuelChannel->nIndex1 = 0;
; 238  : 		lpDuelChannel->nIndex2 = 0;
; 239  : 
; 240  : 		memset(lpDuelChannel->szName1, 0, MAX_IDSTRING);
; 241  : 		memset(lpDuelChannel->szName2, 0, MAX_IDSTRING);
; 242  : 
; 243  : 		m_DuelChannelList.channel[nId].bStart = 0;

  00029	6b ff 16	 imul	 edi, 22			; 00000016H
  0002c	88 4e 22	 mov	 BYTE PTR [esi+34], cl
  0002f	89 4e 24	 mov	 DWORD PTR [esi+36], ecx
  00032	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  00035	89 4e 08	 mov	 DWORD PTR [esi+8], ecx

; 244  : 		m_DuelChannelList.channel[nId].bWatch = 0;
; 245  : 
; 246  : 		memset(m_DuelChannelList.channel[nId].szName1, 0, MAX_IDSTRING);
; 247  : 		memset(m_DuelChannelList.channel[nId].szName2, 0, MAX_IDSTRING);
; 248  : 
; 249  : 		SetDuelStatus(requester, responsor, nStatus);

  00038	8b 55 10	 mov	 edx, DWORD PTR _requester$[ebp]
  0003b	33 c0		 xor	 eax, eax
  0003d	89 46 0c	 mov	 DWORD PTR [esi+12], eax
  00040	89 46 10	 mov	 DWORD PTR [esi+16], eax
  00043	66 89 46 14	 mov	 WORD PTR [esi+20], ax
  00047	89 46 17	 mov	 DWORD PTR [esi+23], eax
  0004a	89 46 1b	 mov	 DWORD PTR [esi+27], eax
  0004d	66 89 46 1f	 mov	 WORD PTR [esi+31], ax
  00051	8d 04 1f	 lea	 eax, DWORD PTR [edi+ebx]
  00054	66 89 48 20	 mov	 WORD PTR [eax+32], cx
  00058	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  0005b	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  0005e	66 89 48 14	 mov	 WORD PTR [eax+20], cx
  00062	89 48 16	 mov	 DWORD PTR [eax+22], ecx
  00065	89 48 1a	 mov	 DWORD PTR [eax+26], ecx
  00068	51		 push	 ecx
  00069	66 89 48 1e	 mov	 WORD PTR [eax+30], cx
  0006d	8b 4d 14	 mov	 ecx, DWORD PTR _responsor$[ebp]
  00070	51		 push	 ecx
  00071	52		 push	 edx
  00072	8b cb		 mov	 ecx, ebx
  00074	e8 00 00 00 00	 call	 ?SetDuelStatus@CNewPVP@@AAEXAAUOBJECTSTRUCT@@0H@Z ; CNewPVP::SetDuelStatus
  00079	5f		 pop	 edi
  0007a	5e		 pop	 esi
  0007b	5b		 pop	 ebx

; 280  : 	  break;
; 281  : 	}
; 282  : }

  0007c	5d		 pop	 ebp
  0007d	c2 10 00	 ret	 16			; 00000010H
$LN4@SetStatus:

; 250  : 		break;
; 251  : 	case 2:
; 252  : 		lpDuelChannel->nStatus = nStatus;

  00080	c6 46 22 02	 mov	 BYTE PTR [esi+34], 2

; 253  : 		lpDuelChannel->dwTime = GetTickCount();

  00084	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0

; 254  : 
; 255  : 		lpDuelChannel->nIndex1 = requester.m_Index;
; 256  : 		lpDuelChannel->nIndex2 = responsor.m_Index;
; 257  : 
; 258  : 		memcpy(lpDuelChannel->szName1, requester.Name, MAX_IDSTRING);
; 259  : 		memcpy(lpDuelChannel->szName2, responsor.Name, MAX_IDSTRING);
; 260  : 
; 261  : 		m_DuelChannelList.channel[nId].bStart = 1;

  0008a	6b ff 16	 imul	 edi, 22			; 00000016H
  0008d	8b 4d 10	 mov	 ecx, DWORD PTR _requester$[ebp]
  00090	8b 55 14	 mov	 edx, DWORD PTR _responsor$[ebp]
  00093	89 46 24	 mov	 DWORD PTR [esi+36], eax
  00096	8b 01		 mov	 eax, DWORD PTR [ecx]
  00098	89 46 04	 mov	 DWORD PTR [esi+4], eax
  0009b	8b 02		 mov	 eax, DWORD PTR [edx]
  0009d	89 46 08	 mov	 DWORD PTR [esi+8], eax
  000a0	8b 41 5d	 mov	 eax, DWORD PTR [ecx+93]
  000a3	89 46 0c	 mov	 DWORD PTR [esi+12], eax
  000a6	8b 41 61	 mov	 eax, DWORD PTR [ecx+97]
  000a9	89 46 10	 mov	 DWORD PTR [esi+16], eax
  000ac	0f b7 41 65	 movzx	 eax, WORD PTR [ecx+101]
  000b0	66 89 46 14	 mov	 WORD PTR [esi+20], ax
  000b4	8b 42 5d	 mov	 eax, DWORD PTR [edx+93]
  000b7	89 46 17	 mov	 DWORD PTR [esi+23], eax
  000ba	8b 42 61	 mov	 eax, DWORD PTR [edx+97]
  000bd	89 46 1b	 mov	 DWORD PTR [esi+27], eax
  000c0	0f b7 42 65	 movzx	 eax, WORD PTR [edx+101]
  000c4	66 89 46 1f	 mov	 WORD PTR [esi+31], ax
  000c8	8d 04 1f	 lea	 eax, DWORD PTR [edi+ebx]
  000cb	66 c7 40 20 01
	01		 mov	 WORD PTR [eax+32], 257	; 00000101H

; 262  : 		m_DuelChannelList.channel[nId].bWatch = 1;
; 263  : 
; 264  : 		memcpy(m_DuelChannelList.channel[nId].szName1, requester.Name, MAX_IDSTRING);

  000d1	8b 71 5d	 mov	 esi, DWORD PTR [ecx+93]
  000d4	89 70 0c	 mov	 DWORD PTR [eax+12], esi
  000d7	8b 71 61	 mov	 esi, DWORD PTR [ecx+97]
  000da	89 70 10	 mov	 DWORD PTR [eax+16], esi
  000dd	0f b7 71 65	 movzx	 esi, WORD PTR [ecx+101]
  000e1	66 89 70 14	 mov	 WORD PTR [eax+20], si

; 265  : 		memcpy(m_DuelChannelList.channel[nId].szName2, responsor.Name, MAX_IDSTRING);

  000e5	8b 72 5d	 mov	 esi, DWORD PTR [edx+93]
  000e8	89 70 16	 mov	 DWORD PTR [eax+22], esi
  000eb	8b 72 61	 mov	 esi, DWORD PTR [edx+97]

; 266  : 
; 267  : 		SetDuelStatus(requester, responsor, nStatus);

  000ee	6a 02		 push	 2
  000f0	89 70 1a	 mov	 DWORD PTR [eax+26], esi
  000f3	0f b7 72 65	 movzx	 esi, WORD PTR [edx+101]
  000f7	52		 push	 edx
  000f8	51		 push	 ecx
  000f9	8b cb		 mov	 ecx, ebx
  000fb	66 89 70 1e	 mov	 WORD PTR [eax+30], si
  000ff	e8 00 00 00 00	 call	 ?SetDuelStatus@CNewPVP@@AAEXAAUOBJECTSTRUCT@@0H@Z ; CNewPVP::SetDuelStatus
  00104	5f		 pop	 edi
  00105	5e		 pop	 esi
  00106	5b		 pop	 ebx

; 280  : 	  break;
; 281  : 	}
; 282  : }

  00107	5d		 pop	 ebp
  00108	c2 10 00	 ret	 16			; 00000010H
$LN3@SetStatus:

; 268  : 	  break;
; 269  : 	case 3:
; 270  : 	  lpDuelChannel->nStatus = nStatus;

  0010b	c6 46 22 03	 mov	 BYTE PTR [esi+34], 3

; 279  : 	  lpDuelChannel->dwTime = GetTickCount();

  0010f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00115	5f		 pop	 edi
  00116	89 46 24	 mov	 DWORD PTR [esi+36], eax
  00119	5e		 pop	 esi
  0011a	5b		 pop	 ebx

; 280  : 	  break;
; 281  : 	}
; 282  : }

  0011b	5d		 pop	 ebp
  0011c	c2 10 00	 ret	 16			; 00000010H
$LN2@SetStatus:

; 271  : 	  lpDuelChannel->dwTime = GetTickCount();
; 272  : 	  break;
; 273  : 	case 4:
; 274  : 	  lpDuelChannel->nStatus = nStatus;

  0011f	c6 46 22 04	 mov	 BYTE PTR [esi+34], 4

; 279  : 	  lpDuelChannel->dwTime = GetTickCount();

  00123	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00129	5f		 pop	 edi
  0012a	89 46 24	 mov	 DWORD PTR [esi+36], eax
  0012d	5e		 pop	 esi
  0012e	5b		 pop	 ebx

; 280  : 	  break;
; 281  : 	}
; 282  : }

  0012f	5d		 pop	 ebp
  00130	c2 10 00	 ret	 16			; 00000010H
$LN1@SetStatus:

; 275  : 	  lpDuelChannel->dwTime = GetTickCount();
; 276  : 	  break;
; 277  : 	case DC_RESERVEDEND:
; 278  : 	  lpDuelChannel->nStatus = nStatus;

  00133	c6 46 22 05	 mov	 BYTE PTR [esi+34], 5

; 279  : 	  lpDuelChannel->dwTime = GetTickCount();

  00137	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0013d	89 46 24	 mov	 DWORD PTR [esi+36], eax
$LN6@SetStatus:
  00140	5f		 pop	 edi
  00141	5e		 pop	 esi
  00142	5b		 pop	 ebx

; 280  : 	  break;
; 281  : 	}
; 282  : }

  00143	5d		 pop	 ebp
  00144	c2 10 00	 ret	 16			; 00000010H
  00147	90		 npad	 1
$LN11@SetStatus:
  00148	00 00 00 00	 DD	 $LN5@SetStatus
  0014c	00 00 00 00	 DD	 $LN6@SetStatus
  00150	00 00 00 00	 DD	 $LN4@SetStatus
  00154	00 00 00 00	 DD	 $LN3@SetStatus
  00158	00 00 00 00	 DD	 $LN2@SetStatus
  0015c	00 00 00 00	 DD	 $LN1@SetStatus
?SetStatus@CNewPVP@@AAEXHHAAUOBJECTSTRUCT@@0@Z ENDP	; CNewPVP::SetStatus
_TEXT	ENDS
PUBLIC	??9?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> > >::operator!=
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??9?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> > >::operator!=, COMDAT
; _this$ = ecx

; 334  : 		{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 335  : 		return (!(*this == _Right));

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00008	33 c9		 xor	 ecx, ecx
  0000a	3b 02		 cmp	 eax, DWORD PTR [edx]
  0000c	0f 95 c0	 setne	 al

; 336  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??9?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> > >::operator!=
_TEXT	ENDS
PUBLIC	?_Lmost@?$_Tree@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::_Lmost
; Function compile flags: /Ogtp
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Lmost@?$_Tree@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::_Lmost, COMDAT
; _this$ = ecx

; 1759 : 		return (this->_Left(this->_Myhead));

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 1760 : 		}

  00003	c3		 ret	 0
?_Lmost@?$_Tree@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::_Lmost
_TEXT	ENDS
PUBLIC	?_Rmost@?$_Tree@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::_Rmost
; Function compile flags: /Ogtp
;	COMDAT ?_Rmost@?$_Tree@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Rmost@?$_Tree@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::_Rmost, COMDAT
; _this$ = ecx

; 1784 : 		return (this->_Right(this->_Myhead));

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	83 c0 08	 add	 eax, 8

; 1785 : 		}

  00006	c3		 ret	 0
?_Rmost@?$_Tree@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::_Rmost
_TEXT	ENDS
PUBLIC	?_Root@?$_Tree@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::_Root
; Function compile flags: /Ogtp
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Root@?$_Tree@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::_Root, COMDAT
; _this$ = ecx

; 1789 : 		return (this->_Parent(this->_Myhead));

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	83 c0 04	 add	 eax, 4

; 1790 : 		}

  00006	c3		 ret	 0
?_Root@?$_Tree@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::_Root
_TEXT	ENDS
PUBLIC	?_Rrotate@?$_Tree@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::_Rrotate
; Function compile flags: /Ogtp
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Wherenode$ = 8					; size = 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::_Rrotate, COMDAT
; _this$ = ecx

; 1793 : 		{	// promote left node to root of subtree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1794 : 		_Nodeptr _Pnode = this->_Left(_Wherenode);

  00003	8b 55 08	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  00006	8b 02		 mov	 eax, DWORD PTR [edx]
  00008	56		 push	 esi

; 1795 : 		this->_Left(_Wherenode) = this->_Right(_Pnode);

  00009	8b 70 08	 mov	 esi, DWORD PTR [eax+8]
  0000c	89 32		 mov	 DWORD PTR [edx], esi

; 1796 : 
; 1797 : 		if (!this->_Isnil(this->_Right(_Pnode)))

  0000e	8b 70 08	 mov	 esi, DWORD PTR [eax+8]
  00011	80 7e 21 00	 cmp	 BYTE PTR [esi+33], 0
  00015	75 03		 jne	 SHORT $LN5@Rrotate

; 1798 : 			this->_Parent(this->_Right(_Pnode)) = _Wherenode;

  00017	89 56 04	 mov	 DWORD PTR [esi+4], edx
$LN5@Rrotate:

; 1799 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

  0001a	8b 72 04	 mov	 esi, DWORD PTR [edx+4]
  0001d	89 70 04	 mov	 DWORD PTR [eax+4], esi

; 1800 : 
; 1801 : 		if (_Wherenode == _Root())

  00020	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00023	5e		 pop	 esi
  00024	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00027	75 0d		 jne	 SHORT $LN4@Rrotate

; 1802 : 			_Root() = _Pnode;

  00029	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1807 : 
; 1808 : 		this->_Right(_Pnode) = _Wherenode;

  0002c	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 1809 : 		this->_Parent(_Wherenode) = _Pnode;

  0002f	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 1810 : 		}

  00032	5d		 pop	 ebp
  00033	c2 04 00	 ret	 4
$LN4@Rrotate:

; 1803 : 		else if (_Wherenode == this->_Right(this->_Parent(_Wherenode)))

  00036	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00039	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  0003c	75 0d		 jne	 SHORT $LN2@Rrotate

; 1804 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;

  0003e	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 1807 : 
; 1808 : 		this->_Right(_Pnode) = _Wherenode;

  00041	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 1809 : 		this->_Parent(_Wherenode) = _Pnode;

  00044	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 1810 : 		}

  00047	5d		 pop	 ebp
  00048	c2 04 00	 ret	 4
$LN2@Rrotate:

; 1805 : 		else
; 1806 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;

  0004b	89 01		 mov	 DWORD PTR [ecx], eax

; 1807 : 
; 1808 : 		this->_Right(_Pnode) = _Wherenode;

  0004d	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 1809 : 		this->_Parent(_Wherenode) = _Pnode;

  00050	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 1810 : 		}

  00053	5d		 pop	 ebp
  00054	c2 04 00	 ret	 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::_Rrotate
_TEXT	ENDS
PUBLIC	??1?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::~_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >
; Function compile flags: /Ogtp
;	COMDAT ??1?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::~_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >, COMDAT
; _this$ = ecx

; 555  : 		this->_Alnod.deallocate(this->_Myhead, 1);

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	50		 push	 eax
  00004	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00009	59		 pop	 ecx

; 556  : 		}

  0000a	c3		 ret	 0
??1?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::~_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >
_TEXT	ENDS
PUBLIC	?_Key@?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@SAAAHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::_Key
; Function compile flags: /Ogtp
;	COMDAT ?_Key@?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@SAAAHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Key@?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@SAAAHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::_Key, COMDAT

; 616  : 		{	// return reference to key in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 617  : 		return ((key_type&)_Traits::_Kfn(_Myval(_Pnode)));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 0c	 add	 eax, 12			; 0000000cH

; 618  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Key@?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@SAAAHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::_Key
_TEXT	ENDS
PUBLIC	?_Lmost@?$_Tree@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::_Lmost
; Function compile flags: /Ogtp
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Lmost@?$_Tree@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::_Lmost, COMDAT
; _this$ = ecx

; 1759 : 		return (this->_Left(this->_Myhead));

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 1760 : 		}

  00003	c3		 ret	 0
?_Lmost@?$_Tree@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::_Lmost
_TEXT	ENDS
PUBLIC	?_Rmost@?$_Tree@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::_Rmost
; Function compile flags: /Ogtp
;	COMDAT ?_Rmost@?$_Tree@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Rmost@?$_Tree@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::_Rmost, COMDAT
; _this$ = ecx

; 1784 : 		return (this->_Right(this->_Myhead));

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	83 c0 08	 add	 eax, 8

; 1785 : 		}

  00006	c3		 ret	 0
?_Rmost@?$_Tree@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::_Rmost
_TEXT	ENDS
PUBLIC	?_Root@?$_Tree@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::_Root
; Function compile flags: /Ogtp
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Root@?$_Tree@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::_Root, COMDAT
; _this$ = ecx

; 1789 : 		return (this->_Parent(this->_Myhead));

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	83 c0 04	 add	 eax, 4

; 1790 : 		}

  00006	c3		 ret	 0
?_Root@?$_Tree@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::_Root
_TEXT	ENDS
PUBLIC	?_Rrotate@?$_Tree@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::_Rrotate
; Function compile flags: /Ogtp
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Wherenode$ = 8					; size = 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::_Rrotate, COMDAT
; _this$ = ecx

; 1793 : 		{	// promote left node to root of subtree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1794 : 		_Nodeptr _Pnode = this->_Left(_Wherenode);

  00003	8b 55 08	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  00006	8b 02		 mov	 eax, DWORD PTR [edx]
  00008	56		 push	 esi

; 1795 : 		this->_Left(_Wherenode) = this->_Right(_Pnode);

  00009	8b 70 08	 mov	 esi, DWORD PTR [eax+8]
  0000c	89 32		 mov	 DWORD PTR [edx], esi

; 1796 : 
; 1797 : 		if (!this->_Isnil(this->_Right(_Pnode)))

  0000e	8b 70 08	 mov	 esi, DWORD PTR [eax+8]
  00011	80 7e 25 00	 cmp	 BYTE PTR [esi+37], 0
  00015	75 03		 jne	 SHORT $LN5@Rrotate@2

; 1798 : 			this->_Parent(this->_Right(_Pnode)) = _Wherenode;

  00017	89 56 04	 mov	 DWORD PTR [esi+4], edx
$LN5@Rrotate@2:

; 1799 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

  0001a	8b 72 04	 mov	 esi, DWORD PTR [edx+4]
  0001d	89 70 04	 mov	 DWORD PTR [eax+4], esi

; 1800 : 
; 1801 : 		if (_Wherenode == _Root())

  00020	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00023	5e		 pop	 esi
  00024	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00027	75 0d		 jne	 SHORT $LN4@Rrotate@2

; 1802 : 			_Root() = _Pnode;

  00029	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1807 : 
; 1808 : 		this->_Right(_Pnode) = _Wherenode;

  0002c	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 1809 : 		this->_Parent(_Wherenode) = _Pnode;

  0002f	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 1810 : 		}

  00032	5d		 pop	 ebp
  00033	c2 04 00	 ret	 4
$LN4@Rrotate@2:

; 1803 : 		else if (_Wherenode == this->_Right(this->_Parent(_Wherenode)))

  00036	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00039	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  0003c	75 0d		 jne	 SHORT $LN2@Rrotate@2

; 1804 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;

  0003e	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 1807 : 
; 1808 : 		this->_Right(_Pnode) = _Wherenode;

  00041	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 1809 : 		this->_Parent(_Wherenode) = _Pnode;

  00044	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 1810 : 		}

  00047	5d		 pop	 ebp
  00048	c2 04 00	 ret	 4
$LN2@Rrotate@2:

; 1805 : 		else
; 1806 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;

  0004b	89 01		 mov	 DWORD PTR [ecx], eax

; 1807 : 
; 1808 : 		this->_Right(_Pnode) = _Wherenode;

  0004d	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 1809 : 		this->_Parent(_Wherenode) = _Pnode;

  00050	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 1810 : 		}

  00053	5d		 pop	 ebp
  00054	c2 04 00	 ret	 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::_Rrotate
_TEXT	ENDS
PUBLIC	??1?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::~_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >
; Function compile flags: /Ogtp
;	COMDAT ??1?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::~_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >, COMDAT
; _this$ = ecx

; 555  : 		this->_Alnod.deallocate(this->_Myhead, 1);

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	50		 push	 eax
  00004	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00009	59		 pop	 ecx

; 556  : 		}

  0000a	c3		 ret	 0
??1?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::~_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >
_TEXT	ENDS
PUBLIC	?_Key@?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@SAAAHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::_Key
; Function compile flags: /Ogtp
;	COMDAT ?_Key@?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@SAAAHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Key@?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@SAAAHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::_Key, COMDAT

; 616  : 		{	// return reference to key in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 617  : 		return ((key_type&)_Traits::_Kfn(_Myval(_Pnode)));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 0c	 add	 eax, 12			; 0000000cH

; 618  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Key@?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@SAAAHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::_Key
_TEXT	ENDS
PUBLIC	??D?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@std@@QBEAAU?$pair@$$CBHU_tagWaiting@@@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> > >::operator*
; Function compile flags: /Ogtp
;	COMDAT ??D?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@std@@QBEAAU?$pair@$$CBHU_tagWaiting@@@1@XZ
_TEXT	SEGMENT
??D?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@std@@QBEAAU?$pair@$$CBHU_tagWaiting@@@1@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> > >::operator*, COMDAT
; _this$ = ecx

; 396  : 		return ((reference)**(_Mybase *)this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 0c	 add	 eax, 12			; 0000000cH

; 397  : 		}

  00005	c3		 ret	 0
??D?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@std@@QBEAAU?$pair@$$CBHU_tagWaiting@@@1@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> > >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> > >::operator++
; Function compile flags: /Ogtp
;	COMDAT ??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> > >::operator++, COMDAT
; _this$ = ecx

; 250  : 		{	// preincrement

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 251  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 252  : 		if (this->_Getcont() == 0
; 253  : 			|| this->_Ptr == 0
; 254  : 			|| _Mytree::_Isnil(this->_Ptr))
; 255  : 			{	// report error
; 256  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 257  : 			_SCL_SECURE_OUT_OF_RANGE;
; 258  : 			}
; 259  : 
; 260  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 261  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 262  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 263  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 264  : 
; 265  : 		++(*(_Mybase *)this);

  00003	e8 00 00 00 00	 call	 ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >,std::_Iterator_base0>::operator++

; 266  : 		return (*this);

  00008	8b c6		 mov	 eax, esi
  0000a	5e		 pop	 esi

; 267  : 		}

  0000b	c3		 ret	 0
??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> > >::operator++
_TEXT	ENDS
PUBLIC	??D?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@std@@QBEAAU?$pair@$$CBHU_tagObserverInfo@@@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> > >::operator*
; Function compile flags: /Ogtp
;	COMDAT ??D?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@std@@QBEAAU?$pair@$$CBHU_tagObserverInfo@@@1@XZ
_TEXT	SEGMENT
??D?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@std@@QBEAAU?$pair@$$CBHU_tagObserverInfo@@@1@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> > >::operator*, COMDAT
; _this$ = ecx

; 396  : 		return ((reference)**(_Mybase *)this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 0c	 add	 eax, 12			; 0000000cH

; 397  : 		}

  00005	c3		 ret	 0
??D?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@std@@QBEAAU?$pair@$$CBHU_tagObserverInfo@@@1@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> > >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> > >::operator++
; Function compile flags: /Ogtp
;	COMDAT ??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> > >::operator++, COMDAT
; _this$ = ecx

; 250  : 		{	// preincrement

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 251  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 252  : 		if (this->_Getcont() == 0
; 253  : 			|| this->_Ptr == 0
; 254  : 			|| _Mytree::_Isnil(this->_Ptr))
; 255  : 			{	// report error
; 256  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 257  : 			_SCL_SECURE_OUT_OF_RANGE;
; 258  : 			}
; 259  : 
; 260  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 261  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 262  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 263  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 264  : 
; 265  : 		++(*(_Mybase *)this);

  00003	e8 00 00 00 00	 call	 ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >,std::_Iterator_base0>::operator++

; 266  : 		return (*this);

  00008	8b c6		 mov	 eax, esi
  0000a	5e		 pop	 esi

; 267  : 		}

  0000b	c3		 ret	 0
??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> > >::operator++
_TEXT	ENDS
PUBLIC	?_Lbound@?$_Tree@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::_Lbound
; Function compile flags: /Ogtp
;	COMDAT ?_Lbound@?$_Tree@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@2@ABH@Z
_TEXT	SEGMENT
__Keyval$ = 8						; size = 4
?_Lbound@?$_Tree@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@2@ABH@Z PROC ; std::_Tree<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::_Lbound, COMDAT
; _this$ = ecx

; 1741 : 		{	// find leftmost node not less than _Keyval

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1742 : 		_Nodeptr _Pnode = _Root();

  00003	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00006	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]

; 1743 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 1744 : 
; 1745 : 		while (!this->_Isnil(_Pnode))

  00009	80 79 21 00	 cmp	 BYTE PTR [ecx+33], 0
  0000d	75 19		 jne	 SHORT $LN3@Lbound
  0000f	8b 55 08	 mov	 edx, DWORD PTR __Keyval$[ebp]
  00012	8b 12		 mov	 edx, DWORD PTR [edx]
$LL4@Lbound:

; 1746 : 			if (_DEBUG_LT_PRED(this->comp, this->_Key(_Pnode), _Keyval))

  00014	39 51 0c	 cmp	 DWORD PTR [ecx+12], edx
  00017	7d 05		 jge	 SHORT $LN2@Lbound

; 1747 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree

  00019	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]

; 1748 : 			else

  0001c	eb 04		 jmp	 SHORT $LN1@Lbound
$LN2@Lbound:

; 1749 : 				{	// _Pnode not less than _Keyval, remember it
; 1750 : 				_Wherenode = _Pnode;

  0001e	8b c1		 mov	 eax, ecx

; 1751 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree

  00020	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN1@Lbound:

; 1743 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 1744 : 
; 1745 : 		while (!this->_Isnil(_Pnode))

  00022	80 79 21 00	 cmp	 BYTE PTR [ecx+33], 0
  00026	74 ec		 je	 SHORT $LL4@Lbound
$LN3@Lbound:

; 1752 : 				}
; 1753 : 
; 1754 : 		return (_Wherenode);	// return best remembered candidate
; 1755 : 		}

  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
?_Lbound@?$_Tree@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@2@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::_Lbound
_TEXT	ENDS
PUBLIC	?_Lbound@?$_Tree@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::_Lbound
; Function compile flags: /Ogtp
;	COMDAT ?_Lbound@?$_Tree@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@2@ABH@Z
_TEXT	SEGMENT
__Keyval$ = 8						; size = 4
?_Lbound@?$_Tree@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@2@ABH@Z PROC ; std::_Tree<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::_Lbound, COMDAT
; _this$ = ecx

; 1741 : 		{	// find leftmost node not less than _Keyval

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1742 : 		_Nodeptr _Pnode = _Root();

  00003	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00006	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]

; 1743 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 1744 : 
; 1745 : 		while (!this->_Isnil(_Pnode))

  00009	80 79 25 00	 cmp	 BYTE PTR [ecx+37], 0
  0000d	75 19		 jne	 SHORT $LN3@Lbound@2
  0000f	8b 55 08	 mov	 edx, DWORD PTR __Keyval$[ebp]
  00012	8b 12		 mov	 edx, DWORD PTR [edx]
$LL4@Lbound@2:

; 1746 : 			if (_DEBUG_LT_PRED(this->comp, this->_Key(_Pnode), _Keyval))

  00014	39 51 0c	 cmp	 DWORD PTR [ecx+12], edx
  00017	7d 05		 jge	 SHORT $LN2@Lbound@2

; 1747 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree

  00019	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]

; 1748 : 			else

  0001c	eb 04		 jmp	 SHORT $LN1@Lbound@2
$LN2@Lbound@2:

; 1749 : 				{	// _Pnode not less than _Keyval, remember it
; 1750 : 				_Wherenode = _Pnode;

  0001e	8b c1		 mov	 eax, ecx

; 1751 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree

  00020	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN1@Lbound@2:

; 1743 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 1744 : 
; 1745 : 		while (!this->_Isnil(_Pnode))

  00022	80 79 25 00	 cmp	 BYTE PTR [ecx+37], 0
  00026	74 ec		 je	 SHORT $LL4@Lbound@2
$LN3@Lbound@2:

; 1752 : 				}
; 1753 : 
; 1754 : 		return (_Wherenode);	// return best remembered candidate
; 1755 : 		}

  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
?_Lbound@?$_Tree@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@2@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::_Lbound
_TEXT	ENDS
PUBLIC	??0?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@1@@Z ; std::_Tree_nod<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::_Tree_nod<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >
; Function compile flags: /Ogtp
;	COMDAT ??0?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@1@@Z PROC ; std::_Tree_nod<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::_Tree_nod<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >, COMDAT
; _this$ = ecx

; 482  : 		{	// construct traits from _Parg and allocators from _Al

  00000	8b c1		 mov	 eax, ecx

; 483  : 		}

  00002	c2 08 00	 ret	 8
??0?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@1@@Z ENDP ; std::_Tree_nod<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::_Tree_nod<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::_Node>::allocate
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
$T195087 = -12						; size = 12
$T195085 = 8						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@2@I@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::_Node>::allocate, COMDAT
; _this$ = ecx

; 186  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 187  : 		return (_Allocate(_Count, (pointer)0));

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00009	33 c0		 xor	 eax, eax
  0000b	85 c9		 test	 ecx, ecx
  0000d	74 44		 je	 SHORT $LN1@allocate
  0000f	81 f9 c7 71 1c
	07		 cmp	 ecx, 119304647		; 071c71c7H
  00015	77 14		 ja	 SHORT $LN3@allocate
  00017	8d 04 c9	 lea	 eax, DWORD PTR [ecx+ecx*8]
  0001a	03 c0		 add	 eax, eax
  0001c	03 c0		 add	 eax, eax
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00024	83 c4 04	 add	 esp, 4
  00027	85 c0		 test	 eax, eax
  00029	75 28		 jne	 SHORT $LN1@allocate
$LN3@allocate:
  0002b	8d 4d 08	 lea	 ecx, DWORD PTR $T195085[ebp]
  0002e	51		 push	 ecx
  0002f	8d 4d f4	 lea	 ecx, DWORD PTR $T195087[ebp]
  00032	c7 45 08 00 00
	00 00		 mov	 DWORD PTR $T195085[ebp], 0
  00039	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  0003e	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00043	8d 55 f4	 lea	 edx, DWORD PTR $T195087[ebp]
  00046	52		 push	 edx
  00047	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T195087[ebp], OFFSET ??_7bad_alloc@std@@6B@
  0004e	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN13@allocate:
$LN1@allocate:

; 188  : 		}

  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c2 04 00	 ret	 4
$LN12@allocate:
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::_Node>::allocate
_TEXT	ENDS
PUBLIC	??0?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@1@@Z ; std::_Tree_nod<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::_Tree_nod<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??0?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@1@@Z PROC ; std::_Tree_nod<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::_Tree_nod<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >, COMDAT
; _this$ = ecx

; 482  : 		{	// construct traits from _Parg and allocators from _Al

  00000	8b c1		 mov	 eax, ecx

; 483  : 		}

  00002	c2 08 00	 ret	 8
??0?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@1@@Z ENDP ; std::_Tree_nod<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::_Tree_nod<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::_Node>::allocate
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
$T195122 = -12						; size = 12
$T195120 = 8						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@2@I@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::_Node>::allocate, COMDAT
; _this$ = ecx

; 186  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 187  : 		return (_Allocate(_Count, (pointer)0));

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00009	33 c0		 xor	 eax, eax
  0000b	85 c9		 test	 ecx, ecx
  0000d	74 46		 je	 SHORT $LN1@allocate@2
  0000f	81 f9 66 66 66
	06		 cmp	 ecx, 107374182		; 06666666H
  00015	77 16		 ja	 SHORT $LN3@allocate@2
  00017	8d 04 89	 lea	 eax, DWORD PTR [ecx+ecx*4]
  0001a	03 c0		 add	 eax, eax
  0001c	03 c0		 add	 eax, eax
  0001e	03 c0		 add	 eax, eax
  00020	50		 push	 eax
  00021	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00026	83 c4 04	 add	 esp, 4
  00029	85 c0		 test	 eax, eax
  0002b	75 28		 jne	 SHORT $LN1@allocate@2
$LN3@allocate@2:
  0002d	8d 4d 08	 lea	 ecx, DWORD PTR $T195120[ebp]
  00030	51		 push	 ecx
  00031	8d 4d f4	 lea	 ecx, DWORD PTR $T195122[ebp]
  00034	c7 45 08 00 00
	00 00		 mov	 DWORD PTR $T195120[ebp], 0
  0003b	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00040	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00045	8d 55 f4	 lea	 edx, DWORD PTR $T195122[ebp]
  00048	52		 push	 edx
  00049	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T195122[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00050	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN13@allocate@2:
$LN1@allocate@2:

; 188  : 		}

  00055	8b e5		 mov	 esp, ebp
  00057	5d		 pop	 ebp
  00058	c2 04 00	 ret	 4
$LN12@allocate@2:
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::_Node>::allocate
_TEXT	ENDS
PUBLIC	??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> > >::operator++
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@std@@QAE?AV01@H@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> > >::operator++, COMDAT
; _this$ = ecx

; 270  : 		{	// postincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 271  : 		_Myiter _Tmp = *this;

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	56		 push	 esi
  00006	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  00009	89 06		 mov	 DWORD PTR [esi], eax

; 272  : 		++*this;

  0000b	e8 00 00 00 00	 call	 ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >,std::_Iterator_base0>::operator++

; 273  : 		return (_Tmp);

  00010	8b c6		 mov	 eax, esi
  00012	5e		 pop	 esi

; 274  : 		}

  00013	5d		 pop	 ebp
  00014	c2 08 00	 ret	 8
??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@std@@QAE?AV01@H@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> > >::operator++
_TEXT	ENDS
PUBLIC	??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@1@@Z ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >,std::_Iterator_base0>
; Function compile flags: /Ogtp
;	COMDAT ??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@1@@Z PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >,std::_Iterator_base0>, COMDAT
; _this$ = ecx

; 43   : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 44   : 		this->_Adopt(_Plist);
; 45   : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@1@@Z ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >,std::_Iterator_base0>
_TEXT	ENDS
PUBLIC	??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> > >::operator++
; Function compile flags: /Ogtp
;	COMDAT ??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@std@@QAE?AV01@H@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> > >::operator++, COMDAT
; _this$ = ecx

; 270  : 		{	// postincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 271  : 		_Myiter _Tmp = *this;

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	56		 push	 esi
  00006	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  00009	89 06		 mov	 DWORD PTR [esi], eax

; 272  : 		++*this;

  0000b	e8 00 00 00 00	 call	 ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >,std::_Iterator_base0>::operator++

; 273  : 		return (_Tmp);

  00010	8b c6		 mov	 eax, esi
  00012	5e		 pop	 esi

; 274  : 		}

  00013	5d		 pop	 ebp
  00014	c2 08 00	 ret	 8
??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@std@@QAE?AV01@H@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> > >::operator++
_TEXT	ENDS
PUBLIC	??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@1@@Z ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >,std::_Iterator_base0>
; Function compile flags: /Ogtp
;	COMDAT ??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@1@@Z PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >,std::_Iterator_base0>, COMDAT
; _this$ = ecx

; 43   : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 44   : 		this->_Adopt(_Plist);
; 45   : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@1@@Z ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >,std::_Iterator_base0>
_TEXT	ENDS
PUBLIC	??$swap@D@std@@YAXAAD0@Z			; std::swap<char>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$swap@D@std@@YAXAAD0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@D@std@@YAXAAD0@Z PROC				; std::swap<char>, COMDAT

; 101  : 	{	// exchange values stored at _Left and _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 102  : 	_Ty _Tmp = _Move(_Left);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  00006	8a 08		 mov	 cl, BYTE PTR [eax]
  00008	56		 push	 esi

; 103  : 	_Left = _Move(_Right);

  00009	8b 75 0c	 mov	 esi, DWORD PTR __Right$[ebp]
  0000c	8a 16		 mov	 dl, BYTE PTR [esi]
  0000e	88 10		 mov	 BYTE PTR [eax], dl

; 104  : 	_Right = _Move(_Tmp);

  00010	88 0e		 mov	 BYTE PTR [esi], cl
  00012	5e		 pop	 esi

; 105  : 	}

  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
??$swap@D@std@@YAXAAD0@Z ENDP				; std::swap<char>
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@std@@QAEXPAU?$pair@$$CBHU_tagWaiting@@@2@@Z ; std::allocator<std::pair<int const ,_tagWaiting> >::destroy
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?destroy@?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@std@@QAEXPAU?$pair@$$CBHU_tagWaiting@@@2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@std@@QAEXPAU?$pair@$$CBHU_tagWaiting@@@2@@Z PROC ; std::allocator<std::pair<int const ,_tagWaiting> >::destroy, COMDAT
; _this$ = ecx

; 213  : 		_Destroy(_Ptr);
; 214  : 		}

  00000	c2 04 00	 ret	 4
?destroy@?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@std@@QAEXPAU?$pair@$$CBHU_tagWaiting@@@2@@Z ENDP ; std::allocator<std::pair<int const ,_tagWaiting> >::destroy
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@std@@QAEXPAU?$pair@$$CBHU_tagObserverInfo@@@2@@Z ; std::allocator<std::pair<int const ,_tagObserverInfo> >::destroy
; Function compile flags: /Ogtp
;	COMDAT ?destroy@?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@std@@QAEXPAU?$pair@$$CBHU_tagObserverInfo@@@2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@std@@QAEXPAU?$pair@$$CBHU_tagObserverInfo@@@2@@Z PROC ; std::allocator<std::pair<int const ,_tagObserverInfo> >::destroy, COMDAT
; _this$ = ecx

; 213  : 		_Destroy(_Ptr);
; 214  : 		}

  00000	c2 04 00	 ret	 4
?destroy@?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@std@@QAEXPAU?$pair@$$CBHU_tagObserverInfo@@@2@@Z ENDP ; std::allocator<std::pair<int const ,_tagObserverInfo> >::destroy
_TEXT	ENDS
PUBLIC	?max_size@?$_Tree@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::max_size
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ?max_size@?$_Tree@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$_Tree@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@QBEIXZ PROC ; std::_Tree<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::max_size, COMDAT
; _this$ = ecx

; 874  : 		return (this->_Alval.max_size());

  00000	b8 cc cc cc 0c	 mov	 eax, 214748364		; 0cccccccH

; 875  : 		}

  00005	c3		 ret	 0
?max_size@?$_Tree@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::max_size
_TEXT	ENDS
PUBLIC	?max_size@?$_Tree@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::max_size
; Function compile flags: /Ogtp
;	COMDAT ?max_size@?$_Tree@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$_Tree@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@QBEIXZ PROC ; std::_Tree<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::max_size, COMDAT
; _this$ = ecx

; 874  : 		return (this->_Alval.max_size());

  00000	b8 aa aa aa 0a	 mov	 eax, 178956970		; 0aaaaaaaH

; 875  : 		}

  00005	c3		 ret	 0
?max_size@?$_Tree@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::max_size
_TEXT	ENDS
PUBLIC	??F?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> > >::operator--
; Function compile flags: /Ogtp
;	COMDAT ??F?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> > >::operator--, COMDAT
; _this$ = ecx

; 277  : 		{	// predecrement

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 278  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 279  : 		if (this->_Getcont() == 0
; 280  : 			|| this->_Ptr == 0)
; 281  : 			{	// report error
; 282  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 283  : 			_SCL_SECURE_OUT_OF_RANGE;
; 284  : 			}
; 285  : 
; 286  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 287  : 		--(*(_Mybase *)this);
; 288  : 		if (_Ptrsav == this->_Ptr)
; 289  : 			{	// report error
; 290  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 291  : 			_SCL_SECURE_OUT_OF_RANGE;
; 292  : 			}
; 293  : 
; 294  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 295  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 296  : 
; 297  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 298  : 		--(*(_Mybase *)this);
; 299  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 300  : 
; 301  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 302  : 		--(*(_Mybase *)this);

  00003	e8 00 00 00 00	 call	 ??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >,std::_Iterator_base0>::operator--

; 303  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 304  : 
; 305  : 		return (*this);

  00008	8b c6		 mov	 eax, esi
  0000a	5e		 pop	 esi

; 306  : 		}

  0000b	c3		 ret	 0
??F?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> > >::operator--
_TEXT	ENDS
PUBLIC	??0?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> > >,bool>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??0?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z PROC ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> > >,bool>, COMDAT
; _this$ = ecx

; 145  : 		{	// construct from specified values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Val1$[ebp]
  00008	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Val2$[ebp]
  0000d	89 10		 mov	 DWORD PTR [eax], edx
  0000f	8a 11		 mov	 dl, BYTE PTR [ecx]
  00011	88 50 04	 mov	 BYTE PTR [eax+4], dl

; 146  : 		}

  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
??0?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z ENDP ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> > >,bool>
_TEXT	ENDS
PUBLIC	??F?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> > >::operator--
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??F?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> > >::operator--, COMDAT
; _this$ = ecx

; 277  : 		{	// predecrement

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 278  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 279  : 		if (this->_Getcont() == 0
; 280  : 			|| this->_Ptr == 0)
; 281  : 			{	// report error
; 282  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 283  : 			_SCL_SECURE_OUT_OF_RANGE;
; 284  : 			}
; 285  : 
; 286  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 287  : 		--(*(_Mybase *)this);
; 288  : 		if (_Ptrsav == this->_Ptr)
; 289  : 			{	// report error
; 290  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 291  : 			_SCL_SECURE_OUT_OF_RANGE;
; 292  : 			}
; 293  : 
; 294  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 295  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 296  : 
; 297  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 298  : 		--(*(_Mybase *)this);
; 299  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 300  : 
; 301  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 302  : 		--(*(_Mybase *)this);

  00003	e8 00 00 00 00	 call	 ??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >,std::_Iterator_base0>::operator--

; 303  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 304  : 
; 305  : 		return (*this);

  00008	8b c6		 mov	 eax, esi
  0000a	5e		 pop	 esi

; 306  : 		}

  0000b	c3		 ret	 0
??F?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> > >::operator--
_TEXT	ENDS
PUBLIC	??0?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> > >,bool>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??0?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z PROC ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> > >,bool>, COMDAT
; _this$ = ecx

; 145  : 		{	// construct from specified values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Val1$[ebp]
  00008	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Val2$[ebp]
  0000d	89 10		 mov	 DWORD PTR [eax], edx
  0000f	8a 11		 mov	 dl, BYTE PTR [ecx]
  00011	88 50 04	 mov	 BYTE PTR [eax+4], dl

; 146  : 		}

  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
??0?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z ENDP ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> > >,bool>
_TEXT	ENDS
PUBLIC	??$?0AAHAAU_tagWaiting@@@?$pair@HU_tagWaiting@@@std@@QAE@AAHAAU_tagWaiting@@@Z ; std::pair<int,_tagWaiting>::pair<int,_tagWaiting><int &,_tagWaiting &>
; Function compile flags: /Ogtp
;	COMDAT ??$?0AAHAAU_tagWaiting@@@?$pair@HU_tagWaiting@@@std@@QAE@AAHAAU_tagWaiting@@@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAHAAU_tagWaiting@@@?$pair@HU_tagWaiting@@@std@@QAE@AAHAAU_tagWaiting@@@Z PROC ; std::pair<int,_tagWaiting>::pair<int,_tagWaiting><int &,_tagWaiting &>, COMDAT
; _this$ = ecx

; 247  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Val1$[ebp]
  00008	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Val2$[ebp]
  0000d	89 10		 mov	 DWORD PTR [eax], edx
  0000f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00011	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00014	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00017	89 50 08	 mov	 DWORD PTR [eax+8], edx
  0001a	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0001d	89 50 0c	 mov	 DWORD PTR [eax+12], edx
  00020	8b 49 0c	 mov	 ecx, DWORD PTR [ecx+12]
  00023	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 248  : 		}

  00026	5d		 pop	 ebp
  00027	c2 08 00	 ret	 8
??$?0AAHAAU_tagWaiting@@@?$pair@HU_tagWaiting@@@std@@QAE@AAHAAU_tagWaiting@@@Z ENDP ; std::pair<int,_tagWaiting>::pair<int,_tagWaiting><int &,_tagWaiting &>
_TEXT	ENDS
PUBLIC	??$?0AAHAAU_tagObserverInfo@@@?$pair@HU_tagObserverInfo@@@std@@QAE@AAHAAU_tagObserverInfo@@@Z ; std::pair<int,_tagObserverInfo>::pair<int,_tagObserverInfo><int &,_tagObserverInfo &>
; Function compile flags: /Ogtp
;	COMDAT ??$?0AAHAAU_tagObserverInfo@@@?$pair@HU_tagObserverInfo@@@std@@QAE@AAHAAU_tagObserverInfo@@@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAHAAU_tagObserverInfo@@@?$pair@HU_tagObserverInfo@@@std@@QAE@AAHAAU_tagObserverInfo@@@Z PROC ; std::pair<int,_tagObserverInfo>::pair<int,_tagObserverInfo><int &,_tagObserverInfo &>, COMDAT
; _this$ = ecx

; 247  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Val1$[ebp]
  00008	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Val2$[ebp]
  0000d	89 10		 mov	 DWORD PTR [eax], edx
  0000f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00011	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00014	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00017	89 50 08	 mov	 DWORD PTR [eax+8], edx
  0001a	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0001d	89 50 0c	 mov	 DWORD PTR [eax+12], edx
  00020	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00023	89 50 10	 mov	 DWORD PTR [eax+16], edx
  00026	8b 49 10	 mov	 ecx, DWORD PTR [ecx+16]
  00029	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 248  : 		}

  0002c	5d		 pop	 ebp
  0002d	c2 08 00	 ret	 8
??$?0AAHAAU_tagObserverInfo@@@?$pair@HU_tagObserverInfo@@@std@@QAE@AAHAAU_tagObserverInfo@@@Z ENDP ; std::pair<int,_tagObserverInfo>::pair<int,_tagObserverInfo><int &,_tagObserverInfo &>
_TEXT	ENDS
PUBLIC	??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@std@@_N@?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> > > &,bool>
; Function compile flags: /Ogtp
;	COMDAT ??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@std@@_N@?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@std@@_N@?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z PROC ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> > > &,bool>, COMDAT
; _this$ = ecx

; 247  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Val1$[ebp]
  00008	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Val2$[ebp]
  0000d	89 10		 mov	 DWORD PTR [eax], edx
  0000f	8a 11		 mov	 dl, BYTE PTR [ecx]
  00011	88 50 04	 mov	 BYTE PTR [eax+4], dl

; 248  : 		}

  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@std@@_N@?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z ENDP ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> > > &,bool>
_TEXT	ENDS
PUBLIC	??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@std@@_N@?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> > > &,bool>
; Function compile flags: /Ogtp
;	COMDAT ??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@std@@_N@?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@std@@_N@?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z PROC ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> > > &,bool>, COMDAT
; _this$ = ecx

; 247  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Val1$[ebp]
  00008	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Val2$[ebp]
  0000d	89 10		 mov	 DWORD PTR [eax], edx
  0000f	8a 11		 mov	 dl, BYTE PTR [ecx]
  00011	88 50 04	 mov	 BYTE PTR [eax+4], dl

; 248  : 		}

  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@std@@_N@?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z ENDP ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> > > &,bool>
_TEXT	ENDS
PUBLIC	?_Buynode@?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::_Buynode
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ?_Buynode@?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
$T195332 = -16						; size = 12
$T195315 = -4						; size = 4
?_Buynode@?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@2@XZ PROC ; std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::_Buynode, COMDAT
; _this$ = ecx

; 559  : 		{	// allocate a node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi

; 560  : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

  00007	6a 24		 push	 36			; 00000024H
  00009	8b f1		 mov	 esi, ecx
  0000b	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00010	33 c9		 xor	 ecx, ecx
  00012	83 c4 04	 add	 esp, 4
  00015	3b c1		 cmp	 eax, ecx
  00017	74 1a		 je	 SHORT $LN5@Buynode

; 561  : 
; 562  : 		this->_Left(_Wherenode) = this->_Myhead;

  00019	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0001c	89 10		 mov	 DWORD PTR [eax], edx

; 563  : 		this->_Parent(_Wherenode) = this->_Myhead;

  0001e	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00021	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 564  : 		this->_Right(_Wherenode) = this->_Myhead;

  00024	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00027	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 565  : 		this->_Color(_Wherenode) = this->_Red;

  0002a	66 89 48 20	 mov	 WORD PTR [eax+32], cx
  0002e	5e		 pop	 esi

; 566  : 		this->_Isnil(_Wherenode) = false;
; 567  : 		return (_Wherenode);
; 568  : 		}

  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0

; 560  : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

$LN5@Buynode:
  00033	8d 45 fc	 lea	 eax, DWORD PTR $T195315[ebp]
  00036	89 4d fc	 mov	 DWORD PTR $T195315[ebp], ecx
  00039	50		 push	 eax
  0003a	8d 4d f0	 lea	 ecx, DWORD PTR $T195332[ebp]
  0003d	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00042	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00047	8d 4d f0	 lea	 ecx, DWORD PTR $T195332[ebp]
  0004a	51		 push	 ecx
  0004b	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T195332[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00052	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN27@Buynode:
$LN26@Buynode:
  00057	cc		 int	 3
?_Buynode@?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::_Buynode
_TEXT	ENDS
PUBLIC	?_Buynode@?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::_Buynode
; Function compile flags: /Ogtp
;	COMDAT ?_Buynode@?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
$T195385 = -16						; size = 12
$T195368 = -4						; size = 4
?_Buynode@?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@2@XZ PROC ; std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::_Buynode, COMDAT
; _this$ = ecx

; 559  : 		{	// allocate a node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi

; 560  : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

  00007	6a 28		 push	 40			; 00000028H
  00009	8b f1		 mov	 esi, ecx
  0000b	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00010	33 c9		 xor	 ecx, ecx
  00012	83 c4 04	 add	 esp, 4
  00015	3b c1		 cmp	 eax, ecx
  00017	74 1a		 je	 SHORT $LN5@Buynode@2

; 561  : 
; 562  : 		this->_Left(_Wherenode) = this->_Myhead;

  00019	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0001c	89 10		 mov	 DWORD PTR [eax], edx

; 563  : 		this->_Parent(_Wherenode) = this->_Myhead;

  0001e	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00021	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 564  : 		this->_Right(_Wherenode) = this->_Myhead;

  00024	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00027	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 565  : 		this->_Color(_Wherenode) = this->_Red;

  0002a	66 89 48 24	 mov	 WORD PTR [eax+36], cx
  0002e	5e		 pop	 esi

; 566  : 		this->_Isnil(_Wherenode) = false;
; 567  : 		return (_Wherenode);
; 568  : 		}

  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0

; 560  : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

$LN5@Buynode@2:
  00033	8d 45 fc	 lea	 eax, DWORD PTR $T195368[ebp]
  00036	89 4d fc	 mov	 DWORD PTR $T195368[ebp], ecx
  00039	50		 push	 eax
  0003a	8d 4d f0	 lea	 ecx, DWORD PTR $T195385[ebp]
  0003d	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00042	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00047	8d 4d f0	 lea	 ecx, DWORD PTR $T195385[ebp]
  0004a	51		 push	 ecx
  0004b	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T195385[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00052	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN27@Buynode@2:
$LN26@Buynode@2:
  00057	cc		 int	 3
?_Buynode@?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::_Buynode
_TEXT	ENDS
PUBLIC	??$?0HU_tagWaiting@@@?$pair@$$CBHU_tagWaiting@@@std@@QAE@$$QAU?$pair@HU_tagWaiting@@@1@@Z ; std::pair<int const ,_tagWaiting>::pair<int const ,_tagWaiting><int,_tagWaiting>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$?0HU_tagWaiting@@@?$pair@$$CBHU_tagWaiting@@@std@@QAE@$$QAU?$pair@HU_tagWaiting@@@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??$?0HU_tagWaiting@@@?$pair@$$CBHU_tagWaiting@@@std@@QAE@$$QAU?$pair@HU_tagWaiting@@@1@@Z PROC ; std::pair<int const ,_tagWaiting>::pair<int const ,_tagWaiting><int,_tagWaiting>, COMDAT
; _this$ = ecx

; 255  : 		{	// construct from moved compatible pair

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00008	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000a	89 10		 mov	 DWORD PTR [eax], edx
  0000c	8d 51 04	 lea	 edx, DWORD PTR [ecx+4]
  0000f	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00011	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00014	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00017	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  0001a	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  0001d	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  00020	8b 52 0c	 mov	 edx, DWORD PTR [edx+12]
  00023	89 50 10	 mov	 DWORD PTR [eax+16], edx

; 256  : 		}

  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
??$?0HU_tagWaiting@@@?$pair@$$CBHU_tagWaiting@@@std@@QAE@$$QAU?$pair@HU_tagWaiting@@@1@@Z ENDP ; std::pair<int const ,_tagWaiting>::pair<int const ,_tagWaiting><int,_tagWaiting>
_TEXT	ENDS
PUBLIC	??$?0HU_tagObserverInfo@@@?$pair@$$CBHU_tagObserverInfo@@@std@@QAE@$$QAU?$pair@HU_tagObserverInfo@@@1@@Z ; std::pair<int const ,_tagObserverInfo>::pair<int const ,_tagObserverInfo><int,_tagObserverInfo>
; Function compile flags: /Ogtp
;	COMDAT ??$?0HU_tagObserverInfo@@@?$pair@$$CBHU_tagObserverInfo@@@std@@QAE@$$QAU?$pair@HU_tagObserverInfo@@@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??$?0HU_tagObserverInfo@@@?$pair@$$CBHU_tagObserverInfo@@@std@@QAE@$$QAU?$pair@HU_tagObserverInfo@@@1@@Z PROC ; std::pair<int const ,_tagObserverInfo>::pair<int const ,_tagObserverInfo><int,_tagObserverInfo>, COMDAT
; _this$ = ecx

; 255  : 		{	// construct from moved compatible pair

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00008	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000a	89 10		 mov	 DWORD PTR [eax], edx
  0000c	8d 51 04	 lea	 edx, DWORD PTR [ecx+4]
  0000f	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00011	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00014	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00017	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  0001a	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  0001d	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  00020	8b 4a 0c	 mov	 ecx, DWORD PTR [edx+12]
  00023	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  00026	8b 52 10	 mov	 edx, DWORD PTR [edx+16]
  00029	89 50 14	 mov	 DWORD PTR [eax+20], edx

; 256  : 		}

  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??$?0HU_tagObserverInfo@@@?$pair@$$CBHU_tagObserverInfo@@@std@@QAE@$$QAU?$pair@HU_tagObserverInfo@@@1@@Z ENDP ; std::pair<int const ,_tagObserverInfo>::pair<int const ,_tagObserverInfo><int,_tagObserverInfo>
_TEXT	ENDS
PUBLIC	??C?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@std@@QBEPAU?$pair@$$CBHU_tagWaiting@@@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> > >::operator->
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??C?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@std@@QBEPAU?$pair@$$CBHU_tagWaiting@@@1@XZ
_TEXT	SEGMENT
??C?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@std@@QBEPAU?$pair@$$CBHU_tagWaiting@@@1@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> > >::operator->, COMDAT
; _this$ = ecx

; 401  : 		return (&**this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 0c	 add	 eax, 12			; 0000000cH

; 402  : 		}

  00005	c3		 ret	 0
??C?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@std@@QBEPAU?$pair@$$CBHU_tagWaiting@@@1@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> > >::operator->
_TEXT	ENDS
PUBLIC	??C?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@std@@QBEPAU?$pair@$$CBHU_tagObserverInfo@@@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> > >::operator->
; Function compile flags: /Ogtp
;	COMDAT ??C?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@std@@QBEPAU?$pair@$$CBHU_tagObserverInfo@@@1@XZ
_TEXT	SEGMENT
??C?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@std@@QBEPAU?$pair@$$CBHU_tagObserverInfo@@@1@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> > >::operator->, COMDAT
; _this$ = ecx

; 401  : 		return (&**this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 0c	 add	 eax, 12			; 0000000cH

; 402  : 		}

  00005	c3		 ret	 0
??C?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@std@@QBEPAU?$pair@$$CBHU_tagObserverInfo@@@1@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> > >::operator->
_TEXT	ENDS
PUBLIC	??E?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> > >::operator++
; Function compile flags: /Ogtp
;	COMDAT ??E?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> > >::operator++, COMDAT
; _this$ = ecx

; 405  : 		{	// preincrement

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 406  : 		++(*(_Mybase *)this);

  00003	e8 00 00 00 00	 call	 ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >,std::_Iterator_base0>::operator++

; 407  : 		return (*this);

  00008	8b c6		 mov	 eax, esi
  0000a	5e		 pop	 esi

; 408  : 		}

  0000b	c3		 ret	 0
??E?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> > >::operator++
_TEXT	ENDS
PUBLIC	??E?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> > >::operator++
; Function compile flags: /Ogtp
;	COMDAT ??E?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??E?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@std@@QAE?AV01@H@Z PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> > >::operator++, COMDAT
; _this$ = ecx

; 411  : 		{	// postincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 412  : 		_Myiter _Tmp = *this;

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	56		 push	 esi
  00006	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  00009	89 06		 mov	 DWORD PTR [esi], eax

; 413  : 		++*this;

  0000b	e8 00 00 00 00	 call	 ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >,std::_Iterator_base0>::operator++

; 414  : 		return (_Tmp);

  00010	8b c6		 mov	 eax, esi
  00012	5e		 pop	 esi

; 415  : 		}

  00013	5d		 pop	 ebp
  00014	c2 08 00	 ret	 8
??E?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@std@@QAE?AV01@H@Z ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> > >::operator++
_TEXT	ENDS
PUBLIC	?_Lrotate@?$_Tree@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::_Lrotate
; Function compile flags: /Ogtp
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Wherenode$ = 8					; size = 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::_Lrotate, COMDAT
; _this$ = ecx

; 1763 : 		{	// promote right node to root of subtree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1764 : 		_Nodeptr _Pnode = this->_Right(_Wherenode);

  00003	8b 55 08	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  00006	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00009	56		 push	 esi

; 1765 : 		this->_Right(_Wherenode) = this->_Left(_Pnode);

  0000a	8b 30		 mov	 esi, DWORD PTR [eax]
  0000c	89 72 08	 mov	 DWORD PTR [edx+8], esi

; 1766 : 
; 1767 : 		if (!this->_Isnil(this->_Left(_Pnode)))

  0000f	8b 30		 mov	 esi, DWORD PTR [eax]
  00011	80 7e 21 00	 cmp	 BYTE PTR [esi+33], 0
  00015	75 03		 jne	 SHORT $LN5@Lrotate

; 1768 : 			this->_Parent(this->_Left(_Pnode)) = _Wherenode;

  00017	89 56 04	 mov	 DWORD PTR [esi+4], edx
$LN5@Lrotate:

; 1769 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

  0001a	8b 72 04	 mov	 esi, DWORD PTR [edx+4]
  0001d	89 70 04	 mov	 DWORD PTR [eax+4], esi

; 1770 : 
; 1771 : 		if (_Wherenode == _Root())

  00020	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00023	5e		 pop	 esi
  00024	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00027	75 0c		 jne	 SHORT $LN4@Lrotate

; 1772 : 			_Root() = _Pnode;

  00029	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1777 : 
; 1778 : 		this->_Left(_Pnode) = _Wherenode;

  0002c	89 10		 mov	 DWORD PTR [eax], edx

; 1779 : 		this->_Parent(_Wherenode) = _Pnode;

  0002e	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 1780 : 		}

  00031	5d		 pop	 ebp
  00032	c2 04 00	 ret	 4
$LN4@Lrotate:

; 1773 : 		else if (_Wherenode == this->_Left(this->_Parent(_Wherenode)))

  00035	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00038	3b 11		 cmp	 edx, DWORD PTR [ecx]
  0003a	75 0b		 jne	 SHORT $LN2@Lrotate

; 1774 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;

  0003c	89 01		 mov	 DWORD PTR [ecx], eax

; 1777 : 
; 1778 : 		this->_Left(_Pnode) = _Wherenode;

  0003e	89 10		 mov	 DWORD PTR [eax], edx

; 1779 : 		this->_Parent(_Wherenode) = _Pnode;

  00040	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 1780 : 		}

  00043	5d		 pop	 ebp
  00044	c2 04 00	 ret	 4
$LN2@Lrotate:

; 1775 : 		else
; 1776 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;

  00047	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 1777 : 
; 1778 : 		this->_Left(_Pnode) = _Wherenode;

  0004a	89 10		 mov	 DWORD PTR [eax], edx

; 1779 : 		this->_Parent(_Wherenode) = _Pnode;

  0004c	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 1780 : 		}

  0004f	5d		 pop	 ebp
  00050	c2 04 00	 ret	 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::_Lrotate
_TEXT	ENDS
PUBLIC	?_Lrotate@?$_Tree@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::_Lrotate
; Function compile flags: /Ogtp
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Wherenode$ = 8					; size = 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::_Lrotate, COMDAT
; _this$ = ecx

; 1763 : 		{	// promote right node to root of subtree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1764 : 		_Nodeptr _Pnode = this->_Right(_Wherenode);

  00003	8b 55 08	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  00006	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00009	56		 push	 esi

; 1765 : 		this->_Right(_Wherenode) = this->_Left(_Pnode);

  0000a	8b 30		 mov	 esi, DWORD PTR [eax]
  0000c	89 72 08	 mov	 DWORD PTR [edx+8], esi

; 1766 : 
; 1767 : 		if (!this->_Isnil(this->_Left(_Pnode)))

  0000f	8b 30		 mov	 esi, DWORD PTR [eax]
  00011	80 7e 25 00	 cmp	 BYTE PTR [esi+37], 0
  00015	75 03		 jne	 SHORT $LN5@Lrotate@2

; 1768 : 			this->_Parent(this->_Left(_Pnode)) = _Wherenode;

  00017	89 56 04	 mov	 DWORD PTR [esi+4], edx
$LN5@Lrotate@2:

; 1769 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

  0001a	8b 72 04	 mov	 esi, DWORD PTR [edx+4]
  0001d	89 70 04	 mov	 DWORD PTR [eax+4], esi

; 1770 : 
; 1771 : 		if (_Wherenode == _Root())

  00020	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00023	5e		 pop	 esi
  00024	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00027	75 0c		 jne	 SHORT $LN4@Lrotate@2

; 1772 : 			_Root() = _Pnode;

  00029	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1777 : 
; 1778 : 		this->_Left(_Pnode) = _Wherenode;

  0002c	89 10		 mov	 DWORD PTR [eax], edx

; 1779 : 		this->_Parent(_Wherenode) = _Pnode;

  0002e	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 1780 : 		}

  00031	5d		 pop	 ebp
  00032	c2 04 00	 ret	 4
$LN4@Lrotate@2:

; 1773 : 		else if (_Wherenode == this->_Left(this->_Parent(_Wherenode)))

  00035	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00038	3b 11		 cmp	 edx, DWORD PTR [ecx]
  0003a	75 0b		 jne	 SHORT $LN2@Lrotate@2

; 1774 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;

  0003c	89 01		 mov	 DWORD PTR [ecx], eax

; 1777 : 
; 1778 : 		this->_Left(_Pnode) = _Wherenode;

  0003e	89 10		 mov	 DWORD PTR [eax], edx

; 1779 : 		this->_Parent(_Wherenode) = _Pnode;

  00040	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 1780 : 		}

  00043	5d		 pop	 ebp
  00044	c2 04 00	 ret	 4
$LN2@Lrotate@2:

; 1775 : 		else
; 1776 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;

  00047	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 1777 : 
; 1778 : 		this->_Left(_Pnode) = _Wherenode;

  0004a	89 10		 mov	 DWORD PTR [eax], edx

; 1779 : 		this->_Parent(_Wherenode) = _Pnode;

  0004c	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 1780 : 		}

  0004f	5d		 pop	 ebp
  00050	c2 04 00	 ret	 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::_Lrotate
_TEXT	ENDS
PUBLIC	??E?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> > >::operator++
; Function compile flags: /Ogtp
;	COMDAT ??E?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> > >::operator++, COMDAT
; _this$ = ecx

; 405  : 		{	// preincrement

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 406  : 		++(*(_Mybase *)this);

  00003	e8 00 00 00 00	 call	 ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >,std::_Iterator_base0>::operator++

; 407  : 		return (*this);

  00008	8b c6		 mov	 eax, esi
  0000a	5e		 pop	 esi

; 408  : 		}

  0000b	c3		 ret	 0
??E?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> > >::operator++
_TEXT	ENDS
PUBLIC	??0?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >
; Function compile flags: /Ogtp
;	COMDAT ??0?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@1@@Z
_TEXT	SEGMENT
$T195705 = -16						; size = 12
$T195689 = -4						; size = 4
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@1@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >, COMDAT
; _this$ = ecx

; 542  : 		{	// construct base, and allocator from _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx

; 543  : 		this->_Mysize = 0;
; 544  : 		this->_Myhead = this->_Alnod.allocate(1);

  00009	6a 24		 push	 36			; 00000024H
  0000b	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00012	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00017	83 c4 04	 add	 esp, 4
  0001a	85 c0		 test	 eax, eax
  0001c	74 28		 je	 SHORT $LN15@Tree_val
  0001e	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 545  : 
; 546  : 		this->_Left(this->_Myhead) = this->_Myhead;

  00021	89 00		 mov	 DWORD PTR [eax], eax

; 547  : 		this->_Parent(this->_Myhead) = this->_Myhead;

  00023	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00026	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 548  : 		this->_Right(this->_Myhead) = this->_Myhead;

  00029	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0002c	89 40 08	 mov	 DWORD PTR [eax+8], eax

; 549  : 		this->_Color(this->_Myhead) = this->_Black;

  0002f	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00032	b0 01		 mov	 al, 1
  00034	88 41 20	 mov	 BYTE PTR [ecx+32], al

; 550  : 		this->_Isnil(this->_Myhead) = true;

  00037	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0003a	88 42 21	 mov	 BYTE PTR [edx+33], al

; 551  : 		}

  0003d	8b c6		 mov	 eax, esi
  0003f	5e		 pop	 esi
  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c2 08 00	 ret	 8

; 543  : 		this->_Mysize = 0;
; 544  : 		this->_Myhead = this->_Alnod.allocate(1);

$LN15@Tree_val:
  00046	8d 45 fc	 lea	 eax, DWORD PTR $T195689[ebp]
  00049	50		 push	 eax
  0004a	8d 4d f0	 lea	 ecx, DWORD PTR $T195705[ebp]
  0004d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T195689[ebp], 0
  00054	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00059	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0005e	8d 4d f0	 lea	 ecx, DWORD PTR $T195705[ebp]
  00061	51		 push	 ecx
  00062	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T195705[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00069	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN37@Tree_val:
$LN36@Tree_val:
  0006e	cc		 int	 3
??0?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@1@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >
_TEXT	ENDS
PUBLIC	??0?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >
; Function compile flags: /Ogtp
;	COMDAT ??0?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@1@@Z
_TEXT	SEGMENT
$T195784 = -16						; size = 12
$T195768 = -4						; size = 4
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@1@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >, COMDAT
; _this$ = ecx

; 542  : 		{	// construct base, and allocator from _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx

; 543  : 		this->_Mysize = 0;
; 544  : 		this->_Myhead = this->_Alnod.allocate(1);

  00009	6a 28		 push	 40			; 00000028H
  0000b	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00012	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00017	83 c4 04	 add	 esp, 4
  0001a	85 c0		 test	 eax, eax
  0001c	74 28		 je	 SHORT $LN15@Tree_val@2
  0001e	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 545  : 
; 546  : 		this->_Left(this->_Myhead) = this->_Myhead;

  00021	89 00		 mov	 DWORD PTR [eax], eax

; 547  : 		this->_Parent(this->_Myhead) = this->_Myhead;

  00023	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00026	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 548  : 		this->_Right(this->_Myhead) = this->_Myhead;

  00029	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0002c	89 40 08	 mov	 DWORD PTR [eax+8], eax

; 549  : 		this->_Color(this->_Myhead) = this->_Black;

  0002f	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00032	b0 01		 mov	 al, 1
  00034	88 41 24	 mov	 BYTE PTR [ecx+36], al

; 550  : 		this->_Isnil(this->_Myhead) = true;

  00037	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0003a	88 42 25	 mov	 BYTE PTR [edx+37], al

; 551  : 		}

  0003d	8b c6		 mov	 eax, esi
  0003f	5e		 pop	 esi
  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c2 08 00	 ret	 8

; 543  : 		this->_Mysize = 0;
; 544  : 		this->_Myhead = this->_Alnod.allocate(1);

$LN15@Tree_val@2:
  00046	8d 45 fc	 lea	 eax, DWORD PTR $T195768[ebp]
  00049	50		 push	 eax
  0004a	8d 4d f0	 lea	 ecx, DWORD PTR $T195784[ebp]
  0004d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T195768[ebp], 0
  00054	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00059	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0005e	8d 4d f0	 lea	 ecx, DWORD PTR $T195784[ebp]
  00061	51		 push	 ecx
  00062	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T195784[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00069	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN37@Tree_val@2:
$LN36@Tree_val@2:
  0006e	cc		 int	 3
??0?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@1@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >
_TEXT	ENDS
PUBLIC	??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@1@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> > >::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> > >
; Function compile flags: /Ogtp
;	COMDAT ??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@1@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> > >::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> > >, COMDAT
; _this$ = ecx

; 213  : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 214  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@1@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> > >::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> > >
_TEXT	ENDS
PUBLIC	??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@1@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> > >::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> > >
; Function compile flags: /Ogtp
;	COMDAT ??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@1@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> > >::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> > >, COMDAT
; _this$ = ecx

; 213  : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 214  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@1@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> > >::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> > >
_TEXT	ENDS
PUBLIC	??$make_pair@AAHAAU_tagWaiting@@@std@@YA?AU?$pair@HU_tagWaiting@@@0@AAHAAU_tagWaiting@@@Z ; std::make_pair<int &,_tagWaiting &>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$make_pair@AAHAAU_tagWaiting@@@std@@YA?AU?$pair@HU_tagWaiting@@@0@AAHAAU_tagWaiting@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Val1$ = 12						; size = 4
__Val2$ = 16						; size = 4
??$make_pair@AAHAAU_tagWaiting@@@std@@YA?AU?$pair@HU_tagWaiting@@@0@AAHAAU_tagWaiting@@@Z PROC ; std::make_pair<int &,_tagWaiting &>, COMDAT

; 356  : 	{	// return pair composed from arguments

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 357  : 	typedef pair<typename _Unrefwrap<_Ty1>::type,
; 358  : 		typename _Unrefwrap<_Ty2>::type> _Mypair;
; 359  : 	return (_Mypair(_STD forward<_Ty1>(_Val1),

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Val1$[ebp]
  00006	8b 08		 mov	 ecx, DWORD PTR [eax]
  00008	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0000b	89 08		 mov	 DWORD PTR [eax], ecx
  0000d	8b 4d 10	 mov	 ecx, DWORD PTR __Val2$[ebp]
  00010	8b 11		 mov	 edx, DWORD PTR [ecx]
  00012	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00015	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00018	89 50 08	 mov	 DWORD PTR [eax+8], edx
  0001b	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0001e	8b 49 0c	 mov	 ecx, DWORD PTR [ecx+12]
  00021	89 50 0c	 mov	 DWORD PTR [eax+12], edx
  00024	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 360  : 		_STD forward<_Ty2>(_Val2)));
; 361  : 	}

  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??$make_pair@AAHAAU_tagWaiting@@@std@@YA?AU?$pair@HU_tagWaiting@@@0@AAHAAU_tagWaiting@@@Z ENDP ; std::make_pair<int &,_tagWaiting &>
_TEXT	ENDS
PUBLIC	??$make_pair@AAHAAU_tagObserverInfo@@@std@@YA?AU?$pair@HU_tagObserverInfo@@@0@AAHAAU_tagObserverInfo@@@Z ; std::make_pair<int &,_tagObserverInfo &>
; Function compile flags: /Ogtp
;	COMDAT ??$make_pair@AAHAAU_tagObserverInfo@@@std@@YA?AU?$pair@HU_tagObserverInfo@@@0@AAHAAU_tagObserverInfo@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Val1$ = 12						; size = 4
__Val2$ = 16						; size = 4
??$make_pair@AAHAAU_tagObserverInfo@@@std@@YA?AU?$pair@HU_tagObserverInfo@@@0@AAHAAU_tagObserverInfo@@@Z PROC ; std::make_pair<int &,_tagObserverInfo &>, COMDAT

; 356  : 	{	// return pair composed from arguments

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 357  : 	typedef pair<typename _Unrefwrap<_Ty1>::type,
; 358  : 		typename _Unrefwrap<_Ty2>::type> _Mypair;
; 359  : 	return (_Mypair(_STD forward<_Ty1>(_Val1),

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Val1$[ebp]
  00006	8b 08		 mov	 ecx, DWORD PTR [eax]
  00008	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0000b	89 08		 mov	 DWORD PTR [eax], ecx
  0000d	8b 4d 10	 mov	 ecx, DWORD PTR __Val2$[ebp]
  00010	8b 11		 mov	 edx, DWORD PTR [ecx]
  00012	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00015	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00018	89 50 08	 mov	 DWORD PTR [eax+8], edx
  0001b	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0001e	89 50 0c	 mov	 DWORD PTR [eax+12], edx
  00021	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00024	8b 49 10	 mov	 ecx, DWORD PTR [ecx+16]
  00027	89 50 10	 mov	 DWORD PTR [eax+16], edx
  0002a	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 360  : 		_STD forward<_Ty2>(_Val2)));
; 361  : 	}

  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
??$make_pair@AAHAAU_tagObserverInfo@@@std@@YA?AU?$pair@HU_tagObserverInfo@@@0@AAHAAU_tagObserverInfo@@@Z ENDP ; std::make_pair<int &,_tagObserverInfo &>
_TEXT	ENDS
PUBLIC	??$_Dest_val@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@std@@U?$pair@$$CBHU_tagWaiting@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@0@PAU?$pair@$$CBHU_tagWaiting@@@0@@Z ; std::_Dest_val<std::allocator<std::pair<int const ,_tagWaiting> >,std::pair<int const ,_tagWaiting> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Dest_val@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@std@@U?$pair@$$CBHU_tagWaiting@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@0@PAU?$pair@$$CBHU_tagWaiting@@@0@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
??$_Dest_val@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@std@@U?$pair@$$CBHU_tagWaiting@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@0@PAU?$pair@$$CBHU_tagWaiting@@@0@@Z PROC ; std::_Dest_val<std::allocator<std::pair<int const ,_tagWaiting> >,std::pair<int const ,_tagWaiting> >, COMDAT

; 287  : 	_Alval.destroy(_Pdest);
; 288  : 	}

  00000	c3		 ret	 0
??$_Dest_val@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@std@@U?$pair@$$CBHU_tagWaiting@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@0@PAU?$pair@$$CBHU_tagWaiting@@@0@@Z ENDP ; std::_Dest_val<std::allocator<std::pair<int const ,_tagWaiting> >,std::pair<int const ,_tagWaiting> >
_TEXT	ENDS
PUBLIC	??$_Dest_val@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@std@@U?$pair@$$CBHU_tagObserverInfo@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@0@PAU?$pair@$$CBHU_tagObserverInfo@@@0@@Z ; std::_Dest_val<std::allocator<std::pair<int const ,_tagObserverInfo> >,std::pair<int const ,_tagObserverInfo> >
; Function compile flags: /Ogtp
;	COMDAT ??$_Dest_val@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@std@@U?$pair@$$CBHU_tagObserverInfo@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@0@PAU?$pair@$$CBHU_tagObserverInfo@@@0@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
??$_Dest_val@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@std@@U?$pair@$$CBHU_tagObserverInfo@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@0@PAU?$pair@$$CBHU_tagObserverInfo@@@0@@Z PROC ; std::_Dest_val<std::allocator<std::pair<int const ,_tagObserverInfo> >,std::pair<int const ,_tagObserverInfo> >, COMDAT

; 287  : 	_Alval.destroy(_Pdest);
; 288  : 	}

  00000	c3		 ret	 0
??$_Dest_val@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@std@@U?$pair@$$CBHU_tagObserverInfo@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@0@PAU?$pair@$$CBHU_tagObserverInfo@@@0@@Z ENDP ; std::_Dest_val<std::allocator<std::pair<int const ,_tagObserverInfo> >,std::pair<int const ,_tagObserverInfo> >
_TEXT	ENDS
PUBLIC	??F?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> > >::operator--
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??F?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> > >::operator--, COMDAT
; _this$ = ecx

; 418  : 		{	// predecrement

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 419  : 		--(*(_Mybase *)this);

  00003	e8 00 00 00 00	 call	 ??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >,std::_Iterator_base0>::operator--

; 420  : 		return (*this);

  00008	8b c6		 mov	 eax, esi
  0000a	5e		 pop	 esi

; 421  : 		}

  0000b	c3		 ret	 0
??F?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> > >::operator--
_TEXT	ENDS
PUBLIC	??0?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> > >,bool>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??0?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z PROC ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> > >,bool>, COMDAT
; _this$ = ecx

; 227  : 		{	// construct from specified values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Val1$[ebp]
  00008	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Val2$[ebp]
  0000d	89 10		 mov	 DWORD PTR [eax], edx
  0000f	8a 11		 mov	 dl, BYTE PTR [ecx]
  00011	88 50 04	 mov	 BYTE PTR [eax+4], dl

; 228  : 		}

  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
??0?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z ENDP ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> > >,bool>
_TEXT	ENDS
PUBLIC	??F?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> > >::operator--
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??F?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> > >::operator--, COMDAT
; _this$ = ecx

; 418  : 		{	// predecrement

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 419  : 		--(*(_Mybase *)this);

  00003	e8 00 00 00 00	 call	 ??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >,std::_Iterator_base0>::operator--

; 420  : 		return (*this);

  00008	8b c6		 mov	 eax, esi
  0000a	5e		 pop	 esi

; 421  : 		}

  0000b	c3		 ret	 0
??F?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> > >::operator--
_TEXT	ENDS
PUBLIC	??0?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> > >,bool>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??0?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z PROC ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> > >,bool>, COMDAT
; _this$ = ecx

; 227  : 		{	// construct from specified values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Val1$[ebp]
  00008	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Val2$[ebp]
  0000d	89 10		 mov	 DWORD PTR [eax], edx
  0000f	8a 11		 mov	 dl, BYTE PTR [ecx]
  00011	88 50 04	 mov	 BYTE PTR [eax+4], dl

; 228  : 		}

  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
??0?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z ENDP ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> > >,bool>
_TEXT	ENDS
PUBLIC	??$construct@U?$pair@HU_tagWaiting@@@std@@@?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@std@@QAEXPAU?$pair@$$CBHU_tagWaiting@@@1@$$QAU?$pair@HU_tagWaiting@@@1@@Z ; std::allocator<std::pair<int const ,_tagWaiting> >::construct<std::pair<int,_tagWaiting> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$construct@U?$pair@HU_tagWaiting@@@std@@@?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@std@@QAEXPAU?$pair@$$CBHU_tagWaiting@@@1@$$QAU?$pair@HU_tagWaiting@@@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$construct@U?$pair@HU_tagWaiting@@@std@@@?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@std@@QAEXPAU?$pair@$$CBHU_tagWaiting@@@1@$$QAU?$pair@HU_tagWaiting@@@1@@Z PROC ; std::allocator<std::pair<int const ,_tagWaiting> >::construct<std::pair<int,_tagWaiting> >, COMDAT
; _this$ = ecx

; 206  : 		void construct(pointer _Ptr, _Other&& _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 207  : 		{	// construct object at _Ptr with value _Val
; 208  : 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Other>(_Val));

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 1f		 je	 SHORT $LN3@construct
  0000a	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  0000d	8b 10		 mov	 edx, DWORD PTR [eax]
  0000f	89 11		 mov	 DWORD PTR [ecx], edx
  00011	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00014	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  00017	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0001a	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  0001d	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  00020	89 51 0c	 mov	 DWORD PTR [ecx+12], edx
  00023	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00026	89 41 10	 mov	 DWORD PTR [ecx+16], eax
$LN3@construct:

; 209  : 		}

  00029	5d		 pop	 ebp
  0002a	c2 08 00	 ret	 8
??$construct@U?$pair@HU_tagWaiting@@@std@@@?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@std@@QAEXPAU?$pair@$$CBHU_tagWaiting@@@1@$$QAU?$pair@HU_tagWaiting@@@1@@Z ENDP ; std::allocator<std::pair<int const ,_tagWaiting> >::construct<std::pair<int,_tagWaiting> >
_TEXT	ENDS
PUBLIC	??$construct@U?$pair@HU_tagObserverInfo@@@std@@@?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@std@@QAEXPAU?$pair@$$CBHU_tagObserverInfo@@@1@$$QAU?$pair@HU_tagObserverInfo@@@1@@Z ; std::allocator<std::pair<int const ,_tagObserverInfo> >::construct<std::pair<int,_tagObserverInfo> >
; Function compile flags: /Ogtp
;	COMDAT ??$construct@U?$pair@HU_tagObserverInfo@@@std@@@?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@std@@QAEXPAU?$pair@$$CBHU_tagObserverInfo@@@1@$$QAU?$pair@HU_tagObserverInfo@@@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$construct@U?$pair@HU_tagObserverInfo@@@std@@@?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@std@@QAEXPAU?$pair@$$CBHU_tagObserverInfo@@@1@$$QAU?$pair@HU_tagObserverInfo@@@1@@Z PROC ; std::allocator<std::pair<int const ,_tagObserverInfo> >::construct<std::pair<int,_tagObserverInfo> >, COMDAT
; _this$ = ecx

; 206  : 		void construct(pointer _Ptr, _Other&& _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 207  : 		{	// construct object at _Ptr with value _Val
; 208  : 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Other>(_Val));

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 25		 je	 SHORT $LN3@construct@2
  0000a	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  0000d	8b 10		 mov	 edx, DWORD PTR [eax]
  0000f	89 11		 mov	 DWORD PTR [ecx], edx
  00011	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00014	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  00017	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0001a	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  0001d	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  00020	89 51 0c	 mov	 DWORD PTR [ecx+12], edx
  00023	8b 50 10	 mov	 edx, DWORD PTR [eax+16]
  00026	89 51 10	 mov	 DWORD PTR [ecx+16], edx
  00029	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  0002c	89 41 14	 mov	 DWORD PTR [ecx+20], eax
$LN3@construct@2:

; 209  : 		}

  0002f	5d		 pop	 ebp
  00030	c2 08 00	 ret	 8
??$construct@U?$pair@HU_tagObserverInfo@@@std@@@?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@std@@QAEXPAU?$pair@$$CBHU_tagObserverInfo@@@1@$$QAU?$pair@HU_tagObserverInfo@@@1@@Z ENDP ; std::allocator<std::pair<int const ,_tagObserverInfo> >::construct<std::pair<int,_tagObserverInfo> >
_TEXT	ENDS
PUBLIC	??E?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> > >::operator++
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??E?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??E?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@std@@QAE?AV01@H@Z PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> > >::operator++, COMDAT
; _this$ = ecx

; 411  : 		{	// postincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 412  : 		_Myiter _Tmp = *this;

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	56		 push	 esi
  00006	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  00009	89 06		 mov	 DWORD PTR [esi], eax

; 413  : 		++*this;

  0000b	e8 00 00 00 00	 call	 ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >,std::_Iterator_base0>::operator++

; 414  : 		return (_Tmp);

  00010	8b c6		 mov	 eax, esi
  00012	5e		 pop	 esi

; 415  : 		}

  00013	5d		 pop	 ebp
  00014	c2 08 00	 ret	 8
??E?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@std@@QAE?AV01@H@Z ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> > >::operator++
_TEXT	ENDS
PUBLIC	??0?$_Tree@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::_Tree<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >
; Function compile flags: /Ogtp
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@1@@Z
_TEXT	SEGMENT
$T196174 = -16						; size = 12
$T196114 = -4						; size = 4
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 4
??0?$_Tree@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::_Tree<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >, COMDAT
; _this$ = ecx

; 698  : 		{	// construct empty tree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	6a 24		 push	 36			; 00000024H
  0000b	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00012	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00017	83 c4 04	 add	 esp, 4
  0001a	85 c0		 test	 eax, eax
  0001c	74 28		 je	 SHORT $LN20@Tree
  0001e	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00021	89 00		 mov	 DWORD PTR [eax], eax
  00023	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00026	89 40 04	 mov	 DWORD PTR [eax+4], eax
  00029	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0002c	89 40 08	 mov	 DWORD PTR [eax+8], eax
  0002f	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00032	b0 01		 mov	 al, 1
  00034	88 41 20	 mov	 BYTE PTR [ecx+32], al
  00037	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0003a	88 42 21	 mov	 BYTE PTR [edx+33], al

; 699  : 		}

  0003d	8b c6		 mov	 eax, esi
  0003f	5e		 pop	 esi
  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c2 08 00	 ret	 8

; 698  : 		{	// construct empty tree

$LN20@Tree:
  00046	8d 45 fc	 lea	 eax, DWORD PTR $T196114[ebp]
  00049	50		 push	 eax
  0004a	8d 4d f0	 lea	 ecx, DWORD PTR $T196174[ebp]
  0004d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T196114[ebp], 0
  00054	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00059	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0005e	8d 4d f0	 lea	 ecx, DWORD PTR $T196174[ebp]
  00061	51		 push	 ecx
  00062	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T196174[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00069	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN43@Tree:
$LN42@Tree:
  0006e	cc		 int	 3
??0?$_Tree@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::_Tree<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >
_TEXT	ENDS
PUBLIC	?_Erase@?$_Tree@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::_Erase
; Function compile flags: /Ogtp
;	COMDAT ?_Erase@?$_Tree@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Rootnode$ = 8						; size = 4
?_Erase@?$_Tree@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::_Erase, COMDAT
; _this$ = ecx

; 1610 : 		{	// free entire subtree, recursively

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	57		 push	 edi

; 1611 : 		for (_Nodeptr _Pnode = _Rootnode;

  00006	8b 7d 08	 mov	 edi, DWORD PTR __Rootnode$[ebp]

; 1612 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)

  00009	80 7f 21 00	 cmp	 BYTE PTR [edi+33], 0
  0000d	8b d9		 mov	 ebx, ecx
  0000f	8b f7		 mov	 esi, edi
  00011	75 1e		 jne	 SHORT $LN1@Erase
$LL3@Erase:

; 1613 : 			{	// free subtrees, then node
; 1614 : 			_Erase(this->_Right(_Pnode));

  00013	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00016	50		 push	 eax
  00017	8b cb		 mov	 ecx, ebx
  00019	e8 00 00 00 00	 call	 ?_Erase@?$_Tree@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::_Erase

; 1615 : 			_Pnode = this->_Left(_Pnode);

  0001e	8b 36		 mov	 esi, DWORD PTR [esi]

; 1616 : 			_Dest_val(this->_Alval,
; 1617 : 				_STD addressof(this->_Myval(_Rootnode)));
; 1618 : 
; 1619 : 			this->_Alnod.deallocate(_Rootnode, 1);

  00020	57		 push	 edi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00026	83 c4 04	 add	 esp, 4
  00029	80 7e 21 00	 cmp	 BYTE PTR [esi+33], 0
  0002d	8b fe		 mov	 edi, esi
  0002f	74 e2		 je	 SHORT $LL3@Erase
$LN1@Erase:
  00031	5f		 pop	 edi
  00032	5e		 pop	 esi
  00033	5b		 pop	 ebx

; 1620 : 			}
; 1621 : 		}

  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4
?_Erase@?$_Tree@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::_Erase
_TEXT	ENDS
PUBLIC	??0?$_Tree@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::_Tree<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >
; Function compile flags: /Ogtp
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@1@@Z
_TEXT	SEGMENT
$T196319 = -16						; size = 12
$T196259 = -4						; size = 4
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 4
??0?$_Tree@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::_Tree<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >, COMDAT
; _this$ = ecx

; 698  : 		{	// construct empty tree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	6a 28		 push	 40			; 00000028H
  0000b	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00012	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00017	83 c4 04	 add	 esp, 4
  0001a	85 c0		 test	 eax, eax
  0001c	74 28		 je	 SHORT $LN20@Tree@2
  0001e	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00021	89 00		 mov	 DWORD PTR [eax], eax
  00023	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00026	89 40 04	 mov	 DWORD PTR [eax+4], eax
  00029	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0002c	89 40 08	 mov	 DWORD PTR [eax+8], eax
  0002f	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00032	b0 01		 mov	 al, 1
  00034	88 41 24	 mov	 BYTE PTR [ecx+36], al
  00037	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0003a	88 42 25	 mov	 BYTE PTR [edx+37], al

; 699  : 		}

  0003d	8b c6		 mov	 eax, esi
  0003f	5e		 pop	 esi
  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c2 08 00	 ret	 8

; 698  : 		{	// construct empty tree

$LN20@Tree@2:
  00046	8d 45 fc	 lea	 eax, DWORD PTR $T196259[ebp]
  00049	50		 push	 eax
  0004a	8d 4d f0	 lea	 ecx, DWORD PTR $T196319[ebp]
  0004d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T196259[ebp], 0
  00054	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00059	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0005e	8d 4d f0	 lea	 ecx, DWORD PTR $T196319[ebp]
  00061	51		 push	 ecx
  00062	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T196319[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00069	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN43@Tree@2:
$LN42@Tree@2:
  0006e	cc		 int	 3
??0?$_Tree@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::_Tree<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >
_TEXT	ENDS
PUBLIC	?_Erase@?$_Tree@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::_Erase
; Function compile flags: /Ogtp
;	COMDAT ?_Erase@?$_Tree@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Rootnode$ = 8						; size = 4
?_Erase@?$_Tree@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::_Erase, COMDAT
; _this$ = ecx

; 1610 : 		{	// free entire subtree, recursively

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	57		 push	 edi

; 1611 : 		for (_Nodeptr _Pnode = _Rootnode;

  00006	8b 7d 08	 mov	 edi, DWORD PTR __Rootnode$[ebp]

; 1612 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)

  00009	80 7f 25 00	 cmp	 BYTE PTR [edi+37], 0
  0000d	8b d9		 mov	 ebx, ecx
  0000f	8b f7		 mov	 esi, edi
  00011	75 1e		 jne	 SHORT $LN1@Erase@2
$LL3@Erase@2:

; 1613 : 			{	// free subtrees, then node
; 1614 : 			_Erase(this->_Right(_Pnode));

  00013	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00016	50		 push	 eax
  00017	8b cb		 mov	 ecx, ebx
  00019	e8 00 00 00 00	 call	 ?_Erase@?$_Tree@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::_Erase

; 1615 : 			_Pnode = this->_Left(_Pnode);

  0001e	8b 36		 mov	 esi, DWORD PTR [esi]

; 1616 : 			_Dest_val(this->_Alval,
; 1617 : 				_STD addressof(this->_Myval(_Rootnode)));
; 1618 : 
; 1619 : 			this->_Alnod.deallocate(_Rootnode, 1);

  00020	57		 push	 edi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00026	83 c4 04	 add	 esp, 4
  00029	80 7e 25 00	 cmp	 BYTE PTR [esi+37], 0
  0002d	8b fe		 mov	 edi, esi
  0002f	74 e2		 je	 SHORT $LL3@Erase@2
$LN1@Erase@2:
  00031	5f		 pop	 edi
  00032	5e		 pop	 esi
  00033	5b		 pop	 ebx

; 1620 : 			}
; 1621 : 		}

  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4
?_Erase@?$_Tree@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::_Erase
_TEXT	ENDS
PUBLIC	??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@1@@Z ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> > >::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> > >
; Function compile flags: /Ogtp
;	COMDAT ??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@1@@Z PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> > >::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> > >, COMDAT
; _this$ = ecx

; 378  : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 379  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@1@@Z ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> > >::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> > >
_TEXT	ENDS
PUBLIC	??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@1@@Z ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> > >::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> > >
; Function compile flags: /Ogtp
;	COMDAT ??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@1@@Z PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> > >::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> > >, COMDAT
; _this$ = ecx

; 378  : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 379  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@1@@Z ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> > >::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> > >
_TEXT	ENDS
PUBLIC	??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?_Insert@?$_Tree@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::_Insert
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
;	COMDAT ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
CONST	SEGMENT
??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@ DB 'map/set<T> too l'
	DB	'ong', 00H					; `string'
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
CONST	ENDS
;	COMDAT ?_Insert@?$_Tree@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@2@1@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Addleft$ = 12						; size = 1
__Wherenode$ = 16					; size = 4
__Newnode$ = 20						; size = 4
?_Insert@?$_Tree@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@2@1@Z PROC ; std::_Tree<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::_Insert, COMDAT
; _this$ = ecx

; 1631 : 		{	// add node with value next to _Wherenode, to left if _Addleft

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1632 : 		if (max_size() - 1 <= this->_Mysize)

  00003	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00006	3d cb cc cc 0c	 cmp	 eax, 214748363		; 0ccccccbH
  0000b	72 16		 jb	 SHORT $LN17@Insert

; 1633 : 			{	// tree would get too big, fail
; 1634 : 			_Dest_val(this->_Alval,
; 1635 : 				_STD addressof(this->_Myval(_Newnode)));
; 1636 : 
; 1637 : 			this->_Alnod.deallocate(_Newnode, 1);

  0000d	8b 45 14	 mov	 eax, DWORD PTR __Newnode$[ebp]
  00010	50		 push	 eax
  00011	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00016	83 c4 04	 add	 esp, 4

; 1638 : 
; 1639 : 			_Xlength_error("map/set<T> too long");

  00019	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
  0001e	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN377@Insert:
$LN17@Insert:

; 1640 : 			}
; 1641 : 		++this->_Mysize;

  00023	40		 inc	 eax
  00024	53		 push	 ebx
  00025	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 1642 : 		_Newnode->_Parent = _Wherenode;

  00028	8b 45 10	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0002b	57		 push	 edi
  0002c	8b 7d 14	 mov	 edi, DWORD PTR __Newnode$[ebp]
  0002f	89 47 04	 mov	 DWORD PTR [edi+4], eax

; 1643 : 
; 1644 : 		if (_Wherenode == this->_Myhead)

  00032	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00035	32 db		 xor	 bl, bl
  00037	3b c2		 cmp	 eax, edx
  00039	75 10		 jne	 SHORT $LN16@Insert

; 1645 : 			{	// first node in tree, just set head values
; 1646 : 			_Root() = _Newnode;

  0003b	89 7a 04	 mov	 DWORD PTR [edx+4], edi

; 1647 : 			_Lmost() = _Newnode;

  0003e	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00041	89 3a		 mov	 DWORD PTR [edx], edi

; 1648 : 			_Rmost() = _Newnode;

  00043	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00046	89 78 08	 mov	 DWORD PTR [eax+8], edi
  00049	eb 20		 jmp	 SHORT $LN11@Insert
$LN16@Insert:

; 1649 : 			}
; 1650 : 		else if (_Addleft)

  0004b	38 5d 0c	 cmp	 BYTE PTR __Addleft$[ebp], bl
  0004e	74 0d		 je	 SHORT $LN14@Insert

; 1651 : 			{	// add to left of _Wherenode
; 1652 : 			this->_Left(_Wherenode) = _Newnode;

  00050	89 38		 mov	 DWORD PTR [eax], edi

; 1653 : 			if (_Wherenode == _Lmost())

  00052	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00055	3b 02		 cmp	 eax, DWORD PTR [edx]
  00057	75 12		 jne	 SHORT $LN11@Insert

; 1654 : 				_Lmost() = _Newnode;

  00059	89 3a		 mov	 DWORD PTR [edx], edi

; 1655 : 			}
; 1656 : 		else

  0005b	eb 0e		 jmp	 SHORT $LN11@Insert
$LN14@Insert:

; 1657 : 			{	// add to right of _Wherenode
; 1658 : 			this->_Right(_Wherenode) = _Newnode;

  0005d	89 78 08	 mov	 DWORD PTR [eax+8], edi

; 1659 : 			if (_Wherenode == _Rmost())

  00060	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00063	3b 42 08	 cmp	 eax, DWORD PTR [edx+8]
  00066	75 03		 jne	 SHORT $LN11@Insert

; 1660 : 				_Rmost() = _Newnode;

  00068	89 7a 08	 mov	 DWORD PTR [edx+8], edi
$LN11@Insert:

; 1661 : 			}
; 1662 : 
; 1663 : 		for (_Nodeptr _Pnode = _Newnode;
; 1664 : 			this->_Color(this->_Parent(_Pnode)) == this->_Red; )

  0006b	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  0006e	8b c7		 mov	 eax, edi
  00070	38 5a 20	 cmp	 BYTE PTR [edx+32], bl
  00073	0f 85 97 01 00
	00		 jne	 $LN9@Insert
  00079	56		 push	 esi
  0007a	8d 9b 00 00 00
	00		 npad	 6
$LL10@Insert:

; 1665 : 			if (this->_Parent(_Pnode)
; 1666 : 				== this->_Left(this->_Parent(this->_Parent(_Pnode))))

  00080	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00083	8b 72 04	 mov	 esi, DWORD PTR [edx+4]
  00086	3b 16		 cmp	 edx, DWORD PTR [esi]
  00088	0f 85 c1 00 00
	00		 jne	 $LN8@Insert

; 1667 : 				{	// fixup red-red in left subtree
; 1668 : 				_Wherenode =
; 1669 : 					this->_Right(this->_Parent(this->_Parent(_Pnode)));

  0008e	8b 76 08	 mov	 esi, DWORD PTR [esi+8]

; 1670 : 				if (this->_Color(_Wherenode) == this->_Red)

  00091	38 5e 20	 cmp	 BYTE PTR [esi+32], bl
  00094	75 1c		 jne	 SHORT $LN7@Insert

; 1671 : 					{	// parent has two red children, blacken both
; 1672 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;

  00096	c6 42 20 01	 mov	 BYTE PTR [edx+32], 1

; 1673 : 					this->_Color(_Wherenode) = this->_Black;

  0009a	c6 46 20 01	 mov	 BYTE PTR [esi+32], 1

; 1674 : 					this->_Color(this->_Parent(this->_Parent(_Pnode)))
; 1675 : 						= this->_Red;

  0009e	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000a1	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  000a4	88 5a 20	 mov	 BYTE PTR [edx+32], bl

; 1676 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));

  000a7	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000aa	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 1677 : 					}
; 1678 : 				else

  000ad	e9 51 01 00 00	 jmp	 $LN316@Insert
$LN7@Insert:

; 1679 : 					{	// parent has red and black children
; 1680 : 					if (_Pnode == this->_Right(this->_Parent(_Pnode)))

  000b2	3b 42 08	 cmp	 eax, DWORD PTR [edx+8]
  000b5	75 3a		 jne	 SHORT $LN111@Insert

; 1681 : 						{	// rotate right child to left
; 1682 : 						_Pnode = this->_Parent(_Pnode);

  000b7	8b c2		 mov	 eax, edx

; 1683 : 						_Lrotate(_Pnode);

  000b9	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  000bc	8b 32		 mov	 esi, DWORD PTR [edx]
  000be	89 70 08	 mov	 DWORD PTR [eax+8], esi
  000c1	8b 32		 mov	 esi, DWORD PTR [edx]
  000c3	38 5e 21	 cmp	 BYTE PTR [esi+33], bl
  000c6	75 03		 jne	 SHORT $LN110@Insert
  000c8	89 46 04	 mov	 DWORD PTR [esi+4], eax
$LN110@Insert:
  000cb	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  000ce	89 72 04	 mov	 DWORD PTR [edx+4], esi
  000d1	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  000d4	3b 46 04	 cmp	 eax, DWORD PTR [esi+4]
  000d7	75 05		 jne	 SHORT $LN109@Insert
  000d9	89 56 04	 mov	 DWORD PTR [esi+4], edx
  000dc	eb 0e		 jmp	 SHORT $LN106@Insert
$LN109@Insert:
  000de	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  000e1	3b 06		 cmp	 eax, DWORD PTR [esi]
  000e3	75 04		 jne	 SHORT $LN107@Insert
  000e5	89 16		 mov	 DWORD PTR [esi], edx
  000e7	eb 03		 jmp	 SHORT $LN106@Insert
$LN107@Insert:
  000e9	89 56 08	 mov	 DWORD PTR [esi+8], edx
$LN106@Insert:
  000ec	89 02		 mov	 DWORD PTR [edx], eax
  000ee	89 50 04	 mov	 DWORD PTR [eax+4], edx
$LN111@Insert:

; 1684 : 						}
; 1685 : 					this->_Color(this->_Parent(_Pnode)) =
; 1686 : 						this->_Black;	// propagate red up

  000f1	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000f4	c6 42 20 01	 mov	 BYTE PTR [edx+32], 1

; 1687 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1688 : 						this->_Red;

  000f8	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000fb	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  000fe	88 5a 20	 mov	 BYTE PTR [edx+32], bl

; 1689 : 					_Rrotate(this->_Parent(this->_Parent(_Pnode)));

  00101	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00104	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  00107	8b 32		 mov	 esi, DWORD PTR [edx]
  00109	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  0010c	89 3a		 mov	 DWORD PTR [edx], edi
  0010e	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  00111	38 5f 21	 cmp	 BYTE PTR [edi+33], bl
  00114	75 03		 jne	 SHORT $LN173@Insert
  00116	89 57 04	 mov	 DWORD PTR [edi+4], edx
$LN173@Insert:
  00119	8b 7a 04	 mov	 edi, DWORD PTR [edx+4]
  0011c	89 7e 04	 mov	 DWORD PTR [esi+4], edi
  0011f	8b 79 04	 mov	 edi, DWORD PTR [ecx+4]
  00122	3b 57 04	 cmp	 edx, DWORD PTR [edi+4]
  00125	75 0b		 jne	 SHORT $LN172@Insert
  00127	89 77 04	 mov	 DWORD PTR [edi+4], esi
  0012a	89 56 08	 mov	 DWORD PTR [esi+8], edx

; 1690 : 					}
; 1691 : 				}
; 1692 : 			else

  0012d	e9 cb 00 00 00	 jmp	 $LN376@Insert

; 1689 : 					_Rrotate(this->_Parent(this->_Parent(_Pnode)));

$LN172@Insert:
  00132	8b 7a 04	 mov	 edi, DWORD PTR [edx+4]
  00135	3b 57 08	 cmp	 edx, DWORD PTR [edi+8]
  00138	75 0b		 jne	 SHORT $LN170@Insert
  0013a	89 77 08	 mov	 DWORD PTR [edi+8], esi
  0013d	89 56 08	 mov	 DWORD PTR [esi+8], edx

; 1690 : 					}
; 1691 : 				}
; 1692 : 			else

  00140	e9 b8 00 00 00	 jmp	 $LN376@Insert

; 1689 : 					_Rrotate(this->_Parent(this->_Parent(_Pnode)));

$LN170@Insert:
  00145	89 37		 mov	 DWORD PTR [edi], esi
  00147	89 56 08	 mov	 DWORD PTR [esi+8], edx

; 1690 : 					}
; 1691 : 				}
; 1692 : 			else

  0014a	e9 ae 00 00 00	 jmp	 $LN376@Insert
$LN8@Insert:

; 1693 : 				{	// fixup red-red in right subtree
; 1694 : 				_Wherenode =
; 1695 : 					this->_Left(this->_Parent(this->_Parent(_Pnode)));

  0014f	8b 36		 mov	 esi, DWORD PTR [esi]

; 1696 : 				if (this->_Color(_Wherenode) == this->_Red)

  00151	38 5e 20	 cmp	 BYTE PTR [esi+32], bl
  00154	75 1c		 jne	 SHORT $LN3@Insert

; 1697 : 					{	// parent has two red children, blacken both
; 1698 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;

  00156	c6 42 20 01	 mov	 BYTE PTR [edx+32], 1

; 1699 : 					this->_Color(_Wherenode) = this->_Black;

  0015a	c6 46 20 01	 mov	 BYTE PTR [esi+32], 1

; 1700 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1701 : 						this->_Red;

  0015e	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00161	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  00164	88 5a 20	 mov	 BYTE PTR [edx+32], bl

; 1702 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));

  00167	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0016a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 1703 : 					}
; 1704 : 				else

  0016d	e9 91 00 00 00	 jmp	 $LN316@Insert
$LN3@Insert:

; 1705 : 					{	// parent has red and black children
; 1706 : 					if (_Pnode == this->_Left(this->_Parent(_Pnode)))

  00172	3b 02		 cmp	 eax, DWORD PTR [edx]
  00174	75 3c		 jne	 SHORT $LN253@Insert

; 1707 : 						{	// rotate left child to right
; 1708 : 						_Pnode = this->_Parent(_Pnode);

  00176	8b c2		 mov	 eax, edx

; 1709 : 						_Rrotate(_Pnode);

  00178	8b 10		 mov	 edx, DWORD PTR [eax]
  0017a	8b 72 08	 mov	 esi, DWORD PTR [edx+8]
  0017d	89 30		 mov	 DWORD PTR [eax], esi
  0017f	8b 72 08	 mov	 esi, DWORD PTR [edx+8]
  00182	38 5e 21	 cmp	 BYTE PTR [esi+33], bl
  00185	75 03		 jne	 SHORT $LN252@Insert
  00187	89 46 04	 mov	 DWORD PTR [esi+4], eax
$LN252@Insert:
  0018a	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  0018d	89 72 04	 mov	 DWORD PTR [edx+4], esi
  00190	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  00193	3b 46 04	 cmp	 eax, DWORD PTR [esi+4]
  00196	75 05		 jne	 SHORT $LN251@Insert
  00198	89 56 04	 mov	 DWORD PTR [esi+4], edx
  0019b	eb 0f		 jmp	 SHORT $LN248@Insert
$LN251@Insert:
  0019d	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  001a0	3b 46 08	 cmp	 eax, DWORD PTR [esi+8]
  001a3	75 05		 jne	 SHORT $LN249@Insert
  001a5	89 56 08	 mov	 DWORD PTR [esi+8], edx
  001a8	eb 02		 jmp	 SHORT $LN248@Insert
$LN249@Insert:
  001aa	89 16		 mov	 DWORD PTR [esi], edx
$LN248@Insert:
  001ac	89 42 08	 mov	 DWORD PTR [edx+8], eax
  001af	89 50 04	 mov	 DWORD PTR [eax+4], edx
$LN253@Insert:

; 1710 : 						}
; 1711 : 					this->_Color(this->_Parent(_Pnode)) =
; 1712 : 						this->_Black;	// propagate red up

  001b2	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  001b5	c6 42 20 01	 mov	 BYTE PTR [edx+32], 1

; 1713 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1714 : 						this->_Red;

  001b9	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  001bc	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  001bf	88 5a 20	 mov	 BYTE PTR [edx+32], bl

; 1715 : 					_Lrotate(this->_Parent(this->_Parent(_Pnode)));

  001c2	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  001c5	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  001c8	8b 72 08	 mov	 esi, DWORD PTR [edx+8]
  001cb	8b 3e		 mov	 edi, DWORD PTR [esi]
  001cd	89 7a 08	 mov	 DWORD PTR [edx+8], edi
  001d0	8b 3e		 mov	 edi, DWORD PTR [esi]
  001d2	38 5f 21	 cmp	 BYTE PTR [edi+33], bl
  001d5	75 03		 jne	 SHORT $LN315@Insert
  001d7	89 57 04	 mov	 DWORD PTR [edi+4], edx
$LN315@Insert:
  001da	8b 7a 04	 mov	 edi, DWORD PTR [edx+4]
  001dd	89 7e 04	 mov	 DWORD PTR [esi+4], edi
  001e0	8b 79 04	 mov	 edi, DWORD PTR [ecx+4]
  001e3	3b 57 04	 cmp	 edx, DWORD PTR [edi+4]
  001e6	75 05		 jne	 SHORT $LN314@Insert
  001e8	89 77 04	 mov	 DWORD PTR [edi+4], esi
  001eb	eb 0e		 jmp	 SHORT $LN311@Insert
$LN314@Insert:
  001ed	8b 7a 04	 mov	 edi, DWORD PTR [edx+4]
  001f0	3b 17		 cmp	 edx, DWORD PTR [edi]
  001f2	75 04		 jne	 SHORT $LN312@Insert
  001f4	89 37		 mov	 DWORD PTR [edi], esi
  001f6	eb 03		 jmp	 SHORT $LN311@Insert
$LN312@Insert:
  001f8	89 77 08	 mov	 DWORD PTR [edi+8], esi
$LN311@Insert:
  001fb	89 16		 mov	 DWORD PTR [esi], edx
$LN376@Insert:
  001fd	8b 7d 14	 mov	 edi, DWORD PTR __Newnode$[ebp]
  00200	89 72 04	 mov	 DWORD PTR [edx+4], esi
$LN316@Insert:

; 1661 : 			}
; 1662 : 
; 1663 : 		for (_Nodeptr _Pnode = _Newnode;
; 1664 : 			this->_Color(this->_Parent(_Pnode)) == this->_Red; )

  00203	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00206	38 5a 20	 cmp	 BYTE PTR [edx+32], bl
  00209	0f 84 71 fe ff
	ff		 je	 $LL10@Insert
  0020f	5e		 pop	 esi
$LN9@Insert:

; 1716 : 					}
; 1717 : 				}
; 1718 : 
; 1719 : 		this->_Color(_Root()) = this->_Black;	// root is always black

  00210	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00213	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]

; 1720 : 		return (iterator(_Newnode, this));

  00216	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00219	89 38		 mov	 DWORD PTR [eax], edi
  0021b	5f		 pop	 edi
  0021c	c6 41 20 01	 mov	 BYTE PTR [ecx+32], 1
  00220	5b		 pop	 ebx

; 1721 : 		}

  00221	5d		 pop	 ebp
  00222	c2 10 00	 ret	 16			; 00000010H
$LN375@Insert:
?_Insert@?$_Tree@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@2@1@Z ENDP ; std::_Tree<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::_Insert
_TEXT	ENDS
PUBLIC	?_Insert@?$_Tree@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::_Insert
; Function compile flags: /Ogtp
;	COMDAT ?_Insert@?$_Tree@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@2@1@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Addleft$ = 12						; size = 1
__Wherenode$ = 16					; size = 4
__Newnode$ = 20						; size = 4
?_Insert@?$_Tree@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@2@1@Z PROC ; std::_Tree<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::_Insert, COMDAT
; _this$ = ecx

; 1631 : 		{	// add node with value next to _Wherenode, to left if _Addleft

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1632 : 		if (max_size() - 1 <= this->_Mysize)

  00003	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00006	3d a9 aa aa 0a	 cmp	 eax, 178956969		; 0aaaaaa9H
  0000b	72 16		 jb	 SHORT $LN17@Insert@2

; 1633 : 			{	// tree would get too big, fail
; 1634 : 			_Dest_val(this->_Alval,
; 1635 : 				_STD addressof(this->_Myval(_Newnode)));
; 1636 : 
; 1637 : 			this->_Alnod.deallocate(_Newnode, 1);

  0000d	8b 45 14	 mov	 eax, DWORD PTR __Newnode$[ebp]
  00010	50		 push	 eax
  00011	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00016	83 c4 04	 add	 esp, 4

; 1638 : 
; 1639 : 			_Xlength_error("map/set<T> too long");

  00019	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
  0001e	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN377@Insert@2:
$LN17@Insert@2:

; 1640 : 			}
; 1641 : 		++this->_Mysize;

  00023	40		 inc	 eax
  00024	53		 push	 ebx
  00025	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 1642 : 		_Newnode->_Parent = _Wherenode;

  00028	8b 45 10	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0002b	57		 push	 edi
  0002c	8b 7d 14	 mov	 edi, DWORD PTR __Newnode$[ebp]
  0002f	89 47 04	 mov	 DWORD PTR [edi+4], eax

; 1643 : 
; 1644 : 		if (_Wherenode == this->_Myhead)

  00032	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00035	32 db		 xor	 bl, bl
  00037	3b c2		 cmp	 eax, edx
  00039	75 10		 jne	 SHORT $LN16@Insert@2

; 1645 : 			{	// first node in tree, just set head values
; 1646 : 			_Root() = _Newnode;

  0003b	89 7a 04	 mov	 DWORD PTR [edx+4], edi

; 1647 : 			_Lmost() = _Newnode;

  0003e	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00041	89 3a		 mov	 DWORD PTR [edx], edi

; 1648 : 			_Rmost() = _Newnode;

  00043	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00046	89 78 08	 mov	 DWORD PTR [eax+8], edi
  00049	eb 20		 jmp	 SHORT $LN11@Insert@2
$LN16@Insert@2:

; 1649 : 			}
; 1650 : 		else if (_Addleft)

  0004b	38 5d 0c	 cmp	 BYTE PTR __Addleft$[ebp], bl
  0004e	74 0d		 je	 SHORT $LN14@Insert@2

; 1651 : 			{	// add to left of _Wherenode
; 1652 : 			this->_Left(_Wherenode) = _Newnode;

  00050	89 38		 mov	 DWORD PTR [eax], edi

; 1653 : 			if (_Wherenode == _Lmost())

  00052	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00055	3b 02		 cmp	 eax, DWORD PTR [edx]
  00057	75 12		 jne	 SHORT $LN11@Insert@2

; 1654 : 				_Lmost() = _Newnode;

  00059	89 3a		 mov	 DWORD PTR [edx], edi

; 1655 : 			}
; 1656 : 		else

  0005b	eb 0e		 jmp	 SHORT $LN11@Insert@2
$LN14@Insert@2:

; 1657 : 			{	// add to right of _Wherenode
; 1658 : 			this->_Right(_Wherenode) = _Newnode;

  0005d	89 78 08	 mov	 DWORD PTR [eax+8], edi

; 1659 : 			if (_Wherenode == _Rmost())

  00060	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00063	3b 42 08	 cmp	 eax, DWORD PTR [edx+8]
  00066	75 03		 jne	 SHORT $LN11@Insert@2

; 1660 : 				_Rmost() = _Newnode;

  00068	89 7a 08	 mov	 DWORD PTR [edx+8], edi
$LN11@Insert@2:

; 1661 : 			}
; 1662 : 
; 1663 : 		for (_Nodeptr _Pnode = _Newnode;
; 1664 : 			this->_Color(this->_Parent(_Pnode)) == this->_Red; )

  0006b	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  0006e	8b c7		 mov	 eax, edi
  00070	38 5a 24	 cmp	 BYTE PTR [edx+36], bl
  00073	0f 85 97 01 00
	00		 jne	 $LN9@Insert@2
  00079	56		 push	 esi
  0007a	8d 9b 00 00 00
	00		 npad	 6
$LL10@Insert@2:

; 1665 : 			if (this->_Parent(_Pnode)
; 1666 : 				== this->_Left(this->_Parent(this->_Parent(_Pnode))))

  00080	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00083	8b 72 04	 mov	 esi, DWORD PTR [edx+4]
  00086	3b 16		 cmp	 edx, DWORD PTR [esi]
  00088	0f 85 c1 00 00
	00		 jne	 $LN8@Insert@2

; 1667 : 				{	// fixup red-red in left subtree
; 1668 : 				_Wherenode =
; 1669 : 					this->_Right(this->_Parent(this->_Parent(_Pnode)));

  0008e	8b 76 08	 mov	 esi, DWORD PTR [esi+8]

; 1670 : 				if (this->_Color(_Wherenode) == this->_Red)

  00091	38 5e 24	 cmp	 BYTE PTR [esi+36], bl
  00094	75 1c		 jne	 SHORT $LN7@Insert@2

; 1671 : 					{	// parent has two red children, blacken both
; 1672 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;

  00096	c6 42 24 01	 mov	 BYTE PTR [edx+36], 1

; 1673 : 					this->_Color(_Wherenode) = this->_Black;

  0009a	c6 46 24 01	 mov	 BYTE PTR [esi+36], 1

; 1674 : 					this->_Color(this->_Parent(this->_Parent(_Pnode)))
; 1675 : 						= this->_Red;

  0009e	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000a1	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  000a4	88 5a 24	 mov	 BYTE PTR [edx+36], bl

; 1676 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));

  000a7	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000aa	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 1677 : 					}
; 1678 : 				else

  000ad	e9 51 01 00 00	 jmp	 $LN316@Insert@2
$LN7@Insert@2:

; 1679 : 					{	// parent has red and black children
; 1680 : 					if (_Pnode == this->_Right(this->_Parent(_Pnode)))

  000b2	3b 42 08	 cmp	 eax, DWORD PTR [edx+8]
  000b5	75 3a		 jne	 SHORT $LN111@Insert@2

; 1681 : 						{	// rotate right child to left
; 1682 : 						_Pnode = this->_Parent(_Pnode);

  000b7	8b c2		 mov	 eax, edx

; 1683 : 						_Lrotate(_Pnode);

  000b9	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  000bc	8b 32		 mov	 esi, DWORD PTR [edx]
  000be	89 70 08	 mov	 DWORD PTR [eax+8], esi
  000c1	8b 32		 mov	 esi, DWORD PTR [edx]
  000c3	38 5e 25	 cmp	 BYTE PTR [esi+37], bl
  000c6	75 03		 jne	 SHORT $LN110@Insert@2
  000c8	89 46 04	 mov	 DWORD PTR [esi+4], eax
$LN110@Insert@2:
  000cb	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  000ce	89 72 04	 mov	 DWORD PTR [edx+4], esi
  000d1	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  000d4	3b 46 04	 cmp	 eax, DWORD PTR [esi+4]
  000d7	75 05		 jne	 SHORT $LN109@Insert@2
  000d9	89 56 04	 mov	 DWORD PTR [esi+4], edx
  000dc	eb 0e		 jmp	 SHORT $LN106@Insert@2
$LN109@Insert@2:
  000de	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  000e1	3b 06		 cmp	 eax, DWORD PTR [esi]
  000e3	75 04		 jne	 SHORT $LN107@Insert@2
  000e5	89 16		 mov	 DWORD PTR [esi], edx
  000e7	eb 03		 jmp	 SHORT $LN106@Insert@2
$LN107@Insert@2:
  000e9	89 56 08	 mov	 DWORD PTR [esi+8], edx
$LN106@Insert@2:
  000ec	89 02		 mov	 DWORD PTR [edx], eax
  000ee	89 50 04	 mov	 DWORD PTR [eax+4], edx
$LN111@Insert@2:

; 1684 : 						}
; 1685 : 					this->_Color(this->_Parent(_Pnode)) =
; 1686 : 						this->_Black;	// propagate red up

  000f1	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000f4	c6 42 24 01	 mov	 BYTE PTR [edx+36], 1

; 1687 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1688 : 						this->_Red;

  000f8	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000fb	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  000fe	88 5a 24	 mov	 BYTE PTR [edx+36], bl

; 1689 : 					_Rrotate(this->_Parent(this->_Parent(_Pnode)));

  00101	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00104	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  00107	8b 32		 mov	 esi, DWORD PTR [edx]
  00109	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  0010c	89 3a		 mov	 DWORD PTR [edx], edi
  0010e	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  00111	38 5f 25	 cmp	 BYTE PTR [edi+37], bl
  00114	75 03		 jne	 SHORT $LN173@Insert@2
  00116	89 57 04	 mov	 DWORD PTR [edi+4], edx
$LN173@Insert@2:
  00119	8b 7a 04	 mov	 edi, DWORD PTR [edx+4]
  0011c	89 7e 04	 mov	 DWORD PTR [esi+4], edi
  0011f	8b 79 04	 mov	 edi, DWORD PTR [ecx+4]
  00122	3b 57 04	 cmp	 edx, DWORD PTR [edi+4]
  00125	75 0b		 jne	 SHORT $LN172@Insert@2
  00127	89 77 04	 mov	 DWORD PTR [edi+4], esi
  0012a	89 56 08	 mov	 DWORD PTR [esi+8], edx

; 1690 : 					}
; 1691 : 				}
; 1692 : 			else

  0012d	e9 cb 00 00 00	 jmp	 $LN376@Insert@2

; 1689 : 					_Rrotate(this->_Parent(this->_Parent(_Pnode)));

$LN172@Insert@2:
  00132	8b 7a 04	 mov	 edi, DWORD PTR [edx+4]
  00135	3b 57 08	 cmp	 edx, DWORD PTR [edi+8]
  00138	75 0b		 jne	 SHORT $LN170@Insert@2
  0013a	89 77 08	 mov	 DWORD PTR [edi+8], esi
  0013d	89 56 08	 mov	 DWORD PTR [esi+8], edx

; 1690 : 					}
; 1691 : 				}
; 1692 : 			else

  00140	e9 b8 00 00 00	 jmp	 $LN376@Insert@2

; 1689 : 					_Rrotate(this->_Parent(this->_Parent(_Pnode)));

$LN170@Insert@2:
  00145	89 37		 mov	 DWORD PTR [edi], esi
  00147	89 56 08	 mov	 DWORD PTR [esi+8], edx

; 1690 : 					}
; 1691 : 				}
; 1692 : 			else

  0014a	e9 ae 00 00 00	 jmp	 $LN376@Insert@2
$LN8@Insert@2:

; 1693 : 				{	// fixup red-red in right subtree
; 1694 : 				_Wherenode =
; 1695 : 					this->_Left(this->_Parent(this->_Parent(_Pnode)));

  0014f	8b 36		 mov	 esi, DWORD PTR [esi]

; 1696 : 				if (this->_Color(_Wherenode) == this->_Red)

  00151	38 5e 24	 cmp	 BYTE PTR [esi+36], bl
  00154	75 1c		 jne	 SHORT $LN3@Insert@2

; 1697 : 					{	// parent has two red children, blacken both
; 1698 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;

  00156	c6 42 24 01	 mov	 BYTE PTR [edx+36], 1

; 1699 : 					this->_Color(_Wherenode) = this->_Black;

  0015a	c6 46 24 01	 mov	 BYTE PTR [esi+36], 1

; 1700 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1701 : 						this->_Red;

  0015e	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00161	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  00164	88 5a 24	 mov	 BYTE PTR [edx+36], bl

; 1702 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));

  00167	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0016a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 1703 : 					}
; 1704 : 				else

  0016d	e9 91 00 00 00	 jmp	 $LN316@Insert@2
$LN3@Insert@2:

; 1705 : 					{	// parent has red and black children
; 1706 : 					if (_Pnode == this->_Left(this->_Parent(_Pnode)))

  00172	3b 02		 cmp	 eax, DWORD PTR [edx]
  00174	75 3c		 jne	 SHORT $LN253@Insert@2

; 1707 : 						{	// rotate left child to right
; 1708 : 						_Pnode = this->_Parent(_Pnode);

  00176	8b c2		 mov	 eax, edx

; 1709 : 						_Rrotate(_Pnode);

  00178	8b 10		 mov	 edx, DWORD PTR [eax]
  0017a	8b 72 08	 mov	 esi, DWORD PTR [edx+8]
  0017d	89 30		 mov	 DWORD PTR [eax], esi
  0017f	8b 72 08	 mov	 esi, DWORD PTR [edx+8]
  00182	38 5e 25	 cmp	 BYTE PTR [esi+37], bl
  00185	75 03		 jne	 SHORT $LN252@Insert@2
  00187	89 46 04	 mov	 DWORD PTR [esi+4], eax
$LN252@Insert@2:
  0018a	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  0018d	89 72 04	 mov	 DWORD PTR [edx+4], esi
  00190	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  00193	3b 46 04	 cmp	 eax, DWORD PTR [esi+4]
  00196	75 05		 jne	 SHORT $LN251@Insert@2
  00198	89 56 04	 mov	 DWORD PTR [esi+4], edx
  0019b	eb 0f		 jmp	 SHORT $LN248@Insert@2
$LN251@Insert@2:
  0019d	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  001a0	3b 46 08	 cmp	 eax, DWORD PTR [esi+8]
  001a3	75 05		 jne	 SHORT $LN249@Insert@2
  001a5	89 56 08	 mov	 DWORD PTR [esi+8], edx
  001a8	eb 02		 jmp	 SHORT $LN248@Insert@2
$LN249@Insert@2:
  001aa	89 16		 mov	 DWORD PTR [esi], edx
$LN248@Insert@2:
  001ac	89 42 08	 mov	 DWORD PTR [edx+8], eax
  001af	89 50 04	 mov	 DWORD PTR [eax+4], edx
$LN253@Insert@2:

; 1710 : 						}
; 1711 : 					this->_Color(this->_Parent(_Pnode)) =
; 1712 : 						this->_Black;	// propagate red up

  001b2	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  001b5	c6 42 24 01	 mov	 BYTE PTR [edx+36], 1

; 1713 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1714 : 						this->_Red;

  001b9	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  001bc	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  001bf	88 5a 24	 mov	 BYTE PTR [edx+36], bl

; 1715 : 					_Lrotate(this->_Parent(this->_Parent(_Pnode)));

  001c2	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  001c5	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  001c8	8b 72 08	 mov	 esi, DWORD PTR [edx+8]
  001cb	8b 3e		 mov	 edi, DWORD PTR [esi]
  001cd	89 7a 08	 mov	 DWORD PTR [edx+8], edi
  001d0	8b 3e		 mov	 edi, DWORD PTR [esi]
  001d2	38 5f 25	 cmp	 BYTE PTR [edi+37], bl
  001d5	75 03		 jne	 SHORT $LN315@Insert@2
  001d7	89 57 04	 mov	 DWORD PTR [edi+4], edx
$LN315@Insert@2:
  001da	8b 7a 04	 mov	 edi, DWORD PTR [edx+4]
  001dd	89 7e 04	 mov	 DWORD PTR [esi+4], edi
  001e0	8b 79 04	 mov	 edi, DWORD PTR [ecx+4]
  001e3	3b 57 04	 cmp	 edx, DWORD PTR [edi+4]
  001e6	75 05		 jne	 SHORT $LN314@Insert@2
  001e8	89 77 04	 mov	 DWORD PTR [edi+4], esi
  001eb	eb 0e		 jmp	 SHORT $LN311@Insert@2
$LN314@Insert@2:
  001ed	8b 7a 04	 mov	 edi, DWORD PTR [edx+4]
  001f0	3b 17		 cmp	 edx, DWORD PTR [edi]
  001f2	75 04		 jne	 SHORT $LN312@Insert@2
  001f4	89 37		 mov	 DWORD PTR [edi], esi
  001f6	eb 03		 jmp	 SHORT $LN311@Insert@2
$LN312@Insert@2:
  001f8	89 77 08	 mov	 DWORD PTR [edi+8], esi
$LN311@Insert@2:
  001fb	89 16		 mov	 DWORD PTR [esi], edx
$LN376@Insert@2:
  001fd	8b 7d 14	 mov	 edi, DWORD PTR __Newnode$[ebp]
  00200	89 72 04	 mov	 DWORD PTR [edx+4], esi
$LN316@Insert@2:

; 1661 : 			}
; 1662 : 
; 1663 : 		for (_Nodeptr _Pnode = _Newnode;
; 1664 : 			this->_Color(this->_Parent(_Pnode)) == this->_Red; )

  00203	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00206	38 5a 24	 cmp	 BYTE PTR [edx+36], bl
  00209	0f 84 71 fe ff
	ff		 je	 $LL10@Insert@2
  0020f	5e		 pop	 esi
$LN9@Insert@2:

; 1716 : 					}
; 1717 : 				}
; 1718 : 
; 1719 : 		this->_Color(_Root()) = this->_Black;	// root is always black

  00210	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00213	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]

; 1720 : 		return (iterator(_Newnode, this));

  00216	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00219	89 38		 mov	 DWORD PTR [eax], edi
  0021b	5f		 pop	 edi
  0021c	c6 41 24 01	 mov	 BYTE PTR [ecx+36], 1
  00220	5b		 pop	 ebx

; 1721 : 		}

  00221	5d		 pop	 ebp
  00222	c2 10 00	 ret	 16			; 00000010H
$LN375@Insert@2:
?_Insert@?$_Tree@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@2@1@Z ENDP ; std::_Tree<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::_Insert
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@std@@U?$pair@$$CBHU_tagWaiting@@@2@U?$pair@HU_tagWaiting@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@0@PAU?$pair@$$CBHU_tagWaiting@@@0@$$QAU?$pair@HU_tagWaiting@@@0@@Z ; std::_Cons_val<std::allocator<std::pair<int const ,_tagWaiting> >,std::pair<int const ,_tagWaiting>,std::pair<int,_tagWaiting> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Cons_val@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@std@@U?$pair@$$CBHU_tagWaiting@@@2@U?$pair@HU_tagWaiting@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@0@PAU?$pair@$$CBHU_tagWaiting@@@0@$$QAU?$pair@HU_tagWaiting@@@0@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@std@@U?$pair@$$CBHU_tagWaiting@@@2@U?$pair@HU_tagWaiting@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@0@PAU?$pair@$$CBHU_tagWaiting@@@0@$$QAU?$pair@HU_tagWaiting@@@0@@Z PROC ; std::_Cons_val<std::allocator<std::pair<int const ,_tagWaiting> >,std::pair<int const ,_tagWaiting>,std::pair<int,_tagWaiting> >, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Pdest$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 1f		 je	 SHORT $LN7@Cons_val
  0000a	8b 45 10	 mov	 eax, DWORD PTR __Src$[ebp]
  0000d	8b 10		 mov	 edx, DWORD PTR [eax]
  0000f	89 11		 mov	 DWORD PTR [ecx], edx
  00011	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00014	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  00017	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0001a	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  0001d	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  00020	89 51 0c	 mov	 DWORD PTR [ecx+12], edx
  00023	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00026	89 41 10	 mov	 DWORD PTR [ecx+16], eax
$LN7@Cons_val:

; 281  : 	}

  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
??$_Cons_val@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@std@@U?$pair@$$CBHU_tagWaiting@@@2@U?$pair@HU_tagWaiting@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@0@PAU?$pair@$$CBHU_tagWaiting@@@0@$$QAU?$pair@HU_tagWaiting@@@0@@Z ENDP ; std::_Cons_val<std::allocator<std::pair<int const ,_tagWaiting> >,std::pair<int const ,_tagWaiting>,std::pair<int,_tagWaiting> >
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@std@@U?$pair@$$CBHU_tagObserverInfo@@@2@U?$pair@HU_tagObserverInfo@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@0@PAU?$pair@$$CBHU_tagObserverInfo@@@0@$$QAU?$pair@HU_tagObserverInfo@@@0@@Z ; std::_Cons_val<std::allocator<std::pair<int const ,_tagObserverInfo> >,std::pair<int const ,_tagObserverInfo>,std::pair<int,_tagObserverInfo> >
; Function compile flags: /Ogtp
;	COMDAT ??$_Cons_val@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@std@@U?$pair@$$CBHU_tagObserverInfo@@@2@U?$pair@HU_tagObserverInfo@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@0@PAU?$pair@$$CBHU_tagObserverInfo@@@0@$$QAU?$pair@HU_tagObserverInfo@@@0@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@std@@U?$pair@$$CBHU_tagObserverInfo@@@2@U?$pair@HU_tagObserverInfo@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@0@PAU?$pair@$$CBHU_tagObserverInfo@@@0@$$QAU?$pair@HU_tagObserverInfo@@@0@@Z PROC ; std::_Cons_val<std::allocator<std::pair<int const ,_tagObserverInfo> >,std::pair<int const ,_tagObserverInfo>,std::pair<int,_tagObserverInfo> >, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Pdest$[ebp]
  00006	85 c9		 test	 ecx, ecx
  00008	74 25		 je	 SHORT $LN7@Cons_val@2
  0000a	8b 45 10	 mov	 eax, DWORD PTR __Src$[ebp]
  0000d	8b 10		 mov	 edx, DWORD PTR [eax]
  0000f	89 11		 mov	 DWORD PTR [ecx], edx
  00011	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00014	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  00017	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0001a	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  0001d	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  00020	89 51 0c	 mov	 DWORD PTR [ecx+12], edx
  00023	8b 50 10	 mov	 edx, DWORD PTR [eax+16]
  00026	89 51 10	 mov	 DWORD PTR [ecx+16], edx
  00029	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  0002c	89 41 14	 mov	 DWORD PTR [ecx+20], eax
$LN7@Cons_val@2:

; 281  : 	}

  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
??$_Cons_val@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@std@@U?$pair@$$CBHU_tagObserverInfo@@@2@U?$pair@HU_tagObserverInfo@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@0@PAU?$pair@$$CBHU_tagObserverInfo@@@0@$$QAU?$pair@HU_tagObserverInfo@@@0@@Z ENDP ; std::_Cons_val<std::allocator<std::pair<int const ,_tagObserverInfo> >,std::pair<int const ,_tagObserverInfo>,std::pair<int,_tagObserverInfo> >
_TEXT	ENDS
PUBLIC	?begin@?$_Tree@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::begin
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$_Tree@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::begin, COMDAT
; _this$ = ecx

; 806  : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 807  : 		return (iterator(_Lmost(), this));

  00003	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00006	8b 08		 mov	 ecx, DWORD PTR [eax]
  00008	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0000b	89 08		 mov	 DWORD PTR [eax], ecx

; 808  : 		}

  0000d	5d		 pop	 ebp
  0000e	c2 04 00	 ret	 4
?begin@?$_Tree@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::begin
_TEXT	ENDS
PUBLIC	?end@?$_Tree@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::end
; Function compile flags: /Ogtp
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$_Tree@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::end, COMDAT
; _this$ = ecx

; 816  : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 817  : 		return (iterator(this->_Myhead, this));

  00003	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00006	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 818  : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
?end@?$_Tree@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::end
_TEXT	ENDS
PUBLIC	??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@ ; `string'
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::erase
EXTRN	?_Xout_of_range@std@@YAXPBD@Z:PROC		; std::_Xout_of_range
;	COMDAT ??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
CONST	SEGMENT
??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@ DB 'invalid '
	DB	'map/set<T> iterator', 00H			; `string'
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
CONST	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@2@@Z
_TEXT	SEGMENT
tv795 = -12						; size = 4
__Erasednode$ = -8					; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::erase, COMDAT
; _this$ = ecx

; 1195 : 		{	// erase element at _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx

; 1196 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1197 : 		if (_Where._Getcont() != this || this->_Isnil(_Where._Mynode()))
; 1198 : 			_DEBUG_ERROR("map/set erase iterator outside range");
; 1199 : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 1200 : 		++_Where;	// save successor iterator for return
; 1201 : 		_Orphan_ptr(*this, _Erasednode);
; 1202 : 
; 1203 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1204 : 		if (this->_Isnil(_Where._Mynode()))

  00007	8b 5d 0c	 mov	 ebx, DWORD PTR __Where$[ebp]
  0000a	80 7b 21 00	 cmp	 BYTE PTR [ebx+33], 0
  0000e	56		 push	 esi
  0000f	57		 push	 edi
  00010	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00013	74 0a		 je	 SHORT $LN40@erase

; 1205 : 			_Xout_of_range("invalid map/set<T> iterator");

  00015	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@
  0001a	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN295@erase:
$LN40@erase:

; 1206 : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 1207 : 		++_Where;	// save successor iterator for return

  0001f	8d 4d 0c	 lea	 ecx, DWORD PTR __Where$[ebp]
  00022	89 5d f8	 mov	 DWORD PTR __Erasednode$[ebp], ebx
  00025	e8 00 00 00 00	 call	 ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >,std::_Iterator_base0>::operator++

; 1208 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1209 : 
; 1210 : 		_Nodeptr _Fixnode;	// the node to recolor as needed
; 1211 : 		_Nodeptr _Fixnodeparent;	// parent of _Fixnode (which may be nil)
; 1212 : 		_Nodeptr _Pnode = _Erasednode;
; 1213 : 
; 1214 : 		if (this->_Isnil(this->_Left(_Pnode)))

  0002a	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  0002c	80 79 21 00	 cmp	 BYTE PTR [ecx+33], 0
  00030	74 05		 je	 SHORT $LN39@erase

; 1215 : 			_Fixnode = this->_Right(_Pnode);	// stitch up right subtree

  00032	8b 7b 08	 mov	 edi, DWORD PTR [ebx+8]

; 1216 : 		else if (this->_Isnil(this->_Right(_Pnode)))

  00035	eb 17		 jmp	 SHORT $LN291@erase
$LN39@erase:
  00037	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  0003a	80 78 21 00	 cmp	 BYTE PTR [eax+33], 0
  0003e	74 04		 je	 SHORT $LN37@erase

; 1217 : 			_Fixnode = this->_Left(_Pnode);	// stitch up left subtree

  00040	8b f9		 mov	 edi, ecx

; 1218 : 		else

  00042	eb 0a		 jmp	 SHORT $LN291@erase
$LN37@erase:

; 1219 : 			{	// two subtrees, must lift successor node to replace erased
; 1220 : 			_Pnode = _Where._Mynode();	// _Pnode is successor node

  00044	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]

; 1221 : 			_Fixnode = this->_Right(_Pnode);	// _Fixnode is only subtree

  00047	8b 78 08	 mov	 edi, DWORD PTR [eax+8]

; 1222 : 			}
; 1223 : 
; 1224 : 		if (_Pnode == _Erasednode)

  0004a	3b c3		 cmp	 eax, ebx
  0004c	75 72		 jne	 SHORT $LN35@erase
$LN291@erase:

; 1225 : 			{	// at most one subtree, relink it
; 1226 : 			_Fixnodeparent = this->_Parent(_Erasednode);
; 1227 : 			if (!this->_Isnil(_Fixnode))

  0004e	80 7f 21 00	 cmp	 BYTE PTR [edi+33], 0
  00052	8b 73 04	 mov	 esi, DWORD PTR [ebx+4]
  00055	75 03		 jne	 SHORT $LN34@erase

; 1228 : 				this->_Parent(_Fixnode) = _Fixnodeparent;	// link up

  00057	89 77 04	 mov	 DWORD PTR [edi+4], esi
$LN34@erase:

; 1229 : 
; 1230 : 			if (_Root() == _Erasednode)

  0005a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0005d	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00060	39 58 04	 cmp	 DWORD PTR [eax+4], ebx
  00063	75 05		 jne	 SHORT $LN33@erase

; 1231 : 				_Root() = _Fixnode;	// link down from root

  00065	89 78 04	 mov	 DWORD PTR [eax+4], edi

; 1232 : 			else if (this->_Left(_Fixnodeparent) == _Erasednode)

  00068	eb 0b		 jmp	 SHORT $LN30@erase
$LN33@erase:
  0006a	39 1e		 cmp	 DWORD PTR [esi], ebx
  0006c	75 04		 jne	 SHORT $LN31@erase

; 1233 : 				this->_Left(_Fixnodeparent) = _Fixnode;	// link down to left

  0006e	89 3e		 mov	 DWORD PTR [esi], edi

; 1234 : 			else

  00070	eb 03		 jmp	 SHORT $LN30@erase
$LN31@erase:

; 1235 : 				this->_Right(_Fixnodeparent) =
; 1236 : 					_Fixnode;	// link down to right

  00072	89 7e 08	 mov	 DWORD PTR [esi+8], edi
$LN30@erase:

; 1237 : 
; 1238 : 			if (_Lmost() == _Erasednode)

  00075	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00078	39 18		 cmp	 DWORD PTR [eax], ebx
  0007a	75 1b		 jne	 SHORT $LN29@erase

; 1239 : 				_Lmost() = this->_Isnil(_Fixnode)
; 1240 : 					? _Fixnodeparent	// smallest is parent of erased node
; 1241 : 					: this->_Min(_Fixnode);	// smallest in relinked subtree

  0007c	80 7f 21 00	 cmp	 BYTE PTR [edi+33], 0
  00080	74 04		 je	 SHORT $LN43@erase
  00082	8b c6		 mov	 eax, esi
  00084	eb 0c		 jmp	 SHORT $LN44@erase
$LN43@erase:
  00086	57		 push	 edi
  00087	e8 00 00 00 00	 call	 ?_Min@?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::_Min
  0008c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0008f	83 c4 04	 add	 esp, 4
$LN44@erase:
  00092	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00095	89 02		 mov	 DWORD PTR [edx], eax
$LN29@erase:

; 1242 : 
; 1243 : 			if (_Rmost() == _Erasednode)

  00097	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0009a	89 4d f4	 mov	 DWORD PTR tv795[ebp], ecx
  0009d	39 59 08	 cmp	 DWORD PTR [ecx+8], ebx
  000a0	75 78		 jne	 SHORT $LN165@erase

; 1244 : 				_Rmost() = this->_Isnil(_Fixnode)
; 1245 : 					? _Fixnodeparent	// largest is parent of erased node
; 1246 : 					: this->_Max(_Fixnode);	// largest in relinked subtree

  000a2	80 7f 21 00	 cmp	 BYTE PTR [edi+33], 0
  000a6	74 07		 je	 SHORT $LN45@erase
  000a8	8b c6		 mov	 eax, esi
  000aa	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 1247 : 			}
; 1248 : 		else

  000ad	eb 6b		 jmp	 SHORT $LN165@erase
$LN45@erase:

; 1244 : 				_Rmost() = this->_Isnil(_Fixnode)
; 1245 : 					? _Fixnodeparent	// largest is parent of erased node
; 1246 : 					: this->_Max(_Fixnode);	// largest in relinked subtree

  000af	57		 push	 edi
  000b0	e8 00 00 00 00	 call	 ?_Max@?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::_Max
  000b5	8b 4d f4	 mov	 ecx, DWORD PTR tv795[ebp]
  000b8	83 c4 04	 add	 esp, 4
  000bb	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 1247 : 			}
; 1248 : 		else

  000be	eb 5a		 jmp	 SHORT $LN165@erase
$LN35@erase:

; 1249 : 			{	// erased has two subtrees, _Pnode is successor to erased
; 1250 : 			this->_Parent(this->_Left(_Erasednode)) =
; 1251 : 				_Pnode;	// link left up

  000c0	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1252 : 			this->_Left(_Pnode) =
; 1253 : 				this->_Left(_Erasednode);	// link successor down

  000c3	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  000c5	89 08		 mov	 DWORD PTR [eax], ecx

; 1254 : 
; 1255 : 			if (_Pnode == this->_Right(_Erasednode))

  000c7	3b 43 08	 cmp	 eax, DWORD PTR [ebx+8]
  000ca	75 04		 jne	 SHORT $LN26@erase

; 1256 : 				_Fixnodeparent = _Pnode;	// successor is next to erased

  000cc	8b f0		 mov	 esi, eax

; 1257 : 			else

  000ce	eb 1a		 jmp	 SHORT $LN25@erase
$LN26@erase:

; 1258 : 				{	// successor further down, link in place of erased
; 1259 : 				_Fixnodeparent =
; 1260 : 					this->_Parent(_Pnode);	// parent is successor's
; 1261 : 				if (!this->_Isnil(_Fixnode))

  000d0	80 7f 21 00	 cmp	 BYTE PTR [edi+33], 0
  000d4	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  000d7	75 03		 jne	 SHORT $LN24@erase

; 1262 : 					this->_Parent(_Fixnode) = _Fixnodeparent;	// link fix up

  000d9	89 77 04	 mov	 DWORD PTR [edi+4], esi
$LN24@erase:

; 1263 : 				this->_Left(_Fixnodeparent) = _Fixnode;	// link fix down

  000dc	89 3e		 mov	 DWORD PTR [esi], edi

; 1264 : 				this->_Right(_Pnode) =
; 1265 : 					this->_Right(_Erasednode);	// link next down

  000de	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  000e1	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 1266 : 				this->_Parent(this->_Right(_Erasednode)) =
; 1267 : 					_Pnode;	// right up

  000e4	8b 53 08	 mov	 edx, DWORD PTR [ebx+8]
  000e7	89 42 04	 mov	 DWORD PTR [edx+4], eax
$LN25@erase:

; 1268 : 				}
; 1269 : 
; 1270 : 			if (_Root() == _Erasednode)

  000ea	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000ed	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  000f0	39 59 04	 cmp	 DWORD PTR [ecx+4], ebx
  000f3	75 05		 jne	 SHORT $LN23@erase

; 1271 : 				_Root() = _Pnode;	// link down from root

  000f5	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1272 : 			else if (this->_Left(this->_Parent(_Erasednode)) == _Erasednode)

  000f8	eb 0e		 jmp	 SHORT $LN20@erase
$LN23@erase:
  000fa	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  000fd	39 19		 cmp	 DWORD PTR [ecx], ebx
  000ff	75 04		 jne	 SHORT $LN21@erase

; 1273 : 				this->_Left(this->_Parent(_Erasednode)) =
; 1274 : 					_Pnode;	// link down to left

  00101	89 01		 mov	 DWORD PTR [ecx], eax

; 1275 : 			else

  00103	eb 03		 jmp	 SHORT $LN20@erase
$LN21@erase:

; 1276 : 				this->_Right(this->_Parent(_Erasednode)) =
; 1277 : 					_Pnode;	// link down to right

  00105	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$LN20@erase:

; 1278 : 
; 1279 : 			this->_Parent(_Pnode) =
; 1280 : 				this->_Parent(_Erasednode);	// link successor up

  00108	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  0010b	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 1281 : 			_STD swap(this->_Color(_Pnode),
; 1282 : 				this->_Color(_Erasednode));	// recolor it

  0010e	8a 53 20	 mov	 dl, BYTE PTR [ebx+32]
  00111	8a 48 20	 mov	 cl, BYTE PTR [eax+32]
  00114	88 50 20	 mov	 BYTE PTR [eax+32], dl
  00117	88 4b 20	 mov	 BYTE PTR [ebx+32], cl
$LN165@erase:

; 1283 : 			}
; 1284 : 
; 1285 : 		if (this->_Color(_Erasednode) == this->_Black)

  0011a	8b 45 f8	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  0011d	b3 01		 mov	 bl, 1
  0011f	38 58 20	 cmp	 BYTE PTR [eax+32], bl
  00122	0f 85 fa 00 00
	00		 jne	 $LN19@erase

; 1286 : 			{	// erasing black link, must recolor/rebalance tree
; 1287 : 			for (; _Fixnode != _Root()
; 1288 : 				&& this->_Color(_Fixnode) == this->_Black;
; 1289 : 				_Fixnodeparent = this->_Parent(_Fixnode))

  00128	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0012b	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0012e	3b 7a 04	 cmp	 edi, DWORD PTR [edx+4]
  00131	0f 84 e8 00 00
	00		 je	 $LN16@erase
$LL18@erase:
  00137	38 5f 20	 cmp	 BYTE PTR [edi+32], bl
  0013a	0f 85 df 00 00
	00		 jne	 $LN16@erase

; 1290 : 				if (_Fixnode == this->_Left(_Fixnodeparent))

  00140	8b 06		 mov	 eax, DWORD PTR [esi]
  00142	3b f8		 cmp	 edi, eax
  00144	75 65		 jne	 SHORT $LN15@erase

; 1291 : 					{	// fixup left subtree
; 1292 : 					_Pnode = this->_Right(_Fixnodeparent);

  00146	8b 46 08	 mov	 eax, DWORD PTR [esi+8]

; 1293 : 					if (this->_Color(_Pnode) == this->_Red)

  00149	80 78 20 00	 cmp	 BYTE PTR [eax+32], 0
  0014d	75 13		 jne	 SHORT $LN14@erase

; 1294 : 						{	// rotate red up from right subtree
; 1295 : 						this->_Color(_Pnode) = this->_Black;

  0014f	88 58 20	 mov	 BYTE PTR [eax+32], bl

; 1296 : 						this->_Color(_Fixnodeparent) = this->_Red;
; 1297 : 						_Lrotate(_Fixnodeparent);

  00152	56		 push	 esi
  00153	c6 46 20 00	 mov	 BYTE PTR [esi+32], 0
  00157	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::_Lrotate

; 1298 : 						_Pnode = this->_Right(_Fixnodeparent);

  0015c	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0015f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
$LN14@erase:

; 1299 : 						}
; 1300 : 
; 1301 : 					if (this->_Isnil(_Pnode))

  00162	80 78 21 00	 cmp	 BYTE PTR [eax+33], 0

; 1302 : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 1303 : 					else if (this->_Color(this->_Left(_Pnode)) == this->_Black

  00166	75 74		 jne	 SHORT $LN293@erase

; 1304 : 						&& this->_Color(this->_Right(_Pnode)) == this->_Black)

  00168	8b 10		 mov	 edx, DWORD PTR [eax]
  0016a	38 5a 20	 cmp	 BYTE PTR [edx+32], bl
  0016d	75 08		 jne	 SHORT $LN11@erase
  0016f	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00172	38 5a 20	 cmp	 BYTE PTR [edx+32], bl
  00175	74 61		 je	 SHORT $LN294@erase
$LN11@erase:

; 1305 : 						{	// redden right subtree with black children
; 1306 : 						this->_Color(_Pnode) = this->_Red;
; 1307 : 						_Fixnode = _Fixnodeparent;
; 1308 : 						}
; 1309 : 					else
; 1310 : 						{	// must rearrange right subtree
; 1311 : 						if (this->_Color(this->_Right(_Pnode))
; 1312 : 							== this->_Black)

  00177	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0017a	38 5a 20	 cmp	 BYTE PTR [edx+32], bl
  0017d	75 15		 jne	 SHORT $LN9@erase

; 1313 : 							{	// rotate red up from left sub-subtree
; 1314 : 							this->_Color(this->_Left(_Pnode)) = this->_Black;

  0017f	8b 10		 mov	 edx, DWORD PTR [eax]
  00181	88 5a 20	 mov	 BYTE PTR [edx+32], bl

; 1315 : 							this->_Color(_Pnode) = this->_Red;
; 1316 : 							_Rrotate(_Pnode);

  00184	50		 push	 eax
  00185	c6 40 20 00	 mov	 BYTE PTR [eax+32], 0
  00189	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::_Rrotate

; 1317 : 							_Pnode = this->_Right(_Fixnodeparent);

  0018e	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00191	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
$LN9@erase:

; 1318 : 							}
; 1319 : 
; 1320 : 						this->_Color(_Pnode) = this->_Color(_Fixnodeparent);

  00194	8a 56 20	 mov	 dl, BYTE PTR [esi+32]
  00197	88 50 20	 mov	 BYTE PTR [eax+32], dl

; 1321 : 						this->_Color(_Fixnodeparent) = this->_Black;

  0019a	88 5e 20	 mov	 BYTE PTR [esi+32], bl

; 1322 : 						this->_Color(this->_Right(_Pnode)) = this->_Black;

  0019d	8b 40 08	 mov	 eax, DWORD PTR [eax+8]

; 1323 : 						_Lrotate(_Fixnodeparent);

  001a0	56		 push	 esi
  001a1	88 58 20	 mov	 BYTE PTR [eax+32], bl
  001a4	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::_Lrotate

; 1324 : 						break;	// tree now recolored/rebalanced

  001a9	eb 74		 jmp	 SHORT $LN16@erase
$LN15@erase:

; 1325 : 						}
; 1326 : 					}
; 1327 : 				else
; 1328 : 					{	// fixup right subtree
; 1329 : 					_Pnode = this->_Left(_Fixnodeparent);
; 1330 : 					if (this->_Color(_Pnode) == this->_Red)

  001ab	80 78 20 00	 cmp	 BYTE PTR [eax+32], 0
  001af	75 12		 jne	 SHORT $LN7@erase

; 1331 : 						{	// rotate red up from left subtree
; 1332 : 						this->_Color(_Pnode) = this->_Black;

  001b1	88 58 20	 mov	 BYTE PTR [eax+32], bl

; 1333 : 						this->_Color(_Fixnodeparent) = this->_Red;
; 1334 : 						_Rrotate(_Fixnodeparent);

  001b4	56		 push	 esi
  001b5	c6 46 20 00	 mov	 BYTE PTR [esi+32], 0
  001b9	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::_Rrotate

; 1335 : 						_Pnode = this->_Left(_Fixnodeparent);

  001be	8b 06		 mov	 eax, DWORD PTR [esi]
  001c0	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
$LN7@erase:

; 1336 : 						}
; 1337 : 					if (this->_Isnil(_Pnode))

  001c3	80 78 21 00	 cmp	 BYTE PTR [eax+33], 0

; 1338 : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 1339 : 					else if (this->_Color(this->_Right(_Pnode)) ==

  001c7	75 13		 jne	 SHORT $LN293@erase

; 1340 : 						this->_Black
; 1341 : 						&& this->_Color(this->_Left(_Pnode)) == this->_Black)

  001c9	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  001cc	38 5a 20	 cmp	 BYTE PTR [edx+32], bl
  001cf	75 1e		 jne	 SHORT $LN4@erase
  001d1	8b 10		 mov	 edx, DWORD PTR [eax]
  001d3	38 5a 20	 cmp	 BYTE PTR [edx+32], bl
  001d6	75 17		 jne	 SHORT $LN4@erase
$LN294@erase:

; 1342 : 						{	// redden left subtree with black children
; 1343 : 						this->_Color(_Pnode) = this->_Red;

  001d8	c6 40 20 00	 mov	 BYTE PTR [eax+32], 0
$LN293@erase:

; 1286 : 			{	// erasing black link, must recolor/rebalance tree
; 1287 : 			for (; _Fixnode != _Root()
; 1288 : 				&& this->_Color(_Fixnode) == this->_Black;
; 1289 : 				_Fixnodeparent = this->_Parent(_Fixnode))

  001dc	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 1344 : 						_Fixnode = _Fixnodeparent;

  001df	8b fe		 mov	 edi, esi
  001e1	8b 76 04	 mov	 esi, DWORD PTR [esi+4]
  001e4	3b 78 04	 cmp	 edi, DWORD PTR [eax+4]
  001e7	0f 85 4a ff ff
	ff		 jne	 $LL18@erase

; 1286 : 			{	// erasing black link, must recolor/rebalance tree
; 1287 : 			for (; _Fixnode != _Root()
; 1288 : 				&& this->_Color(_Fixnode) == this->_Black;
; 1289 : 				_Fixnodeparent = this->_Parent(_Fixnode))

  001ed	eb 30		 jmp	 SHORT $LN16@erase
$LN4@erase:

; 1345 : 						}
; 1346 : 					else
; 1347 : 						{	// must rearrange left subtree
; 1348 : 						if (this->_Color(this->_Left(_Pnode)) == this->_Black)

  001ef	8b 10		 mov	 edx, DWORD PTR [eax]
  001f1	38 5a 20	 cmp	 BYTE PTR [edx+32], bl
  001f4	75 15		 jne	 SHORT $LN2@erase

; 1349 : 							{	// rotate red up from right sub-subtree
; 1350 : 							this->_Color(this->_Right(_Pnode)) = this->_Black;

  001f6	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  001f9	88 5a 20	 mov	 BYTE PTR [edx+32], bl

; 1351 : 							this->_Color(_Pnode) = this->_Red;
; 1352 : 							_Lrotate(_Pnode);

  001fc	50		 push	 eax
  001fd	c6 40 20 00	 mov	 BYTE PTR [eax+32], 0
  00201	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::_Lrotate

; 1353 : 							_Pnode = this->_Left(_Fixnodeparent);

  00206	8b 06		 mov	 eax, DWORD PTR [esi]
  00208	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
$LN2@erase:

; 1354 : 							}
; 1355 : 
; 1356 : 						this->_Color(_Pnode) = this->_Color(_Fixnodeparent);

  0020b	8a 56 20	 mov	 dl, BYTE PTR [esi+32]
  0020e	88 50 20	 mov	 BYTE PTR [eax+32], dl

; 1357 : 						this->_Color(_Fixnodeparent) = this->_Black;

  00211	88 5e 20	 mov	 BYTE PTR [esi+32], bl

; 1358 : 						this->_Color(this->_Left(_Pnode)) = this->_Black;

  00214	8b 00		 mov	 eax, DWORD PTR [eax]

; 1359 : 						_Rrotate(_Fixnodeparent);

  00216	56		 push	 esi
  00217	88 58 20	 mov	 BYTE PTR [eax+32], bl
  0021a	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::_Rrotate
$LN16@erase:

; 1360 : 						break;	// tree now recolored/rebalanced
; 1361 : 						}
; 1362 : 					}
; 1363 : 
; 1364 : 			this->_Color(_Fixnode) = this->_Black;	// stopping node is black

  0021f	88 5f 20	 mov	 BYTE PTR [edi+32], bl
$LN19@erase:

; 1365 : 			}
; 1366 : 
; 1367 : 		_Dest_val(this->_Alval,
; 1368 : 			_STD addressof(this->_Myval(_Erasednode)));	// delete erased node
; 1369 : 
; 1370 : 		this->_Alnod.deallocate(_Erasednode, 1);

  00222	8b 4d f8	 mov	 ecx, DWORD PTR __Erasednode$[ebp]
  00225	51		 push	 ecx
  00226	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete

; 1371 : 
; 1372 : 		if (0 < this->_Mysize)

  0022b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0022e	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00231	83 c4 04	 add	 esp, 4
  00234	5f		 pop	 edi
  00235	5e		 pop	 esi
  00236	5b		 pop	 ebx
  00237	85 c0		 test	 eax, eax
  00239	74 04		 je	 SHORT $LN1@erase

; 1373 : 			--this->_Mysize;

  0023b	48		 dec	 eax
  0023c	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$LN1@erase:

; 1374 : 
; 1375 : 		return (iterator(_Where._Ptr, this));	// return successor iterator

  0023f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00242	8b 55 0c	 mov	 edx, DWORD PTR __Where$[ebp]
  00245	89 10		 mov	 DWORD PTR [eax], edx

; 1376 : 		}

  00247	8b e5		 mov	 esp, ebp
  00249	5d		 pop	 ebp
  0024a	c2 08 00	 ret	 8
$LN292@erase:
?erase@?$_Tree@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::erase
_TEXT	ENDS
PUBLIC	?clear@?$_Tree@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::clear
; Function compile flags: /Ogtp
;	COMDAT ?clear@?$_Tree@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$_Tree@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::clear, COMDAT
; _this$ = ecx

; 1410 : 		{	// erase all

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	57		 push	 edi
  00003	8b f9		 mov	 edi, ecx

; 1411 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1412 : 		this->_Orphan_ptr(*this, 0);
; 1413 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1414 : 
; 1415 : 		_Erase(_Root());

  00005	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00008	8b 58 04	 mov	 ebx, DWORD PTR [eax+4]
  0000b	80 7b 21 00	 cmp	 BYTE PTR [ebx+33], 0
  0000f	8b f3		 mov	 esi, ebx
  00011	75 1e		 jne	 SHORT $LN7@clear
$LL9@clear:
  00013	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00016	51		 push	 ecx
  00017	8b cf		 mov	 ecx, edi
  00019	e8 00 00 00 00	 call	 ?_Erase@?$_Tree@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::_Erase
  0001e	8b 36		 mov	 esi, DWORD PTR [esi]
  00020	53		 push	 ebx
  00021	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00026	83 c4 04	 add	 esp, 4
  00029	80 7e 21 00	 cmp	 BYTE PTR [esi+33], 0
  0002d	8b de		 mov	 ebx, esi
  0002f	74 e2		 je	 SHORT $LL9@clear
$LN7@clear:

; 1416 : 		_Root() = this->_Myhead;

  00031	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00034	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 1417 : 		_Lmost() = this->_Myhead;

  00037	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0003a	89 00		 mov	 DWORD PTR [eax], eax

; 1418 : 		_Rmost() = this->_Myhead;

  0003c	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0003f	89 40 08	 mov	 DWORD PTR [eax+8], eax

; 1419 : 		this->_Mysize = 0;

  00042	c7 47 08 00 00
	00 00		 mov	 DWORD PTR [edi+8], 0
  00049	5f		 pop	 edi
  0004a	5e		 pop	 esi
  0004b	5b		 pop	 ebx

; 1420 : 		}

  0004c	c3		 ret	 0
?clear@?$_Tree@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::clear
_TEXT	ENDS
PUBLIC	?begin@?$_Tree@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::begin
; Function compile flags: /Ogtp
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$_Tree@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::begin, COMDAT
; _this$ = ecx

; 806  : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 807  : 		return (iterator(_Lmost(), this));

  00003	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00006	8b 08		 mov	 ecx, DWORD PTR [eax]
  00008	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0000b	89 08		 mov	 DWORD PTR [eax], ecx

; 808  : 		}

  0000d	5d		 pop	 ebp
  0000e	c2 04 00	 ret	 4
?begin@?$_Tree@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::begin
_TEXT	ENDS
PUBLIC	?end@?$_Tree@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::end
; Function compile flags: /Ogtp
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$_Tree@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::end, COMDAT
; _this$ = ecx

; 816  : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 817  : 		return (iterator(this->_Myhead, this));

  00003	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00006	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 818  : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
?end@?$_Tree@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::end
_TEXT	ENDS
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::erase
; Function compile flags: /Ogtp
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@2@@Z
_TEXT	SEGMENT
tv795 = -12						; size = 4
__Erasednode$ = -8					; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::erase, COMDAT
; _this$ = ecx

; 1195 : 		{	// erase element at _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx

; 1196 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1197 : 		if (_Where._Getcont() != this || this->_Isnil(_Where._Mynode()))
; 1198 : 			_DEBUG_ERROR("map/set erase iterator outside range");
; 1199 : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 1200 : 		++_Where;	// save successor iterator for return
; 1201 : 		_Orphan_ptr(*this, _Erasednode);
; 1202 : 
; 1203 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1204 : 		if (this->_Isnil(_Where._Mynode()))

  00007	8b 5d 0c	 mov	 ebx, DWORD PTR __Where$[ebp]
  0000a	80 7b 25 00	 cmp	 BYTE PTR [ebx+37], 0
  0000e	56		 push	 esi
  0000f	57		 push	 edi
  00010	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00013	74 0a		 je	 SHORT $LN40@erase@2

; 1205 : 			_Xout_of_range("invalid map/set<T> iterator");

  00015	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@
  0001a	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN295@erase@2:
$LN40@erase@2:

; 1206 : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 1207 : 		++_Where;	// save successor iterator for return

  0001f	8d 4d 0c	 lea	 ecx, DWORD PTR __Where$[ebp]
  00022	89 5d f8	 mov	 DWORD PTR __Erasednode$[ebp], ebx
  00025	e8 00 00 00 00	 call	 ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >,std::_Iterator_base0>::operator++

; 1208 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1209 : 
; 1210 : 		_Nodeptr _Fixnode;	// the node to recolor as needed
; 1211 : 		_Nodeptr _Fixnodeparent;	// parent of _Fixnode (which may be nil)
; 1212 : 		_Nodeptr _Pnode = _Erasednode;
; 1213 : 
; 1214 : 		if (this->_Isnil(this->_Left(_Pnode)))

  0002a	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  0002c	80 79 25 00	 cmp	 BYTE PTR [ecx+37], 0
  00030	74 05		 je	 SHORT $LN39@erase@2

; 1215 : 			_Fixnode = this->_Right(_Pnode);	// stitch up right subtree

  00032	8b 7b 08	 mov	 edi, DWORD PTR [ebx+8]

; 1216 : 		else if (this->_Isnil(this->_Right(_Pnode)))

  00035	eb 17		 jmp	 SHORT $LN291@erase@2
$LN39@erase@2:
  00037	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  0003a	80 78 25 00	 cmp	 BYTE PTR [eax+37], 0
  0003e	74 04		 je	 SHORT $LN37@erase@2

; 1217 : 			_Fixnode = this->_Left(_Pnode);	// stitch up left subtree

  00040	8b f9		 mov	 edi, ecx

; 1218 : 		else

  00042	eb 0a		 jmp	 SHORT $LN291@erase@2
$LN37@erase@2:

; 1219 : 			{	// two subtrees, must lift successor node to replace erased
; 1220 : 			_Pnode = _Where._Mynode();	// _Pnode is successor node

  00044	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]

; 1221 : 			_Fixnode = this->_Right(_Pnode);	// _Fixnode is only subtree

  00047	8b 78 08	 mov	 edi, DWORD PTR [eax+8]

; 1222 : 			}
; 1223 : 
; 1224 : 		if (_Pnode == _Erasednode)

  0004a	3b c3		 cmp	 eax, ebx
  0004c	75 72		 jne	 SHORT $LN35@erase@2
$LN291@erase@2:

; 1225 : 			{	// at most one subtree, relink it
; 1226 : 			_Fixnodeparent = this->_Parent(_Erasednode);
; 1227 : 			if (!this->_Isnil(_Fixnode))

  0004e	80 7f 25 00	 cmp	 BYTE PTR [edi+37], 0
  00052	8b 73 04	 mov	 esi, DWORD PTR [ebx+4]
  00055	75 03		 jne	 SHORT $LN34@erase@2

; 1228 : 				this->_Parent(_Fixnode) = _Fixnodeparent;	// link up

  00057	89 77 04	 mov	 DWORD PTR [edi+4], esi
$LN34@erase@2:

; 1229 : 
; 1230 : 			if (_Root() == _Erasednode)

  0005a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0005d	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00060	39 58 04	 cmp	 DWORD PTR [eax+4], ebx
  00063	75 05		 jne	 SHORT $LN33@erase@2

; 1231 : 				_Root() = _Fixnode;	// link down from root

  00065	89 78 04	 mov	 DWORD PTR [eax+4], edi

; 1232 : 			else if (this->_Left(_Fixnodeparent) == _Erasednode)

  00068	eb 0b		 jmp	 SHORT $LN30@erase@2
$LN33@erase@2:
  0006a	39 1e		 cmp	 DWORD PTR [esi], ebx
  0006c	75 04		 jne	 SHORT $LN31@erase@2

; 1233 : 				this->_Left(_Fixnodeparent) = _Fixnode;	// link down to left

  0006e	89 3e		 mov	 DWORD PTR [esi], edi

; 1234 : 			else

  00070	eb 03		 jmp	 SHORT $LN30@erase@2
$LN31@erase@2:

; 1235 : 				this->_Right(_Fixnodeparent) =
; 1236 : 					_Fixnode;	// link down to right

  00072	89 7e 08	 mov	 DWORD PTR [esi+8], edi
$LN30@erase@2:

; 1237 : 
; 1238 : 			if (_Lmost() == _Erasednode)

  00075	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00078	39 18		 cmp	 DWORD PTR [eax], ebx
  0007a	75 1b		 jne	 SHORT $LN29@erase@2

; 1239 : 				_Lmost() = this->_Isnil(_Fixnode)
; 1240 : 					? _Fixnodeparent	// smallest is parent of erased node
; 1241 : 					: this->_Min(_Fixnode);	// smallest in relinked subtree

  0007c	80 7f 25 00	 cmp	 BYTE PTR [edi+37], 0
  00080	74 04		 je	 SHORT $LN43@erase@2
  00082	8b c6		 mov	 eax, esi
  00084	eb 0c		 jmp	 SHORT $LN44@erase@2
$LN43@erase@2:
  00086	57		 push	 edi
  00087	e8 00 00 00 00	 call	 ?_Min@?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::_Min
  0008c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0008f	83 c4 04	 add	 esp, 4
$LN44@erase@2:
  00092	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00095	89 02		 mov	 DWORD PTR [edx], eax
$LN29@erase@2:

; 1242 : 
; 1243 : 			if (_Rmost() == _Erasednode)

  00097	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0009a	89 4d f4	 mov	 DWORD PTR tv795[ebp], ecx
  0009d	39 59 08	 cmp	 DWORD PTR [ecx+8], ebx
  000a0	75 78		 jne	 SHORT $LN165@erase@2

; 1244 : 				_Rmost() = this->_Isnil(_Fixnode)
; 1245 : 					? _Fixnodeparent	// largest is parent of erased node
; 1246 : 					: this->_Max(_Fixnode);	// largest in relinked subtree

  000a2	80 7f 25 00	 cmp	 BYTE PTR [edi+37], 0
  000a6	74 07		 je	 SHORT $LN45@erase@2
  000a8	8b c6		 mov	 eax, esi
  000aa	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 1247 : 			}
; 1248 : 		else

  000ad	eb 6b		 jmp	 SHORT $LN165@erase@2
$LN45@erase@2:

; 1244 : 				_Rmost() = this->_Isnil(_Fixnode)
; 1245 : 					? _Fixnodeparent	// largest is parent of erased node
; 1246 : 					: this->_Max(_Fixnode);	// largest in relinked subtree

  000af	57		 push	 edi
  000b0	e8 00 00 00 00	 call	 ?_Max@?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::_Max
  000b5	8b 4d f4	 mov	 ecx, DWORD PTR tv795[ebp]
  000b8	83 c4 04	 add	 esp, 4
  000bb	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 1247 : 			}
; 1248 : 		else

  000be	eb 5a		 jmp	 SHORT $LN165@erase@2
$LN35@erase@2:

; 1249 : 			{	// erased has two subtrees, _Pnode is successor to erased
; 1250 : 			this->_Parent(this->_Left(_Erasednode)) =
; 1251 : 				_Pnode;	// link left up

  000c0	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1252 : 			this->_Left(_Pnode) =
; 1253 : 				this->_Left(_Erasednode);	// link successor down

  000c3	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  000c5	89 08		 mov	 DWORD PTR [eax], ecx

; 1254 : 
; 1255 : 			if (_Pnode == this->_Right(_Erasednode))

  000c7	3b 43 08	 cmp	 eax, DWORD PTR [ebx+8]
  000ca	75 04		 jne	 SHORT $LN26@erase@2

; 1256 : 				_Fixnodeparent = _Pnode;	// successor is next to erased

  000cc	8b f0		 mov	 esi, eax

; 1257 : 			else

  000ce	eb 1a		 jmp	 SHORT $LN25@erase@2
$LN26@erase@2:

; 1258 : 				{	// successor further down, link in place of erased
; 1259 : 				_Fixnodeparent =
; 1260 : 					this->_Parent(_Pnode);	// parent is successor's
; 1261 : 				if (!this->_Isnil(_Fixnode))

  000d0	80 7f 25 00	 cmp	 BYTE PTR [edi+37], 0
  000d4	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  000d7	75 03		 jne	 SHORT $LN24@erase@2

; 1262 : 					this->_Parent(_Fixnode) = _Fixnodeparent;	// link fix up

  000d9	89 77 04	 mov	 DWORD PTR [edi+4], esi
$LN24@erase@2:

; 1263 : 				this->_Left(_Fixnodeparent) = _Fixnode;	// link fix down

  000dc	89 3e		 mov	 DWORD PTR [esi], edi

; 1264 : 				this->_Right(_Pnode) =
; 1265 : 					this->_Right(_Erasednode);	// link next down

  000de	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  000e1	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 1266 : 				this->_Parent(this->_Right(_Erasednode)) =
; 1267 : 					_Pnode;	// right up

  000e4	8b 53 08	 mov	 edx, DWORD PTR [ebx+8]
  000e7	89 42 04	 mov	 DWORD PTR [edx+4], eax
$LN25@erase@2:

; 1268 : 				}
; 1269 : 
; 1270 : 			if (_Root() == _Erasednode)

  000ea	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000ed	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  000f0	39 59 04	 cmp	 DWORD PTR [ecx+4], ebx
  000f3	75 05		 jne	 SHORT $LN23@erase@2

; 1271 : 				_Root() = _Pnode;	// link down from root

  000f5	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1272 : 			else if (this->_Left(this->_Parent(_Erasednode)) == _Erasednode)

  000f8	eb 0e		 jmp	 SHORT $LN20@erase@2
$LN23@erase@2:
  000fa	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  000fd	39 19		 cmp	 DWORD PTR [ecx], ebx
  000ff	75 04		 jne	 SHORT $LN21@erase@2

; 1273 : 				this->_Left(this->_Parent(_Erasednode)) =
; 1274 : 					_Pnode;	// link down to left

  00101	89 01		 mov	 DWORD PTR [ecx], eax

; 1275 : 			else

  00103	eb 03		 jmp	 SHORT $LN20@erase@2
$LN21@erase@2:

; 1276 : 				this->_Right(this->_Parent(_Erasednode)) =
; 1277 : 					_Pnode;	// link down to right

  00105	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$LN20@erase@2:

; 1278 : 
; 1279 : 			this->_Parent(_Pnode) =
; 1280 : 				this->_Parent(_Erasednode);	// link successor up

  00108	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  0010b	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 1281 : 			_STD swap(this->_Color(_Pnode),
; 1282 : 				this->_Color(_Erasednode));	// recolor it

  0010e	8a 53 24	 mov	 dl, BYTE PTR [ebx+36]
  00111	8a 48 24	 mov	 cl, BYTE PTR [eax+36]
  00114	88 50 24	 mov	 BYTE PTR [eax+36], dl
  00117	88 4b 24	 mov	 BYTE PTR [ebx+36], cl
$LN165@erase@2:

; 1283 : 			}
; 1284 : 
; 1285 : 		if (this->_Color(_Erasednode) == this->_Black)

  0011a	8b 45 f8	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  0011d	b3 01		 mov	 bl, 1
  0011f	38 58 24	 cmp	 BYTE PTR [eax+36], bl
  00122	0f 85 fa 00 00
	00		 jne	 $LN19@erase@2

; 1286 : 			{	// erasing black link, must recolor/rebalance tree
; 1287 : 			for (; _Fixnode != _Root()
; 1288 : 				&& this->_Color(_Fixnode) == this->_Black;
; 1289 : 				_Fixnodeparent = this->_Parent(_Fixnode))

  00128	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0012b	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0012e	3b 7a 04	 cmp	 edi, DWORD PTR [edx+4]
  00131	0f 84 e8 00 00
	00		 je	 $LN16@erase@2
$LL18@erase@2:
  00137	38 5f 24	 cmp	 BYTE PTR [edi+36], bl
  0013a	0f 85 df 00 00
	00		 jne	 $LN16@erase@2

; 1290 : 				if (_Fixnode == this->_Left(_Fixnodeparent))

  00140	8b 06		 mov	 eax, DWORD PTR [esi]
  00142	3b f8		 cmp	 edi, eax
  00144	75 65		 jne	 SHORT $LN15@erase@2

; 1291 : 					{	// fixup left subtree
; 1292 : 					_Pnode = this->_Right(_Fixnodeparent);

  00146	8b 46 08	 mov	 eax, DWORD PTR [esi+8]

; 1293 : 					if (this->_Color(_Pnode) == this->_Red)

  00149	80 78 24 00	 cmp	 BYTE PTR [eax+36], 0
  0014d	75 13		 jne	 SHORT $LN14@erase@2

; 1294 : 						{	// rotate red up from right subtree
; 1295 : 						this->_Color(_Pnode) = this->_Black;

  0014f	88 58 24	 mov	 BYTE PTR [eax+36], bl

; 1296 : 						this->_Color(_Fixnodeparent) = this->_Red;
; 1297 : 						_Lrotate(_Fixnodeparent);

  00152	56		 push	 esi
  00153	c6 46 24 00	 mov	 BYTE PTR [esi+36], 0
  00157	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::_Lrotate

; 1298 : 						_Pnode = this->_Right(_Fixnodeparent);

  0015c	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0015f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
$LN14@erase@2:

; 1299 : 						}
; 1300 : 
; 1301 : 					if (this->_Isnil(_Pnode))

  00162	80 78 25 00	 cmp	 BYTE PTR [eax+37], 0

; 1302 : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 1303 : 					else if (this->_Color(this->_Left(_Pnode)) == this->_Black

  00166	75 74		 jne	 SHORT $LN293@erase@2

; 1304 : 						&& this->_Color(this->_Right(_Pnode)) == this->_Black)

  00168	8b 10		 mov	 edx, DWORD PTR [eax]
  0016a	38 5a 24	 cmp	 BYTE PTR [edx+36], bl
  0016d	75 08		 jne	 SHORT $LN11@erase@2
  0016f	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00172	38 5a 24	 cmp	 BYTE PTR [edx+36], bl
  00175	74 61		 je	 SHORT $LN294@erase@2
$LN11@erase@2:

; 1305 : 						{	// redden right subtree with black children
; 1306 : 						this->_Color(_Pnode) = this->_Red;
; 1307 : 						_Fixnode = _Fixnodeparent;
; 1308 : 						}
; 1309 : 					else
; 1310 : 						{	// must rearrange right subtree
; 1311 : 						if (this->_Color(this->_Right(_Pnode))
; 1312 : 							== this->_Black)

  00177	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0017a	38 5a 24	 cmp	 BYTE PTR [edx+36], bl
  0017d	75 15		 jne	 SHORT $LN9@erase@2

; 1313 : 							{	// rotate red up from left sub-subtree
; 1314 : 							this->_Color(this->_Left(_Pnode)) = this->_Black;

  0017f	8b 10		 mov	 edx, DWORD PTR [eax]
  00181	88 5a 24	 mov	 BYTE PTR [edx+36], bl

; 1315 : 							this->_Color(_Pnode) = this->_Red;
; 1316 : 							_Rrotate(_Pnode);

  00184	50		 push	 eax
  00185	c6 40 24 00	 mov	 BYTE PTR [eax+36], 0
  00189	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::_Rrotate

; 1317 : 							_Pnode = this->_Right(_Fixnodeparent);

  0018e	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00191	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
$LN9@erase@2:

; 1318 : 							}
; 1319 : 
; 1320 : 						this->_Color(_Pnode) = this->_Color(_Fixnodeparent);

  00194	8a 56 24	 mov	 dl, BYTE PTR [esi+36]
  00197	88 50 24	 mov	 BYTE PTR [eax+36], dl

; 1321 : 						this->_Color(_Fixnodeparent) = this->_Black;

  0019a	88 5e 24	 mov	 BYTE PTR [esi+36], bl

; 1322 : 						this->_Color(this->_Right(_Pnode)) = this->_Black;

  0019d	8b 40 08	 mov	 eax, DWORD PTR [eax+8]

; 1323 : 						_Lrotate(_Fixnodeparent);

  001a0	56		 push	 esi
  001a1	88 58 24	 mov	 BYTE PTR [eax+36], bl
  001a4	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::_Lrotate

; 1324 : 						break;	// tree now recolored/rebalanced

  001a9	eb 74		 jmp	 SHORT $LN16@erase@2
$LN15@erase@2:

; 1325 : 						}
; 1326 : 					}
; 1327 : 				else
; 1328 : 					{	// fixup right subtree
; 1329 : 					_Pnode = this->_Left(_Fixnodeparent);
; 1330 : 					if (this->_Color(_Pnode) == this->_Red)

  001ab	80 78 24 00	 cmp	 BYTE PTR [eax+36], 0
  001af	75 12		 jne	 SHORT $LN7@erase@2

; 1331 : 						{	// rotate red up from left subtree
; 1332 : 						this->_Color(_Pnode) = this->_Black;

  001b1	88 58 24	 mov	 BYTE PTR [eax+36], bl

; 1333 : 						this->_Color(_Fixnodeparent) = this->_Red;
; 1334 : 						_Rrotate(_Fixnodeparent);

  001b4	56		 push	 esi
  001b5	c6 46 24 00	 mov	 BYTE PTR [esi+36], 0
  001b9	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::_Rrotate

; 1335 : 						_Pnode = this->_Left(_Fixnodeparent);

  001be	8b 06		 mov	 eax, DWORD PTR [esi]
  001c0	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
$LN7@erase@2:

; 1336 : 						}
; 1337 : 					if (this->_Isnil(_Pnode))

  001c3	80 78 25 00	 cmp	 BYTE PTR [eax+37], 0

; 1338 : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 1339 : 					else if (this->_Color(this->_Right(_Pnode)) ==

  001c7	75 13		 jne	 SHORT $LN293@erase@2

; 1340 : 						this->_Black
; 1341 : 						&& this->_Color(this->_Left(_Pnode)) == this->_Black)

  001c9	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  001cc	38 5a 24	 cmp	 BYTE PTR [edx+36], bl
  001cf	75 1e		 jne	 SHORT $LN4@erase@2
  001d1	8b 10		 mov	 edx, DWORD PTR [eax]
  001d3	38 5a 24	 cmp	 BYTE PTR [edx+36], bl
  001d6	75 17		 jne	 SHORT $LN4@erase@2
$LN294@erase@2:

; 1342 : 						{	// redden left subtree with black children
; 1343 : 						this->_Color(_Pnode) = this->_Red;

  001d8	c6 40 24 00	 mov	 BYTE PTR [eax+36], 0
$LN293@erase@2:

; 1286 : 			{	// erasing black link, must recolor/rebalance tree
; 1287 : 			for (; _Fixnode != _Root()
; 1288 : 				&& this->_Color(_Fixnode) == this->_Black;
; 1289 : 				_Fixnodeparent = this->_Parent(_Fixnode))

  001dc	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 1344 : 						_Fixnode = _Fixnodeparent;

  001df	8b fe		 mov	 edi, esi
  001e1	8b 76 04	 mov	 esi, DWORD PTR [esi+4]
  001e4	3b 78 04	 cmp	 edi, DWORD PTR [eax+4]
  001e7	0f 85 4a ff ff
	ff		 jne	 $LL18@erase@2

; 1286 : 			{	// erasing black link, must recolor/rebalance tree
; 1287 : 			for (; _Fixnode != _Root()
; 1288 : 				&& this->_Color(_Fixnode) == this->_Black;
; 1289 : 				_Fixnodeparent = this->_Parent(_Fixnode))

  001ed	eb 30		 jmp	 SHORT $LN16@erase@2
$LN4@erase@2:

; 1345 : 						}
; 1346 : 					else
; 1347 : 						{	// must rearrange left subtree
; 1348 : 						if (this->_Color(this->_Left(_Pnode)) == this->_Black)

  001ef	8b 10		 mov	 edx, DWORD PTR [eax]
  001f1	38 5a 24	 cmp	 BYTE PTR [edx+36], bl
  001f4	75 15		 jne	 SHORT $LN2@erase@2

; 1349 : 							{	// rotate red up from right sub-subtree
; 1350 : 							this->_Color(this->_Right(_Pnode)) = this->_Black;

  001f6	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  001f9	88 5a 24	 mov	 BYTE PTR [edx+36], bl

; 1351 : 							this->_Color(_Pnode) = this->_Red;
; 1352 : 							_Lrotate(_Pnode);

  001fc	50		 push	 eax
  001fd	c6 40 24 00	 mov	 BYTE PTR [eax+36], 0
  00201	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::_Lrotate

; 1353 : 							_Pnode = this->_Left(_Fixnodeparent);

  00206	8b 06		 mov	 eax, DWORD PTR [esi]
  00208	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
$LN2@erase@2:

; 1354 : 							}
; 1355 : 
; 1356 : 						this->_Color(_Pnode) = this->_Color(_Fixnodeparent);

  0020b	8a 56 24	 mov	 dl, BYTE PTR [esi+36]
  0020e	88 50 24	 mov	 BYTE PTR [eax+36], dl

; 1357 : 						this->_Color(_Fixnodeparent) = this->_Black;

  00211	88 5e 24	 mov	 BYTE PTR [esi+36], bl

; 1358 : 						this->_Color(this->_Left(_Pnode)) = this->_Black;

  00214	8b 00		 mov	 eax, DWORD PTR [eax]

; 1359 : 						_Rrotate(_Fixnodeparent);

  00216	56		 push	 esi
  00217	88 58 24	 mov	 BYTE PTR [eax+36], bl
  0021a	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::_Rrotate
$LN16@erase@2:

; 1360 : 						break;	// tree now recolored/rebalanced
; 1361 : 						}
; 1362 : 					}
; 1363 : 
; 1364 : 			this->_Color(_Fixnode) = this->_Black;	// stopping node is black

  0021f	88 5f 24	 mov	 BYTE PTR [edi+36], bl
$LN19@erase@2:

; 1365 : 			}
; 1366 : 
; 1367 : 		_Dest_val(this->_Alval,
; 1368 : 			_STD addressof(this->_Myval(_Erasednode)));	// delete erased node
; 1369 : 
; 1370 : 		this->_Alnod.deallocate(_Erasednode, 1);

  00222	8b 4d f8	 mov	 ecx, DWORD PTR __Erasednode$[ebp]
  00225	51		 push	 ecx
  00226	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete

; 1371 : 
; 1372 : 		if (0 < this->_Mysize)

  0022b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0022e	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00231	83 c4 04	 add	 esp, 4
  00234	5f		 pop	 edi
  00235	5e		 pop	 esi
  00236	5b		 pop	 ebx
  00237	85 c0		 test	 eax, eax
  00239	74 04		 je	 SHORT $LN1@erase@2

; 1373 : 			--this->_Mysize;

  0023b	48		 dec	 eax
  0023c	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$LN1@erase@2:

; 1374 : 
; 1375 : 		return (iterator(_Where._Ptr, this));	// return successor iterator

  0023f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00242	8b 55 0c	 mov	 edx, DWORD PTR __Where$[ebp]
  00245	89 10		 mov	 DWORD PTR [eax], edx

; 1376 : 		}

  00247	8b e5		 mov	 esp, ebp
  00249	5d		 pop	 ebp
  0024a	c2 08 00	 ret	 8
$LN292@erase@2:
?erase@?$_Tree@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::erase
_TEXT	ENDS
PUBLIC	?clear@?$_Tree@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::clear
; Function compile flags: /Ogtp
;	COMDAT ?clear@?$_Tree@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$_Tree@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::clear, COMDAT
; _this$ = ecx

; 1410 : 		{	// erase all

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	57		 push	 edi
  00003	8b f9		 mov	 edi, ecx

; 1411 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1412 : 		this->_Orphan_ptr(*this, 0);
; 1413 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1414 : 
; 1415 : 		_Erase(_Root());

  00005	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00008	8b 58 04	 mov	 ebx, DWORD PTR [eax+4]
  0000b	80 7b 25 00	 cmp	 BYTE PTR [ebx+37], 0
  0000f	8b f3		 mov	 esi, ebx
  00011	75 1e		 jne	 SHORT $LN7@clear@2
$LL9@clear@2:
  00013	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00016	51		 push	 ecx
  00017	8b cf		 mov	 ecx, edi
  00019	e8 00 00 00 00	 call	 ?_Erase@?$_Tree@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::_Erase
  0001e	8b 36		 mov	 esi, DWORD PTR [esi]
  00020	53		 push	 ebx
  00021	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00026	83 c4 04	 add	 esp, 4
  00029	80 7e 25 00	 cmp	 BYTE PTR [esi+37], 0
  0002d	8b de		 mov	 ebx, esi
  0002f	74 e2		 je	 SHORT $LL9@clear@2
$LN7@clear@2:

; 1416 : 		_Root() = this->_Myhead;

  00031	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00034	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 1417 : 		_Lmost() = this->_Myhead;

  00037	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0003a	89 00		 mov	 DWORD PTR [eax], eax

; 1418 : 		_Rmost() = this->_Myhead;

  0003c	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0003f	89 40 08	 mov	 DWORD PTR [eax+8], eax

; 1419 : 		this->_Mysize = 0;

  00042	c7 47 08 00 00
	00 00		 mov	 DWORD PTR [edi+8], 0
  00049	5f		 pop	 edi
  0004a	5e		 pop	 esi
  0004b	5b		 pop	 ebx

; 1420 : 		}

  0004c	c3		 ret	 0
?clear@?$_Tree@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::clear
_TEXT	ENDS
PUBLIC	?lower_bound@?$_Tree@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::lower_bound
; Function compile flags: /Ogtp
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@2@ABH@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
?lower_bound@?$_Tree@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@2@ABH@Z PROC ; std::_Tree<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::lower_bound, COMDAT
; _this$ = ecx

; 1449 : 		{	// find leftmost node not less than _Keyval in mutable tree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1450 : 		return (iterator(_Lbound(_Keyval), this));

  00003	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00006	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00009	80 78 21 00	 cmp	 BYTE PTR [eax+33], 0
  0000d	75 19		 jne	 SHORT $LN36@lower_boun
  0000f	8b 55 0c	 mov	 edx, DWORD PTR __Keyval$[ebp]
  00012	8b 12		 mov	 edx, DWORD PTR [edx]
$LL6@lower_boun:
  00014	39 50 0c	 cmp	 DWORD PTR [eax+12], edx
  00017	7d 05		 jge	 SHORT $LN4@lower_boun
  00019	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0001c	eb 04		 jmp	 SHORT $LN3@lower_boun
$LN4@lower_boun:
  0001e	8b c8		 mov	 ecx, eax
  00020	8b 00		 mov	 eax, DWORD PTR [eax]
$LN3@lower_boun:
  00022	80 78 21 00	 cmp	 BYTE PTR [eax+33], 0
  00026	74 ec		 je	 SHORT $LL6@lower_boun
$LN36@lower_boun:
  00028	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0002b	89 08		 mov	 DWORD PTR [eax], ecx

; 1451 : 		}

  0002d	5d		 pop	 ebp
  0002e	c2 08 00	 ret	 8
?lower_bound@?$_Tree@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@2@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::lower_bound
_TEXT	ENDS
PUBLIC	?lower_bound@?$_Tree@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::lower_bound
; Function compile flags: /Ogtp
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@2@ABH@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
?lower_bound@?$_Tree@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@2@ABH@Z PROC ; std::_Tree<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::lower_bound, COMDAT
; _this$ = ecx

; 1449 : 		{	// find leftmost node not less than _Keyval in mutable tree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1450 : 		return (iterator(_Lbound(_Keyval), this));

  00003	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00006	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00009	80 78 25 00	 cmp	 BYTE PTR [eax+37], 0
  0000d	75 19		 jne	 SHORT $LN36@lower_boun@2
  0000f	8b 55 0c	 mov	 edx, DWORD PTR __Keyval$[ebp]
  00012	8b 12		 mov	 edx, DWORD PTR [edx]
$LL6@lower_boun@2:
  00014	39 50 0c	 cmp	 DWORD PTR [eax+12], edx
  00017	7d 05		 jge	 SHORT $LN4@lower_boun@2
  00019	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0001c	eb 04		 jmp	 SHORT $LN3@lower_boun@2
$LN4@lower_boun@2:
  0001e	8b c8		 mov	 ecx, eax
  00020	8b 00		 mov	 eax, DWORD PTR [eax]
$LN3@lower_boun@2:
  00022	80 78 25 00	 cmp	 BYTE PTR [eax+37], 0
  00026	74 ec		 je	 SHORT $LL6@lower_boun@2
$LN36@lower_boun@2:
  00028	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0002b	89 08		 mov	 DWORD PTR [eax], ecx

; 1451 : 		}

  0002d	5d		 pop	 ebp
  0002e	c2 08 00	 ret	 8
?lower_bound@?$_Tree@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@2@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::lower_bound
_TEXT	ENDS
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::erase
; Function compile flags: /Ogtp
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@2@0@Z
_TEXT	SEGMENT
$T199366 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@2@0@Z PROC ; std::_Tree<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::erase, COMDAT
; _this$ = ecx

; 1379 : 		{	// erase [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1380 : 		if (_First == begin() && _Last == end())

  00004	8b 55 10	 mov	 edx, DWORD PTR __Last$[ebp]
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0000d	8b 4d 0c	 mov	 ecx, DWORD PTR __First$[ebp]
  00010	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00012	75 1c		 jne	 SHORT $LN97@erase@3
  00014	3b d0		 cmp	 edx, eax
  00016	75 18		 jne	 SHORT $LN97@erase@3

; 1381 : 			{	// erase all
; 1382 : 			clear();

  00018	8b ce		 mov	 ecx, esi
  0001a	e8 00 00 00 00	 call	 ?clear@?$_Tree@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::clear

; 1383 : 			return (begin());

  0001f	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00022	8b 08		 mov	 ecx, DWORD PTR [eax]

; 1389 : 			return (iterator(_First._Ptr, this));

  00024	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00027	89 08		 mov	 DWORD PTR [eax], ecx
  00029	5e		 pop	 esi

; 1390 : 			}
; 1391 : 		}

  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 0c 00	 ret	 12			; 0000000cH
$LN97@erase@3:

; 1384 : 			}
; 1385 : 		else
; 1386 : 			{	// partial erase, one at a time
; 1387 : 			while (_First != _Last)

  00030	3b ca		 cmp	 ecx, edx
  00032	74 5e		 je	 SHORT $LN1@erase@3
$LL2@erase@3:

; 1388 : 				erase(_First++);

  00034	80 79 21 00	 cmp	 BYTE PTR [ecx+33], 0
  00038	8b d1		 mov	 edx, ecx
  0003a	75 42		 jne	 SHORT $LN59@erase@3
  0003c	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0003f	80 78 21 00	 cmp	 BYTE PTR [eax+33], 0
  00043	75 1a		 jne	 SHORT $LN99@erase@3
  00045	8b c8		 mov	 ecx, eax
  00047	8b 01		 mov	 eax, DWORD PTR [ecx]
  00049	80 78 21 00	 cmp	 BYTE PTR [eax+33], 0
  0004d	75 0b		 jne	 SHORT $LN73@erase@3
  0004f	90		 npad	 1
$LL74@erase@3:
  00050	8b c8		 mov	 ecx, eax
  00052	8b 01		 mov	 eax, DWORD PTR [ecx]
  00054	80 78 21 00	 cmp	 BYTE PTR [eax+33], 0
  00058	74 f6		 je	 SHORT $LL74@erase@3
$LN73@erase@3:
  0005a	89 4d 0c	 mov	 DWORD PTR __First$[ebp], ecx
  0005d	eb 1f		 jmp	 SHORT $LN59@erase@3
$LN99@erase@3:
  0005f	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00062	80 78 21 00	 cmp	 BYTE PTR [eax+33], 0
  00066	75 13		 jne	 SHORT $LN57@erase@3
$LL58@erase@3:
  00068	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  0006b	75 0e		 jne	 SHORT $LN57@erase@3
  0006d	8b c8		 mov	 ecx, eax
  0006f	89 4d 0c	 mov	 DWORD PTR __First$[ebp], ecx
  00072	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00075	80 78 21 00	 cmp	 BYTE PTR [eax+33], 0
  00079	74 ed		 je	 SHORT $LL58@erase@3
$LN57@erase@3:
  0007b	89 45 0c	 mov	 DWORD PTR __First$[ebp], eax
$LN59@erase@3:
  0007e	52		 push	 edx
  0007f	8d 55 fc	 lea	 edx, DWORD PTR $T199366[ebp]
  00082	52		 push	 edx
  00083	8b ce		 mov	 ecx, esi
  00085	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::erase
  0008a	8b 4d 0c	 mov	 ecx, DWORD PTR __First$[ebp]
  0008d	3b 4d 10	 cmp	 ecx, DWORD PTR __Last$[ebp]
  00090	75 a2		 jne	 SHORT $LL2@erase@3
$LN1@erase@3:

; 1389 : 			return (iterator(_First._Ptr, this));

  00092	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00095	89 08		 mov	 DWORD PTR [eax], ecx
  00097	5e		 pop	 esi

; 1390 : 			}
; 1391 : 		}

  00098	8b e5		 mov	 esp, ebp
  0009a	5d		 pop	 ebp
  0009b	c2 0c 00	 ret	 12			; 0000000cH
?erase@?$_Tree@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@2@0@Z ENDP ; std::_Tree<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::erase
_TEXT	ENDS
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::erase
; Function compile flags: /Ogtp
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@2@0@Z
_TEXT	SEGMENT
$T199702 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@2@0@Z PROC ; std::_Tree<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::erase, COMDAT
; _this$ = ecx

; 1379 : 		{	// erase [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1380 : 		if (_First == begin() && _Last == end())

  00004	8b 55 10	 mov	 edx, DWORD PTR __Last$[ebp]
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0000d	8b 4d 0c	 mov	 ecx, DWORD PTR __First$[ebp]
  00010	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00012	75 1c		 jne	 SHORT $LN97@erase@4
  00014	3b d0		 cmp	 edx, eax
  00016	75 18		 jne	 SHORT $LN97@erase@4

; 1381 : 			{	// erase all
; 1382 : 			clear();

  00018	8b ce		 mov	 ecx, esi
  0001a	e8 00 00 00 00	 call	 ?clear@?$_Tree@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::clear

; 1383 : 			return (begin());

  0001f	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00022	8b 08		 mov	 ecx, DWORD PTR [eax]

; 1389 : 			return (iterator(_First._Ptr, this));

  00024	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00027	89 08		 mov	 DWORD PTR [eax], ecx
  00029	5e		 pop	 esi

; 1390 : 			}
; 1391 : 		}

  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 0c 00	 ret	 12			; 0000000cH
$LN97@erase@4:

; 1384 : 			}
; 1385 : 		else
; 1386 : 			{	// partial erase, one at a time
; 1387 : 			while (_First != _Last)

  00030	3b ca		 cmp	 ecx, edx
  00032	74 5e		 je	 SHORT $LN1@erase@4
$LL2@erase@4:

; 1388 : 				erase(_First++);

  00034	80 79 25 00	 cmp	 BYTE PTR [ecx+37], 0
  00038	8b d1		 mov	 edx, ecx
  0003a	75 42		 jne	 SHORT $LN59@erase@4
  0003c	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0003f	80 78 25 00	 cmp	 BYTE PTR [eax+37], 0
  00043	75 1a		 jne	 SHORT $LN99@erase@4
  00045	8b c8		 mov	 ecx, eax
  00047	8b 01		 mov	 eax, DWORD PTR [ecx]
  00049	80 78 25 00	 cmp	 BYTE PTR [eax+37], 0
  0004d	75 0b		 jne	 SHORT $LN73@erase@4
  0004f	90		 npad	 1
$LL74@erase@4:
  00050	8b c8		 mov	 ecx, eax
  00052	8b 01		 mov	 eax, DWORD PTR [ecx]
  00054	80 78 25 00	 cmp	 BYTE PTR [eax+37], 0
  00058	74 f6		 je	 SHORT $LL74@erase@4
$LN73@erase@4:
  0005a	89 4d 0c	 mov	 DWORD PTR __First$[ebp], ecx
  0005d	eb 1f		 jmp	 SHORT $LN59@erase@4
$LN99@erase@4:
  0005f	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00062	80 78 25 00	 cmp	 BYTE PTR [eax+37], 0
  00066	75 13		 jne	 SHORT $LN57@erase@4
$LL58@erase@4:
  00068	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  0006b	75 0e		 jne	 SHORT $LN57@erase@4
  0006d	8b c8		 mov	 ecx, eax
  0006f	89 4d 0c	 mov	 DWORD PTR __First$[ebp], ecx
  00072	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00075	80 78 25 00	 cmp	 BYTE PTR [eax+37], 0
  00079	74 ed		 je	 SHORT $LL58@erase@4
$LN57@erase@4:
  0007b	89 45 0c	 mov	 DWORD PTR __First$[ebp], eax
$LN59@erase@4:
  0007e	52		 push	 edx
  0007f	8d 55 fc	 lea	 edx, DWORD PTR $T199702[ebp]
  00082	52		 push	 edx
  00083	8b ce		 mov	 ecx, esi
  00085	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::erase
  0008a	8b 4d 0c	 mov	 ecx, DWORD PTR __First$[ebp]
  0008d	3b 4d 10	 cmp	 ecx, DWORD PTR __Last$[ebp]
  00090	75 a2		 jne	 SHORT $LL2@erase@4
$LN1@erase@4:

; 1389 : 			return (iterator(_First._Ptr, this));

  00092	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00095	89 08		 mov	 DWORD PTR [eax], ecx
  00097	5e		 pop	 esi

; 1390 : 			}
; 1391 : 		}

  00098	8b e5		 mov	 esp, ebp
  0009a	5d		 pop	 ebp
  0009b	c2 0c 00	 ret	 12			; 0000000cH
?erase@?$_Tree@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@2@0@Z ENDP ; std::_Tree<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::erase
_TEXT	ENDS
PUBLIC	?_Linsert@?$_Tree@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@std@@_N@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@2@_N@Z ; std::_Tree<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::_Linsert
; Function compile flags: /Ogtp
;	COMDAT ?_Linsert@?$_Tree@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@std@@_N@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@2@_N@Z
_TEXT	SEGMENT
__Addleft$ = -4						; size = 1
___$ReturnUdt$ = 8					; size = 4
__Node$ = 12						; size = 4
$T200043 = 16						; size = 4
$T200041 = 16						; size = 4
__Where$191474 = 16					; size = 4
__Leftish$ = 16						; size = 1
?_Linsert@?$_Tree@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@std@@_N@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@2@_N@Z PROC ; std::_Tree<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::_Linsert, COMDAT
; _this$ = ecx

; 944  : 		{	// try to insert node at _Node, on left if _Leftish

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 945  : 		const value_type& _Val = this->_Myval(_Node);
; 946  : 
; 947  : 		_Nodeptr _Trynode = _Root();
; 948  : 		_Nodeptr _Wherenode = this->_Myhead;
; 949  : 		bool _Addleft = true;	// add to left of head if tree empty
; 950  : 		while (!this->_Isnil(_Trynode))

  00004	8b 55 0c	 mov	 edx, DWORD PTR __Node$[ebp]
  00007	53		 push	 ebx
  00008	8b d9		 mov	 ebx, ecx
  0000a	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  0000d	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00010	80 78 21 00	 cmp	 BYTE PTR [eax+33], 0
  00014	56		 push	 esi
  00015	8b f1		 mov	 esi, ecx
  00017	b1 01		 mov	 cl, 1
  00019	57		 push	 edi
  0001a	88 4d fc	 mov	 BYTE PTR __Addleft$[ebp], cl
  0001d	75 2d		 jne	 SHORT $LN11@Linsert
  0001f	8b 7a 0c	 mov	 edi, DWORD PTR [edx+12]
$LL12@Linsert:

; 951  : 			{	// look for leaf to insert before (_Addleft) or after
; 952  : 			_Wherenode = _Trynode;
; 953  : 			if (_Leftish)

  00022	80 7d 10 00	 cmp	 BYTE PTR __Leftish$[ebp], 0
  00026	8b f0		 mov	 esi, eax
  00028	74 08		 je	 SHORT $LN10@Linsert

; 954  : 				_Addleft = !_DEBUG_LT_PRED(this->comp,

  0002a	39 78 0c	 cmp	 DWORD PTR [eax+12], edi
  0002d	0f 9d c1	 setge	 cl

; 955  : 					this->_Key(_Trynode),
; 956  : 					this->_Kfn(_Val));	// favor left end
; 957  : 			else

  00030	eb 06		 jmp	 SHORT $LN146@Linsert
$LN10@Linsert:

; 958  : 				_Addleft = _DEBUG_LT_PRED(this->comp,

  00032	3b 78 0c	 cmp	 edi, DWORD PTR [eax+12]
  00035	0f 9c c1	 setl	 cl
$LN146@Linsert:
  00038	88 4d fc	 mov	 BYTE PTR __Addleft$[ebp], cl

; 959  : 					this->_Kfn(_Val),
; 960  : 					this->_Key(_Trynode));	// favor right end
; 961  : 			_Trynode = _Addleft ? this->_Left(_Trynode)
; 962  : 				: this->_Right(_Trynode);

  0003b	84 c9		 test	 cl, cl
  0003d	74 04		 je	 SHORT $LN15@Linsert
  0003f	8b 00		 mov	 eax, DWORD PTR [eax]
  00041	eb 03		 jmp	 SHORT $LN16@Linsert
$LN15@Linsert:
  00043	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
$LN16@Linsert:

; 945  : 		const value_type& _Val = this->_Myval(_Node);
; 946  : 
; 947  : 		_Nodeptr _Trynode = _Root();
; 948  : 		_Nodeptr _Wherenode = this->_Myhead;
; 949  : 		bool _Addleft = true;	// add to left of head if tree empty
; 950  : 		while (!this->_Isnil(_Trynode))

  00046	80 78 21 00	 cmp	 BYTE PTR [eax+33], 0
  0004a	74 d6		 je	 SHORT $LL12@Linsert
$LN11@Linsert:

; 963  : 			}
; 964  : 
; 965  : 		if (this->_Multi)
; 966  : 			return (_Pairib(_Insert(_Addleft, _Wherenode, _Node), true));
; 967  : 		else
; 968  : 			{	// insert only if unique
; 969  : 			iterator _Where = iterator(_Wherenode, this);

  0004c	8b fe		 mov	 edi, esi
  0004e	89 7d 10	 mov	 DWORD PTR __Where$191474[ebp], edi

; 970  : 			if (!_Addleft)

  00051	84 c9		 test	 cl, cl
  00053	74 35		 je	 SHORT $LN99@Linsert

; 971  : 				;	// need to test if insert after is okay
; 972  : 			else if (_Where == begin())

  00055	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]

; 973  : 				return (_Pairib(_Insert(true, _Wherenode, _Node), true));

  00058	8d 4d 10	 lea	 ecx, DWORD PTR $T200041[ebp]
  0005b	3b 30		 cmp	 esi, DWORD PTR [eax]
  0005d	75 20		 jne	 SHORT $LN4@Linsert
  0005f	52		 push	 edx
  00060	56		 push	 esi
  00061	6a 01		 push	 1
  00063	51		 push	 ecx
  00064	8b cb		 mov	 ecx, ebx
  00066	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::_Insert
  0006b	8b 10		 mov	 edx, DWORD PTR [eax]
  0006d	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00070	5f		 pop	 edi
  00071	5e		 pop	 esi
  00072	89 10		 mov	 DWORD PTR [eax], edx
  00074	c6 40 04 01	 mov	 BYTE PTR [eax+4], 1
  00078	5b		 pop	 ebx

; 989  : 				}
; 990  : 			}
; 991  : 		}

  00079	8b e5		 mov	 esp, ebp
  0007b	5d		 pop	 ebp
  0007c	c2 0c 00	 ret	 12			; 0000000cH
$LN4@Linsert:

; 974  : 			else
; 975  : 				--_Where;	// need to test if insert before is okay

  0007f	e8 00 00 00 00	 call	 ??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >,std::_Iterator_base0>::operator--
  00084	8b 7d 10	 mov	 edi, DWORD PTR __Where$191474[ebp]
  00087	8b 55 0c	 mov	 edx, DWORD PTR __Node$[ebp]
$LN99@Linsert:

; 976  : 
; 977  : 			if (_DEBUG_LT_PRED(this->comp,

  0008a	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]

; 978  : 				this->_Key(_Where._Mynode()),
; 979  : 				this->_Kfn(_Val)))
; 980  : 				return (_Pairib(_Insert(_Addleft, _Wherenode, _Node), true));

  0008d	52		 push	 edx
  0008e	3b 42 0c	 cmp	 eax, DWORD PTR [edx+12]
  00091	7d 24		 jge	 SHORT $LN2@Linsert
  00093	8b 4d fc	 mov	 ecx, DWORD PTR __Addleft$[ebp]
  00096	56		 push	 esi
  00097	51		 push	 ecx
  00098	8d 55 10	 lea	 edx, DWORD PTR $T200043[ebp]
  0009b	52		 push	 edx
  0009c	8b cb		 mov	 ecx, ebx
  0009e	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::_Insert
  000a3	8b 08		 mov	 ecx, DWORD PTR [eax]
  000a5	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000a8	5f		 pop	 edi
  000a9	5e		 pop	 esi
  000aa	89 08		 mov	 DWORD PTR [eax], ecx
  000ac	c6 40 04 01	 mov	 BYTE PTR [eax+4], 1
  000b0	5b		 pop	 ebx

; 989  : 				}
; 990  : 			}
; 991  : 		}

  000b1	8b e5		 mov	 esp, ebp
  000b3	5d		 pop	 ebp
  000b4	c2 0c 00	 ret	 12			; 0000000cH
$LN2@Linsert:

; 981  : 			else
; 982  : 				{	// duplicate, don't insert
; 983  : 				_Dest_val(this->_Alval,
; 984  : 					_STD addressof(this->_Myval(_Node)));
; 985  : 
; 986  : 				this->_Alnod.deallocate(_Node, 1);

  000b7	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete

; 987  : 
; 988  : 				return (_Pairib(_Where, false));

  000bc	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000bf	83 c4 04	 add	 esp, 4
  000c2	89 38		 mov	 DWORD PTR [eax], edi
  000c4	5f		 pop	 edi
  000c5	5e		 pop	 esi
  000c6	c6 40 04 00	 mov	 BYTE PTR [eax+4], 0
  000ca	5b		 pop	 ebx

; 989  : 				}
; 990  : 			}
; 991  : 		}

  000cb	8b e5		 mov	 esp, ebp
  000cd	5d		 pop	 ebp
  000ce	c2 0c 00	 ret	 12			; 0000000cH
?_Linsert@?$_Tree@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@std@@_N@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@2@_N@Z ENDP ; std::_Tree<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::_Linsert
_TEXT	ENDS
PUBLIC	?_Linsert@?$_Tree@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@std@@_N@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@2@_N@Z ; std::_Tree<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::_Linsert
; Function compile flags: /Ogtp
;	COMDAT ?_Linsert@?$_Tree@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@std@@_N@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@2@_N@Z
_TEXT	SEGMENT
__Addleft$ = -4						; size = 1
___$ReturnUdt$ = 8					; size = 4
__Node$ = 12						; size = 4
$T200363 = 16						; size = 4
$T200361 = 16						; size = 4
__Where$191524 = 16					; size = 4
__Leftish$ = 16						; size = 1
?_Linsert@?$_Tree@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@std@@_N@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@2@_N@Z PROC ; std::_Tree<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::_Linsert, COMDAT
; _this$ = ecx

; 944  : 		{	// try to insert node at _Node, on left if _Leftish

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 945  : 		const value_type& _Val = this->_Myval(_Node);
; 946  : 
; 947  : 		_Nodeptr _Trynode = _Root();
; 948  : 		_Nodeptr _Wherenode = this->_Myhead;
; 949  : 		bool _Addleft = true;	// add to left of head if tree empty
; 950  : 		while (!this->_Isnil(_Trynode))

  00004	8b 55 0c	 mov	 edx, DWORD PTR __Node$[ebp]
  00007	53		 push	 ebx
  00008	8b d9		 mov	 ebx, ecx
  0000a	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  0000d	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00010	80 78 25 00	 cmp	 BYTE PTR [eax+37], 0
  00014	56		 push	 esi
  00015	8b f1		 mov	 esi, ecx
  00017	b1 01		 mov	 cl, 1
  00019	57		 push	 edi
  0001a	88 4d fc	 mov	 BYTE PTR __Addleft$[ebp], cl
  0001d	75 2d		 jne	 SHORT $LN11@Linsert@2
  0001f	8b 7a 0c	 mov	 edi, DWORD PTR [edx+12]
$LL12@Linsert@2:

; 951  : 			{	// look for leaf to insert before (_Addleft) or after
; 952  : 			_Wherenode = _Trynode;
; 953  : 			if (_Leftish)

  00022	80 7d 10 00	 cmp	 BYTE PTR __Leftish$[ebp], 0
  00026	8b f0		 mov	 esi, eax
  00028	74 08		 je	 SHORT $LN10@Linsert@2

; 954  : 				_Addleft = !_DEBUG_LT_PRED(this->comp,

  0002a	39 78 0c	 cmp	 DWORD PTR [eax+12], edi
  0002d	0f 9d c1	 setge	 cl

; 955  : 					this->_Key(_Trynode),
; 956  : 					this->_Kfn(_Val));	// favor left end
; 957  : 			else

  00030	eb 06		 jmp	 SHORT $LN146@Linsert@2
$LN10@Linsert@2:

; 958  : 				_Addleft = _DEBUG_LT_PRED(this->comp,

  00032	3b 78 0c	 cmp	 edi, DWORD PTR [eax+12]
  00035	0f 9c c1	 setl	 cl
$LN146@Linsert@2:
  00038	88 4d fc	 mov	 BYTE PTR __Addleft$[ebp], cl

; 959  : 					this->_Kfn(_Val),
; 960  : 					this->_Key(_Trynode));	// favor right end
; 961  : 			_Trynode = _Addleft ? this->_Left(_Trynode)
; 962  : 				: this->_Right(_Trynode);

  0003b	84 c9		 test	 cl, cl
  0003d	74 04		 je	 SHORT $LN15@Linsert@2
  0003f	8b 00		 mov	 eax, DWORD PTR [eax]
  00041	eb 03		 jmp	 SHORT $LN16@Linsert@2
$LN15@Linsert@2:
  00043	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
$LN16@Linsert@2:

; 945  : 		const value_type& _Val = this->_Myval(_Node);
; 946  : 
; 947  : 		_Nodeptr _Trynode = _Root();
; 948  : 		_Nodeptr _Wherenode = this->_Myhead;
; 949  : 		bool _Addleft = true;	// add to left of head if tree empty
; 950  : 		while (!this->_Isnil(_Trynode))

  00046	80 78 25 00	 cmp	 BYTE PTR [eax+37], 0
  0004a	74 d6		 je	 SHORT $LL12@Linsert@2
$LN11@Linsert@2:

; 963  : 			}
; 964  : 
; 965  : 		if (this->_Multi)
; 966  : 			return (_Pairib(_Insert(_Addleft, _Wherenode, _Node), true));
; 967  : 		else
; 968  : 			{	// insert only if unique
; 969  : 			iterator _Where = iterator(_Wherenode, this);

  0004c	8b fe		 mov	 edi, esi
  0004e	89 7d 10	 mov	 DWORD PTR __Where$191524[ebp], edi

; 970  : 			if (!_Addleft)

  00051	84 c9		 test	 cl, cl
  00053	74 35		 je	 SHORT $LN99@Linsert@2

; 971  : 				;	// need to test if insert after is okay
; 972  : 			else if (_Where == begin())

  00055	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]

; 973  : 				return (_Pairib(_Insert(true, _Wherenode, _Node), true));

  00058	8d 4d 10	 lea	 ecx, DWORD PTR $T200361[ebp]
  0005b	3b 30		 cmp	 esi, DWORD PTR [eax]
  0005d	75 20		 jne	 SHORT $LN4@Linsert@2
  0005f	52		 push	 edx
  00060	56		 push	 esi
  00061	6a 01		 push	 1
  00063	51		 push	 ecx
  00064	8b cb		 mov	 ecx, ebx
  00066	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::_Insert
  0006b	8b 10		 mov	 edx, DWORD PTR [eax]
  0006d	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00070	5f		 pop	 edi
  00071	5e		 pop	 esi
  00072	89 10		 mov	 DWORD PTR [eax], edx
  00074	c6 40 04 01	 mov	 BYTE PTR [eax+4], 1
  00078	5b		 pop	 ebx

; 989  : 				}
; 990  : 			}
; 991  : 		}

  00079	8b e5		 mov	 esp, ebp
  0007b	5d		 pop	 ebp
  0007c	c2 0c 00	 ret	 12			; 0000000cH
$LN4@Linsert@2:

; 974  : 			else
; 975  : 				--_Where;	// need to test if insert before is okay

  0007f	e8 00 00 00 00	 call	 ??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >,std::_Iterator_base0>::operator--
  00084	8b 7d 10	 mov	 edi, DWORD PTR __Where$191524[ebp]
  00087	8b 55 0c	 mov	 edx, DWORD PTR __Node$[ebp]
$LN99@Linsert@2:

; 976  : 
; 977  : 			if (_DEBUG_LT_PRED(this->comp,

  0008a	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]

; 978  : 				this->_Key(_Where._Mynode()),
; 979  : 				this->_Kfn(_Val)))
; 980  : 				return (_Pairib(_Insert(_Addleft, _Wherenode, _Node), true));

  0008d	52		 push	 edx
  0008e	3b 42 0c	 cmp	 eax, DWORD PTR [edx+12]
  00091	7d 24		 jge	 SHORT $LN2@Linsert@2
  00093	8b 4d fc	 mov	 ecx, DWORD PTR __Addleft$[ebp]
  00096	56		 push	 esi
  00097	51		 push	 ecx
  00098	8d 55 10	 lea	 edx, DWORD PTR $T200363[ebp]
  0009b	52		 push	 edx
  0009c	8b cb		 mov	 ecx, ebx
  0009e	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::_Insert
  000a3	8b 08		 mov	 ecx, DWORD PTR [eax]
  000a5	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000a8	5f		 pop	 edi
  000a9	5e		 pop	 esi
  000aa	89 08		 mov	 DWORD PTR [eax], ecx
  000ac	c6 40 04 01	 mov	 BYTE PTR [eax+4], 1
  000b0	5b		 pop	 ebx

; 989  : 				}
; 990  : 			}
; 991  : 		}

  000b1	8b e5		 mov	 esp, ebp
  000b3	5d		 pop	 ebp
  000b4	c2 0c 00	 ret	 12			; 0000000cH
$LN2@Linsert@2:

; 981  : 			else
; 982  : 				{	// duplicate, don't insert
; 983  : 				_Dest_val(this->_Alval,
; 984  : 					_STD addressof(this->_Myval(_Node)));
; 985  : 
; 986  : 				this->_Alnod.deallocate(_Node, 1);

  000b7	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete

; 987  : 
; 988  : 				return (_Pairib(_Where, false));

  000bc	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000bf	83 c4 04	 add	 esp, 4
  000c2	89 38		 mov	 DWORD PTR [eax], edi
  000c4	5f		 pop	 edi
  000c5	5e		 pop	 esi
  000c6	c6 40 04 00	 mov	 BYTE PTR [eax+4], 0
  000ca	5b		 pop	 ebx

; 989  : 				}
; 990  : 			}
; 991  : 		}

  000cb	8b e5		 mov	 esp, ebp
  000cd	5d		 pop	 ebp
  000ce	c2 0c 00	 ret	 12			; 0000000cH
?_Linsert@?$_Tree@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@std@@_N@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@2@_N@Z ENDP ; std::_Tree<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::_Linsert
_TEXT	ENDS
PUBLIC	??$_Buynode@U?$pair@HU_tagWaiting@@@std@@@?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@HU_tagWaiting@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::_Buynode<std::pair<int,_tagWaiting> >
; Function compile flags: /Ogtp
;	COMDAT ??$_Buynode@U?$pair@HU_tagWaiting@@@std@@@?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@HU_tagWaiting@@@1@@Z
_TEXT	SEGMENT
$T200733 = -12						; size = 12
$T200686 = 8						; size = 4
__Val$ = 8						; size = 4
??$_Buynode@U?$pair@HU_tagWaiting@@@std@@@?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@HU_tagWaiting@@@1@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::_Buynode<std::pair<int,_tagWaiting> >, COMDAT
; _this$ = ecx

; 586  : 		_Nodeptr _Buynode(_Valty&& _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi
  00007	57		 push	 edi

; 587  : 		{	// allocate a node with defaults
; 588  : 		_Nodeptr _Wherenode = _Buynode();

  00008	6a 24		 push	 36			; 00000024H
  0000a	8b f9		 mov	 edi, ecx
  0000c	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00011	8b f0		 mov	 esi, eax
  00013	33 c0		 xor	 eax, eax
  00015	83 c4 04	 add	 esp, 4
  00018	3b f0		 cmp	 esi, eax
  0001a	74 33		 je	 SHORT $LN12@Buynode@3
  0001c	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  0001f	89 0e		 mov	 DWORD PTR [esi], ecx
  00021	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  00024	89 56 04	 mov	 DWORD PTR [esi+4], edx
  00027	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]

; 589  : 
; 590  : 		_TRY_BEGIN
; 591  : 		_Cons_val(this->_Alval, _STD addressof(this->_Myval(_Wherenode)),
; 592  : 			_STD forward<_Valty>(_Val));

  0002a	8b 55 08	 mov	 edx, DWORD PTR __Val$[ebp]
  0002d	66 89 46 20	 mov	 WORD PTR [esi+32], ax
  00031	52		 push	 edx
  00032	8d 46 0c	 lea	 eax, DWORD PTR [esi+12]
  00035	50		 push	 eax
  00036	83 c7 0d	 add	 edi, 13			; 0000000dH
  00039	57		 push	 edi
  0003a	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  0003d	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@std@@U?$pair@$$CBHU_tagWaiting@@@2@U?$pair@HU_tagWaiting@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@0@PAU?$pair@$$CBHU_tagWaiting@@@0@$$QAU?$pair@HU_tagWaiting@@@0@@Z ; std::_Cons_val<std::allocator<std::pair<int const ,_tagWaiting> >,std::pair<int const ,_tagWaiting>,std::pair<int,_tagWaiting> >
  00042	83 c4 0c	 add	 esp, 12			; 0000000cH
  00045	5f		 pop	 edi

; 593  : 		_CATCH_ALL
; 594  : 		this->_Alnod.deallocate(_Wherenode, 1);
; 595  : 		_RERAISE;
; 596  : 		_CATCH_END
; 597  : 
; 598  : 		return (_Wherenode);

  00046	8b c6		 mov	 eax, esi
  00048	5e		 pop	 esi

; 599  : 		}

  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c2 04 00	 ret	 4

; 587  : 		{	// allocate a node with defaults
; 588  : 		_Nodeptr _Wherenode = _Buynode();

$LN12@Buynode@3:
  0004f	8d 4d 08	 lea	 ecx, DWORD PTR $T200686[ebp]
  00052	51		 push	 ecx
  00053	8d 4d f4	 lea	 ecx, DWORD PTR $T200733[ebp]
  00056	89 45 08	 mov	 DWORD PTR $T200686[ebp], eax
  00059	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  0005e	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00063	8d 55 f4	 lea	 edx, DWORD PTR $T200733[ebp]
  00066	52		 push	 edx
  00067	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T200733[ebp], OFFSET ??_7bad_alloc@std@@6B@
  0006e	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN44@Buynode@3:
$LN43@Buynode@3:
  00073	cc		 int	 3
??$_Buynode@U?$pair@HU_tagWaiting@@@std@@@?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@HU_tagWaiting@@@1@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::_Buynode<std::pair<int,_tagWaiting> >
_TEXT	ENDS
PUBLIC	??$_Buynode@U?$pair@HU_tagObserverInfo@@@std@@@?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@HU_tagObserverInfo@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::_Buynode<std::pair<int,_tagObserverInfo> >
; Function compile flags: /Ogtp
;	COMDAT ??$_Buynode@U?$pair@HU_tagObserverInfo@@@std@@@?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@HU_tagObserverInfo@@@1@@Z
_TEXT	SEGMENT
$T200830 = -12						; size = 12
$T200785 = 8						; size = 4
__Val$ = 8						; size = 4
??$_Buynode@U?$pair@HU_tagObserverInfo@@@std@@@?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@HU_tagObserverInfo@@@1@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::_Buynode<std::pair<int,_tagObserverInfo> >, COMDAT
; _this$ = ecx

; 586  : 		_Nodeptr _Buynode(_Valty&& _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi
  00007	57		 push	 edi

; 587  : 		{	// allocate a node with defaults
; 588  : 		_Nodeptr _Wherenode = _Buynode();

  00008	6a 28		 push	 40			; 00000028H
  0000a	8b f9		 mov	 edi, ecx
  0000c	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00011	8b f0		 mov	 esi, eax
  00013	33 c0		 xor	 eax, eax
  00015	83 c4 04	 add	 esp, 4
  00018	3b f0		 cmp	 esi, eax
  0001a	74 33		 je	 SHORT $LN12@Buynode@4
  0001c	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  0001f	89 0e		 mov	 DWORD PTR [esi], ecx
  00021	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  00024	89 56 04	 mov	 DWORD PTR [esi+4], edx
  00027	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]

; 589  : 
; 590  : 		_TRY_BEGIN
; 591  : 		_Cons_val(this->_Alval, _STD addressof(this->_Myval(_Wherenode)),
; 592  : 			_STD forward<_Valty>(_Val));

  0002a	8b 55 08	 mov	 edx, DWORD PTR __Val$[ebp]
  0002d	66 89 46 24	 mov	 WORD PTR [esi+36], ax
  00031	52		 push	 edx
  00032	8d 46 0c	 lea	 eax, DWORD PTR [esi+12]
  00035	50		 push	 eax
  00036	83 c7 0d	 add	 edi, 13			; 0000000dH
  00039	57		 push	 edi
  0003a	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  0003d	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@std@@U?$pair@$$CBHU_tagObserverInfo@@@2@U?$pair@HU_tagObserverInfo@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@0@PAU?$pair@$$CBHU_tagObserverInfo@@@0@$$QAU?$pair@HU_tagObserverInfo@@@0@@Z ; std::_Cons_val<std::allocator<std::pair<int const ,_tagObserverInfo> >,std::pair<int const ,_tagObserverInfo>,std::pair<int,_tagObserverInfo> >
  00042	83 c4 0c	 add	 esp, 12			; 0000000cH
  00045	5f		 pop	 edi

; 593  : 		_CATCH_ALL
; 594  : 		this->_Alnod.deallocate(_Wherenode, 1);
; 595  : 		_RERAISE;
; 596  : 		_CATCH_END
; 597  : 
; 598  : 		return (_Wherenode);

  00046	8b c6		 mov	 eax, esi
  00048	5e		 pop	 esi

; 599  : 		}

  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c2 04 00	 ret	 4

; 587  : 		{	// allocate a node with defaults
; 588  : 		_Nodeptr _Wherenode = _Buynode();

$LN12@Buynode@4:
  0004f	8d 4d 08	 lea	 ecx, DWORD PTR $T200785[ebp]
  00052	51		 push	 ecx
  00053	8d 4d f4	 lea	 ecx, DWORD PTR $T200830[ebp]
  00056	89 45 08	 mov	 DWORD PTR $T200785[ebp], eax
  00059	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  0005e	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00063	8d 55 f4	 lea	 edx, DWORD PTR $T200830[ebp]
  00066	52		 push	 edx
  00067	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T200830[ebp], OFFSET ??_7bad_alloc@std@@6B@
  0006e	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN44@Buynode@4:
$LN43@Buynode@4:
  00073	cc		 int	 3
??$_Buynode@U?$pair@HU_tagObserverInfo@@@std@@@?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@HU_tagObserverInfo@@@1@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::_Buynode<std::pair<int,_tagObserverInfo> >
_TEXT	ENDS
PUBLIC	?GetObserverList@CNewPVP@@AAEXHAAU_tagPMSG_DUEL_OBSERVERLIST_BROADCAST@@@Z ; CNewPVP::GetObserverList
; Function compile flags: /Ogtp
; File c:\muserver_dev\development\mu-s8ep2-repack\gameserver\source\newpvp.cpp
;	COMDAT ?GetObserverList@CNewPVP@@AAEXHAAU_tagPMSG_DUEL_OBSERVERLIST_BROADCAST@@@Z
_TEXT	SEGMENT
_nId$ = 8						; size = 4
_res$ = 12						; size = 4
?GetObserverList@CNewPVP@@AAEXHAAU_tagPMSG_DUEL_OBSERVERLIST_BROADCAST@@@Z PROC ; CNewPVP::GetObserverList, COMDAT
; _this$ = ecx

; 746  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 748  : 	for(std::map<int, _tagObserverInfo>::iterator iter = m_ObserverInfoList.begin();iter!=m_ObserverInfoList.end(); ++iter)

  00003	8b 91 28 01 00
	00		 mov	 edx, DWORD PTR [ecx+296]
  00009	8b 02		 mov	 eax, DWORD PTR [edx]
  0000b	53		 push	 ebx
  0000c	33 db		 xor	 ebx, ebx
  0000e	3b c2		 cmp	 eax, edx
  00010	0f 84 83 00 00
	00		 je	 $LN88@GetObserve

; 747  : 	int i = 0;

  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	8b 7d 0c	 mov	 edi, DWORD PTR _res$[ebp]
  0001b	8d 77 05	 lea	 esi, DWORD PTR [edi+5]
  0001e	8b ff		 npad	 2

; 748  : 	for(std::map<int, _tagObserverInfo>::iterator iter = m_ObserverInfoList.begin();iter!=m_ObserverInfoList.end(); ++iter)

$LL28@GetObserve:

; 749  : 	{
; 750  : 		ObserverInfo & info = iter->second;		
; 751  : 		if(info.nId == nId)

  00020	8b 55 08	 mov	 edx, DWORD PTR _nId$[ebp]
  00023	39 50 10	 cmp	 DWORD PTR [eax+16], edx
  00026	75 1c		 jne	 SHORT $LN4@GetObserve

; 752  : 		{
; 753  : 			memcpy(&res.user[i], info.szName, MAX_IDSTRING);

  00028	8b 50 18	 mov	 edx, DWORD PTR [eax+24]
  0002b	89 16		 mov	 DWORD PTR [esi], edx
  0002d	8b 50 1c	 mov	 edx, DWORD PTR [eax+28]
  00030	89 56 04	 mov	 DWORD PTR [esi+4], edx
  00033	66 8b 50 20	 mov	 dx, WORD PTR [eax+32]
  00037	66 89 56 08	 mov	 WORD PTR [esi+8], dx

; 754  : 			i++;

  0003b	43		 inc	 ebx
  0003c	83 c6 0a	 add	 esi, 10			; 0000000aH

; 755  : 			if( i >= 10 )	break;

  0003f	83 fb 0a	 cmp	 ebx, 10			; 0000000aH
  00042	7d 4b		 jge	 SHORT $LN87@GetObserve
$LN4@GetObserve:

; 748  : 	for(std::map<int, _tagObserverInfo>::iterator iter = m_ObserverInfoList.begin();iter!=m_ObserverInfoList.end(); ++iter)

  00044	80 78 25 00	 cmp	 BYTE PTR [eax+37], 0
  00048	75 3d		 jne	 SHORT $LN86@GetObserve
  0004a	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0004d	80 7a 25 00	 cmp	 BYTE PTR [edx+37], 0
  00051	75 19		 jne	 SHORT $LN82@GetObserve
  00053	8b c2		 mov	 eax, edx
  00055	8b 10		 mov	 edx, DWORD PTR [eax]
  00057	80 7a 25 00	 cmp	 BYTE PTR [edx+37], 0
  0005b	75 2a		 jne	 SHORT $LN86@GetObserve
  0005d	8d 49 00	 npad	 3
$LL43@GetObserve:
  00060	8b c2		 mov	 eax, edx
  00062	8b 10		 mov	 edx, DWORD PTR [eax]
  00064	80 7a 25 00	 cmp	 BYTE PTR [edx+37], 0
  00068	74 f6		 je	 SHORT $LL43@GetObserve
  0006a	eb 1b		 jmp	 SHORT $LN86@GetObserve
$LN82@GetObserve:
  0006c	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0006f	80 7a 25 00	 cmp	 BYTE PTR [edx+37], 0
  00073	75 10		 jne	 SHORT $LN26@GetObserve
$LL27@GetObserve:
  00075	3b 42 08	 cmp	 eax, DWORD PTR [edx+8]
  00078	75 0b		 jne	 SHORT $LN26@GetObserve
  0007a	8b c2		 mov	 eax, edx
  0007c	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  0007f	80 7a 25 00	 cmp	 BYTE PTR [edx+37], 0
  00083	74 f0		 je	 SHORT $LL27@GetObserve
$LN26@GetObserve:
  00085	8b c2		 mov	 eax, edx
$LN86@GetObserve:
  00087	3b 81 28 01 00
	00		 cmp	 eax, DWORD PTR [ecx+296]
  0008d	75 91		 jne	 SHORT $LL28@GetObserve
$LN87@GetObserve:

; 756  : 		}
; 757  : 	}
; 758  : 	res.nCount = i;

  0008f	88 5f 04	 mov	 BYTE PTR [edi+4], bl
  00092	5f		 pop	 edi
  00093	5e		 pop	 esi
  00094	5b		 pop	 ebx

; 759  : }

  00095	5d		 pop	 ebp
  00096	c2 08 00	 ret	 8
$LN88@GetObserve:

; 756  : 		}
; 757  : 	}
; 758  : 	res.nCount = i;

  00099	8b 45 0c	 mov	 eax, DWORD PTR _res$[ebp]
  0009c	88 58 04	 mov	 BYTE PTR [eax+4], bl
  0009f	5b		 pop	 ebx

; 759  : }

  000a0	5d		 pop	 ebp
  000a1	c2 08 00	 ret	 8
?GetObserverList@CNewPVP@@AAEXHAAU_tagPMSG_DUEL_OBSERVERLIST_BROADCAST@@@Z ENDP ; CNewPVP::GetObserverList
_TEXT	ENDS
PUBLIC	?LeaveChannelObserver@CNewPVP@@AAEXH@Z		; CNewPVP::LeaveChannelObserver
; Function compile flags: /Ogtp
;	COMDAT ?LeaveChannelObserver@CNewPVP@@AAEXH@Z
_TEXT	SEGMENT
$T201156 = -4						; size = 4
_nId$ = 8						; size = 4
?LeaveChannelObserver@CNewPVP@@AAEXH@Z PROC		; CNewPVP::LeaveChannelObserver, COMDAT
; _this$ = ecx

; 871  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	8b d9		 mov	 ebx, ecx

; 872  : 	std::map<int, _tagObserverInfo>::iterator iter = m_ObserverInfoList.begin();

  00007	8b 83 28 01 00
	00		 mov	 eax, DWORD PTR [ebx+296]
  0000d	56		 push	 esi
  0000e	8b 30		 mov	 esi, DWORD PTR [eax]

; 873  : 	while(iter!=m_ObserverInfoList.end())

  00010	3b f0		 cmp	 esi, eax
  00012	0f 84 bd 00 00
	00		 je	 $LN89@LeaveChann
  00018	57		 push	 edi
  00019	8d a4 24 00 00
	00 00		 npad	 7
$LL4@LeaveChann:

; 874  : 	{
; 875  : 		ObserverInfo & info = iter->second;		
; 876  : 		if(info.nId == nId)

  00020	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00023	3b 45 08	 cmp	 eax, DWORD PTR _nId$[ebp]
  00026	75 45		 jne	 SHORT $LN2@LeaveChann

; 877  : 		{
; 878  : 			LPOBJ lpObj = (LPOBJ)&gObj[info.nIndex];

  00028	8b 7e 14	 mov	 edi, DWORD PTR [esi+20]
  0002b	69 ff 40 27 00
	00		 imul	 edi, 10048		; 00002740H
  00031	03 3d 00 00 00
	00		 add	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 879  : 
; 880  : 			if( IsPKFieldMap(lpObj->MapNumber) )	MoveGate(lpObj->m_Index, 294);

  00037	80 bf 23 01 00
	00 40		 cmp	 BYTE PTR [edi+291], 64	; 00000040H
  0003e	75 0f		 jne	 SHORT $LN1@LeaveChann
  00040	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00042	68 26 01 00 00	 push	 294			; 00000126H
  00047	51		 push	 ecx
  00048	8b cb		 mov	 ecx, ebx
  0004a	e8 00 00 00 00	 call	 ?MoveGate@CNewPVP@@AAEHHH@Z ; CNewPVP::MoveGate
$LN1@LeaveChann:

; 881  : 			
; 882  : 			SetBuff(*lpObj, FALSE);

  0004f	6a 00		 push	 0
  00051	57		 push	 edi
  00052	8b cb		 mov	 ecx, ebx
  00054	e8 00 00 00 00	 call	 ?SetBuff@CNewPVP@@QAEXAAUOBJECTSTRUCT@@H@Z ; CNewPVP::SetBuff

; 883  : 			iter = m_ObserverInfoList.erase(iter);

  00059	56		 push	 esi
  0005a	8d 55 fc	 lea	 edx, DWORD PTR $T201156[ebp]
  0005d	52		 push	 edx
  0005e	8d 8b 24 01 00
	00		 lea	 ecx, DWORD PTR [ebx+292]
  00064	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::erase
  00069	8b 30		 mov	 esi, DWORD PTR [eax]

; 884  : 			continue;

  0006b	eb 45		 jmp	 SHORT $LN53@LeaveChann
$LN2@LeaveChann:

; 885  : 		}		
; 886  : 		iter++;

  0006d	80 7e 25 00	 cmp	 BYTE PTR [esi+37], 0
  00071	75 3f		 jne	 SHORT $LN53@LeaveChann
  00073	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00076	80 78 25 00	 cmp	 BYTE PTR [eax+37], 0
  0007a	75 16		 jne	 SHORT $LN86@LeaveChann
  0007c	8b f0		 mov	 esi, eax
  0007e	8b 06		 mov	 eax, DWORD PTR [esi]
  00080	80 78 25 00	 cmp	 BYTE PTR [eax+37], 0
  00084	75 2c		 jne	 SHORT $LN53@LeaveChann
$LL68@LeaveChann:
  00086	8b f0		 mov	 esi, eax
  00088	8b 06		 mov	 eax, DWORD PTR [esi]
  0008a	80 78 25 00	 cmp	 BYTE PTR [eax+37], 0
  0008e	74 f6		 je	 SHORT $LL68@LeaveChann
  00090	eb 20		 jmp	 SHORT $LN53@LeaveChann
$LN86@LeaveChann:
  00092	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00095	80 78 25 00	 cmp	 BYTE PTR [eax+37], 0
  00099	75 15		 jne	 SHORT $LN51@LeaveChann
  0009b	eb 03 8d 49 00	 npad	 5
$LL52@LeaveChann:
  000a0	3b 70 08	 cmp	 esi, DWORD PTR [eax+8]
  000a3	75 0b		 jne	 SHORT $LN51@LeaveChann
  000a5	8b f0		 mov	 esi, eax
  000a7	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000aa	80 78 25 00	 cmp	 BYTE PTR [eax+37], 0
  000ae	74 f0		 je	 SHORT $LL52@LeaveChann
$LN51@LeaveChann:
  000b0	8b f0		 mov	 esi, eax
$LN53@LeaveChann:

; 873  : 	while(iter!=m_ObserverInfoList.end())

  000b2	3b b3 28 01 00
	00		 cmp	 esi, DWORD PTR [ebx+296]
  000b8	0f 85 62 ff ff
	ff		 jne	 $LL4@LeaveChann

; 887  : 	}
; 888  : 	m_ObserverCount[nId] = 0;

  000be	8b 45 08	 mov	 eax, DWORD PTR _nId$[ebp]
  000c1	5f		 pop	 edi
  000c2	5e		 pop	 esi
  000c3	c7 84 83 34 01
	00 00 00 00 00
	00		 mov	 DWORD PTR [ebx+eax*4+308], 0
  000ce	5b		 pop	 ebx

; 889  : }

  000cf	8b e5		 mov	 esp, ebp
  000d1	5d		 pop	 ebp
  000d2	c2 04 00	 ret	 4
$LN89@LeaveChann:

; 887  : 	}
; 888  : 	m_ObserverCount[nId] = 0;

  000d5	8b 4d 08	 mov	 ecx, DWORD PTR _nId$[ebp]
  000d8	5e		 pop	 esi
  000d9	c7 84 8b 34 01
	00 00 00 00 00
	00		 mov	 DWORD PTR [ebx+ecx*4+308], 0
  000e4	5b		 pop	 ebx

; 889  : }

  000e5	8b e5		 mov	 esp, ebp
  000e7	5d		 pop	 ebp
  000e8	c2 04 00	 ret	 4
?LeaveChannelObserver@CNewPVP@@AAEXH@Z ENDP		; CNewPVP::LeaveChannelObserver
_TEXT	ENDS
PUBLIC	?BroadcastToObserver@CNewPVP@@AAEXHPAEH@Z	; CNewPVP::BroadcastToObserver
EXTRN	?gObjIsConnected@@YAHH@Z:PROC			; gObjIsConnected
; Function compile flags: /Ogtp
;	COMDAT ?BroadcastToObserver@CNewPVP@@AAEXHPAEH@Z
_TEXT	SEGMENT
_nId$ = 8						; size = 4
_lpData$ = 12						; size = 4
_nSize$ = 16						; size = 4
?BroadcastToObserver@CNewPVP@@AAEXHPAEH@Z PROC		; CNewPVP::BroadcastToObserver, COMDAT
; _this$ = ecx

; 1055 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi
  00005	8b f9		 mov	 edi, ecx

; 1056 : 	for(std::map<int, _tagObserverInfo>::iterator iter = m_ObserverInfoList.begin();iter!=m_ObserverInfoList.end(); ++iter)

  00007	8b 87 28 01 00
	00		 mov	 eax, DWORD PTR [edi+296]
  0000d	8b 30		 mov	 esi, DWORD PTR [eax]
  0000f	3b f0		 cmp	 esi, eax
  00011	74 7d		 je	 SHORT $LN3@BroadcastT
  00013	53		 push	 ebx
  00014	8b 5d 10	 mov	 ebx, DWORD PTR _nSize$[ebp]
$LL28@BroadcastT:

; 1057 : 	{
; 1058 : 		ObserverInfo & info = iter->second;		
; 1059 : 		if(info.nId == nId)

  00017	8b 45 08	 mov	 eax, DWORD PTR _nId$[ebp]
  0001a	39 46 10	 cmp	 DWORD PTR [esi+16], eax
  0001d	75 21		 jne	 SHORT $LN4@BroadcastT

; 1060 : 		{
; 1061 : 			if( gObjIsConnected(info.nIndex) )

  0001f	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00022	51		 push	 ecx
  00023	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00028	83 c4 04	 add	 esp, 4
  0002b	85 c0		 test	 eax, eax
  0002d	74 11		 je	 SHORT $LN4@BroadcastT

; 1062 : 			{
; 1063 : 				DataSend(info.nIndex, lpData, nSize);

  0002f	8b 55 0c	 mov	 edx, DWORD PTR _lpData$[ebp]
  00032	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00035	53		 push	 ebx
  00036	52		 push	 edx
  00037	50		 push	 eax
  00038	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0003d	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN4@BroadcastT:

; 1056 : 	for(std::map<int, _tagObserverInfo>::iterator iter = m_ObserverInfoList.begin();iter!=m_ObserverInfoList.end(); ++iter)

  00040	80 7e 25 00	 cmp	 BYTE PTR [esi+37], 0
  00044	75 41		 jne	 SHORT $LN85@BroadcastT
  00046	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00049	80 78 25 00	 cmp	 BYTE PTR [eax+37], 0
  0004d	75 1d		 jne	 SHORT $LN82@BroadcastT
  0004f	8b f0		 mov	 esi, eax
  00051	8b 06		 mov	 eax, DWORD PTR [esi]
  00053	80 78 25 00	 cmp	 BYTE PTR [eax+37], 0
  00057	75 2e		 jne	 SHORT $LN85@BroadcastT
  00059	8d a4 24 00 00
	00 00		 npad	 7
$LL43@BroadcastT:
  00060	8b f0		 mov	 esi, eax
  00062	8b 06		 mov	 eax, DWORD PTR [esi]
  00064	80 78 25 00	 cmp	 BYTE PTR [eax+37], 0
  00068	74 f6		 je	 SHORT $LL43@BroadcastT
  0006a	eb 1b		 jmp	 SHORT $LN85@BroadcastT
$LN82@BroadcastT:
  0006c	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0006f	80 78 25 00	 cmp	 BYTE PTR [eax+37], 0
  00073	75 10		 jne	 SHORT $LN26@BroadcastT
$LL27@BroadcastT:
  00075	3b 70 08	 cmp	 esi, DWORD PTR [eax+8]
  00078	75 0b		 jne	 SHORT $LN26@BroadcastT
  0007a	8b f0		 mov	 esi, eax
  0007c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0007f	80 78 25 00	 cmp	 BYTE PTR [eax+37], 0
  00083	74 f0		 je	 SHORT $LL27@BroadcastT
$LN26@BroadcastT:
  00085	8b f0		 mov	 esi, eax
$LN85@BroadcastT:
  00087	3b b7 28 01 00
	00		 cmp	 esi, DWORD PTR [edi+296]
  0008d	75 88		 jne	 SHORT $LL28@BroadcastT
  0008f	5b		 pop	 ebx
$LN3@BroadcastT:
  00090	5f		 pop	 edi
  00091	5e		 pop	 esi

; 1064 : 			}
; 1065 : 		}
; 1066 : 	}
; 1067 : }

  00092	5d		 pop	 ebp
  00093	c2 0c 00	 ret	 12			; 0000000cH
?BroadcastToObserver@CNewPVP@@AAEXHPAEH@Z ENDP		; CNewPVP::BroadcastToObserver
_TEXT	ENDS
PUBLIC	_this$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?BroadcastMessage@CNewPVP@@AAEXHEEH@Z		; CNewPVP::BroadcastMessage
EXTRN	?MakeNoticeMsgEx@TNotice@@SAXPAXEPADZZ:PROC	; TNotice::MakeNoticeMsgEx
EXTRN	?Get@Message@@QAEPADH@Z:PROC			; Message::Get
EXTRN	?lMsg@@3VMessage@@A:BYTE			; lMsg
; Function compile flags: /Ogtp
;	COMDAT ?BroadcastMessage@CNewPVP@@AAEXHEEH@Z
_TEXT	SEGMENT
_this$GSCopy$ = -280					; size = 4
_res$ = -276						; size = 272
__$ArrayPad$ = -4					; size = 4
_nId$ = 8						; size = 4
_nFlag$ = 12						; size = 1
_nMsgType$ = 16						; size = 1
_nNotifySec$ = 20					; size = 4
?BroadcastMessage@CNewPVP@@AAEXHEEH@Z PROC		; CNewPVP::BroadcastMessage, COMDAT
; _this$ = ecx

; 1071 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 18 01 00
	00		 sub	 esp, 280		; 00000118H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	8b 5d 08	 mov	 ebx, DWORD PTR _nId$[ebp]

; 1102 : 	{
; 1103 : 		BroadcastToObserver(nId, (LPBYTE)&res, res.h.size);

  00017	89 8d e8 fe ff
	ff		 mov	 DWORD PTR _this$GSCopy$[ebp], ecx
  0001d	83 fb 03	 cmp	 ebx, 3
  00020	0f 87 5e 01 00
	00		 ja	 $LN12@BroadcastM

; 1073 : 	if( nNotifySec <= 0 )	return;

  00026	83 7d 14 00	 cmp	 DWORD PTR _nNotifySec$[ebp], 0
  0002a	0f 8e 43 01 00
	00		 jle	 $LN1@BroadcastM

; 1074 : 
; 1075 : 	OBJECTSTRUCT &requester = gObj[m_DuelChannel[nId].nIndex1];

  00030	8b c3		 mov	 eax, ebx
  00032	6b c0 2c	 imul	 eax, 44			; 0000002cH
  00035	56		 push	 esi
  00036	8b 74 08 68	 mov	 esi, DWORD PTR [eax+ecx+104]
  0003a	57		 push	 edi
  0003b	69 f6 40 27 00
	00		 imul	 esi, 10048		; 00002740H

; 1076 :     OBJECTSTRUCT &responsor = gObj[m_DuelChannel[nId].nIndex2];

  00041	8b 7c 08 6c	 mov	 edi, DWORD PTR [eax+ecx+108]
  00045	03 c1		 add	 eax, ecx
  00047	69 ff 40 27 00
	00		 imul	 edi, 10048		; 00002740H
  0004d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 1077 : 
; 1078 : 	PMSG_NOTICE res = {0} ;

  00053	68 0f 01 00 00	 push	 271			; 0000010fH
  00058	03 f1		 add	 esi, ecx
  0005a	03 f9		 add	 edi, ecx
  0005c	8d 8d ed fe ff
	ff		 lea	 ecx, DWORD PTR _res$[ebp+1]
  00062	6a 00		 push	 0
  00064	51		 push	 ecx
  00065	c6 85 ec fe ff
	ff 00		 mov	 BYTE PTR _res$[ebp], 0
  0006c	e8 00 00 00 00	 call	 _memset

; 1079 : 
; 1080 : 	switch(nMsgType)

  00071	0f b6 45 10	 movzx	 eax, BYTE PTR _nMsgType$[ebp]
  00075	83 c4 0c	 add	 esp, 12			; 0000000cH
  00078	83 e8 00	 sub	 eax, 0
  0007b	74 48		 je	 SHORT $LN8@BroadcastM
  0007d	48		 dec	 eax
  0007e	74 26		 je	 SHORT $LN7@BroadcastM
  00080	48		 dec	 eax
  00081	0f 85 ea 00 00
	00		 jne	 $LN21@BroadcastM

; 1084 : 	case 2:	TNotice::MakeNoticeMsgEx(&res, 1, lMsg.Get(3421),nNotifySec);	break;

  00087	8b 55 14	 mov	 edx, DWORD PTR _nNotifySec$[ebp]
  0008a	52		 push	 edx
  0008b	68 5d 0d 00 00	 push	 3421			; 00000d5dH
  00090	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  00095	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  0009a	50		 push	 eax
  0009b	6a 01		 push	 1
  0009d	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _res$[ebp]
  000a3	50		 push	 eax
  000a4	eb 3c		 jmp	 SHORT $LN23@BroadcastM
$LN7@BroadcastM:

; 1083 : 	case 1:	TNotice::MakeNoticeMsgEx(&res, 1, lMsg.Get(3420),nNotifySec);	break;

  000a6	8b 4d 14	 mov	 ecx, DWORD PTR _nNotifySec$[ebp]
  000a9	51		 push	 ecx
  000aa	68 5c 0d 00 00	 push	 3420			; 00000d5cH
  000af	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  000b4	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  000b9	50		 push	 eax
  000ba	6a 01		 push	 1
  000bc	8d 95 ec fe ff
	ff		 lea	 edx, DWORD PTR _res$[ebp]
  000c2	52		 push	 edx
  000c3	eb 1d		 jmp	 SHORT $LN23@BroadcastM
$LN8@BroadcastM:

; 1081 : 	{
; 1082 : 	case 0:	TNotice::MakeNoticeMsgEx(&res, 1, lMsg.Get(3419),nNotifySec);	break;

  000c5	8b 45 14	 mov	 eax, DWORD PTR _nNotifySec$[ebp]
  000c8	50		 push	 eax
  000c9	68 5b 0d 00 00	 push	 3419			; 00000d5bH
  000ce	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  000d3	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  000d8	50		 push	 eax
  000d9	6a 01		 push	 1
  000db	8d 8d ec fe ff
	ff		 lea	 ecx, DWORD PTR _res$[ebp]
  000e1	51		 push	 ecx
$LN23@BroadcastM:
  000e2	e8 00 00 00 00	 call	 ?MakeNoticeMsgEx@TNotice@@SAXPAXEPADZZ ; TNotice::MakeNoticeMsgEx
  000e7	83 c4 10	 add	 esp, 16			; 00000010H

; 1085 : 	default:	return;
; 1086 : 	}
; 1087 : 
; 1088 : 	if( (nFlag & 1) == 1 )

  000ea	f6 45 0c 01	 test	 BYTE PTR _nFlag$[ebp], 1
  000ee	74 60		 je	 SHORT $LN20@BroadcastM

; 1089 :     {
; 1090 : 		if( gObjIsConnected(&requester) 
; 1091 : 			&& this->IsPKFieldMap(requester.MapNumber) )	//fix

  000f0	56		 push	 esi
  000f1	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHPAUOBJECTSTRUCT@@@Z ; gObjIsConnected
  000f6	83 c4 04	 add	 esp, 4
  000f9	85 c0		 test	 eax, eax
  000fb	74 23		 je	 SHORT $LN3@BroadcastM
  000fd	80 be 23 01 00
	00 40		 cmp	 BYTE PTR [esi+291], 64	; 00000040H
  00104	75 1a		 jne	 SHORT $LN3@BroadcastM

; 1092 : 		{
; 1093 : 			DataSend(requester.m_Index, (LPBYTE)&res,res.h.size);

  00106	0f b6 95 ed fe
	ff ff		 movzx	 edx, BYTE PTR _res$[ebp+1]
  0010d	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0010f	52		 push	 edx
  00110	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _res$[ebp]
  00116	50		 push	 eax
  00117	51		 push	 ecx
  00118	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0011d	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN3@BroadcastM:

; 1094 : 		}
; 1095 : 		if( gObjIsConnected(&responsor) 
; 1096 : 			&& this->IsPKFieldMap(responsor.MapNumber) )	//fix

  00120	57		 push	 edi
  00121	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHPAUOBJECTSTRUCT@@@Z ; gObjIsConnected
  00126	83 c4 04	 add	 esp, 4
  00129	85 c0		 test	 eax, eax
  0012b	74 23		 je	 SHORT $LN20@BroadcastM
  0012d	80 bf 23 01 00
	00 40		 cmp	 BYTE PTR [edi+291], 64	; 00000040H
  00134	75 1a		 jne	 SHORT $LN20@BroadcastM

; 1097 : 		{
; 1098 : 			DataSend(responsor.m_Index, (LPBYTE)&res,res.h.size);

  00136	0f b6 95 ed fe
	ff ff		 movzx	 edx, BYTE PTR _res$[ebp+1]
  0013d	8b 0f		 mov	 ecx, DWORD PTR [edi]
  0013f	52		 push	 edx
  00140	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _res$[ebp]
  00146	50		 push	 eax
  00147	51		 push	 ecx
  00148	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0014d	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN20@BroadcastM:

; 1099 : 		}
; 1100 :     }
; 1101 : 	if( (nFlag & 2) == 2 )

  00150	f6 45 0c 02	 test	 BYTE PTR _nFlag$[ebp], 2
  00154	74 1b		 je	 SHORT $LN21@BroadcastM

; 1102 : 	{
; 1103 : 		BroadcastToObserver(nId, (LPBYTE)&res, res.h.size);

  00156	0f b6 95 ed fe
	ff ff		 movzx	 edx, BYTE PTR _res$[ebp+1]
  0015d	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  00163	52		 push	 edx
  00164	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _res$[ebp]
  0016a	50		 push	 eax
  0016b	53		 push	 ebx
  0016c	e8 00 00 00 00	 call	 ?BroadcastToObserver@CNewPVP@@AAEXHPAEH@Z ; CNewPVP::BroadcastToObserver
$LN21@BroadcastM:
  00171	5f		 pop	 edi
  00172	5e		 pop	 esi
$LN1@BroadcastM:
  00173	5b		 pop	 ebx

; 1104 : 	}
; 1105 : }

  00174	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00177	33 cd		 xor	 ecx, ebp
  00179	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0017e	8b e5		 mov	 esp, ebp
  00180	5d		 pop	 ebp
  00181	c2 10 00	 ret	 16			; 00000010H
$LN12@BroadcastM:

; 1072 : 	if( nId < 0 || nId >= DUEL_CHANNEL_MAX ){ LogAddTD("%s\t%s\t%s\t%s\t%d","nId>=0 && nId<DUEL_CHANNEL_MAX","0","NULL",__FILE__, __LINE__); return; }

  00184	68 30 04 00 00	 push	 1072			; 00000430H
  00189	68 00 00 00 00	 push	 OFFSET ??_C@_0L@IGELOCEA@NewPVP?4cpp?$AA@
  0018e	68 00 00 00 00	 push	 OFFSET ??_C@_04HIBGFPH@NULL?$AA@
  00193	68 00 00 00 00	 push	 OFFSET ??_C@_01GBGANLPD@0?$AA@
  00198	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@OMAPJGHA@nId?$DO?$DN0?5?$CG?$CG?5nId?$DMDUEL_CHANNEL_MAX?$AA@
  0019d	68 00 00 00 00	 push	 OFFSET ??_C@_0P@ENJPCMFP@?$CFs?7?$CFs?7?$CFs?7?$CFs?7?$CFd?$AA@
  001a2	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 1104 : 	}
; 1105 : }

  001a8	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001ab	83 c4 18	 add	 esp, 24			; 00000018H
  001ae	33 cd		 xor	 ecx, ebp
  001b0	5b		 pop	 ebx
  001b1	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001b6	8b e5		 mov	 esp, ebp
  001b8	5d		 pop	 ebp
  001b9	c2 10 00	 ret	 16			; 00000010H
?BroadcastMessage@CNewPVP@@AAEXHEEH@Z ENDP		; CNewPVP::BroadcastMessage
_TEXT	ENDS
PUBLIC	?BroadcastRound@CNewPVP@@AAEXHEH@Z		; CNewPVP::BroadcastRound
; Function compile flags: /Ogtp
;	COMDAT ?BroadcastRound@CNewPVP@@AAEXHEH@Z
_TEXT	SEGMENT
_res$ = -8						; size = 5
_nId$ = 8						; size = 4
_nFlag$ = 12						; size = 1
_bEnd$ = 16						; size = 4
?BroadcastRound@CNewPVP@@AAEXHEH@Z PROC			; CNewPVP::BroadcastRound, COMDAT
; _this$ = ecx

; 1109 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx

; 1110 : 	if( nId < 0 || nId >= DUEL_CHANNEL_MAX ){ LogAddTD("%s\t%s\t%s\t%s\t%d","nId>=0 && nId<DUEL_CHANNEL_MAX","0","NULL",__FILE__, __LINE__); return; }

  00007	8b 5d 08	 mov	 ebx, DWORD PTR _nId$[ebp]
  0000a	57		 push	 edi
  0000b	8b f9		 mov	 edi, ecx
  0000d	83 fb 03	 cmp	 ebx, 3
  00010	77 7f		 ja	 SHORT $LN3@BroadcastR

; 1113 :     OBJECTSTRUCT &responsor = gObj[m_DuelChannel[nId].nIndex2];

  00012	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 1114 : 
; 1115 : 	PMSG_DUEL_ROUNDSTART_BROADCAST res = {0}; 
; 1116 :     res.h.c = PMHC_BYTE;
; 1117 :     res.h.headcode = 0xAA;
; 1118 :     res.h.subcode = 0x0D;
; 1119 :     res.h.size = sizeof(PMSG_DUEL_ROUNDSTART_BROADCAST);
; 1120 :     res.nFlag = bEnd;

  00018	8a 55 10	 mov	 dl, BYTE PTR _bEnd$[ebp]
  0001b	8b c3		 mov	 eax, ebx
  0001d	6b c0 2c	 imul	 eax, 44			; 0000002cH
  00020	56		 push	 esi
  00021	8b 74 38 6c	 mov	 esi, DWORD PTR [eax+edi+108]
  00025	69 f6 40 27 00
	00		 imul	 esi, 10048		; 00002740H
  0002b	03 f1		 add	 esi, ecx

; 1121 : 
; 1122 :     if( (nFlag & 1) == 1 )

  0002d	f6 45 0c 01	 test	 BYTE PTR _nFlag$[ebp], 1
  00031	c7 45 f9 00 00
	00 00		 mov	 DWORD PTR _res$[ebp+1], 0
  00038	c7 45 f8 c1 05
	aa 0d		 mov	 DWORD PTR _res$[ebp], 229246401 ; 0daa05c1H
  0003f	88 55 fc	 mov	 BYTE PTR _res$[ebp+4], dl
  00042	74 2d		 je	 SHORT $LN7@BroadcastR

; 1111 : 
; 1112 : 	OBJECTSTRUCT &requester = gObj[m_DuelChannel[nId].nIndex1];

  00044	8b 44 38 68	 mov	 eax, DWORD PTR [eax+edi+104]
  00048	69 c0 40 27 00
	00		 imul	 eax, 10048		; 00002740H

; 1123 :     {
; 1124 : 		DataSend(requester.m_Index,(LPBYTE)&res,res.h.size);

  0004e	8b 0c 08	 mov	 ecx, DWORD PTR [eax+ecx]
  00051	6a 05		 push	 5
  00053	8d 55 f8	 lea	 edx, DWORD PTR _res$[ebp]
  00056	52		 push	 edx
  00057	51		 push	 ecx
  00058	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 1125 : 		DataSend(responsor.m_Index, (LPBYTE)&res, res.h.size);

  0005d	0f b6 55 f9	 movzx	 edx, BYTE PTR _res$[ebp+1]
  00061	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00063	52		 push	 edx
  00064	8d 45 f8	 lea	 eax, DWORD PTR _res$[ebp]
  00067	50		 push	 eax
  00068	51		 push	 ecx
  00069	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0006e	83 c4 18	 add	 esp, 24			; 00000018H
$LN7@BroadcastR:

; 1126 :     }
; 1127 :     if( (nFlag & 2) == 2 )

  00071	f6 45 0c 02	 test	 BYTE PTR _nFlag$[ebp], 2
  00075	5e		 pop	 esi
  00076	74 40		 je	 SHORT $LN1@BroadcastR

; 1128 : 	{
; 1129 : 		BroadcastToObserver(nId, (LPBYTE)&res,res.h.size);

  00078	0f b6 55 f9	 movzx	 edx, BYTE PTR _res$[ebp+1]
  0007c	52		 push	 edx
  0007d	8d 45 f8	 lea	 eax, DWORD PTR _res$[ebp]
  00080	50		 push	 eax
  00081	53		 push	 ebx
  00082	8b cf		 mov	 ecx, edi
  00084	e8 00 00 00 00	 call	 ?BroadcastToObserver@CNewPVP@@AAEXHPAEH@Z ; CNewPVP::BroadcastToObserver
  00089	5f		 pop	 edi
  0008a	5b		 pop	 ebx

; 1130 : 	}
; 1131 : }

  0008b	8b e5		 mov	 esp, ebp
  0008d	5d		 pop	 ebp
  0008e	c2 0c 00	 ret	 12			; 0000000cH
$LN3@BroadcastR:

; 1110 : 	if( nId < 0 || nId >= DUEL_CHANNEL_MAX ){ LogAddTD("%s\t%s\t%s\t%s\t%d","nId>=0 && nId<DUEL_CHANNEL_MAX","0","NULL",__FILE__, __LINE__); return; }

  00091	68 56 04 00 00	 push	 1110			; 00000456H
  00096	68 00 00 00 00	 push	 OFFSET ??_C@_0L@IGELOCEA@NewPVP?4cpp?$AA@
  0009b	68 00 00 00 00	 push	 OFFSET ??_C@_04HIBGFPH@NULL?$AA@
  000a0	68 00 00 00 00	 push	 OFFSET ??_C@_01GBGANLPD@0?$AA@
  000a5	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@OMAPJGHA@nId?$DO?$DN0?5?$CG?$CG?5nId?$DMDUEL_CHANNEL_MAX?$AA@
  000aa	68 00 00 00 00	 push	 OFFSET ??_C@_0P@ENJPCMFP@?$CFs?7?$CFs?7?$CFs?7?$CFs?7?$CFd?$AA@
  000af	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  000b5	83 c4 18	 add	 esp, 24			; 00000018H
$LN1@BroadcastR:
  000b8	5f		 pop	 edi
  000b9	5b		 pop	 ebx

; 1130 : 	}
; 1131 : }

  000ba	8b e5		 mov	 esp, ebp
  000bc	5d		 pop	 ebp
  000bd	c2 0c 00	 ret	 12			; 0000000cH
?BroadcastRound@CNewPVP@@AAEXHEH@Z ENDP			; CNewPVP::BroadcastRound
_TEXT	ENDS
PUBLIC	?find@?$_Tree@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::find
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ?find@?$_Tree@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@2@ABH@Z
_TEXT	SEGMENT
$T201775 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Keyval$ = 12						; size = 4
?find@?$_Tree@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@2@ABH@Z PROC ; std::_Tree<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::find, COMDAT
; _this$ = ecx

; 1423 : 		{	// find an element in mutable sequence that matches _Keyval

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1424 : 		iterator _Where = lower_bound(_Keyval);

  00004	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00007	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0000a	80 78 21 00	 cmp	 BYTE PTR [eax+33], 0
  0000e	57		 push	 edi
  0000f	8b 7d 0c	 mov	 edi, DWORD PTR __Keyval$[ebp]
  00012	75 18		 jne	 SHORT $LN9@find
  00014	56		 push	 esi
  00015	8b 37		 mov	 esi, DWORD PTR [edi]
$LL10@find:
  00017	39 70 0c	 cmp	 DWORD PTR [eax+12], esi
  0001a	7d 05		 jge	 SHORT $LN8@find
  0001c	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0001f	eb 04		 jmp	 SHORT $LN7@find
$LN8@find:
  00021	8b d0		 mov	 edx, eax
  00023	8b 00		 mov	 eax, DWORD PTR [eax]
$LN7@find:
  00025	80 78 21 00	 cmp	 BYTE PTR [eax+33], 0
  00029	74 ec		 je	 SHORT $LL10@find
  0002b	5e		 pop	 esi
$LN9@find:

; 1425 : 		return (_Where == end()
; 1426 : 			|| _DEBUG_LT_PRED(this->comp,
; 1427 : 				_Keyval, this->_Key(_Where._Mynode()))
; 1428 : 					? end() : _Where);

  0002c	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0002f	89 55 0c	 mov	 DWORD PTR __Where$[ebp], edx
  00032	3b d0		 cmp	 edx, eax
  00034	74 18		 je	 SHORT $LN3@find
  00036	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00038	3b 4a 0c	 cmp	 ecx, DWORD PTR [edx+12]
  0003b	7c 11		 jl	 SHORT $LN3@find
  0003d	8d 45 0c	 lea	 eax, DWORD PTR __Where$[ebp]
  00040	8b 10		 mov	 edx, DWORD PTR [eax]
  00042	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00045	89 10		 mov	 DWORD PTR [eax], edx
  00047	5f		 pop	 edi

; 1429 : 		}

  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c2 08 00	 ret	 8
$LN3@find:

; 1425 : 		return (_Where == end()
; 1426 : 			|| _DEBUG_LT_PRED(this->comp,
; 1427 : 				_Keyval, this->_Key(_Where._Mynode()))
; 1428 : 					? end() : _Where);

  0004e	89 45 fc	 mov	 DWORD PTR $T201775[ebp], eax
  00051	8d 45 fc	 lea	 eax, DWORD PTR $T201775[ebp]
  00054	8b 10		 mov	 edx, DWORD PTR [eax]
  00056	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00059	89 10		 mov	 DWORD PTR [eax], edx
  0005b	5f		 pop	 edi

; 1429 : 		}

  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c2 08 00	 ret	 8
?find@?$_Tree@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@2@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::find
_TEXT	ENDS
PUBLIC	?find@?$_Tree@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::find
; Function compile flags: /Ogtp
;	COMDAT ?find@?$_Tree@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@2@ABH@Z
_TEXT	SEGMENT
$T201998 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Keyval$ = 12						; size = 4
?find@?$_Tree@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@2@ABH@Z PROC ; std::_Tree<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::find, COMDAT
; _this$ = ecx

; 1423 : 		{	// find an element in mutable sequence that matches _Keyval

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1424 : 		iterator _Where = lower_bound(_Keyval);

  00004	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00007	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0000a	80 78 25 00	 cmp	 BYTE PTR [eax+37], 0
  0000e	57		 push	 edi
  0000f	8b 7d 0c	 mov	 edi, DWORD PTR __Keyval$[ebp]
  00012	75 18		 jne	 SHORT $LN9@find@2
  00014	56		 push	 esi
  00015	8b 37		 mov	 esi, DWORD PTR [edi]
$LL10@find@2:
  00017	39 70 0c	 cmp	 DWORD PTR [eax+12], esi
  0001a	7d 05		 jge	 SHORT $LN8@find@2
  0001c	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0001f	eb 04		 jmp	 SHORT $LN7@find@2
$LN8@find@2:
  00021	8b d0		 mov	 edx, eax
  00023	8b 00		 mov	 eax, DWORD PTR [eax]
$LN7@find@2:
  00025	80 78 25 00	 cmp	 BYTE PTR [eax+37], 0
  00029	74 ec		 je	 SHORT $LL10@find@2
  0002b	5e		 pop	 esi
$LN9@find@2:

; 1425 : 		return (_Where == end()
; 1426 : 			|| _DEBUG_LT_PRED(this->comp,
; 1427 : 				_Keyval, this->_Key(_Where._Mynode()))
; 1428 : 					? end() : _Where);

  0002c	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0002f	89 55 0c	 mov	 DWORD PTR __Where$[ebp], edx
  00032	3b d0		 cmp	 edx, eax
  00034	74 18		 je	 SHORT $LN3@find@2
  00036	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00038	3b 4a 0c	 cmp	 ecx, DWORD PTR [edx+12]
  0003b	7c 11		 jl	 SHORT $LN3@find@2
  0003d	8d 45 0c	 lea	 eax, DWORD PTR __Where$[ebp]
  00040	8b 10		 mov	 edx, DWORD PTR [eax]
  00042	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00045	89 10		 mov	 DWORD PTR [eax], edx
  00047	5f		 pop	 edi

; 1429 : 		}

  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c2 08 00	 ret	 8
$LN3@find@2:

; 1425 : 		return (_Where == end()
; 1426 : 			|| _DEBUG_LT_PRED(this->comp,
; 1427 : 				_Keyval, this->_Key(_Where._Mynode()))
; 1428 : 					? end() : _Where);

  0004e	89 45 fc	 mov	 DWORD PTR $T201998[ebp], eax
  00051	8d 45 fc	 lea	 eax, DWORD PTR $T201998[ebp]
  00054	8b 10		 mov	 edx, DWORD PTR [eax]
  00056	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00059	89 10		 mov	 DWORD PTR [eax], edx
  0005b	5f		 pop	 edi

; 1429 : 		}

  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c2 08 00	 ret	 8
?find@?$_Tree@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@2@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::find
_TEXT	ENDS
PUBLIC	?_Tidy@?$_Tree@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::_Tidy
; Function compile flags: /Ogtp
;	COMDAT ?_Tidy@?$_Tree@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
$T202222 = -4						; size = 4
?_Tidy@?$_Tree@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::_Tidy, COMDAT
; _this$ = ecx

; 1865 : 		{	// free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1866 : 		erase(begin(), end());

  00004	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00007	8b 10		 mov	 edx, DWORD PTR [eax]
  00009	50		 push	 eax
  0000a	52		 push	 edx
  0000b	8d 45 fc	 lea	 eax, DWORD PTR $T202222[ebp]
  0000e	50		 push	 eax
  0000f	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::erase

; 1867 : 		}

  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
?_Tidy@?$_Tree@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::_Tidy
_TEXT	ENDS
PUBLIC	?_Tidy@?$_Tree@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::_Tidy
; Function compile flags: /Ogtp
;	COMDAT ?_Tidy@?$_Tree@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
$T202314 = -4						; size = 4
?_Tidy@?$_Tree@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::_Tidy, COMDAT
; _this$ = ecx

; 1865 : 		{	// free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1866 : 		erase(begin(), end());

  00004	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00007	8b 10		 mov	 edx, DWORD PTR [eax]
  00009	50		 push	 eax
  0000a	52		 push	 edx
  0000b	8d 45 fc	 lea	 eax, DWORD PTR $T202314[ebp]
  0000e	50		 push	 eax
  0000f	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::erase

; 1867 : 		}

  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
?_Tidy@?$_Tree@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::_Tidy
_TEXT	ENDS
PUBLIC	??$insert@U?$pair@HU_tagWaiting@@@std@@@?$_Tree@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@HU_tagWaiting@@@1@@Z ; std::_Tree<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::insert<std::pair<int,_tagWaiting> >
; Function compile flags: /Ogtp
;	COMDAT ??$insert@U?$pair@HU_tagWaiting@@@std@@@?$_Tree@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@HU_tagWaiting@@@1@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Val$ = 12						; size = 4
??$insert@U?$pair@HU_tagWaiting@@@std@@@?$_Tree@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@HU_tagWaiting@@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::insert<std::pair<int,_tagWaiting> >, COMDAT
; _this$ = ecx

; 753  : 		_Pairib insert(_Valty&& _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 754  : 		{	// try to insert node with value _Val, favoring right side
; 755  : 		return (_Linsert(this->_Buynode(_STD forward<_Valty>(_Val)),
; 756  : 			false));

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	6a 00		 push	 0
  0000a	50		 push	 eax
  0000b	8b f1		 mov	 esi, ecx
  0000d	e8 00 00 00 00	 call	 ??$_Buynode@U?$pair@HU_tagWaiting@@@std@@@?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@HU_tagWaiting@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::_Buynode<std::pair<int,_tagWaiting> >
  00012	8b 7d 08	 mov	 edi, DWORD PTR ___$ReturnUdt$[ebp]
  00015	50		 push	 eax
  00016	57		 push	 edi
  00017	8b ce		 mov	 ecx, esi
  00019	e8 00 00 00 00	 call	 ?_Linsert@?$_Tree@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@std@@_N@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@2@_N@Z ; std::_Tree<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::_Linsert
  0001e	8b c7		 mov	 eax, edi
  00020	5f		 pop	 edi
  00021	5e		 pop	 esi

; 757  : 		}

  00022	5d		 pop	 ebp
  00023	c2 08 00	 ret	 8
??$insert@U?$pair@HU_tagWaiting@@@std@@@?$_Tree@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@HU_tagWaiting@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::insert<std::pair<int,_tagWaiting> >
_TEXT	ENDS
PUBLIC	??$insert@U?$pair@HU_tagObserverInfo@@@std@@@?$_Tree@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@HU_tagObserverInfo@@@1@@Z ; std::_Tree<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::insert<std::pair<int,_tagObserverInfo> >
; Function compile flags: /Ogtp
;	COMDAT ??$insert@U?$pair@HU_tagObserverInfo@@@std@@@?$_Tree@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@HU_tagObserverInfo@@@1@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Val$ = 12						; size = 4
??$insert@U?$pair@HU_tagObserverInfo@@@std@@@?$_Tree@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@HU_tagObserverInfo@@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::insert<std::pair<int,_tagObserverInfo> >, COMDAT
; _this$ = ecx

; 753  : 		_Pairib insert(_Valty&& _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 754  : 		{	// try to insert node with value _Val, favoring right side
; 755  : 		return (_Linsert(this->_Buynode(_STD forward<_Valty>(_Val)),
; 756  : 			false));

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	6a 00		 push	 0
  0000a	50		 push	 eax
  0000b	8b f1		 mov	 esi, ecx
  0000d	e8 00 00 00 00	 call	 ??$_Buynode@U?$pair@HU_tagObserverInfo@@@std@@@?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@HU_tagObserverInfo@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::_Buynode<std::pair<int,_tagObserverInfo> >
  00012	8b 7d 08	 mov	 edi, DWORD PTR ___$ReturnUdt$[ebp]
  00015	50		 push	 eax
  00016	57		 push	 edi
  00017	8b ce		 mov	 ecx, esi
  00019	e8 00 00 00 00	 call	 ?_Linsert@?$_Tree@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@std@@_N@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@2@_N@Z ; std::_Tree<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::_Linsert
  0001e	8b c7		 mov	 eax, edi
  00020	5f		 pop	 edi
  00021	5e		 pop	 esi

; 757  : 		}

  00022	5d		 pop	 ebp
  00023	c2 08 00	 ret	 8
??$insert@U?$pair@HU_tagObserverInfo@@@std@@@?$_Tree@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@HU_tagObserverInfo@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::insert<std::pair<int,_tagObserverInfo> >
_TEXT	ENDS
PUBLIC	??_C@_0M@FFNHLDAP@pair?4second?$AA@		; `string'
PUBLIC	??_C@_0BI@FIMKCIJJ@ENEWPVP?3?3E_FAILED_ENTER?$AA@ ; `string'
PUBLIC	??_C@_06CEFAPPFE@lpData?$AA@			; `string'
PUBLIC	??_C@_0CF@DMFJILEL@ENEWPVP?3?3E_NOT_FOUND_MOVEREQUEST@ ; `string'
PUBLIC	_responsor$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?Reserve@CNewPVP@@QAEHAAUOBJECTSTRUCT@@0@Z	; CNewPVP::Reserve
EXTRN	?GetMoveCommandData@CMoveCommand@@QAEPAUMOVE_COMMAND_DATA@@H@Z:PROC ; CMoveCommand::GetMoveCommandData
EXTRN	?gMoveCommand@@3VCMoveCommand@@A:BYTE		; gMoveCommand
;	COMDAT ??_C@_0M@FFNHLDAP@pair?4second?$AA@
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
CONST	SEGMENT
??_C@_0M@FFNHLDAP@pair?4second?$AA@ DB 'pair.second', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@FIMKCIJJ@ENEWPVP?3?3E_FAILED_ENTER?$AA@
CONST	SEGMENT
??_C@_0BI@FIMKCIJJ@ENEWPVP?3?3E_FAILED_ENTER?$AA@ DB 'ENEWPVP::E_FAILED_E'
	DB	'NTER', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_06CEFAPPFE@lpData?$AA@
CONST	SEGMENT
??_C@_06CEFAPPFE@lpData?$AA@ DB 'lpData', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@DMFJILEL@ENEWPVP?3?3E_NOT_FOUND_MOVEREQUEST@
CONST	SEGMENT
??_C@_0CF@DMFJILEL@ENEWPVP?3?3E_NOT_FOUND_MOVEREQUEST@ DB 'ENEWPVP::E_NOT'
	DB	'_FOUND_MOVEREQUESTDATA', 00H		; `string'
; Function compile flags: /Ogtp
; File c:\muserver_dev\development\mu-s8ep2-repack\gameserver\source\newpvp.cpp
CONST	ENDS
;	COMDAT ?Reserve@CNewPVP@@QAEHAAUOBJECTSTRUCT@@0@Z
_TEXT	SEGMENT
$T187133 = -60						; size = 20
_waiting$ = -40						; size = 16
_pair$ = -32						; size = 8
_responsor$GSCopy$ = -24				; size = 4
_req$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_requester$ = 8						; size = 4
_responsor$ = 12					; size = 4
?Reserve@CNewPVP@@QAEHAAUOBJECTSTRUCT@@0@Z PROC		; CNewPVP::Reserve, COMDAT
; _this$ = ecx

; 321  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 3c	 sub	 esp, 60			; 0000003cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	8b 75 08	 mov	 esi, DWORD PTR _requester$[ebp]
  00015	57		 push	 edi
  00016	8b 7d 0c	 mov	 edi, DWORD PTR _responsor$[ebp]

; 322  : 	int nRet = GetDuelStatus(requester);

  00019	56		 push	 esi
  0001a	8b d9		 mov	 ebx, ecx

; 351  : 
; 352  : 	SetDuelStatus(requester, responsor, 1);

  0001c	89 7d e8	 mov	 DWORD PTR _responsor$GSCopy$[ebp], edi
  0001f	e8 00 00 00 00	 call	 ?GetDuelStatus@CNewPVP@@AAEHAAUOBJECTSTRUCT@@@Z ; CNewPVP::GetDuelStatus
  00024	85 c0		 test	 eax, eax
  00026	0f 85 cd 01 00
	00		 jne	 $LN13@Reserve

; 323  : 	if(nRet)	return nRet;
; 324  : 
; 325  : 	nRet = GetDuelStatusByResponsor(requester);

  0002c	56		 push	 esi
  0002d	8b cb		 mov	 ecx, ebx
  0002f	e8 00 00 00 00	 call	 ?GetDuelStatusByResponsor@CNewPVP@@AAEHAAUOBJECTSTRUCT@@@Z ; CNewPVP::GetDuelStatusByResponsor

; 326  : 	if(nRet)	return nRet;

  00034	85 c0		 test	 eax, eax
  00036	0f 85 bd 01 00
	00		 jne	 $LN13@Reserve

; 327  : 
; 328  : 	MOVE_COMMAND_DATA * lpData = gMoveCommand.GetMoveCommandData(42);

  0003c	6a 2a		 push	 42			; 0000002aH
  0003e	b9 00 00 00 00	 mov	 ecx, OFFSET ?gMoveCommand@@3VCMoveCommand@@A ; gMoveCommand
  00043	e8 00 00 00 00	 call	 ?GetMoveCommandData@CMoveCommand@@QAEPAUMOVE_COMMAND_DATA@@H@Z ; CMoveCommand::GetMoveCommandData

; 329  : 	if(lpData == NULL){ LogAddTD("%s\t%s\t%s\t%s\t%d","lpData","ENEWPVP::E_NOT_FOUND_MOVEREQUESTDATA","NULL",__FILE__, __LINE__); return ENEWPVP::E_NOT_FOUND_MOVEREQUESTDATA; }

  00048	85 c0		 test	 eax, eax
  0004a	75 3f		 jne	 SHORT $LN10@Reserve
  0004c	68 49 01 00 00	 push	 329			; 00000149H
  00051	68 00 00 00 00	 push	 OFFSET ??_C@_0L@IGELOCEA@NewPVP?4cpp?$AA@
  00056	68 00 00 00 00	 push	 OFFSET ??_C@_04HIBGFPH@NULL?$AA@
  0005b	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@DMFJILEL@ENEWPVP?3?3E_NOT_FOUND_MOVEREQUEST@
  00060	68 00 00 00 00	 push	 OFFSET ??_C@_06CEFAPPFE@lpData?$AA@
  00065	68 00 00 00 00	 push	 OFFSET ??_C@_0P@ENJPCMFP@?$CFs?7?$CFs?7?$CFs?7?$CFs?7?$CFd?$AA@
  0006a	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00070	83 c4 18	 add	 esp, 24			; 00000018H
  00073	5f		 pop	 edi
  00074	5e		 pop	 esi
  00075	b8 1d 00 00 00	 mov	 eax, 29			; 0000001dH
  0007a	5b		 pop	 ebx

; 364  : }

  0007b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0007e	33 cd		 xor	 ecx, ebp
  00080	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00085	8b e5		 mov	 esp, ebp
  00087	5d		 pop	 ebp
  00088	c2 08 00	 ret	 8
$LN10@Reserve:

; 330  : 
; 331  : 	if( !IsVulcanusMap(requester.MapNumber) )

  0008b	b1 3f		 mov	 cl, 63			; 0000003fH
  0008d	38 8e 23 01 00
	00		 cmp	 BYTE PTR [esi+291], cl
  00093	74 26		 je	 SHORT $LN8@Reserve

; 332  : 	{
; 333  : 		if(IsVulcanusMap(requester.MapNumber) || requester.Money - lpData->NeedZen < 0)	return ENEWPVP::E_NOT_ENOUGH_MONEY;

  00095	8b 96 cc 00 00
	00		 mov	 edx, DWORD PTR [esi+204]
  0009b	2b 90 04 02 00
	00		 sub	 edx, DWORD PTR [eax+516]
  000a1	79 18		 jns	 SHORT $LN8@Reserve
$LN45@Reserve:
  000a3	5f		 pop	 edi
  000a4	5e		 pop	 esi
  000a5	b8 1e 00 00 00	 mov	 eax, 30			; 0000001eH
  000aa	5b		 pop	 ebx

; 364  : }

  000ab	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000ae	33 cd		 xor	 ecx, ebp
  000b0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000b5	8b e5		 mov	 esp, ebp
  000b7	5d		 pop	 ebp
  000b8	c2 08 00	 ret	 8
$LN8@Reserve:

; 334  : 	}
; 335  : 	if( !IsVulcanusMap(responsor.MapNumber) )

  000bb	38 8f 23 01 00
	00		 cmp	 BYTE PTR [edi+291], cl
  000c1	74 0e		 je	 SHORT $LN5@Reserve

; 336  : 	{
; 337  : 		if(IsVulcanusMap(responsor.MapNumber) || responsor.Money - lpData->NeedZen < 0)	return ENEWPVP::E_NOT_ENOUGH_MONEY;

  000c3	8b 8f cc 00 00
	00		 mov	 ecx, DWORD PTR [edi+204]
  000c9	2b 88 04 02 00
	00		 sub	 ecx, DWORD PTR [eax+516]
  000cf	78 d2		 js	 SHORT $LN45@Reserve
$LN5@Reserve:

; 338  : 	}
; 339  : 
; 340  : 	if( !CheckLimitLevel(requester.m_Index,g_GateRequester[0]) )	return ENEWPVP::E_LIMIT_LEVEL;

  000d1	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _g_GateRequester
  000d7	8b 06		 mov	 eax, DWORD PTR [esi]
  000d9	52		 push	 edx
  000da	50		 push	 eax
  000db	8b cb		 mov	 ecx, ebx
  000dd	e8 00 00 00 00	 call	 ?CheckLimitLevel@CNewPVP@@AAEHHH@Z ; CNewPVP::CheckLimitLevel
  000e2	85 c0		 test	 eax, eax
  000e4	75 18		 jne	 SHORT $LN3@Reserve
$LN46@Reserve:
  000e6	5f		 pop	 edi
  000e7	5e		 pop	 esi
  000e8	b8 1c 00 00 00	 mov	 eax, 28			; 0000001cH
  000ed	5b		 pop	 ebx

; 364  : }

  000ee	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000f1	33 cd		 xor	 ecx, ebp
  000f3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000f8	8b e5		 mov	 esp, ebp
  000fa	5d		 pop	 ebp
  000fb	c2 08 00	 ret	 8
$LN3@Reserve:

; 341  : 	if( !CheckLimitLevel(responsor.m_Index,g_GateResponsor[0]) )	return ENEWPVP::E_LIMIT_LEVEL;

  000fe	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _g_GateResponsor
  00104	8b 17		 mov	 edx, DWORD PTR [edi]
  00106	51		 push	 ecx
  00107	52		 push	 edx
  00108	8b cb		 mov	 ecx, ebx
  0010a	e8 00 00 00 00	 call	 ?CheckLimitLevel@CNewPVP@@AAEHHH@Z ; CNewPVP::CheckLimitLevel
  0010f	85 c0		 test	 eax, eax
  00111	74 d3		 je	 SHORT $LN46@Reserve

; 342  : 
; 343  : 	_tagWaiting waiting = {0};
; 344  :     waiting.nRequester = requester.m_Index;

  00113	8b 3e		 mov	 edi, DWORD PTR [esi]
  00115	33 c0		 xor	 eax, eax
  00117	89 45 dc	 mov	 DWORD PTR _waiting$[ebp+4], eax
  0011a	89 45 e0	 mov	 DWORD PTR _waiting$[ebp+8], eax
  0011d	89 45 e4	 mov	 DWORD PTR _waiting$[ebp+12], eax

; 345  :     waiting.nResponsor = responsor.m_Index;

  00120	8b 45 e8	 mov	 eax, DWORD PTR _responsor$GSCopy$[ebp]
  00123	8b 08		 mov	 ecx, DWORD PTR [eax]
  00125	89 4d dc	 mov	 DWORD PTR _waiting$[ebp+4], ecx

; 346  :     waiting.bExpired = 0;

  00128	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _waiting$[ebp+8], 0

; 347  :     waiting.dwTime = GetTickCount();

  0012f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0

; 348  : 
; 349  : 	std::pair< std::map<int,_tagWaiting>::iterator, bool > pair = m_Waiting.insert( std::make_pair(requester.m_Index,  waiting) );

  00135	8b 16		 mov	 edx, DWORD PTR [esi]
  00137	8b 4d dc	 mov	 ecx, DWORD PTR _waiting$[ebp+4]
  0013a	89 45 d4	 mov	 DWORD PTR $T187133[ebp+16], eax
  0013d	89 55 c4	 mov	 DWORD PTR $T187133[ebp], edx
  00140	8b 55 e0	 mov	 edx, DWORD PTR _waiting$[ebp+8]
  00143	6a 00		 push	 0
  00145	8d 45 c4	 lea	 eax, DWORD PTR $T187133[ebp]
  00148	89 4d cc	 mov	 DWORD PTR $T187133[ebp+8], ecx
  0014b	50		 push	 eax
  0014c	8d 8b 14 01 00
	00		 lea	 ecx, DWORD PTR [ebx+276]
  00152	89 7d c8	 mov	 DWORD PTR $T187133[ebp+4], edi
  00155	89 55 d0	 mov	 DWORD PTR $T187133[ebp+12], edx
  00158	e8 00 00 00 00	 call	 ??$_Buynode@U?$pair@HU_tagWaiting@@@std@@@?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@HU_tagWaiting@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::_Buynode<std::pair<int,_tagWaiting> >
  0015d	50		 push	 eax
  0015e	8d 4d e0	 lea	 ecx, DWORD PTR _pair$[ebp]
  00161	51		 push	 ecx
  00162	8d 8b 14 01 00
	00		 lea	 ecx, DWORD PTR [ebx+276]
  00168	e8 00 00 00 00	 call	 ?_Linsert@?$_Tree@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@std@@_N@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@2@_N@Z ; std::_Tree<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::_Linsert

; 350  : 	if(pair.second == false){ LogAddTD("%s\t%s\t%s\t%s\t%d","pair.second","ENEWPVP::E_FAILED_ENTER","NULL",__FILE__,__LINE__); return ENEWPVP::E_FAILED_ENTER; }

  0016d	80 7d e4 00	 cmp	 BYTE PTR _pair$[ebp+4], 0
  00171	75 3f		 jne	 SHORT $LN1@Reserve
  00173	68 5e 01 00 00	 push	 350			; 0000015eH
  00178	68 00 00 00 00	 push	 OFFSET ??_C@_0L@IGELOCEA@NewPVP?4cpp?$AA@
  0017d	68 00 00 00 00	 push	 OFFSET ??_C@_04HIBGFPH@NULL?$AA@
  00182	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@FIMKCIJJ@ENEWPVP?3?3E_FAILED_ENTER?$AA@
  00187	68 00 00 00 00	 push	 OFFSET ??_C@_0M@FFNHLDAP@pair?4second?$AA@
  0018c	68 00 00 00 00	 push	 OFFSET ??_C@_0P@ENJPCMFP@?$CFs?7?$CFs?7?$CFs?7?$CFs?7?$CFd?$AA@
  00191	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00197	83 c4 18	 add	 esp, 24			; 00000018H
  0019a	5f		 pop	 edi
  0019b	5e		 pop	 esi
  0019c	b8 19 00 00 00	 mov	 eax, 25			; 00000019H
  001a1	5b		 pop	 ebx

; 364  : }

  001a2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001a5	33 cd		 xor	 ecx, ebp
  001a7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001ac	8b e5		 mov	 esp, ebp
  001ae	5d		 pop	 ebp
  001af	c2 08 00	 ret	 8
$LN1@Reserve:

; 351  : 
; 352  : 	SetDuelStatus(requester, responsor, 1);

  001b2	8b 7d e8	 mov	 edi, DWORD PTR _responsor$GSCopy$[ebp]
  001b5	6a 01		 push	 1
  001b7	57		 push	 edi
  001b8	56		 push	 esi
  001b9	8b cb		 mov	 ecx, ebx
  001bb	e8 00 00 00 00	 call	 ?SetDuelStatus@CNewPVP@@AAEXAAUOBJECTSTRUCT@@0H@Z ; CNewPVP::SetDuelStatus

; 353  : 
; 354  : 	PMSG_REQ_DUEL_ANSWER req;
; 355  :     req.h.c = PMHC_BYTE;
; 356  :     req.h.size = sizeof(PMSG_REQ_DUEL_ANSWER);
; 357  :     req.h.headcode = 0xAA;
; 358  :     req.h.subcode = 0x02;
; 359  :     req.NumberH = HIBYTE(requester.m_Index);

  001c0	8a 56 01	 mov	 dl, BYTE PTR [esi+1]

; 360  :     req.NumberL = LOBYTE(requester.m_Index);
; 361  :     memcpy(req.szName, requester.Name, MAX_IDSTRING);

  001c3	8b 4e 5d	 mov	 ecx, DWORD PTR [esi+93]
  001c6	8a 06		 mov	 al, BYTE PTR [esi]
  001c8	88 55 f0	 mov	 BYTE PTR _req$[ebp+4], dl
  001cb	8b 56 61	 mov	 edx, DWORD PTR [esi+97]
  001ce	89 4d f2	 mov	 DWORD PTR _req$[ebp+6], ecx

; 362  :     DataSend(responsor.m_Index, (LPBYTE)&req, req.h.size);

  001d1	6a 10		 push	 16			; 00000010H
  001d3	8d 4d ec	 lea	 ecx, DWORD PTR _req$[ebp]
  001d6	89 55 f6	 mov	 DWORD PTR _req$[ebp+10], edx
  001d9	8b 17		 mov	 edx, DWORD PTR [edi]
  001db	88 45 f1	 mov	 BYTE PTR _req$[ebp+5], al
  001de	66 8b 46 65	 mov	 ax, WORD PTR [esi+101]
  001e2	51		 push	 ecx
  001e3	52		 push	 edx
  001e4	c7 45 ec c1 10
	aa 02		 mov	 DWORD PTR _req$[ebp], 44699841 ; 02aa10c1H
  001eb	66 89 45 fa	 mov	 WORD PTR _req$[ebp+14], ax
  001ef	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  001f4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 363  : 	return 0;

  001f7	33 c0		 xor	 eax, eax
$LN13@Reserve:

; 364  : }

  001f9	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001fc	5f		 pop	 edi
  001fd	5e		 pop	 esi
  001fe	33 cd		 xor	 ecx, ebp
  00200	5b		 pop	 ebx
  00201	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00206	8b e5		 mov	 esp, ebp
  00208	5d		 pop	 ebp
  00209	c2 08 00	 ret	 8
?Reserve@CNewPVP@@QAEHAAUOBJECTSTRUCT@@0@Z ENDP		; CNewPVP::Reserve
_TEXT	ENDS
PUBLIC	??_C@_0BG@NENFJOPG@iter?$CB?$DNm_Waiting?4end?$CI?$CJ?$AA@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?Cancel@CNewPVP@@QAEXAAUOBJECTSTRUCT@@0H@Z	; CNewPVP::Cancel
;	COMDAT ??_C@_0BG@NENFJOPG@iter?$CB?$DNm_Waiting?4end?$CI?$CJ?$AA@
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
CONST	SEGMENT
??_C@_0BG@NENFJOPG@iter?$CB?$DNm_Waiting?4end?$CI?$CJ?$AA@ DB 'iter!=m_Wa'
	DB	'iting.end()', 00H				; `string'
; Function compile flags: /Ogtp
; File c:\muserver_dev\development\mu-s8ep2-repack\gameserver\source\newpvp.cpp
CONST	ENDS
;	COMDAT ?Cancel@CNewPVP@@QAEXAAUOBJECTSTRUCT@@0H@Z
_TEXT	SEGMENT
_iter$ = -28						; size = 4
_res$187279 = -24					; size = 17
__$ArrayPad$ = -4					; size = 4
_requester$ = 8						; size = 4
_responsor$ = 12					; size = 4
_bSendPacket$ = 16					; size = 4
?Cancel@CNewPVP@@QAEXAAUOBJECTSTRUCT@@0H@Z PROC		; CNewPVP::Cancel, COMDAT
; _this$ = ecx

; 439  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	8b 75 0c	 mov	 esi, DWORD PTR _responsor$[ebp]
  00015	57		 push	 edi
  00016	8b 7d 08	 mov	 edi, DWORD PTR _requester$[ebp]
  00019	8b d9		 mov	 ebx, ecx

; 440  : 	std::map<int, _tagWaiting>::iterator iter = m_Waiting.find(requester.m_Index); 

  0001b	57		 push	 edi
  0001c	8d 45 e4	 lea	 eax, DWORD PTR _iter$[ebp]
  0001f	50		 push	 eax
  00020	8d 8b 14 01 00
	00		 lea	 ecx, DWORD PTR [ebx+276]
  00026	e8 00 00 00 00	 call	 ?find@?$_Tree@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::find

; 441  : 	if(!(iter!=m_Waiting.end())){ LogAddTD("%s\t%s\t%s\t%s\t%d","iter!=m_Waiting.end()","0","NULL", __FILE__,  __LINE__); return; }

  0002b	8b 45 e4	 mov	 eax, DWORD PTR _iter$[ebp]
  0002e	3b 83 18 01 00
	00		 cmp	 eax, DWORD PTR [ebx+280]
  00034	75 3a		 jne	 SHORT $LN4@Cancel
  00036	68 b9 01 00 00	 push	 441			; 000001b9H
  0003b	68 00 00 00 00	 push	 OFFSET ??_C@_0L@IGELOCEA@NewPVP?4cpp?$AA@
  00040	68 00 00 00 00	 push	 OFFSET ??_C@_04HIBGFPH@NULL?$AA@
  00045	68 00 00 00 00	 push	 OFFSET ??_C@_01GBGANLPD@0?$AA@
  0004a	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@NENFJOPG@iter?$CB?$DNm_Waiting?4end?$CI?$CJ?$AA@
  0004f	68 00 00 00 00	 push	 OFFSET ??_C@_0P@ENJPCMFP@?$CFs?7?$CFs?7?$CFs?7?$CFs?7?$CFd?$AA@
  00054	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0005a	83 c4 18	 add	 esp, 24			; 00000018H
  0005d	5f		 pop	 edi
  0005e	5e		 pop	 esi
  0005f	5b		 pop	 ebx

; 460  :     }
; 461  : }

  00060	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00063	33 cd		 xor	 ecx, ebp
  00065	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0006a	8b e5		 mov	 esp, ebp
  0006c	5d		 pop	 ebp
  0006d	c2 0c 00	 ret	 12			; 0000000cH
$LN4@Cancel:

; 442  : 
; 443  : 	_tagWaiting & waiting = iter->second;
; 444  : 	waiting.bExpired = 1;
; 445  : 
; 446  : 	SetDuelStatus(requester, responsor, DC_IDLE);

  00070	6a 00		 push	 0
  00072	56		 push	 esi
  00073	57		 push	 edi
  00074	8b cb		 mov	 ecx, ebx
  00076	c7 40 18 01 00
	00 00		 mov	 DWORD PTR [eax+24], 1
  0007d	e8 00 00 00 00	 call	 ?SetDuelStatus@CNewPVP@@AAEXAAUOBJECTSTRUCT@@0H@Z ; CNewPVP::SetDuelStatus

; 447  : 
; 448  : 	if( bSendPacket == TRUE )

  00082	83 7d 10 01	 cmp	 DWORD PTR _bSendPacket$[ebp], 1
  00086	75 6f		 jne	 SHORT $LN1@Cancel

; 449  :     {
; 450  : 		PMSG_ANS_DUEL_INVITE res = {0};
; 451  : 		res.h.c = PMHC_BYTE;
; 452  : 		res.h.size = sizeof(PMSG_ANS_DUEL_INVITE);
; 453  : 		res.h.headcode = 0xAA;
; 454  : 		res.h.subcode = 0x01;
; 455  : 		memcpy(res.szName, responsor.Name, MAX_IDSTRING);

  00088	8b 4e 5d	 mov	 ecx, DWORD PTR [esi+93]
  0008b	8b 56 61	 mov	 edx, DWORD PTR [esi+97]
  0008e	33 c0		 xor	 eax, eax
  00090	89 45 e9	 mov	 DWORD PTR _res$187279[ebp+1], eax
  00093	89 45 f1	 mov	 DWORD PTR _res$187279[ebp+9], eax
  00096	89 45 f5	 mov	 DWORD PTR _res$187279[ebp+13], eax
  00099	89 45 ed	 mov	 DWORD PTR _res$187279[ebp+5], eax
  0009c	66 8b 46 65	 mov	 ax, WORD PTR [esi+101]

; 456  : 		res.nResult = 0x0F;
; 457  :       
; 458  : 		if( gObjIsConnected(&requester) )	DataSend(requester.m_Index, (LPBYTE)&res,res.h.size);

  000a0	57		 push	 edi
  000a1	c7 45 e8 c1 11
	aa 01		 mov	 DWORD PTR _res$187279[ebp], 27922881 ; 01aa11c1H
  000a8	89 4d ef	 mov	 DWORD PTR _res$187279[ebp+7], ecx
  000ab	89 55 f3	 mov	 DWORD PTR _res$187279[ebp+11], edx
  000ae	66 89 45 f7	 mov	 WORD PTR _res$187279[ebp+15], ax
  000b2	c6 45 ec 0f	 mov	 BYTE PTR _res$187279[ebp+4], 15 ; 0000000fH
  000b6	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHPAUOBJECTSTRUCT@@@Z ; gObjIsConnected
  000bb	83 c4 04	 add	 esp, 4
  000be	85 c0		 test	 eax, eax
  000c0	74 14		 je	 SHORT $LN2@Cancel
  000c2	0f b6 4d e9	 movzx	 ecx, BYTE PTR _res$187279[ebp+1]
  000c6	8b 07		 mov	 eax, DWORD PTR [edi]
  000c8	51		 push	 ecx
  000c9	8d 55 e8	 lea	 edx, DWORD PTR _res$187279[ebp]
  000cc	52		 push	 edx
  000cd	50		 push	 eax
  000ce	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  000d3	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@Cancel:

; 459  : 		if( gObjIsConnected(&responsor) )	DataSend(responsor.m_Index, (LPBYTE)&res, res.h.size);

  000d6	56		 push	 esi
  000d7	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHPAUOBJECTSTRUCT@@@Z ; gObjIsConnected
  000dc	83 c4 04	 add	 esp, 4
  000df	85 c0		 test	 eax, eax
  000e1	74 14		 je	 SHORT $LN1@Cancel
  000e3	0f b6 4d e9	 movzx	 ecx, BYTE PTR _res$187279[ebp+1]
  000e7	8b 06		 mov	 eax, DWORD PTR [esi]
  000e9	51		 push	 ecx
  000ea	8d 55 e8	 lea	 edx, DWORD PTR _res$187279[ebp]
  000ed	52		 push	 edx
  000ee	50		 push	 eax
  000ef	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  000f4	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@Cancel:

; 460  :     }
; 461  : }

  000f7	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000fa	5f		 pop	 edi
  000fb	5e		 pop	 esi
  000fc	33 cd		 xor	 ecx, ebp
  000fe	5b		 pop	 ebx
  000ff	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00104	8b e5		 mov	 esp, ebp
  00106	5d		 pop	 ebp
  00107	c2 0c 00	 ret	 12			; 0000000cH
?Cancel@CNewPVP@@QAEXAAUOBJECTSTRUCT@@0H@Z ENDP		; CNewPVP::Cancel
_TEXT	ENDS
PUBLIC	??_C@_0BN@CPLOFFJH@ENEWPVP?3?3E_INVALID_CHANNELID?$AA@ ; `string'
PUBLIC	??_C@_0M@EPIOBBFH@lpTargetObj?$AA@		; `string'
PUBLIC	??_C@_0BJ@EGLACHLG@ENEWPVP?3?3E_INVALID_INDEX?$AA@ ; `string'
PUBLIC	??_C@_0BK@PKKMGGKN@ENEWPVP?3?3E_INVALID_STATUS?$AA@ ; `string'
PUBLIC	?Leave@CNewPVP@@QAEHAAUOBJECTSTRUCT@@@Z		; CNewPVP::Leave
;	COMDAT ??_C@_0BN@CPLOFFJH@ENEWPVP?3?3E_INVALID_CHANNELID?$AA@
; File c:\muserver_dev\development\mu-s8ep2-repack\gameserver\source\newpvp.h
CONST	SEGMENT
??_C@_0BN@CPLOFFJH@ENEWPVP?3?3E_INVALID_CHANNELID?$AA@ DB 'ENEWPVP::E_INV'
	DB	'ALID_CHANNELID', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@EPIOBBFH@lpTargetObj?$AA@
CONST	SEGMENT
??_C@_0M@EPIOBBFH@lpTargetObj?$AA@ DB 'lpTargetObj', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@EGLACHLG@ENEWPVP?3?3E_INVALID_INDEX?$AA@
CONST	SEGMENT
??_C@_0BJ@EGLACHLG@ENEWPVP?3?3E_INVALID_INDEX?$AA@ DB 'ENEWPVP::E_INVALID'
	DB	'_INDEX', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@PKKMGGKN@ENEWPVP?3?3E_INVALID_STATUS?$AA@
CONST	SEGMENT
??_C@_0BK@PKKMGGKN@ENEWPVP?3?3E_INVALID_STATUS?$AA@ DB 'ENEWPVP::E_INVALI'
	DB	'D_STATUS', 00H				; `string'
; Function compile flags: /Ogtp
; File c:\muserver_dev\development\mu-s8ep2-repack\gameserver\source\newpvp.cpp
CONST	ENDS
;	COMDAT ?Leave@CNewPVP@@QAEHAAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_obj$ = 8						; size = 4
?Leave@CNewPVP@@QAEHAAUOBJECTSTRUCT@@@Z PROC		; CNewPVP::Leave, COMDAT
; _this$ = ecx

; 465  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 466  : 	int nId = GetDuelChannelId(obj.m_Index);

  00004	8b 5d 08	 mov	 ebx, DWORD PTR _obj$[ebp]
  00007	8b 03		 mov	 eax, DWORD PTR [ebx]
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	50		 push	 eax
  0000c	8b f1		 mov	 esi, ecx
  0000e	e8 00 00 00 00	 call	 ?GetDuelChannelId@CNewPVP@@AAEHH@Z ; CNewPVP::GetDuelChannelId
  00013	8b f8		 mov	 edi, eax

; 467  : 	if(nId < 0 || nId >= DUEL_CHANNEL_MAX){	LogAddTD("%s\t%s\t%s\t%s\t%d","nId>=0 && nId<DUEL_CHANNEL_MAX","ENEWPVP::E_INVALID_CHANNELID","NULL",__FILE__, __LINE__); return ENEWPVP::E_INVALID_CHANNELID; }

  00015	83 ff 03	 cmp	 edi, 3
  00018	0f 87 dd 00 00
	00		 ja	 $LN6@Leave@2

; 468  : 	if( !IS_START(m_DuelChannel[nId].nStatus ) && m_DuelChannel[nId].nStatus != DC_RESERVEDEND ){ LogAddTD("%s\t%s\t%s\t%s\t%d","IS_START(m_DuelChannel[nId].nStatus)||m_DuelChannel[nId].nStatus==DC_RESERVEDEND", "ENEWPVP::E_INVALID_STATUS","NULL",__FILE__, __LINE__); return ENEWPVP::E_INVALID_STATUS; }	

  0001e	8b cf		 mov	 ecx, edi
  00020	6b c9 2c	 imul	 ecx, 44			; 0000002cH
  00023	8a 84 31 86 00
	00 00		 mov	 al, BYTE PTR [ecx+esi+134]
  0002a	8d 8c 31 86 00
	00 00		 lea	 ecx, DWORD PTR [ecx+esi+134]
  00031	3c 02		 cmp	 al, 2
  00033	72 04		 jb	 SHORT $LN4@Leave@2
  00035	3c 04		 cmp	 al, 4
  00037	76 37		 jbe	 SHORT $LN5@Leave@2
$LN4@Leave@2:
  00039	3c 05		 cmp	 al, 5
  0003b	74 33		 je	 SHORT $LN5@Leave@2
  0003d	68 d4 01 00 00	 push	 468			; 000001d4H
  00042	68 00 00 00 00	 push	 OFFSET ??_C@_0L@IGELOCEA@NewPVP?4cpp?$AA@
  00047	68 00 00 00 00	 push	 OFFSET ??_C@_04HIBGFPH@NULL?$AA@
  0004c	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@PKKMGGKN@ENEWPVP?3?3E_INVALID_STATUS?$AA@
  00051	68 00 00 00 00	 push	 OFFSET ??_C@_0FB@CPAGFMCM@IS_START?$CIm_DuelChannel?$FLnId?$FN?4nSta@
  00056	68 00 00 00 00	 push	 OFFSET ??_C@_0P@ENJPCMFP@?$CFs?7?$CFs?7?$CFs?7?$CFs?7?$CFd?$AA@
  0005b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00061	83 c4 18	 add	 esp, 24			; 00000018H
  00064	5f		 pop	 edi
  00065	5e		 pop	 esi
  00066	b8 11 00 00 00	 mov	 eax, 17			; 00000011H
  0006b	5b		 pop	 ebx

; 484  : }

  0006c	5d		 pop	 ebp
  0006d	c2 04 00	 ret	 4
$LN5@Leave@2:

; 469  : 
; 470  : 	LPOBJ lpTargetObj = NULL;
; 471  : 
; 472  : 	obj.m_iDuelUserReserved = -1;
; 473  : 
; 474  : 	if( IsDuel(obj) )	lpTargetObj = (LPOBJ)&gObj[obj.m_iDuelUser];

  00070	8b 83 50 12 00
	00		 mov	 eax, DWORD PTR [ebx+4688]
  00076	c7 83 48 12 00
	00 ff ff ff ff	 mov	 DWORD PTR [ebx+4680], -1
  00080	85 c0		 test	 eax, eax
  00082	78 1c		 js	 SHORT $LN14@Leave@2
  00084	33 d2		 xor	 edx, edx
  00086	3d eb 2c 00 00	 cmp	 eax, 11499		; 00002cebH
  0008b	0f 9e c2	 setle	 dl
  0008e	85 d2		 test	 edx, edx
  00090	74 0e		 je	 SHORT $LN14@Leave@2
  00092	69 c0 40 27 00
	00		 imul	 eax, 10048		; 00002740H
  00098	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 475  : 
; 476  : 	if(lpTargetObj == NULL){ LogAddTD("%s\t%s\t%s\t%s\t%d","lpTargetObj","ENEWPVP::E_INVALID_INDEX","NULL", __FILE__, __LINE__); return ENEWPVP::E_INVALID_INDEX; }

  0009e	75 33		 jne	 SHORT $LN2@Leave@2
$LN14@Leave@2:
  000a0	68 dc 01 00 00	 push	 476			; 000001dcH
  000a5	68 00 00 00 00	 push	 OFFSET ??_C@_0L@IGELOCEA@NewPVP?4cpp?$AA@
  000aa	68 00 00 00 00	 push	 OFFSET ??_C@_04HIBGFPH@NULL?$AA@
  000af	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@EGLACHLG@ENEWPVP?3?3E_INVALID_INDEX?$AA@
  000b4	68 00 00 00 00	 push	 OFFSET ??_C@_0M@EPIOBBFH@lpTargetObj?$AA@
  000b9	68 00 00 00 00	 push	 OFFSET ??_C@_0P@ENJPCMFP@?$CFs?7?$CFs?7?$CFs?7?$CFs?7?$CFd?$AA@
  000be	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  000c4	83 c4 18	 add	 esp, 24			; 00000018H
  000c7	5f		 pop	 edi
  000c8	5e		 pop	 esi
  000c9	b8 0b 00 00 00	 mov	 eax, 11			; 0000000bH
  000ce	5b		 pop	 ebx

; 484  : }

  000cf	5d		 pop	 ebp
  000d0	c2 04 00	 ret	 4
$LN2@Leave@2:

; 477  : 
; 478  : 	if( m_DuelChannel[nId].nStatus != DC_RESERVEDEND )

  000d3	80 39 05	 cmp	 BYTE PTR [ecx], 5
  000d6	74 1a		 je	 SHORT $LN1@Leave@2

; 479  :     {
; 480  :         SetStatus(DC_RESERVEDEND, nId, obj, *lpTargetObj);

  000d8	50		 push	 eax
  000d9	53		 push	 ebx
  000da	57		 push	 edi
  000db	6a 05		 push	 5
  000dd	8b ce		 mov	 ecx, esi
  000df	e8 00 00 00 00	 call	 ?SetStatus@CNewPVP@@AAEXHHAAUOBJECTSTRUCT@@0@Z ; CNewPVP::SetStatus

; 481  :         BroadcastMessage( nId, 1, 1, 10);

  000e4	6a 0a		 push	 10			; 0000000aH
  000e6	6a 01		 push	 1
  000e8	6a 01		 push	 1
  000ea	57		 push	 edi
  000eb	8b ce		 mov	 ecx, esi
  000ed	e8 00 00 00 00	 call	 ?BroadcastMessage@CNewPVP@@AAEXHEEH@Z ; CNewPVP::BroadcastMessage
$LN1@Leave@2:

; 482  :     }
; 483  : 	return 0;

  000f2	5f		 pop	 edi
  000f3	5e		 pop	 esi
  000f4	33 c0		 xor	 eax, eax
  000f6	5b		 pop	 ebx

; 484  : }

  000f7	5d		 pop	 ebp
  000f8	c2 04 00	 ret	 4
$LN6@Leave@2:

; 467  : 	if(nId < 0 || nId >= DUEL_CHANNEL_MAX){	LogAddTD("%s\t%s\t%s\t%s\t%d","nId>=0 && nId<DUEL_CHANNEL_MAX","ENEWPVP::E_INVALID_CHANNELID","NULL",__FILE__, __LINE__); return ENEWPVP::E_INVALID_CHANNELID; }

  000fb	68 d3 01 00 00	 push	 467			; 000001d3H
  00100	68 00 00 00 00	 push	 OFFSET ??_C@_0L@IGELOCEA@NewPVP?4cpp?$AA@
  00105	68 00 00 00 00	 push	 OFFSET ??_C@_04HIBGFPH@NULL?$AA@
  0010a	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@CPLOFFJH@ENEWPVP?3?3E_INVALID_CHANNELID?$AA@
  0010f	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@OMAPJGHA@nId?$DO?$DN0?5?$CG?$CG?5nId?$DMDUEL_CHANNEL_MAX?$AA@
  00114	68 00 00 00 00	 push	 OFFSET ??_C@_0P@ENJPCMFP@?$CFs?7?$CFs?7?$CFs?7?$CFs?7?$CFd?$AA@
  00119	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0011f	83 c4 18	 add	 esp, 24			; 00000018H
  00122	5f		 pop	 edi
  00123	5e		 pop	 esi
  00124	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  00129	5b		 pop	 ebx

; 484  : }

  0012a	5d		 pop	 ebp
  0012b	c2 04 00	 ret	 4
?Leave@CNewPVP@@QAEHAAUOBJECTSTRUCT@@@Z ENDP		; CNewPVP::Leave
_TEXT	ENDS
PUBLIC	??_C@_0CJ@LJHODCKE@info?4nId?$DO?$DN0?5?$CG?$CG?5info?4nId?$DMDUEL_CHA@ ; `string'
PUBLIC	??_C@_02PGHGPEOM@?91?$AA@			; `string'
PUBLIC	?GetChannelIdByObserver@CNewPVP@@AAEHAAUOBJECTSTRUCT@@@Z ; CNewPVP::GetChannelIdByObserver
;	COMDAT ??_C@_0CJ@LJHODCKE@info?4nId?$DO?$DN0?5?$CG?$CG?5info?4nId?$DMDUEL_CHA@
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
CONST	SEGMENT
??_C@_0CJ@LJHODCKE@info?4nId?$DO?$DN0?5?$CG?$CG?5info?4nId?$DMDUEL_CHA@ DB 'i'
	DB	'nfo.nId>=0 && info.nId<DUEL_CHANNEL_MAX', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02PGHGPEOM@?91?$AA@
CONST	SEGMENT
??_C@_02PGHGPEOM@?91?$AA@ DB '-1', 00H			; `string'
; Function compile flags: /Ogtp
; File c:\muserver_dev\development\mu-s8ep2-repack\gameserver\source\newpvp.cpp
CONST	ENDS
;	COMDAT ?GetChannelIdByObserver@CNewPVP@@AAEHAAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_iter$ = 8						; size = 4
_obj$ = 8						; size = 4
?GetChannelIdByObserver@CNewPVP@@AAEHAAUOBJECTSTRUCT@@@Z PROC ; CNewPVP::GetChannelIdByObserver, COMDAT
; _this$ = ecx

; 676  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 677  : 	std::map<int, _tagObserverInfo>::iterator iter = m_ObserverInfoList.find(obj.m_Index);

  00003	8b 45 08	 mov	 eax, DWORD PTR _obj$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	50		 push	 eax
  0000a	8d 4d 08	 lea	 ecx, DWORD PTR _iter$[ebp]
  0000d	51		 push	 ecx
  0000e	8d 8e 24 01 00
	00		 lea	 ecx, DWORD PTR [esi+292]
  00014	e8 00 00 00 00	 call	 ?find@?$_Tree@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::find

; 678  : 	if(!(iter!=m_ObserverInfoList.end()))

  00019	8b 45 08	 mov	 eax, DWORD PTR _iter$[ebp]
  0001c	3b 86 28 01 00
	00		 cmp	 eax, DWORD PTR [esi+296]
  00022	5e		 pop	 esi

; 679  : 	{
; 680  : 		return -1;

  00023	74 33		 je	 SHORT $LN28@GetChannel@2

; 681  : 	}
; 682  : 
; 683  : 	_tagObserverInfo & info = iter->second;
; 684  : 
; 685  : 	if( info.nId < 0 || info.nId >= DUEL_CHANNEL_MAX)

  00025	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00028	85 c0		 test	 eax, eax
  0002a	78 05		 js	 SHORT $LN1@GetChannel@2
  0002c	83 f8 04	 cmp	 eax, 4

; 689  :     }
; 690  : 	return info.nId;

  0002f	7c 2a		 jl	 SHORT $LN4@GetChannel@2
$LN1@GetChannel@2:

; 686  :     {
; 687  : 		LogAddTD("%s\t%s\t%s\t%s\t%d","info.nId>=0 && info.nId<DUEL_CHANNEL_MAX","-1","NULL",__FILE__, __LINE__);

  00031	68 af 02 00 00	 push	 687			; 000002afH
  00036	68 00 00 00 00	 push	 OFFSET ??_C@_0L@IGELOCEA@NewPVP?4cpp?$AA@
  0003b	68 00 00 00 00	 push	 OFFSET ??_C@_04HIBGFPH@NULL?$AA@
  00040	68 00 00 00 00	 push	 OFFSET ??_C@_02PGHGPEOM@?91?$AA@
  00045	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@LJHODCKE@info?4nId?$DO?$DN0?5?$CG?$CG?5info?4nId?$DMDUEL_CHA@
  0004a	68 00 00 00 00	 push	 OFFSET ??_C@_0P@ENJPCMFP@?$CFs?7?$CFs?7?$CFs?7?$CFs?7?$CFd?$AA@
  0004f	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00055	83 c4 18	 add	 esp, 24			; 00000018H
$LN28@GetChannel@2:

; 688  : 		return -1;

  00058	83 c8 ff	 or	 eax, -1
$LN4@GetChannel@2:

; 691  : }

  0005b	5d		 pop	 ebp
  0005c	c2 04 00	 ret	 4
?GetChannelIdByObserver@CNewPVP@@AAEHAAUOBJECTSTRUCT@@@Z ENDP ; CNewPVP::GetChannelIdByObserver
_TEXT	ENDS
PUBLIC	?CheckUsersOnConnect@CNewPVP@@AAEHH@Z		; CNewPVP::CheckUsersOnConnect
; Function compile flags: /Ogtp
;	COMDAT ?CheckUsersOnConnect@CNewPVP@@AAEHH@Z
_TEXT	SEGMENT
_nId$ = 8						; size = 4
?CheckUsersOnConnect@CNewPVP@@AAEHH@Z PROC		; CNewPVP::CheckUsersOnConnect, COMDAT
; _this$ = ecx

; 695  : {  

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 696  : 	if(nId < 0 || nId >= DUEL_CHANNEL_MAX){ LogAddTD("%s\t%s\t%s\t%s\t%d","nId>=0 && nId<DUEL_CHANNEL_MAX","FALSE","NULL",__FILE__, __LINE__); return FALSE; }

  00003	8b 45 08	 mov	 eax, DWORD PTR _nId$[ebp]
  00006	53		 push	 ebx
  00007	8b d9		 mov	 ebx, ecx
  00009	83 f8 03	 cmp	 eax, 3
  0000c	0f 87 c5 00 00
	00		 ja	 $LN7@CheckUsers

; 697  : 	if( !IS_START(m_DuelChannel[nId].nStatus) ){ LogAddTD("%s\t%s\t%s\t%s\t%d","IS_START(m_DuelChannel[nId].nStatus)", "FALSE","NULL",__FILE__, __LINE__); return FALSE; }

  00012	6b c0 2c	 imul	 eax, 44			; 0000002cH
  00015	8a 8c 18 86 00
	00 00		 mov	 cl, BYTE PTR [eax+ebx+134]
  0001c	80 f9 02	 cmp	 cl, 2
  0001f	0f 82 84 00 00
	00		 jb	 $LN5@CheckUsers
  00025	80 f9 04	 cmp	 cl, 4
  00028	77 7f		 ja	 SHORT $LN5@CheckUsers

; 698  : 
; 699  : 	OBJECTSTRUCT & requester = gObj[m_DuelChannel[nId].nIndex1];

  0002a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00030	56		 push	 esi
  00031	8b 74 18 68	 mov	 esi, DWORD PTR [eax+ebx+104]
  00035	57		 push	 edi
  00036	69 f6 40 27 00
	00		 imul	 esi, 10048		; 00002740H

; 700  : 	OBJECTSTRUCT & responsor = gObj[m_DuelChannel[nId].nIndex2];

  0003c	8b 7c 18 6c	 mov	 edi, DWORD PTR [eax+ebx+108]

; 701  : 
; 702  : 	if( !gObjIsConnected(requester.m_Index) || !IsPKFieldMap( requester.MapNumber) ){ Leave(requester); return FALSE; }

  00040	8b 04 0e	 mov	 eax, DWORD PTR [esi+ecx]
  00043	69 ff 40 27 00
	00		 imul	 edi, 10048		; 00002740H
  00049	03 f1		 add	 esi, ecx
  0004b	50		 push	 eax
  0004c	03 f9		 add	 edi, ecx
  0004e	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00053	83 c4 04	 add	 esp, 4
  00056	85 c0		 test	 eax, eax
  00058	74 3e		 je	 SHORT $LN3@CheckUsers
  0005a	80 be 23 01 00
	00 40		 cmp	 BYTE PTR [esi+291], 64	; 00000040H
  00061	75 35		 jne	 SHORT $LN3@CheckUsers

; 703  : 	if( !gObjIsConnected(responsor.m_Index) || !IsPKFieldMap( responsor.MapNumber) ){ Leave(responsor); return FALSE; }

  00063	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00065	51		 push	 ecx
  00066	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  0006b	83 c4 04	 add	 esp, 4
  0006e	85 c0		 test	 eax, eax
  00070	74 15		 je	 SHORT $LN1@CheckUsers
  00072	80 bf 23 01 00
	00 40		 cmp	 BYTE PTR [edi+291], 64	; 00000040H
  00079	75 0c		 jne	 SHORT $LN1@CheckUsers

; 704  : 	return TRUE;

  0007b	5f		 pop	 edi
  0007c	5e		 pop	 esi
  0007d	b8 01 00 00 00	 mov	 eax, 1
  00082	5b		 pop	 ebx

; 705  : }

  00083	5d		 pop	 ebp
  00084	c2 04 00	 ret	 4
$LN1@CheckUsers:

; 703  : 	if( !gObjIsConnected(responsor.m_Index) || !IsPKFieldMap( responsor.MapNumber) ){ Leave(responsor); return FALSE; }

  00087	57		 push	 edi
  00088	8b cb		 mov	 ecx, ebx
  0008a	e8 00 00 00 00	 call	 ?Leave@CNewPVP@@QAEHAAUOBJECTSTRUCT@@@Z ; CNewPVP::Leave
  0008f	5f		 pop	 edi
  00090	5e		 pop	 esi
  00091	33 c0		 xor	 eax, eax
  00093	5b		 pop	 ebx

; 705  : }

  00094	5d		 pop	 ebp
  00095	c2 04 00	 ret	 4
$LN3@CheckUsers:

; 701  : 
; 702  : 	if( !gObjIsConnected(requester.m_Index) || !IsPKFieldMap( requester.MapNumber) ){ Leave(requester); return FALSE; }

  00098	56		 push	 esi

; 703  : 	if( !gObjIsConnected(responsor.m_Index) || !IsPKFieldMap( responsor.MapNumber) ){ Leave(responsor); return FALSE; }

  00099	8b cb		 mov	 ecx, ebx
  0009b	e8 00 00 00 00	 call	 ?Leave@CNewPVP@@QAEHAAUOBJECTSTRUCT@@@Z ; CNewPVP::Leave
  000a0	5f		 pop	 edi
  000a1	5e		 pop	 esi
  000a2	33 c0		 xor	 eax, eax
  000a4	5b		 pop	 ebx

; 705  : }

  000a5	5d		 pop	 ebp
  000a6	c2 04 00	 ret	 4
$LN5@CheckUsers:

; 697  : 	if( !IS_START(m_DuelChannel[nId].nStatus) ){ LogAddTD("%s\t%s\t%s\t%s\t%d","IS_START(m_DuelChannel[nId].nStatus)", "FALSE","NULL",__FILE__, __LINE__); return FALSE; }

  000a9	68 b9 02 00 00	 push	 697			; 000002b9H
  000ae	68 00 00 00 00	 push	 OFFSET ??_C@_0L@IGELOCEA@NewPVP?4cpp?$AA@
  000b3	68 00 00 00 00	 push	 OFFSET ??_C@_04HIBGFPH@NULL?$AA@
  000b8	68 00 00 00 00	 push	 OFFSET ??_C@_05MAJJAKPI@FALSE?$AA@
  000bd	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@CINMDLEF@IS_START?$CIm_DuelChannel?$FLnId?$FN?4nSta@
$LN18@CheckUsers:
  000c2	68 00 00 00 00	 push	 OFFSET ??_C@_0P@ENJPCMFP@?$CFs?7?$CFs?7?$CFs?7?$CFs?7?$CFd?$AA@
  000c7	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  000cd	83 c4 18	 add	 esp, 24			; 00000018H
  000d0	33 c0		 xor	 eax, eax
  000d2	5b		 pop	 ebx

; 705  : }

  000d3	5d		 pop	 ebp
  000d4	c2 04 00	 ret	 4
$LN7@CheckUsers:

; 696  : 	if(nId < 0 || nId >= DUEL_CHANNEL_MAX){ LogAddTD("%s\t%s\t%s\t%s\t%d","nId>=0 && nId<DUEL_CHANNEL_MAX","FALSE","NULL",__FILE__, __LINE__); return FALSE; }

  000d7	68 b8 02 00 00	 push	 696			; 000002b8H
  000dc	68 00 00 00 00	 push	 OFFSET ??_C@_0L@IGELOCEA@NewPVP?4cpp?$AA@
  000e1	68 00 00 00 00	 push	 OFFSET ??_C@_04HIBGFPH@NULL?$AA@
  000e6	68 00 00 00 00	 push	 OFFSET ??_C@_05MAJJAKPI@FALSE?$AA@
  000eb	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@OMAPJGHA@nId?$DO?$DN0?5?$CG?$CG?5nId?$DMDUEL_CHANNEL_MAX?$AA@
  000f0	eb d0		 jmp	 SHORT $LN18@CheckUsers
?CheckUsersOnConnect@CNewPVP@@AAEHH@Z ENDP		; CNewPVP::CheckUsersOnConnect
_TEXT	ENDS
PUBLIC	??_C@_0CE@IELDJHDH@m_DuelChannel?$FLnId?$FN?4nStatus?$CB?$DNDC_I@ ; `string'
PUBLIC	?ChatMsgSend@CNewPVP@@QAEXAAUOBJECTSTRUCT@@PAEH@Z ; CNewPVP::ChatMsgSend
;	COMDAT ??_C@_0CE@IELDJHDH@m_DuelChannel?$FLnId?$FN?4nStatus?$CB?$DNDC_I@
; File c:\muserver_dev\development\mu-s8ep2-repack\gameserver\source\newpvp.h
CONST	SEGMENT
??_C@_0CE@IELDJHDH@m_DuelChannel?$FLnId?$FN?4nStatus?$CB?$DNDC_I@ DB 'm_D'
	DB	'uelChannel[nId].nStatus!=DC_IDLE', 00H	; `string'
; Function compile flags: /Ogtp
; File c:\muserver_dev\development\mu-s8ep2-repack\gameserver\source\newpvp.cpp
CONST	ENDS
;	COMDAT ?ChatMsgSend@CNewPVP@@QAEXAAUOBJECTSTRUCT@@PAEH@Z
_TEXT	SEGMENT
_nId$ = 8						; size = 4
_obj$ = 8						; size = 4
_Msg$ = 12						; size = 4
_size$ = 16						; size = 4
?ChatMsgSend@CNewPVP@@QAEXAAUOBJECTSTRUCT@@PAEH@Z PROC	; CNewPVP::ChatMsgSend, COMDAT
; _this$ = ecx

; 709  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi

; 710  : 	int nId = -1;
; 711  : 	if( IsDuel(obj) == TRUE ){

  00005	8b 75 08	 mov	 esi, DWORD PTR _obj$[ebp]
  00008	8b 86 50 12 00
	00		 mov	 eax, DWORD PTR [esi+4688]
  0000e	8b d9		 mov	 ebx, ecx
  00010	85 c0		 test	 eax, eax
  00012	78 1b		 js	 SHORT $LN7@ChatMsgSen
  00014	33 c9		 xor	 ecx, ecx
  00016	3d eb 2c 00 00	 cmp	 eax, 11499		; 00002cebH
  0001b	0f 9e c1	 setle	 cl
  0001e	83 f9 01	 cmp	 ecx, 1
  00021	75 0c		 jne	 SHORT $LN7@ChatMsgSen

; 712  : 		nId = GetDuelChannelId(obj.m_Index);

  00023	8b 16		 mov	 edx, DWORD PTR [esi]
  00025	52		 push	 edx
  00026	8b cb		 mov	 ecx, ebx
  00028	e8 00 00 00 00	 call	 ?GetDuelChannelId@CNewPVP@@AAEHH@Z ; CNewPVP::GetDuelChannelId
  0002d	eb 08		 jmp	 SHORT $LN15@ChatMsgSen
$LN7@ChatMsgSen:

; 713  : 	}
; 714  : 	else nId = GetChannelIdByObserver(obj);

  0002f	56		 push	 esi
  00030	8b cb		 mov	 ecx, ebx
  00032	e8 00 00 00 00	 call	 ?GetChannelIdByObserver@CNewPVP@@AAEHAAUOBJECTSTRUCT@@@Z ; CNewPVP::GetChannelIdByObserver
$LN15@ChatMsgSen:
  00037	89 45 08	 mov	 DWORD PTR _nId$[ebp], eax

; 715  : 	if(nId < 0 || nId >= DUEL_CHANNEL_MAX){ LogAddTD("%s\t%s\t%s\t%s\t%d","nId>=0 && nId<DUEL_CHANNEL_MAX","0","NULL",__FILE__, __LINE__); return; }

  0003a	83 f8 03	 cmp	 eax, 3
  0003d	0f 87 b3 00 00
	00		 ja	 $LN4@ChatMsgSen

; 716  : 	if(m_DuelChannel[nId].nStatus == DC_IDLE){ LogAddTD("%s\t%s\t%s\t%s\t%d","m_DuelChannel[nId].nStatus!=DC_IDLE","0","NULL",__FILE__, __LINE__); return; }

  00043	6b c0 2c	 imul	 eax, 44			; 0000002cH
  00046	80 bc 18 86 00
	00 00 00	 cmp	 BYTE PTR [eax+ebx+134], 0
  0004e	75 2d		 jne	 SHORT $LN3@ChatMsgSen
  00050	68 cc 02 00 00	 push	 716			; 000002ccH
  00055	68 00 00 00 00	 push	 OFFSET ??_C@_0L@IGELOCEA@NewPVP?4cpp?$AA@
  0005a	68 00 00 00 00	 push	 OFFSET ??_C@_04HIBGFPH@NULL?$AA@
  0005f	68 00 00 00 00	 push	 OFFSET ??_C@_01GBGANLPD@0?$AA@
  00064	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@IELDJHDH@m_DuelChannel?$FLnId?$FN?4nStatus?$CB?$DNDC_I@
  00069	68 00 00 00 00	 push	 OFFSET ??_C@_0P@ENJPCMFP@?$CFs?7?$CFs?7?$CFs?7?$CFs?7?$CFd?$AA@
  0006e	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00074	83 c4 18	 add	 esp, 24			; 00000018H
  00077	5e		 pop	 esi
  00078	5b		 pop	 ebx

; 727  : }

  00079	5d		 pop	 ebp
  0007a	c2 0c 00	 ret	 12			; 0000000cH
$LN3@ChatMsgSen:

; 717  : 
; 718  : 	LPDUEL_CHANNEL lpChannel = &m_DuelChannel[nId];
; 719  : 
; 720  : 	OBJECTSTRUCT& requester = gObj[lpChannel->nIndex1];

  0007d	8b 74 18 68	 mov	 esi, DWORD PTR [eax+ebx+104]
  00081	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00087	69 f6 40 27 00
	00		 imul	 esi, 10048		; 00002740H
  0008d	57		 push	 edi

; 721  :     OBJECTSTRUCT& responsor = gObj[lpChannel->nIndex2];

  0008e	8b 7c 18 6c	 mov	 edi, DWORD PTR [eax+ebx+108]
  00092	69 ff 40 27 00
	00		 imul	 edi, 10048		; 00002740H
  00098	03 f1		 add	 esi, ecx

; 722  : 
; 723  : 	if(gObjIsConnected(&requester))	DataSend(requester.m_Index, Msg, size);

  0009a	56		 push	 esi
  0009b	03 f9		 add	 edi, ecx
  0009d	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHPAUOBJECTSTRUCT@@@Z ; gObjIsConnected
  000a2	83 c4 04	 add	 esp, 4
  000a5	85 c0		 test	 eax, eax
  000a7	74 13		 je	 SHORT $LN2@ChatMsgSen
  000a9	8b 45 10	 mov	 eax, DWORD PTR _size$[ebp]
  000ac	8b 4d 0c	 mov	 ecx, DWORD PTR _Msg$[ebp]
  000af	8b 16		 mov	 edx, DWORD PTR [esi]
  000b1	50		 push	 eax
  000b2	51		 push	 ecx
  000b3	52		 push	 edx
  000b4	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  000b9	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@ChatMsgSen:

; 724  : 	if(gObjIsConnected(&responsor))	DataSend(responsor.m_Index, Msg, size);

  000bc	57		 push	 edi
  000bd	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHPAUOBJECTSTRUCT@@@Z ; gObjIsConnected
  000c2	83 c4 04	 add	 esp, 4
  000c5	85 c0		 test	 eax, eax
  000c7	74 13		 je	 SHORT $LN14@ChatMsgSen
  000c9	8b 45 10	 mov	 eax, DWORD PTR _size$[ebp]
  000cc	8b 4d 0c	 mov	 ecx, DWORD PTR _Msg$[ebp]
  000cf	8b 17		 mov	 edx, DWORD PTR [edi]
  000d1	50		 push	 eax
  000d2	51		 push	 ecx
  000d3	52		 push	 edx
  000d4	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  000d9	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN14@ChatMsgSen:

; 725  : 
; 726  : 	BroadcastToObserver(nId, Msg, size);

  000dc	8b 45 10	 mov	 eax, DWORD PTR _size$[ebp]
  000df	8b 4d 0c	 mov	 ecx, DWORD PTR _Msg$[ebp]
  000e2	8b 55 08	 mov	 edx, DWORD PTR _nId$[ebp]
  000e5	50		 push	 eax
  000e6	51		 push	 ecx
  000e7	52		 push	 edx
  000e8	8b cb		 mov	 ecx, ebx
  000ea	e8 00 00 00 00	 call	 ?BroadcastToObserver@CNewPVP@@AAEXHPAEH@Z ; CNewPVP::BroadcastToObserver
  000ef	5f		 pop	 edi
  000f0	5e		 pop	 esi
  000f1	5b		 pop	 ebx

; 727  : }

  000f2	5d		 pop	 ebp
  000f3	c2 0c 00	 ret	 12			; 0000000cH
$LN4@ChatMsgSen:

; 715  : 	if(nId < 0 || nId >= DUEL_CHANNEL_MAX){ LogAddTD("%s\t%s\t%s\t%s\t%d","nId>=0 && nId<DUEL_CHANNEL_MAX","0","NULL",__FILE__, __LINE__); return; }

  000f6	68 cb 02 00 00	 push	 715			; 000002cbH
  000fb	68 00 00 00 00	 push	 OFFSET ??_C@_0L@IGELOCEA@NewPVP?4cpp?$AA@
  00100	68 00 00 00 00	 push	 OFFSET ??_C@_04HIBGFPH@NULL?$AA@
  00105	68 00 00 00 00	 push	 OFFSET ??_C@_01GBGANLPD@0?$AA@
  0010a	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@OMAPJGHA@nId?$DO?$DN0?5?$CG?$CG?5nId?$DMDUEL_CHANNEL_MAX?$AA@
  0010f	68 00 00 00 00	 push	 OFFSET ??_C@_0P@ENJPCMFP@?$CFs?7?$CFs?7?$CFs?7?$CFs?7?$CFd?$AA@
  00114	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0011a	83 c4 18	 add	 esp, 24			; 00000018H
  0011d	5e		 pop	 esi
  0011e	5b		 pop	 ebx

; 727  : }

  0011f	5d		 pop	 ebp
  00120	c2 0c 00	 ret	 12			; 0000000cH
?ChatMsgSend@CNewPVP@@QAEXAAUOBJECTSTRUCT@@PAEH@Z ENDP	; CNewPVP::ChatMsgSend
_TEXT	ENDS
PUBLIC	_this$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?BroadcastScore@CNewPVP@@AAEXHE@Z		; CNewPVP::BroadcastScore
; Function compile flags: /Ogtp
;	COMDAT ?BroadcastScore@CNewPVP@@AAEXHE@Z
_TEXT	SEGMENT
_this$GSCopy$ = -20					; size = 4
_res$ = -16						; size = 10
__$ArrayPad$ = -4					; size = 4
_nId$ = 8						; size = 4
_nFlag$ = 12						; size = 1
?BroadcastScore@CNewPVP@@AAEXHE@Z PROC			; CNewPVP::BroadcastScore, COMDAT
; _this$ = ecx

; 900  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	57		 push	 edi
  00011	8b 7d 08	 mov	 edi, DWORD PTR _nId$[ebp]

; 925  : 	{
; 926  :         BroadcastToObserver(nId, (LPBYTE)&res, res.h.size);

  00014	89 4d ec	 mov	 DWORD PTR _this$GSCopy$[ebp], ecx
  00017	83 ff 03	 cmp	 edi, 3
  0001a	0f 87 ea 00 00
	00		 ja	 $LN5@BroadcastS

; 902  : 	if( !IS_START(m_DuelChannel[nId].nStatus) ){ LogAddTD("%s\t%s\t%s\t%s\t%d","IS_START(m_DuelChannel[nId].nStatus)", "0","NULL",__FILE__, __LINE__); return; }

  00020	8b c7		 mov	 eax, edi
  00022	6b c0 2c	 imul	 eax, 44			; 0000002cH
  00025	03 c8		 add	 ecx, eax
  00027	8a 81 86 00 00
	00		 mov	 al, BYTE PTR [ecx+134]
  0002d	3c 02		 cmp	 al, 2
  0002f	0f 82 ba 00 00
	00		 jb	 $LN3@BroadcastS
  00035	3c 04		 cmp	 al, 4
  00037	0f 87 b2 00 00
	00		 ja	 $LN3@BroadcastS

; 903  : 
; 904  : 	OBJECTSTRUCT & requester = gObj[m_DuelChannel[nId].nIndex1];

  0003d	8b 41 68	 mov	 eax, DWORD PTR [ecx+104]
  00040	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00046	69 c0 40 27 00
	00		 imul	 eax, 10048		; 00002740H
  0004c	53		 push	 ebx
  0004d	56		 push	 esi

; 905  :     OBJECTSTRUCT & responsor = gObj[m_DuelChannel[nId].nIndex2];

  0004e	8b 71 6c	 mov	 esi, DWORD PTR [ecx+108]

; 906  : 
; 907  : 	PMSG_DUEL_SCORE_BROADCAST res = {0};

  00051	33 c9		 xor	 ecx, ecx
  00053	69 f6 40 27 00
	00		 imul	 esi, 10048		; 00002740H
  00059	89 4d f5	 mov	 DWORD PTR _res$[ebp+5], ecx
  0005c	89 4d f1	 mov	 DWORD PTR _res$[ebp+1], ecx
  0005f	03 c2		 add	 eax, edx
  00061	88 4d f9	 mov	 BYTE PTR _res$[ebp+9], cl

; 908  : 	res.h.c = PMHC_BYTE;
; 909  : 	res.h.headcode = 0xAA;

  00064	c7 45 f0 c1 0a
	aa 04		 mov	 DWORD PTR _res$[ebp], 78252737 ; 04aa0ac1H

; 910  : 	res.h.subcode = 0x04;
; 911  : 	res.h.size = sizeof(PMSG_DUEL_SCORE_BROADCAST);
; 912  : 	res.NumberH1 = HIBYTE(requester.m_Index);

  0006b	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]

; 913  :     res.NumberL1 = LOBYTE(requester.m_Index);
; 914  :     res.NumberH2 = HIBYTE(responsor.m_Index);
; 915  :     res.NumberL2 = LOBYTE(responsor.m_Index);
; 916  :     res.btDuelScore1 = requester.m_btDuelScore;
; 917  :     res.btDuelScore2 = responsor.m_btDuelScore;
; 918  :       
; 919  : 	if( (nFlag & 1) == 1 )

  0006f	8a 5d 0c	 mov	 bl, BYTE PTR _nFlag$[ebp]
  00072	03 f2		 add	 esi, edx
  00074	88 4d f4	 mov	 BYTE PTR _res$[ebp+4], cl
  00077	0f b6 10	 movzx	 edx, BYTE PTR [eax]
  0007a	88 55 f5	 mov	 BYTE PTR _res$[ebp+5], dl
  0007d	0f b6 4e 01	 movzx	 ecx, BYTE PTR [esi+1]
  00081	88 4d f6	 mov	 BYTE PTR _res$[ebp+6], cl
  00084	0f b6 16	 movzx	 edx, BYTE PTR [esi]
  00087	88 55 f7	 mov	 BYTE PTR _res$[ebp+7], dl
  0008a	0f b6 88 54 12
	00 00		 movzx	 ecx, BYTE PTR [eax+4692]
  00091	88 4d f8	 mov	 BYTE PTR _res$[ebp+8], cl
  00094	0f b6 96 54 12
	00 00		 movzx	 edx, BYTE PTR [esi+4692]
  0009b	88 55 f9	 mov	 BYTE PTR _res$[ebp+9], dl
  0009e	f6 c3 01	 test	 bl, 1
  000a1	74 22		 je	 SHORT $LN2@BroadcastS

; 920  :     {
; 921  : 		DataSend(requester.m_Index, (LPBYTE)&res, res.h.size);

  000a3	8b 10		 mov	 edx, DWORD PTR [eax]
  000a5	6a 0a		 push	 10			; 0000000aH
  000a7	8d 4d f0	 lea	 ecx, DWORD PTR _res$[ebp]
  000aa	51		 push	 ecx
  000ab	52		 push	 edx
  000ac	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 922  :         DataSend(responsor.m_Index, (LPBYTE)&res, res.h.size);

  000b1	0f b6 45 f1	 movzx	 eax, BYTE PTR _res$[ebp+1]
  000b5	8b 16		 mov	 edx, DWORD PTR [esi]
  000b7	50		 push	 eax
  000b8	8d 4d f0	 lea	 ecx, DWORD PTR _res$[ebp]
  000bb	51		 push	 ecx
  000bc	52		 push	 edx
  000bd	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  000c2	83 c4 18	 add	 esp, 24			; 00000018H
$LN2@BroadcastS:

; 923  :     }
; 924  : 	if( (nFlag & 2) == 2 )

  000c5	5e		 pop	 esi
  000c6	f6 c3 02	 test	 bl, 2
  000c9	5b		 pop	 ebx
  000ca	74 65		 je	 SHORT $LN1@BroadcastS

; 925  : 	{
; 926  :         BroadcastToObserver(nId, (LPBYTE)&res, res.h.size);

  000cc	0f b6 45 f1	 movzx	 eax, BYTE PTR _res$[ebp+1]
  000d0	50		 push	 eax
  000d1	8d 4d f0	 lea	 ecx, DWORD PTR _res$[ebp]
  000d4	51		 push	 ecx
  000d5	8b 4d ec	 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  000d8	57		 push	 edi
  000d9	e8 00 00 00 00	 call	 ?BroadcastToObserver@CNewPVP@@AAEXHPAEH@Z ; CNewPVP::BroadcastToObserver
  000de	5f		 pop	 edi

; 927  : 	}
; 928  : }

  000df	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000e2	33 cd		 xor	 ecx, ebp
  000e4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e9	8b e5		 mov	 esp, ebp
  000eb	5d		 pop	 ebp
  000ec	c2 08 00	 ret	 8
$LN3@BroadcastS:

; 902  : 	if( !IS_START(m_DuelChannel[nId].nStatus) ){ LogAddTD("%s\t%s\t%s\t%s\t%d","IS_START(m_DuelChannel[nId].nStatus)", "0","NULL",__FILE__, __LINE__); return; }

  000ef	68 86 03 00 00	 push	 902			; 00000386H
  000f4	68 00 00 00 00	 push	 OFFSET ??_C@_0L@IGELOCEA@NewPVP?4cpp?$AA@
  000f9	68 00 00 00 00	 push	 OFFSET ??_C@_04HIBGFPH@NULL?$AA@
  000fe	68 00 00 00 00	 push	 OFFSET ??_C@_01GBGANLPD@0?$AA@
  00103	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@CINMDLEF@IS_START?$CIm_DuelChannel?$FLnId?$FN?4nSta@
  00108	eb 19		 jmp	 SHORT $LN9@BroadcastS
$LN5@BroadcastS:

; 901  : 	if( nId < 0 || nId >= DUEL_CHANNEL_MAX ){ LogAddTD("%s\t%s\t%s\t%s\t%d","nId>=0 && nId<DUEL_CHANNEL_MAX","0","NULL",__FILE__, __LINE__); return; }

  0010a	68 85 03 00 00	 push	 901			; 00000385H
  0010f	68 00 00 00 00	 push	 OFFSET ??_C@_0L@IGELOCEA@NewPVP?4cpp?$AA@
  00114	68 00 00 00 00	 push	 OFFSET ??_C@_04HIBGFPH@NULL?$AA@
  00119	68 00 00 00 00	 push	 OFFSET ??_C@_01GBGANLPD@0?$AA@
  0011e	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@OMAPJGHA@nId?$DO?$DN0?5?$CG?$CG?5nId?$DMDUEL_CHANNEL_MAX?$AA@
$LN9@BroadcastS:
  00123	68 00 00 00 00	 push	 OFFSET ??_C@_0P@ENJPCMFP@?$CFs?7?$CFs?7?$CFs?7?$CFs?7?$CFd?$AA@
  00128	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0012e	83 c4 18	 add	 esp, 24			; 00000018H
$LN1@BroadcastS:

; 927  : 	}
; 928  : }

  00131	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00134	33 cd		 xor	 ecx, ebp
  00136	5f		 pop	 edi
  00137	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0013c	8b e5		 mov	 esp, ebp
  0013e	5d		 pop	 ebp
  0013f	c2 08 00	 ret	 8
?BroadcastScore@CNewPVP@@AAEXHE@Z ENDP			; CNewPVP::BroadcastScore
_TEXT	ENDS
PUBLIC	??_C@_0M@NHOMKAFP@IsDuel?$CIobj?$CJ?$AA@	; `string'
PUBLIC	??_C@_0BN@CEOLHPDN@gObjIsConnected?$CIobj?4m_Index?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0CL@FHCIJMFA@m_DuelChannel?$FLnId?$FN?4nStatus?$DN?$DNDC_R@ ; `string'
PUBLIC	_this$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?BroadcastResult@CNewPVP@@AAEXHEAAUOBJECTSTRUCT@@@Z ; CNewPVP::BroadcastResult
;	COMDAT ??_C@_0M@NHOMKAFP@IsDuel?$CIobj?$CJ?$AA@
CONST	SEGMENT
??_C@_0M@NHOMKAFP@IsDuel?$CIobj?$CJ?$AA@ DB 'IsDuel(obj)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@CEOLHPDN@gObjIsConnected?$CIobj?4m_Index?$CJ?$AA@
CONST	SEGMENT
??_C@_0BN@CEOLHPDN@gObjIsConnected?$CIobj?4m_Index?$CJ?$AA@ DB 'gObjIsCon'
	DB	'nected(obj.m_Index)', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@FHCIJMFA@m_DuelChannel?$FLnId?$FN?4nStatus?$DN?$DNDC_R@
CONST	SEGMENT
??_C@_0CL@FHCIJMFA@m_DuelChannel?$FLnId?$FN?4nStatus?$DN?$DNDC_R@ DB 'm_D'
	DB	'uelChannel[nId].nStatus==DC_RESERVEDEND', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?BroadcastResult@CNewPVP@@AAEXHEAAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_this$GSCopy$ = -32					; size = 4
_res$ = -28						; size = 24
__$ArrayPad$ = -4					; size = 4
_nId$ = 8						; size = 4
_nFlag$ = 12						; size = 1
_obj$ = 16						; size = 4
?BroadcastResult@CNewPVP@@AAEXHEAAUOBJECTSTRUCT@@@Z PROC ; CNewPVP::BroadcastResult, COMDAT
; _this$ = ecx

; 932  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 933  : 	if( nId < 0 || nId >= DUEL_CHANNEL_MAX ){ LogAddTD("%s\t%s\t%s\t%s\t%d","nId>=0 && nId<DUEL_CHANNEL_MAX","0","NULL",__FILE__, __LINE__); return; }

  00010	8b 45 08	 mov	 eax, DWORD PTR _nId$[ebp]
  00013	56		 push	 esi
  00014	8b f1		 mov	 esi, ecx
  00016	57		 push	 edi
  00017	8b 7d 10	 mov	 edi, DWORD PTR _obj$[ebp]

; 952  :     }
; 953  : 	if( (nFlag & 2) == 2 )

  0001a	89 75 e0	 mov	 DWORD PTR _this$GSCopy$[ebp], esi
  0001d	83 f8 03	 cmp	 eax, 3
  00020	0f 87 33 01 00
	00		 ja	 $LN6@BroadcastR@2

; 934  : 	if( m_DuelChannel[nId].nStatus != DC_RESERVEDEND ){ LogAddTD("%s\t%s\t%s\t%s\t%d","m_DuelChannel[nId].nStatus==DC_RESERVEDEND", "0","NULL",__FILE__, __LINE__); return;	}

  00026	6b c0 2c	 imul	 eax, 44			; 0000002cH
  00029	80 bc 30 86 00
	00 00 05	 cmp	 BYTE PTR [eax+esi+134], 5
  00031	74 1e		 je	 SHORT $LN5@BroadcastR@2
  00033	68 a6 03 00 00	 push	 934			; 000003a6H
  00038	68 00 00 00 00	 push	 OFFSET ??_C@_0L@IGELOCEA@NewPVP?4cpp?$AA@
  0003d	68 00 00 00 00	 push	 OFFSET ??_C@_04HIBGFPH@NULL?$AA@
  00042	68 00 00 00 00	 push	 OFFSET ??_C@_01GBGANLPD@0?$AA@
  00047	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@FHCIJMFA@m_DuelChannel?$FLnId?$FN?4nStatus?$DN?$DNDC_R@
  0004c	e9 21 01 00 00	 jmp	 $LN10@BroadcastR@2
$LN5@BroadcastR@2:

; 935  : 	if( !gObjIsConnected(obj.m_Index) ){ LogAddTD("%s\t%s\t%s\t%s\t%d","gObjIsConnected(obj.m_Index)", "0","NULL",__FILE__, __LINE__); return; }

  00051	8b 07		 mov	 eax, DWORD PTR [edi]
  00053	50		 push	 eax
  00054	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00059	83 c4 04	 add	 esp, 4
  0005c	85 c0		 test	 eax, eax
  0005e	75 1e		 jne	 SHORT $LN4@BroadcastR@2
  00060	68 a7 03 00 00	 push	 935			; 000003a7H
  00065	68 00 00 00 00	 push	 OFFSET ??_C@_0L@IGELOCEA@NewPVP?4cpp?$AA@
  0006a	68 00 00 00 00	 push	 OFFSET ??_C@_04HIBGFPH@NULL?$AA@
  0006f	68 00 00 00 00	 push	 OFFSET ??_C@_01GBGANLPD@0?$AA@
  00074	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@CEOLHPDN@gObjIsConnected?$CIobj?4m_Index?$CJ?$AA@
  00079	e9 f4 00 00 00	 jmp	 $LN10@BroadcastR@2
$LN4@BroadcastR@2:

; 936  : 	if( !IsDuel(obj) ){ LogAddTD("%s\t%s\t%s\t%s\t%d","IsDuel(obj)", "0","NULL",__FILE__, __LINE__); return; }

  0007e	57		 push	 edi
  0007f	8b ce		 mov	 ecx, esi
  00081	e8 00 00 00 00	 call	 ?IsDuel@CNewPVP@@QAEHAAUOBJECTSTRUCT@@@Z ; CNewPVP::IsDuel
  00086	85 c0		 test	 eax, eax
  00088	75 1e		 jne	 SHORT $LN3@BroadcastR@2
  0008a	68 a8 03 00 00	 push	 936			; 000003a8H
  0008f	68 00 00 00 00	 push	 OFFSET ??_C@_0L@IGELOCEA@NewPVP?4cpp?$AA@
  00094	68 00 00 00 00	 push	 OFFSET ??_C@_04HIBGFPH@NULL?$AA@
  00099	68 00 00 00 00	 push	 OFFSET ??_C@_01GBGANLPD@0?$AA@
  0009e	68 00 00 00 00	 push	 OFFSET ??_C@_0M@NHOMKAFP@IsDuel?$CIobj?$CJ?$AA@
  000a3	e9 ca 00 00 00	 jmp	 $LN10@BroadcastR@2
$LN3@BroadcastR@2:

; 937  : 
; 938  : 	OBJECTSTRUCT & targetObj = gObj[obj.m_iDuelUser];

  000a8	8b b7 50 12 00
	00		 mov	 esi, DWORD PTR [edi+4688]

; 939  :      
; 940  : 	PMSG_DUEL_RESULT_BROADCAST res = {0};
; 941  : 	res.h.c = PMHC_BYTE;
; 942  : 	res.h.headcode = 0xAA;
; 943  : 	res.h.subcode = 0x0C;
; 944  : 	res.h.size = sizeof(PMSG_DUEL_RESULT_BROADCAST);
; 945  : 	memcpy(res.szWinner, obj.Name, MAX_IDSTRING);

  000ae	8b 4f 5d	 mov	 ecx, DWORD PTR [edi+93]
  000b1	69 f6 40 27 00
	00		 imul	 esi, 10048		; 00002740H
  000b7	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  000bd	8b 57 61	 mov	 edx, DWORD PTR [edi+97]
  000c0	33 c0		 xor	 eax, eax
  000c2	89 45 e5	 mov	 DWORD PTR _res$[ebp+1], eax
  000c5	89 45 e9	 mov	 DWORD PTR _res$[ebp+5], eax
  000c8	89 45 ed	 mov	 DWORD PTR _res$[ebp+9], eax
  000cb	89 45 f1	 mov	 DWORD PTR _res$[ebp+13], eax
  000ce	89 45 f5	 mov	 DWORD PTR _res$[ebp+17], eax
  000d1	66 89 45 f9	 mov	 WORD PTR _res$[ebp+21], ax
  000d5	88 45 fb	 mov	 BYTE PTR _res$[ebp+23], al
  000d8	0f b7 47 65	 movzx	 eax, WORD PTR [edi+101]
  000dc	c7 45 e4 c1 18
	aa 0c		 mov	 DWORD PTR _res$[ebp], 212474049 ; 0caa18c1H
  000e3	89 4d e8	 mov	 DWORD PTR _res$[ebp+4], ecx
  000e6	89 55 ec	 mov	 DWORD PTR _res$[ebp+8], edx
  000e9	66 89 45 f0	 mov	 WORD PTR _res$[ebp+12], ax

; 946  : 	memcpy(res.szLoser, targetObj.Name, MAX_IDSTRING);

  000ed	8b 4e 5d	 mov	 ecx, DWORD PTR [esi+93]
  000f0	89 4d f2	 mov	 DWORD PTR _res$[ebp+14], ecx
  000f3	8b 56 61	 mov	 edx, DWORD PTR [esi+97]
  000f6	89 55 f6	 mov	 DWORD PTR _res$[ebp+18], edx
  000f9	0f b7 46 65	 movzx	 eax, WORD PTR [esi+101]
  000fd	53		 push	 ebx

; 947  : 	
; 948  : 	if( (nFlag & 1) == 1 )

  000fe	8a 5d 0c	 mov	 bl, BYTE PTR _nFlag$[ebp]
  00101	66 89 45 fa	 mov	 WORD PTR _res$[ebp+22], ax
  00105	f6 c3 01	 test	 bl, 1
  00108	74 22		 je	 SHORT $LN2@BroadcastR@2

; 949  : 	{
; 950  : 		DataSend(obj.m_Index, (LPBYTE)&res, res.h.size);

  0010a	8b 17		 mov	 edx, DWORD PTR [edi]
  0010c	6a 18		 push	 24			; 00000018H
  0010e	8d 4d e4	 lea	 ecx, DWORD PTR _res$[ebp]
  00111	51		 push	 ecx
  00112	52		 push	 edx
  00113	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 951  : 		DataSend(targetObj.m_Index, (LPBYTE)&res, res.h.size);

  00118	0f b6 45 e5	 movzx	 eax, BYTE PTR _res$[ebp+1]
  0011c	8b 16		 mov	 edx, DWORD PTR [esi]
  0011e	50		 push	 eax
  0011f	8d 4d e4	 lea	 ecx, DWORD PTR _res$[ebp]
  00122	51		 push	 ecx
  00123	52		 push	 edx
  00124	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00129	83 c4 18	 add	 esp, 24			; 00000018H
$LN2@BroadcastR@2:

; 952  :     }
; 953  : 	if( (nFlag & 2) == 2 )

  0012c	f6 c3 02	 test	 bl, 2
  0012f	5b		 pop	 ebx
  00130	74 4e		 je	 SHORT $LN1@BroadcastR@2

; 954  : 	{
; 955  : 		BroadcastToObserver(nId, (LPBYTE)&res,res.h.size);

  00132	0f b6 45 e5	 movzx	 eax, BYTE PTR _res$[ebp+1]
  00136	8b 55 08	 mov	 edx, DWORD PTR _nId$[ebp]
  00139	50		 push	 eax
  0013a	8d 4d e4	 lea	 ecx, DWORD PTR _res$[ebp]
  0013d	51		 push	 ecx
  0013e	8b 4d e0	 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  00141	52		 push	 edx
  00142	e8 00 00 00 00	 call	 ?BroadcastToObserver@CNewPVP@@AAEXHPAEH@Z ; CNewPVP::BroadcastToObserver
  00147	5f		 pop	 edi
  00148	5e		 pop	 esi

; 956  : 	}
; 957  : }

  00149	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0014c	33 cd		 xor	 ecx, ebp
  0014e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00153	8b e5		 mov	 esp, ebp
  00155	5d		 pop	 ebp
  00156	c2 0c 00	 ret	 12			; 0000000cH
$LN6@BroadcastR@2:

; 933  : 	if( nId < 0 || nId >= DUEL_CHANNEL_MAX ){ LogAddTD("%s\t%s\t%s\t%s\t%d","nId>=0 && nId<DUEL_CHANNEL_MAX","0","NULL",__FILE__, __LINE__); return; }

  00159	68 a5 03 00 00	 push	 933			; 000003a5H
  0015e	68 00 00 00 00	 push	 OFFSET ??_C@_0L@IGELOCEA@NewPVP?4cpp?$AA@
  00163	68 00 00 00 00	 push	 OFFSET ??_C@_04HIBGFPH@NULL?$AA@
  00168	68 00 00 00 00	 push	 OFFSET ??_C@_01GBGANLPD@0?$AA@
  0016d	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@OMAPJGHA@nId?$DO?$DN0?5?$CG?$CG?5nId?$DMDUEL_CHANNEL_MAX?$AA@
$LN10@BroadcastR@2:
  00172	68 00 00 00 00	 push	 OFFSET ??_C@_0P@ENJPCMFP@?$CFs?7?$CFs?7?$CFs?7?$CFs?7?$CFd?$AA@
  00177	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0017d	83 c4 18	 add	 esp, 24			; 00000018H
$LN1@BroadcastR@2:

; 956  : 	}
; 957  : }

  00180	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00183	5f		 pop	 edi
  00184	33 cd		 xor	 ecx, ebp
  00186	5e		 pop	 esi
  00187	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0018c	8b e5		 mov	 esp, ebp
  0018e	5d		 pop	 ebp
  0018f	c2 0c 00	 ret	 12			; 0000000cH
?BroadcastResult@CNewPVP@@AAEXHEAAUOBJECTSTRUCT@@@Z ENDP ; CNewPVP::BroadcastResult
_TEXT	ENDS
PUBLIC	__real@4059000000000000
PUBLIC	_nId$GSCopy$
PUBLIC	_this$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?BroadcastDuelInfo@CNewPVP@@AAEXHE@Z		; CNewPVP::BroadcastDuelInfo
;	COMDAT __real@4059000000000000
CONST	SEGMENT
__real@4059000000000000 DQ 04059000000000000r	; 100
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?BroadcastDuelInfo@CNewPVP@@AAEXHE@Z
_TEXT	SEGMENT
tv420 = -36						; size = 4
_nId$GSCopy$ = -32					; size = 4
_this$GSCopy$ = -28					; size = 4
_nLifePer2$ = -24					; size = 4
tv438 = -20						; size = 4
_ShieldPer1$ = -20					; size = 4
_res$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_nId$ = 8						; size = 4
_nFlag$ = 12						; size = 1
?BroadcastDuelInfo@CNewPVP@@AAEXHE@Z PROC		; CNewPVP::BroadcastDuelInfo, COMDAT
; _this$ = ecx

; 961  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 08	 mov	 eax, DWORD PTR _nId$[ebp]

; 991  : 	}
; 992  : 	
; 993  : 	nLifePer1 = (requester.Life / ((float)(requester.AddLife) + requester.MaxLife) * 100.0f);

  00013	89 4d e4	 mov	 DWORD PTR _this$GSCopy$[ebp], ecx
  00016	89 45 e0	 mov	 DWORD PTR _nId$GSCopy$[ebp], eax
  00019	83 f8 03	 cmp	 eax, 3
  0001c	0f 87 c2 01 00
	00		 ja	 $LN9@BroadcastD

; 963  : 	if( !IS_START(m_DuelChannel[nId].nStatus) ) return;

  00022	6b c0 2c	 imul	 eax, 44			; 0000002cH
  00025	03 c1		 add	 eax, ecx
  00027	8a 88 86 00 00
	00		 mov	 cl, BYTE PTR [eax+134]
  0002d	80 f9 02	 cmp	 cl, 2
  00030	0f 82 d5 01 00
	00		 jb	 $LN1@BroadcastD
  00036	80 f9 04	 cmp	 cl, 4
  00039	0f 87 cc 01 00
	00		 ja	 $LN1@BroadcastD

; 964  : 
; 965  : 	OBJECTSTRUCT & requester = gObj[m_DuelChannel[nId].nIndex1];

  0003f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00045	53		 push	 ebx
  00046	56		 push	 esi
  00047	8b 70 68	 mov	 esi, DWORD PTR [eax+104]
  0004a	69 f6 40 27 00
	00		 imul	 esi, 10048		; 00002740H

; 966  :     OBJECTSTRUCT & responsor = gObj[m_DuelChannel[nId].nIndex2];
; 967  : 	
; 968  : 	int nLifePer1 = 0;
; 969  :     int nLifePer2 = 0;
; 970  :     int ShieldPer1 = 0;
; 971  :     int ShieldPer2 = 0;
; 972  : 
; 973  : 	if(requester.AddLife +  requester.MaxLife <  requester.Life)

  00050	db 84 0e 24 01
	00 00		 fild	 DWORD PTR [esi+ecx+292]
  00057	d8 84 0e dc 00
	00 00		 fadd	 DWORD PTR [esi+ecx+220]
  0005e	d9 84 0e d8 00
	00 00		 fld	 DWORD PTR [esi+ecx+216]
  00065	d8 d9		 fcomp	 ST(1)
  00067	03 f1		 add	 esi, ecx
  00069	57		 push	 edi
  0006a	8b 78 6c	 mov	 edi, DWORD PTR [eax+108]
  0006d	69 ff 40 27 00
	00		 imul	 edi, 10048		; 00002740H
  00073	df e0		 fnstsw	 ax
  00075	03 f9		 add	 edi, ecx
  00077	f6 c4 41	 test	 ah, 65			; 00000041H
  0007a	75 08		 jne	 SHORT $LN14@BroadcastD

; 974  : 	{
; 975  : 		 requester.Life =  requester.AddLife +  requester.MaxLife;

  0007c	d9 9e d8 00 00
	00		 fstp	 DWORD PTR [esi+216]
  00082	eb 02		 jmp	 SHORT $LN6@BroadcastD
$LN14@BroadcastD:
  00084	dd d8		 fstp	 ST(0)
$LN6@BroadcastD:

; 976  : 	}
; 977  : 
; 978  : 	if(requester.iShield > requester.iMaxShield + requester.iAddShield)

  00086	8b 86 34 01 00
	00		 mov	 eax, DWORD PTR [esi+308]
  0008c	03 86 30 01 00
	00		 add	 eax, DWORD PTR [esi+304]
  00092	39 86 2c 01 00
	00		 cmp	 DWORD PTR [esi+300], eax
  00098	7e 06		 jle	 SHORT $LN5@BroadcastD

; 979  : 	{
; 980  : 		requester.iShield = requester.iMaxShield + requester.iAddShield;

  0009a	89 86 2c 01 00
	00		 mov	 DWORD PTR [esi+300], eax
$LN5@BroadcastD:

; 981  : 	}
; 982  : 
; 983  : 	if(responsor.AddLife +  responsor.MaxLife <  responsor.Life)

  000a0	db 87 24 01 00
	00		 fild	 DWORD PTR [edi+292]
  000a6	d8 87 dc 00 00
	00		 fadd	 DWORD PTR [edi+220]
  000ac	d9 87 d8 00 00
	00		 fld	 DWORD PTR [edi+216]
  000b2	d8 d9		 fcomp	 ST(1)
  000b4	df e0		 fnstsw	 ax
  000b6	f6 c4 41	 test	 ah, 65			; 00000041H
  000b9	75 06		 jne	 SHORT $LN4@BroadcastD

; 984  : 	{
; 985  : 		 responsor.Life =  responsor.AddLife +  responsor.MaxLife;

  000bb	d9 97 d8 00 00
	00		 fst	 DWORD PTR [edi+216]
$LN4@BroadcastD:

; 986  : 	}
; 987  : 
; 988  : 	if(responsor.iShield > responsor.iMaxShield + responsor.iAddShield)

  000c1	8b 87 30 01 00
	00		 mov	 eax, DWORD PTR [edi+304]
  000c7	03 87 34 01 00
	00		 add	 eax, DWORD PTR [edi+308]
  000cd	89 45 dc	 mov	 DWORD PTR tv420[ebp], eax
  000d0	39 87 2c 01 00
	00		 cmp	 DWORD PTR [edi+300], eax
  000d6	7e 06		 jle	 SHORT $LN3@BroadcastD

; 989  : 	{
; 990  : 		responsor.iShield = responsor.iMaxShield + responsor.iAddShield;

  000d8	89 87 2c 01 00
	00		 mov	 DWORD PTR [edi+300], eax
$LN3@BroadcastD:

; 991  : 	}
; 992  : 	
; 993  : 	nLifePer1 = (requester.Life / ((float)(requester.AddLife) + requester.MaxLife) * 100.0f);

  000de	d9 86 d8 00 00
	00		 fld	 DWORD PTR [esi+216]
  000e4	db 86 24 01 00
	00		 fild	 DWORD PTR [esi+292]
  000ea	d8 86 dc 00 00
	00		 fadd	 DWORD PTR [esi+220]
  000f0	de f9		 fdivp	 ST(1), ST(0)
  000f2	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@4059000000000000
  000f8	dc c9		 fmul	 ST(1), ST(0)
  000fa	d9 c9		 fxch	 ST(1)
  000fc	e8 00 00 00 00	 call	 __ftol2_sse

; 994  : 	nLifePer2 = (responsor.Life / ((float)(responsor.AddLife) + responsor.MaxLife) * 100.0f);

  00101	d9 87 d8 00 00
	00		 fld	 DWORD PTR [edi+216]
  00107	de f2		 fdivrp	 ST(2), ST(0)
  00109	8b d8		 mov	 ebx, eax
  0010b	dc c9		 fmul	 ST(1), ST(0)
  0010d	d9 c9		 fxch	 ST(1)
  0010f	e8 00 00 00 00	 call	 __ftol2_sse

; 995  : 	ShieldPer1 = ((float)(requester.iShield) / (float)((int)(requester.iMaxShield) + (int)(requester.iAddShield)) * 100.0f);

  00114	db 86 2c 01 00
	00		 fild	 DWORD PTR [esi+300]
  0011a	8b 8e 34 01 00
	00		 mov	 ecx, DWORD PTR [esi+308]
  00120	03 8e 30 01 00
	00		 add	 ecx, DWORD PTR [esi+304]
  00126	89 45 e8	 mov	 DWORD PTR _nLifePer2$[ebp], eax
  00129	89 4d ec	 mov	 DWORD PTR tv438[ebp], ecx
  0012c	da 75 ec	 fidiv	 DWORD PTR tv438[ebp]
  0012f	d8 c9		 fmul	 ST(0), ST(1)
  00131	e8 00 00 00 00	 call	 __ftol2_sse

; 996  : 	ShieldPer2 = ((float)(responsor.iShield) / (float)((int)(responsor.iMaxShield) + (int)(responsor.iAddShield)) * 100.0f);

  00136	db 87 2c 01 00
	00		 fild	 DWORD PTR [edi+300]
  0013c	89 45 ec	 mov	 DWORD PTR _ShieldPer1$[ebp], eax
  0013f	da 75 dc	 fidiv	 DWORD PTR tv420[ebp]
  00142	de c9		 fmulp	 ST(1), ST(0)
  00144	e8 00 00 00 00	 call	 __ftol2_sse

; 997  : 
; 998  : 	PMSG_DUEL_HP_BROADCAST res = {0};

  00149	33 c9		 xor	 ecx, ecx
  0014b	89 4d f5	 mov	 DWORD PTR _res$[ebp+5], ecx
  0014e	89 4d f1	 mov	 DWORD PTR _res$[ebp+1], ecx
  00151	66 89 4d f9	 mov	 WORD PTR _res$[ebp+9], cx
  00155	88 4d fb	 mov	 BYTE PTR _res$[ebp+11], cl

; 999  : 	res.h.c = PMHC_BYTE;
; 1000 : 	res.h.headcode = 0xAA;

  00158	c7 45 f0 c1 0c
	aa 05		 mov	 DWORD PTR _res$[ebp], 95030465 ; 05aa0cc1H

; 1001 : 	res.h.subcode = 0x05;
; 1002 : 	res.h.size = sizeof(PMSG_DUEL_HP_BROADCAST);
; 1003 : 	res.NumberH1 = HIBYTE(requester.m_Index);

  0015f	0f b6 56 01	 movzx	 edx, BYTE PTR [esi+1]
  00163	88 55 f4	 mov	 BYTE PTR _res$[ebp+4], dl

; 1004 :     res.NumberL1 = LOBYTE(requester.m_Index);

  00166	0f b6 0e	 movzx	 ecx, BYTE PTR [esi]
  00169	88 4d f5	 mov	 BYTE PTR _res$[ebp+5], cl

; 1005 : 	res.NumberH2 = HIBYTE(responsor.m_Index);

  0016c	0f b6 57 01	 movzx	 edx, BYTE PTR [edi+1]
  00170	88 55 f6	 mov	 BYTE PTR _res$[ebp+6], dl

; 1006 :     res.NumberL2 = LOBYTE(responsor.m_Index);

  00173	0f b6 0f	 movzx	 ecx, BYTE PTR [edi]

; 1007 : 	res.nHP1 = nLifePer1;
; 1008 : 	res.nHP2 = nLifePer2;

  00176	0f b6 55 e8	 movzx	 edx, BYTE PTR _nLifePer2$[ebp]
  0017a	88 4d f7	 mov	 BYTE PTR _res$[ebp+7], cl

; 1009 : 	res.nShield1 = ShieldPer1;

  0017d	0f b6 4d ec	 movzx	 ecx, BYTE PTR _ShieldPer1$[ebp]
  00181	88 5d f8	 mov	 BYTE PTR _res$[ebp+8], bl

; 1010 : 	res.nShield2 = ShieldPer2;
; 1011 : 	
; 1012 : 	if( (nFlag & 1) == 1 )

  00184	8a 5d 0c	 mov	 bl, BYTE PTR _nFlag$[ebp]
  00187	88 55 f9	 mov	 BYTE PTR _res$[ebp+9], dl
  0018a	88 4d fa	 mov	 BYTE PTR _res$[ebp+10], cl
  0018d	88 45 fb	 mov	 BYTE PTR _res$[ebp+11], al
  00190	f6 c3 01	 test	 bl, 1
  00193	74 22		 je	 SHORT $LN2@BroadcastD

; 1013 : 	{
; 1014 : 		DataSend(requester.m_Index, (LPBYTE)&res, res.h.size);

  00195	8b 06		 mov	 eax, DWORD PTR [esi]
  00197	6a 0c		 push	 12			; 0000000cH
  00199	8d 55 f0	 lea	 edx, DWORD PTR _res$[ebp]
  0019c	52		 push	 edx
  0019d	50		 push	 eax
  0019e	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 1015 : 		DataSend(responsor.m_Index, (LPBYTE)&res, res.h.size);

  001a3	0f b6 4d f1	 movzx	 ecx, BYTE PTR _res$[ebp+1]
  001a7	8b 07		 mov	 eax, DWORD PTR [edi]
  001a9	51		 push	 ecx
  001aa	8d 55 f0	 lea	 edx, DWORD PTR _res$[ebp]
  001ad	52		 push	 edx
  001ae	50		 push	 eax
  001af	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  001b4	83 c4 18	 add	 esp, 24			; 00000018H
$LN2@BroadcastD:

; 1016 : 	}
; 1017 : 	if( (nFlag & 2) == 2 )

  001b7	5f		 pop	 edi
  001b8	5e		 pop	 esi
  001b9	f6 c3 02	 test	 bl, 2
  001bc	5b		 pop	 ebx
  001bd	74 4c		 je	 SHORT $LN1@BroadcastD

; 1018 : 	{
; 1019 : 		BroadcastToObserver(nId, (LPBYTE)&res, res.h.size);

  001bf	0f b6 4d f1	 movzx	 ecx, BYTE PTR _res$[ebp+1]
  001c3	8b 45 e0	 mov	 eax, DWORD PTR _nId$GSCopy$[ebp]
  001c6	51		 push	 ecx
  001c7	8b 4d e4	 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  001ca	8d 55 f0	 lea	 edx, DWORD PTR _res$[ebp]
  001cd	52		 push	 edx
  001ce	50		 push	 eax
  001cf	e8 00 00 00 00	 call	 ?BroadcastToObserver@CNewPVP@@AAEXHPAEH@Z ; CNewPVP::BroadcastToObserver

; 1020 : 	}
; 1021 : }

  001d4	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001d7	33 cd		 xor	 ecx, ebp
  001d9	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001de	8b e5		 mov	 esp, ebp
  001e0	5d		 pop	 ebp
  001e1	c2 08 00	 ret	 8
$LN9@BroadcastD:

; 962  : 	if( nId < 0 || nId >= DUEL_CHANNEL_MAX ){ LogAddTD("%s\t%s\t%s\t%s\t%d","nId>=0 && nId<DUEL_CHANNEL_MAX","0","NULL",__FILE__, __LINE__); return; }

  001e4	68 c2 03 00 00	 push	 962			; 000003c2H
  001e9	68 00 00 00 00	 push	 OFFSET ??_C@_0L@IGELOCEA@NewPVP?4cpp?$AA@
  001ee	68 00 00 00 00	 push	 OFFSET ??_C@_04HIBGFPH@NULL?$AA@
  001f3	68 00 00 00 00	 push	 OFFSET ??_C@_01GBGANLPD@0?$AA@
  001f8	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@OMAPJGHA@nId?$DO?$DN0?5?$CG?$CG?5nId?$DMDUEL_CHANNEL_MAX?$AA@
  001fd	68 00 00 00 00	 push	 OFFSET ??_C@_0P@ENJPCMFP@?$CFs?7?$CFs?7?$CFs?7?$CFs?7?$CFd?$AA@
  00202	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00208	83 c4 18	 add	 esp, 24			; 00000018H
$LN1@BroadcastD:

; 1020 : 	}
; 1021 : }

  0020b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0020e	33 cd		 xor	 ecx, ebp
  00210	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00215	8b e5		 mov	 esp, ebp
  00217	5d		 pop	 ebp
  00218	c2 08 00	 ret	 8
?BroadcastDuelInfo@CNewPVP@@AAEXHE@Z ENDP		; CNewPVP::BroadcastDuelInfo
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?BroadcastJoinChannel@CNewPVP@@AAEXHAAUOBJECTSTRUCT@@@Z ; CNewPVP::BroadcastJoinChannel
; Function compile flags: /Ogtp
;	COMDAT ?BroadcastJoinChannel@CNewPVP@@AAEXHAAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_res$ = -20						; size = 14
__$ArrayPad$ = -4					; size = 4
_nId$ = 8						; size = 4
_obj$ = 12						; size = 4
?BroadcastJoinChannel@CNewPVP@@AAEXHAAUOBJECTSTRUCT@@@Z PROC ; CNewPVP::BroadcastJoinChannel, COMDAT
; _this$ = ecx

; 1025 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 55 0c	 mov	 edx, DWORD PTR _obj$[ebp]
  00013	56		 push	 esi

; 1026 : 	if( nId < 0 || nId >= DUEL_CHANNEL_MAX ){ LogAddTD("%s\t%s\t%s\t%s\t%d","nId>=0 && nId<DUEL_CHANNEL_MAX","0","NULL",__FILE__, __LINE__); return; }

  00014	8b 75 08	 mov	 esi, DWORD PTR _nId$[ebp]
  00017	83 fe 03	 cmp	 esi, 3
  0001a	77 75		 ja	 SHORT $LN3@BroadcastJ

; 1027 : 	if( !IS_START(m_DuelChannel[nId].nStatus) ){ LogAddTD("%s\t%s\t%s\t%s\t%d","IS_START(m_DuelChannel[nId].nStatus)","0","NULL",__FILE__, __LINE__); return; }

  0001c	8b c6		 mov	 eax, esi
  0001e	6b c0 2c	 imul	 eax, 44			; 0000002cH
  00021	8a 84 08 86 00
	00 00		 mov	 al, BYTE PTR [eax+ecx+134]
  00028	3c 02		 cmp	 al, 2
  0002a	72 4a		 jb	 SHORT $LN1@BroadcastJ
  0002c	3c 04		 cmp	 al, 4
  0002e	77 46		 ja	 SHORT $LN1@BroadcastJ

; 1028 : 
; 1029 : 	PMSG_DUEL_JOINCNANNEL_BROADCAST res = {0};

  00030	33 c0		 xor	 eax, eax
  00032	89 45 ed	 mov	 DWORD PTR _res$[ebp+1], eax
  00035	89 45 f1	 mov	 DWORD PTR _res$[ebp+5], eax
  00038	89 45 f5	 mov	 DWORD PTR _res$[ebp+9], eax
  0003b	88 45 f9	 mov	 BYTE PTR _res$[ebp+13], al

; 1030 : 	res.h.c = PMHC_BYTE;
; 1031 :     res.h.headcode = 0xAA;
; 1032 :     res.h.subcode = 0x08;
; 1033 : 	res.h.size = sizeof(PMSG_DUEL_JOINCNANNEL_BROADCAST);
; 1034 :     memcpy(res.szName, obj.Name, MAX_IDSTRING);

  0003e	8b 42 5d	 mov	 eax, DWORD PTR [edx+93]
  00041	89 45 f0	 mov	 DWORD PTR _res$[ebp+4], eax
  00044	8b 42 61	 mov	 eax, DWORD PTR [edx+97]
  00047	66 8b 52 65	 mov	 dx, WORD PTR [edx+101]
  0004b	89 45 f4	 mov	 DWORD PTR _res$[ebp+8], eax

; 1035 :     BroadcastToObserver(nId, (LPBYTE)&res, res.h.size);

  0004e	6a 0e		 push	 14			; 0000000eH
  00050	8d 45 ec	 lea	 eax, DWORD PTR _res$[ebp]
  00053	50		 push	 eax
  00054	56		 push	 esi
  00055	c7 45 ec c1 0e
	aa 08		 mov	 DWORD PTR _res$[ebp], 145362625 ; 08aa0ec1H
  0005c	66 89 55 f8	 mov	 WORD PTR _res$[ebp+12], dx
  00060	e8 00 00 00 00	 call	 ?BroadcastToObserver@CNewPVP@@AAEXHPAEH@Z ; CNewPVP::BroadcastToObserver
  00065	5e		 pop	 esi

; 1036 : }

  00066	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00069	33 cd		 xor	 ecx, ebp
  0006b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00070	8b e5		 mov	 esp, ebp
  00072	5d		 pop	 ebp
  00073	c2 08 00	 ret	 8
$LN1@BroadcastJ:

; 1027 : 	if( !IS_START(m_DuelChannel[nId].nStatus) ){ LogAddTD("%s\t%s\t%s\t%s\t%d","IS_START(m_DuelChannel[nId].nStatus)","0","NULL",__FILE__, __LINE__); return; }

  00076	68 03 04 00 00	 push	 1027			; 00000403H
  0007b	68 00 00 00 00	 push	 OFFSET ??_C@_0L@IGELOCEA@NewPVP?4cpp?$AA@
  00080	68 00 00 00 00	 push	 OFFSET ??_C@_04HIBGFPH@NULL?$AA@
  00085	68 00 00 00 00	 push	 OFFSET ??_C@_01GBGANLPD@0?$AA@
  0008a	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@CINMDLEF@IS_START?$CIm_DuelChannel?$FLnId?$FN?4nSta@
  0008f	eb 19		 jmp	 SHORT $LN7@BroadcastJ
$LN3@BroadcastJ:

; 1026 : 	if( nId < 0 || nId >= DUEL_CHANNEL_MAX ){ LogAddTD("%s\t%s\t%s\t%s\t%d","nId>=0 && nId<DUEL_CHANNEL_MAX","0","NULL",__FILE__, __LINE__); return; }

  00091	68 02 04 00 00	 push	 1026			; 00000402H
  00096	68 00 00 00 00	 push	 OFFSET ??_C@_0L@IGELOCEA@NewPVP?4cpp?$AA@
  0009b	68 00 00 00 00	 push	 OFFSET ??_C@_04HIBGFPH@NULL?$AA@
  000a0	68 00 00 00 00	 push	 OFFSET ??_C@_01GBGANLPD@0?$AA@
  000a5	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@OMAPJGHA@nId?$DO?$DN0?5?$CG?$CG?5nId?$DMDUEL_CHANNEL_MAX?$AA@
$LN7@BroadcastJ:
  000aa	68 00 00 00 00	 push	 OFFSET ??_C@_0P@ENJPCMFP@?$CFs?7?$CFs?7?$CFs?7?$CFs?7?$CFd?$AA@
  000af	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 1036 : }

  000b5	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000b8	83 c4 18	 add	 esp, 24			; 00000018H
  000bb	33 cd		 xor	 ecx, ebp
  000bd	5e		 pop	 esi
  000be	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000c3	8b e5		 mov	 esp, ebp
  000c5	5d		 pop	 ebp
  000c6	c2 08 00	 ret	 8
?BroadcastJoinChannel@CNewPVP@@AAEXHAAUOBJECTSTRUCT@@@Z ENDP ; CNewPVP::BroadcastJoinChannel
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?BroadcastLeaveChannel@CNewPVP@@AAEXHAAUOBJECTSTRUCT@@@Z ; CNewPVP::BroadcastLeaveChannel
; Function compile flags: /Ogtp
;	COMDAT ?BroadcastLeaveChannel@CNewPVP@@AAEXHAAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_res$ = -20						; size = 14
__$ArrayPad$ = -4					; size = 4
_nId$ = 8						; size = 4
_obj$ = 12						; size = 4
?BroadcastLeaveChannel@CNewPVP@@AAEXHAAUOBJECTSTRUCT@@@Z PROC ; CNewPVP::BroadcastLeaveChannel, COMDAT
; _this$ = ecx

; 1040 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 55 0c	 mov	 edx, DWORD PTR _obj$[ebp]
  00013	56		 push	 esi

; 1041 : 	if( nId < 0 || nId >= DUEL_CHANNEL_MAX ){ LogAddTD("%s\t%s\t%s\t%s\t%d","nId>=0 && nId<DUEL_CHANNEL_MAX","0","NULL",__FILE__, __LINE__); return; }

  00014	8b 75 08	 mov	 esi, DWORD PTR _nId$[ebp]
  00017	83 fe 03	 cmp	 esi, 3
  0001a	77 75		 ja	 SHORT $LN3@BroadcastL

; 1042 : 	if( !IS_START(m_DuelChannel[nId].nStatus) ){ LogAddTD("%s\t%s\t%s\t%s\t%d","IS_START(m_DuelChannel[nId].nStatus)","0","NULL",__FILE__, __LINE__); return; }

  0001c	8b c6		 mov	 eax, esi
  0001e	6b c0 2c	 imul	 eax, 44			; 0000002cH
  00021	8a 84 08 86 00
	00 00		 mov	 al, BYTE PTR [eax+ecx+134]
  00028	3c 02		 cmp	 al, 2
  0002a	72 4a		 jb	 SHORT $LN1@BroadcastL
  0002c	3c 04		 cmp	 al, 4
  0002e	77 46		 ja	 SHORT $LN1@BroadcastL

; 1043 : 
; 1044 : 	PMSG_DUEL_LEAVECNANNEL_BROADCAST res = {0};

  00030	33 c0		 xor	 eax, eax
  00032	89 45 ed	 mov	 DWORD PTR _res$[ebp+1], eax
  00035	89 45 f1	 mov	 DWORD PTR _res$[ebp+5], eax
  00038	89 45 f5	 mov	 DWORD PTR _res$[ebp+9], eax
  0003b	88 45 f9	 mov	 BYTE PTR _res$[ebp+13], al

; 1045 : 	res.h.c = PMHC_BYTE;
; 1046 :     res.h.headcode = 0xAA;
; 1047 :     res.h.subcode = 0x0A;
; 1048 : 	res.h.size = sizeof(PMSG_DUEL_LEAVECNANNEL_BROADCAST);
; 1049 :     memcpy(res.szName, obj.Name, MAX_IDSTRING);

  0003e	8b 42 5d	 mov	 eax, DWORD PTR [edx+93]
  00041	89 45 f0	 mov	 DWORD PTR _res$[ebp+4], eax
  00044	8b 42 61	 mov	 eax, DWORD PTR [edx+97]
  00047	66 8b 52 65	 mov	 dx, WORD PTR [edx+101]
  0004b	89 45 f4	 mov	 DWORD PTR _res$[ebp+8], eax

; 1050 :     BroadcastToObserver(nId, (LPBYTE)&res,res.h.size);

  0004e	6a 0e		 push	 14			; 0000000eH
  00050	8d 45 ec	 lea	 eax, DWORD PTR _res$[ebp]
  00053	50		 push	 eax
  00054	56		 push	 esi
  00055	c7 45 ec c1 0e
	aa 0a		 mov	 DWORD PTR _res$[ebp], 178917057 ; 0aaa0ec1H
  0005c	66 89 55 f8	 mov	 WORD PTR _res$[ebp+12], dx
  00060	e8 00 00 00 00	 call	 ?BroadcastToObserver@CNewPVP@@AAEXHPAEH@Z ; CNewPVP::BroadcastToObserver
  00065	5e		 pop	 esi

; 1051 : }

  00066	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00069	33 cd		 xor	 ecx, ebp
  0006b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00070	8b e5		 mov	 esp, ebp
  00072	5d		 pop	 ebp
  00073	c2 08 00	 ret	 8
$LN1@BroadcastL:

; 1042 : 	if( !IS_START(m_DuelChannel[nId].nStatus) ){ LogAddTD("%s\t%s\t%s\t%s\t%d","IS_START(m_DuelChannel[nId].nStatus)","0","NULL",__FILE__, __LINE__); return; }

  00076	68 12 04 00 00	 push	 1042			; 00000412H
  0007b	68 00 00 00 00	 push	 OFFSET ??_C@_0L@IGELOCEA@NewPVP?4cpp?$AA@
  00080	68 00 00 00 00	 push	 OFFSET ??_C@_04HIBGFPH@NULL?$AA@
  00085	68 00 00 00 00	 push	 OFFSET ??_C@_01GBGANLPD@0?$AA@
  0008a	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@CINMDLEF@IS_START?$CIm_DuelChannel?$FLnId?$FN?4nSta@
  0008f	eb 19		 jmp	 SHORT $LN7@BroadcastL
$LN3@BroadcastL:

; 1041 : 	if( nId < 0 || nId >= DUEL_CHANNEL_MAX ){ LogAddTD("%s\t%s\t%s\t%s\t%d","nId>=0 && nId<DUEL_CHANNEL_MAX","0","NULL",__FILE__, __LINE__); return; }

  00091	68 11 04 00 00	 push	 1041			; 00000411H
  00096	68 00 00 00 00	 push	 OFFSET ??_C@_0L@IGELOCEA@NewPVP?4cpp?$AA@
  0009b	68 00 00 00 00	 push	 OFFSET ??_C@_04HIBGFPH@NULL?$AA@
  000a0	68 00 00 00 00	 push	 OFFSET ??_C@_01GBGANLPD@0?$AA@
  000a5	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@OMAPJGHA@nId?$DO?$DN0?5?$CG?$CG?5nId?$DMDUEL_CHANNEL_MAX?$AA@
$LN7@BroadcastL:
  000aa	68 00 00 00 00	 push	 OFFSET ??_C@_0P@ENJPCMFP@?$CFs?7?$CFs?7?$CFs?7?$CFs?7?$CFd?$AA@
  000af	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 1051 : }

  000b5	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000b8	83 c4 18	 add	 esp, 24			; 00000018H
  000bb	33 cd		 xor	 ecx, ebp
  000bd	5e		 pop	 esi
  000be	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000c3	8b e5		 mov	 esp, ebp
  000c5	5d		 pop	 ebp
  000c6	c2 08 00	 ret	 8
?BroadcastLeaveChannel@CNewPVP@@AAEXHAAUOBJECTSTRUCT@@@Z ENDP ; CNewPVP::BroadcastLeaveChannel
_TEXT	ENDS
PUBLIC	??_C@_0DE@MJGAINFG@?$FLDuel?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Requested?5to?5Sta@ ; `string'
PUBLIC	??_C@_0BD@DBIFHAEB@error?5?3?5?$CFs?5?$CFd?5?$CI?$CFd?$CJ?$AA@ ; `string'
PUBLIC	?OnCGInviteDuel@@YAHPAU_tagPMSG_REQ_DUEL_INVITE@@H@Z ; OnCGInviteDuel
EXTRN	?IsDuelEnable@@YA_NH@Z:PROC			; IsDuelEnable
EXTRN	?LogAdd@@3P6AXPADZZA:DWORD			; LogAdd
EXTRN	?gNonPK@@3HA:DWORD				; gNonPK
EXTRN	?PacketCheckTime@@YAHPAUOBJECTSTRUCT@@@Z:PROC	; PacketCheckTime
;	COMDAT ??_C@_0DE@MJGAINFG@?$FLDuel?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Requested?5to?5Sta@
CONST	SEGMENT
??_C@_0DE@MJGAINFG@?$FLDuel?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Requested?5to?5Sta@ DB '['
	DB	'Duel] [%s][%s] Requested to Start Duel to [%s][%s]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@DBIFHAEB@error?5?3?5?$CFs?5?$CFd?5?$CI?$CFd?$CJ?$AA@
CONST	SEGMENT
??_C@_0BD@DBIFHAEB@error?5?3?5?$CFs?5?$CFd?5?$CI?$CFd?$CJ?$AA@ DB 'error '
	DB	': %s %d (%d)', 00H				; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?OnCGInviteDuel@@YAHPAU_tagPMSG_REQ_DUEL_INVITE@@H@Z
_TEXT	SEGMENT
_szDuelName$ = -24					; size = 11
_szDuelName2$ = -12					; size = 11
_lpRequester$ = 8					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?OnCGInviteDuel@@YAHPAU_tagPMSG_REQ_DUEL_INVITE@@H@Z PROC ; OnCGInviteDuel, COMDAT

; 1204 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H

; 1205 : 	int nResponsor = MAKEWORD(lpMsg->NumberL, lpMsg->NumberH);
; 1206 : 	
; 1207 : 	LPOBJ lpRequester = (LPOBJ)&gObj[aIndex];

  00006	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0000c	53		 push	 ebx
  0000d	8b 5d 0c	 mov	 ebx, DWORD PTR _aIndex$[ebp]
  00010	56		 push	 esi
  00011	69 db 40 27 00
	00		 imul	 ebx, 10048		; 00002740H
  00017	57		 push	 edi
  00018	8b 7d 08	 mov	 edi, DWORD PTR _lpMsg$[ebp]
  0001b	0f b6 47 04	 movzx	 eax, BYTE PTR [edi+4]
  0001f	0f b6 4f 05	 movzx	 ecx, BYTE PTR [edi+5]
  00023	66 c1 e0 08	 shl	 ax, 8
  00027	0f b7 f0	 movzx	 esi, ax
  0002a	8d 04 13	 lea	 eax, DWORD PTR [ebx+edx]

; 1208 : 
; 1209 : 	if( !PacketCheckTime(lpRequester) ) return ENEWPVP::E_LIMIT_PACKETTIME;

  0002d	50		 push	 eax
  0002e	0b f1		 or	 esi, ecx
  00030	89 45 08	 mov	 DWORD PTR _lpRequester$[ebp], eax
  00033	e8 00 00 00 00	 call	 ?PacketCheckTime@@YAHPAUOBJECTSTRUCT@@@Z ; PacketCheckTime
  00038	83 c4 04	 add	 esp, 4
  0003b	85 c0		 test	 eax, eax
  0003d	75 0c		 jne	 SHORT $LN29@OnCGInvite
  0003f	5f		 pop	 edi
  00040	5e		 pop	 esi
  00041	b8 09 00 00 00	 mov	 eax, 9
  00046	5b		 pop	 ebx

; 1321 : }

  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c3		 ret	 0
$LN29@OnCGInvite:

; 1210 : 	if( nResponsor == aIndex )			return ENEWPVP::E_INVITE_MYSELF;

  0004b	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0004e	3b f0		 cmp	 esi, eax
  00050	75 0c		 jne	 SHORT $LN28@OnCGInvite
  00052	5f		 pop	 edi
  00053	5e		 pop	 esi
  00054	b8 0a 00 00 00	 mov	 eax, 10			; 0000000aH
  00059	5b		 pop	 ebx

; 1321 : }

  0005a	8b e5		 mov	 esp, ebp
  0005c	5d		 pop	 ebp
  0005d	c3		 ret	 0
$LN28@OnCGInvite:

; 1211 : 	if( gNonPK )

  0005e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?gNonPK@@3HA, 0 ; gNonPK
  00065	74 27		 je	 SHORT $LN27@OnCGInvite

; 1212 : 	{
; 1213 : 		GCServerMsgStringSend(lMsg.Get(1198), aIndex, 1);

  00067	6a 01		 push	 1
  00069	50		 push	 eax
  0006a	68 ae 04 00 00	 push	 1198			; 000004aeH
  0006f	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  00074	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  00079	50		 push	 eax
  0007a	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend

; 1263 : 	{
; 1264 : 		GCServerMsgStringSend(lMsg.Get(1213), aIndex, 1);

  0007f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00082	5f		 pop	 edi
  00083	5e		 pop	 esi
  00084	b8 03 00 00 00	 mov	 eax, 3
  00089	5b		 pop	 ebx

; 1321 : }

  0008a	8b e5		 mov	 esp, ebp
  0008c	5d		 pop	 ebp
  0008d	c3		 ret	 0
$LN27@OnCGInvite:

; 1214 : 		return ENEWPVP::E_NON_PKSERVER;
; 1215 : 	}
; 1216 : 	if( gObj[aIndex].CloseType != -1 )	return ENEWPVP::E_CONNECTION_CLOSING;

  0008e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00093	80 7c 03 0d ff	 cmp	 BYTE PTR [ebx+eax+13], -1
  00098	74 0c		 je	 SHORT $LN26@OnCGInvite
  0009a	5f		 pop	 edi
  0009b	5e		 pop	 esi
  0009c	b8 05 00 00 00	 mov	 eax, 5
  000a1	5b		 pop	 ebx

; 1321 : }

  000a2	8b e5		 mov	 esp, ebp
  000a4	5d		 pop	 ebp
  000a5	c3		 ret	 0
$LN26@OnCGInvite:

; 1217 : 	if( g_NewPVP.CheckPKPenalty(lpRequester) )

  000a6	8b 4d 08	 mov	 ecx, DWORD PTR _lpRequester$[ebp]
  000a9	51		 push	 ecx
  000aa	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_NewPVP@@3VCNewPVP@@A ; g_NewPVP
  000af	e8 00 00 00 00	 call	 ?CheckPKPenalty@CNewPVP@@QAEHPAUOBJECTSTRUCT@@@Z ; CNewPVP::CheckPKPenalty
  000b4	85 c0		 test	 eax, eax
  000b6	74 2a		 je	 SHORT $LN25@OnCGInvite

; 1218 : 	{
; 1219 : 		GCServerMsgStringSend(lMsg.Get(1199), aIndex, 1);

  000b8	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  000bb	6a 01		 push	 1
  000bd	52		 push	 edx
  000be	68 af 04 00 00	 push	 1199			; 000004afH
$LN63@OnCGInvite:
  000c3	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  000c8	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  000cd	50		 push	 eax
  000ce	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend

; 1263 : 	{
; 1264 : 		GCServerMsgStringSend(lMsg.Get(1213), aIndex, 1);

  000d3	83 c4 0c	 add	 esp, 12			; 0000000cH
  000d6	5f		 pop	 edi
  000d7	5e		 pop	 esi
  000d8	b8 06 00 00 00	 mov	 eax, 6
  000dd	5b		 pop	 ebx

; 1321 : }

  000de	8b e5		 mov	 esp, ebp
  000e0	5d		 pop	 ebp
  000e1	c3		 ret	 0
$LN25@OnCGInvite:

; 1220 : 		return ENEWPVP::E_NOT_DUEL_MURDERER;
; 1221 : 	}
; 1222 : 	if( !gObjIsConnected(nResponsor) )

  000e2	56		 push	 esi
  000e3	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  000e8	83 c4 04	 add	 esp, 4
  000eb	85 c0		 test	 eax, eax
  000ed	75 19		 jne	 SHORT $LN24@OnCGInvite

; 1223 : 	{
; 1224 : 		LogAdd("error : %s %d (%d)", __FILE__, __LINE__, nResponsor);

  000ef	56		 push	 esi
  000f0	68 c8 04 00 00	 push	 1224			; 000004c8H
  000f5	68 00 00 00 00	 push	 OFFSET ??_C@_0L@IGELOCEA@NewPVP?4cpp?$AA@
  000fa	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@DBIFHAEB@error?5?3?5?$CFs?5?$CFd?5?$CI?$CFd?$CJ?$AA@
  000ff	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00105	83 c4 10	 add	 esp, 16			; 00000010H
$LN24@OnCGInvite:

; 1225 : 	}
; 1226 : 	LPOBJ lpResponsor = (LPOBJ)&gObj[nResponsor];

  00108	69 f6 40 27 00
	00		 imul	 esi, 10048		; 00002740H
  0010e	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 1227 : 	if( g_NewPVP.CheckPKPenalty(lpResponsor) )

  00114	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_NewPVP@@3VCNewPVP@@A ; g_NewPVP
  00119	8b de		 mov	 ebx, esi
  0011b	53		 push	 ebx
  0011c	e8 00 00 00 00	 call	 ?CheckPKPenalty@CNewPVP@@QAEHPAUOBJECTSTRUCT@@@Z ; CNewPVP::CheckPKPenalty
  00121	85 c0		 test	 eax, eax
  00123	74 0d		 je	 SHORT $LN23@OnCGInvite

; 1228 : 	{
; 1229 : 		GCServerMsgStringSend(lMsg.Get(1200), aIndex, 1);

  00125	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00128	6a 01		 push	 1
  0012a	50		 push	 eax
  0012b	68 b0 04 00 00	 push	 1200			; 000004b0H

; 1230 : 		return ENEWPVP::E_NOT_DUEL_MURDERER;

  00130	eb 91		 jmp	 SHORT $LN63@OnCGInvite
$LN23@OnCGInvite:

; 1231 : 	}
; 1232 : 
; 1233 : 	char szDuelName[MAX_IDSTRING+1] = {0};
; 1234 : 	char szDuelName2[MAX_IDSTRING+1] = {0};
; 1235 : 
; 1236 : 	memcpy(szDuelName, lpResponsor->Name, MAX_IDSTRING);

  00132	8b 4b 5d	 mov	 ecx, DWORD PTR [ebx+93]
  00135	8b 53 61	 mov	 edx, DWORD PTR [ebx+97]
  00138	33 c0		 xor	 eax, eax
  0013a	89 45 e9	 mov	 DWORD PTR _szDuelName$[ebp+1], eax
  0013d	89 45 ed	 mov	 DWORD PTR _szDuelName$[ebp+5], eax
  00140	66 89 45 f1	 mov	 WORD PTR _szDuelName$[ebp+9], ax
  00144	89 45 f5	 mov	 DWORD PTR _szDuelName2$[ebp+1], eax
  00147	89 45 f9	 mov	 DWORD PTR _szDuelName2$[ebp+5], eax
  0014a	66 89 45 fd	 mov	 WORD PTR _szDuelName2$[ebp+9], ax
  0014e	0f b7 43 65	 movzx	 eax, WORD PTR [ebx+101]
  00152	8d 73 5d	 lea	 esi, DWORD PTR [ebx+93]
  00155	66 89 45 f0	 mov	 WORD PTR _szDuelName$[ebp+8], ax

; 1237 : 	szDuelName[MAX_IDSTRING] = '\0';
; 1238 : 
; 1239 : 	memcpy(szDuelName2, lpMsg->szName, MAX_IDSTRING);

  00159	0f b7 47 0e	 movzx	 eax, WORD PTR [edi+14]
  0015d	89 4d e8	 mov	 DWORD PTR _szDuelName$[ebp], ecx
  00160	8b 4f 06	 mov	 ecx, DWORD PTR [edi+6]
  00163	89 55 ec	 mov	 DWORD PTR _szDuelName$[ebp+4], edx
  00166	8b 57 0a	 mov	 edx, DWORD PTR [edi+10]
  00169	89 4d f4	 mov	 DWORD PTR _szDuelName2$[ebp], ecx
  0016c	66 89 45 fc	 mov	 WORD PTR _szDuelName2$[ebp+8], ax
  00170	c6 45 f2 00	 mov	 BYTE PTR _szDuelName$[ebp+10], 0
  00174	89 55 f8	 mov	 DWORD PTR _szDuelName2$[ebp+4], edx

; 1240 : 	szDuelName2[MAX_IDSTRING] = '\0';

  00177	c6 45 fe 00	 mov	 BYTE PTR _szDuelName2$[ebp+10], 0

; 1241 : 
; 1242 : 	if( strcmp(szDuelName, szDuelName2) != 0 )

  0017b	8d 4d f4	 lea	 ecx, DWORD PTR _szDuelName2$[ebp]
  0017e	8d 45 e8	 lea	 eax, DWORD PTR _szDuelName$[ebp]
$LL56@OnCGInvite:
  00181	8a 10		 mov	 dl, BYTE PTR [eax]
  00183	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00185	75 1a		 jne	 SHORT $LN57@OnCGInvite
  00187	84 d2		 test	 dl, dl
  00189	74 12		 je	 SHORT $LN58@OnCGInvite
  0018b	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  0018e	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00191	75 0e		 jne	 SHORT $LN57@OnCGInvite
  00193	83 c0 02	 add	 eax, 2
  00196	83 c1 02	 add	 ecx, 2
  00199	84 d2		 test	 dl, dl
  0019b	75 e4		 jne	 SHORT $LL56@OnCGInvite
$LN58@OnCGInvite:
  0019d	33 c0		 xor	 eax, eax
  0019f	eb 05		 jmp	 SHORT $LN59@OnCGInvite
$LN57@OnCGInvite:
  001a1	1b c0		 sbb	 eax, eax
  001a3	83 d8 ff	 sbb	 eax, -1
$LN59@OnCGInvite:
  001a6	85 c0		 test	 eax, eax
  001a8	74 2a		 je	 SHORT $LN22@OnCGInvite

; 1243 : 	{
; 1244 : 		GCServerMsgStringSend(lMsg.Get(1186), aIndex, 1);

  001aa	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  001ad	6a 01		 push	 1
  001af	51		 push	 ecx
  001b0	68 a2 04 00 00	 push	 1186			; 000004a2H
$LN64@OnCGInvite:
  001b5	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  001ba	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  001bf	50		 push	 eax
  001c0	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend

; 1263 : 	{
; 1264 : 		GCServerMsgStringSend(lMsg.Get(1213), aIndex, 1);

  001c5	83 c4 0c	 add	 esp, 12			; 0000000cH
  001c8	5f		 pop	 edi
  001c9	5e		 pop	 esi
  001ca	b8 01 00 00 00	 mov	 eax, 1
  001cf	5b		 pop	 ebx

; 1321 : }

  001d0	8b e5		 mov	 esp, ebp
  001d2	5d		 pop	 ebp
  001d3	c3		 ret	 0
$LN22@OnCGInvite:

; 1245 : 		return ENEWPVP::E_FAILED_RESULT;
; 1246 : 	}
; 1247 : 	if( !IsDuelEnable(lpResponsor->m_Index) )

  001d4	8b 13		 mov	 edx, DWORD PTR [ebx]
  001d6	52		 push	 edx
  001d7	e8 00 00 00 00	 call	 ?IsDuelEnable@@YA_NH@Z	; IsDuelEnable
  001dc	83 c4 04	 add	 esp, 4
  001df	84 c0		 test	 al, al
  001e1	75 0d		 jne	 SHORT $LN21@OnCGInvite

; 1248 : 	{
; 1249 : 		GCServerMsgStringSend(lMsg.Get(1187), aIndex, 1);

  001e3	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  001e6	6a 01		 push	 1
  001e8	50		 push	 eax
  001e9	68 a3 04 00 00	 push	 1187			; 000004a3H

; 1250 : 		return ENEWPVP::E_FAILED_RESULT;

  001ee	eb c5		 jmp	 SHORT $LN64@OnCGInvite
$LN21@OnCGInvite:

; 1251 : 	}
; 1252 : 	if( g_NewPVP.IsGuildWar(lpRequester) )

  001f0	8b 7d 08	 mov	 edi, DWORD PTR _lpRequester$[ebp]
  001f3	57		 push	 edi
  001f4	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_NewPVP@@3VCNewPVP@@A ; g_NewPVP
  001f9	e8 00 00 00 00	 call	 ?IsGuildWar@CNewPVP@@QAEHPAUOBJECTSTRUCT@@@Z ; CNewPVP::IsGuildWar
  001fe	85 c0		 test	 eax, eax
  00200	74 2a		 je	 SHORT $LN20@OnCGInvite

; 1253 : 	{
; 1254 : 		GCServerMsgStringSend(lMsg.Get(1188), aIndex, 1);

  00202	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00205	6a 01		 push	 1
  00207	51		 push	 ecx
  00208	68 a4 04 00 00	 push	 1188			; 000004a4H
$LN65@OnCGInvite:
  0020d	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  00212	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  00217	50		 push	 eax
  00218	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend

; 1263 : 	{
; 1264 : 		GCServerMsgStringSend(lMsg.Get(1213), aIndex, 1);

  0021d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00220	5f		 pop	 edi
  00221	5e		 pop	 esi
  00222	b8 0e 00 00 00	 mov	 eax, 14			; 0000000eH
  00227	5b		 pop	 ebx

; 1321 : }

  00228	8b e5		 mov	 esp, ebp
  0022a	5d		 pop	 ebp
  0022b	c3		 ret	 0
$LN20@OnCGInvite:

; 1255 : 		return ENEWPVP::E_GUILDWAR;
; 1256 : 	}
; 1257 : 	if( g_NewPVP.IsGuildWar(lpResponsor) )

  0022c	53		 push	 ebx
  0022d	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_NewPVP@@3VCNewPVP@@A ; g_NewPVP
  00232	e8 00 00 00 00	 call	 ?IsGuildWar@CNewPVP@@QAEHPAUOBJECTSTRUCT@@@Z ; CNewPVP::IsGuildWar
  00237	85 c0		 test	 eax, eax
  00239	74 0d		 je	 SHORT $LN19@OnCGInvite

; 1258 : 	{
; 1259 : 		GCServerMsgStringSend(lMsg.Get(1189), aIndex, 1);

  0023b	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  0023e	6a 01		 push	 1
  00240	52		 push	 edx
  00241	68 a5 04 00 00	 push	 1189			; 000004a5H

; 1260 : 		return ENEWPVP::E_GUILDWAR;

  00246	eb c5		 jmp	 SHORT $LN65@OnCGInvite
$LN19@OnCGInvite:

; 1261 : 	}
; 1262 : 	if( g_NewPVP.IsSelfDefense(lpRequester) || g_NewPVP.IsSelfDefense(lpResponsor) )

  00248	57		 push	 edi
  00249	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_NewPVP@@3VCNewPVP@@A ; g_NewPVP
  0024e	e8 00 00 00 00	 call	 ?IsSelfDefense@CNewPVP@@QAEHPAUOBJECTSTRUCT@@@Z ; CNewPVP::IsSelfDefense
  00253	85 c0		 test	 eax, eax
  00255	0f 85 84 02 00
	00		 jne	 $LN17@OnCGInvite
  0025b	53		 push	 ebx
  0025c	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_NewPVP@@3VCNewPVP@@A ; g_NewPVP
  00261	e8 00 00 00 00	 call	 ?IsSelfDefense@CNewPVP@@QAEHPAUOBJECTSTRUCT@@@Z ; CNewPVP::IsSelfDefense
  00266	85 c0		 test	 eax, eax
  00268	0f 85 71 02 00
	00		 jne	 $LN17@OnCGInvite

; 1266 : 	}
; 1267 : 	if( CC_MAP_RANGE(lpRequester->MapNumber) || CC_MAP_RANGE(lpResponsor->MapNumber) )

  0026e	8a 87 23 01 00
	00		 mov	 al, BYTE PTR [edi+291]
  00274	3c 35		 cmp	 al, 53			; 00000035H
  00276	0f 84 56 02 00
	00		 je	 $LN15@OnCGInvite
  0027c	3c 12		 cmp	 al, 18			; 00000012H
  0027e	72 10		 jb	 SHORT $LN52@OnCGInvite
  00280	b9 17 00 00 00	 mov	 ecx, 23			; 00000017H
  00285	3a c8		 cmp	 cl, al
  00287	1b c9		 sbb	 ecx, ecx
  00289	41		 inc	 ecx
  0028a	0f 85 42 02 00
	00		 jne	 $LN15@OnCGInvite
$LN52@OnCGInvite:
  00290	8a 8b 23 01 00
	00		 mov	 cl, BYTE PTR [ebx+291]
  00296	80 f9 35	 cmp	 cl, 53			; 00000035H
  00299	0f 84 33 02 00
	00		 je	 $LN15@OnCGInvite
  0029f	80 f9 12	 cmp	 cl, 18			; 00000012H
  002a2	72 10		 jb	 SHORT $LN53@OnCGInvite
  002a4	ba 17 00 00 00	 mov	 edx, 23			; 00000017H
  002a9	3a d1		 cmp	 dl, cl
  002ab	1b d2		 sbb	 edx, edx
  002ad	42		 inc	 edx
  002ae	0f 85 1e 02 00
	00		 jne	 $LN15@OnCGInvite
$LN53@OnCGInvite:

; 1271 : 	}
; 1272 : 	if( DS_MAP_RANGE(lpRequester->MapNumber) || DS_MAP_RANGE(lpResponsor->MapNumber) )

  002b4	3c 09		 cmp	 al, 9
  002b6	0f 84 09 02 00
	00		 je	 $LN13@OnCGInvite
  002bc	33 d2		 xor	 edx, edx
  002be	3c 20		 cmp	 al, 32			; 00000020H
  002c0	0f 94 c2	 sete	 dl
  002c3	85 d2		 test	 edx, edx
  002c5	0f 85 fa 01 00
	00		 jne	 $LN13@OnCGInvite
  002cb	80 f9 09	 cmp	 cl, 9
  002ce	0f 84 f1 01 00
	00		 je	 $LN13@OnCGInvite
  002d4	80 f9 20	 cmp	 cl, 32			; 00000020H
  002d7	0f 94 c2	 sete	 dl
  002da	85 d2		 test	 edx, edx
  002dc	0f 85 e3 01 00
	00		 jne	 $LN13@OnCGInvite

; 1276 : 	}
; 1277 : 	if( BC_MAP_RANGE(lpRequester->MapNumber) || BC_MAP_RANGE(lpResponsor->MapNumber) )

  002e2	3c 34		 cmp	 al, 52			; 00000034H
  002e4	0f 84 b1 01 00
	00		 je	 $LN11@OnCGInvite
  002ea	3c 0b		 cmp	 al, 11			; 0000000bH
  002ec	72 0d		 jb	 SHORT $LN54@OnCGInvite
  002ee	b2 11		 mov	 dl, 17			; 00000011H
  002f0	3a d0		 cmp	 dl, al
  002f2	1b c0		 sbb	 eax, eax
  002f4	40		 inc	 eax
  002f5	0f 85 a0 01 00
	00		 jne	 $LN11@OnCGInvite
$LN54@OnCGInvite:
  002fb	80 f9 34	 cmp	 cl, 52			; 00000034H
  002fe	0f 84 97 01 00
	00		 je	 $LN11@OnCGInvite
  00304	80 f9 0b	 cmp	 cl, 11			; 0000000bH
  00307	72 10		 jb	 SHORT $LN55@OnCGInvite
  00309	b8 11 00 00 00	 mov	 eax, 17			; 00000011H
  0030e	3a c1		 cmp	 al, cl
  00310	1b c0		 sbb	 eax, eax
  00312	40		 inc	 eax
  00313	0f 85 82 01 00
	00		 jne	 $LN11@OnCGInvite
$LN55@OnCGInvite:

; 1281 : 	}
; 1282 : 	if( lpRequester->m_IfState.use > 0 )

  00319	b0 03		 mov	 al, 3
  0031b	8b cf		 mov	 ecx, edi
  0031d	84 81 b8 11 00
	00		 test	 BYTE PTR [ecx+4536], al
  00323	76 10		 jbe	 SHORT $LN10@OnCGInvite

; 1283 : 	{
; 1284 : 		GCServerMsgStringSend(lMsg.Get(1191), aIndex, 1);

  00325	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  00328	6a 01		 push	 1
  0032a	51		 push	 ecx
  0032b	68 a7 04 00 00	 push	 1191			; 000004a7H

; 1285 : 		return ENEWPVP::E_FAILED_RESULT;

  00330	e9 80 fe ff ff	 jmp	 $LN64@OnCGInvite
$LN10@OnCGInvite:

; 1286 : 	}
; 1287 : 	if( lpResponsor->m_IfState.use > 0 )

  00335	84 83 b8 11 00
	00		 test	 BYTE PTR [ebx+4536], al
  0033b	76 2b		 jbe	 SHORT $LN9@OnCGInvite

; 1288 : 	{
; 1289 : 		GCServerMsgStringSendEx(aIndex, 1, lMsg.Get(1192), lpResponsor->Name);

  0033d	56		 push	 esi
  0033e	68 a8 04 00 00	 push	 1192			; 000004a8H
  00343	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  00348	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  0034d	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00350	50		 push	 eax
  00351	6a 01		 push	 1
  00353	52		 push	 edx
  00354	e8 00 00 00 00	 call	 ?GCServerMsgStringSendEx@@YAXHEPADZZ ; GCServerMsgStringSendEx
  00359	83 c4 10	 add	 esp, 16			; 00000010H
  0035c	5f		 pop	 edi
  0035d	5e		 pop	 esi

; 1290 : 		return ENEWPVP::E_FAILED_RESULT;

  0035e	b8 01 00 00 00	 mov	 eax, 1
  00363	5b		 pop	 ebx

; 1321 : }

  00364	8b e5		 mov	 esp, ebp
  00366	5d		 pop	 ebp
  00367	c3		 ret	 0
$LN9@OnCGInvite:

; 1291 : 	}
; 1292 : 	int nRet = g_NewPVP.Reserve(*lpRequester, *lpResponsor);

  00368	53		 push	 ebx
  00369	51		 push	 ecx
  0036a	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_NewPVP@@3VCNewPVP@@A ; g_NewPVP
  0036f	e8 00 00 00 00	 call	 ?Reserve@CNewPVP@@QAEHAAUOBJECTSTRUCT@@0@Z ; CNewPVP::Reserve
  00374	8b f8		 mov	 edi, eax

; 1293 : 	if( nRet != ENEWPVP::E_NO_ERROR )

  00376	85 ff		 test	 edi, edi
  00378	0f 84 da 00 00
	00		 je	 $LN8@OnCGInvite

; 1294 : 	{
; 1295 : 		switch( nRet )

  0037e	8d 47 ed	 lea	 eax, DWORD PTR [edi-19]
  00381	83 f8 04	 cmp	 eax, 4
  00384	0f 87 c5 00 00
	00		 ja	 $LN6@OnCGInvite
  0038a	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN67@OnCGInvite[eax*4]
$LN5@OnCGInvite:

; 1296 : 		{
; 1297 : 		case ENEWPVP::E_ALREADY_DUELRESERVED:
; 1298 : 			GCServerMsgStringSend(lMsg.Get(1183), aIndex, 1);

  00391	8b 75 0c	 mov	 esi, DWORD PTR _aIndex$[ebp]
  00394	6a 01		 push	 1
  00396	56		 push	 esi
  00397	68 9f 04 00 00	 push	 1183			; 0000049fH
$LN62@OnCGInvite:
  0039c	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  003a1	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  003a6	50		 push	 eax
  003a7	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  003ac	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1299 : 			GCServerMsgStringSend(lMsg.Get(1185), aIndex, 1);

  003af	6a 01		 push	 1
  003b1	56		 push	 esi
  003b2	68 a1 04 00 00	 push	 1185			; 000004a1H
  003b7	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  003bc	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  003c1	50		 push	 eax
  003c2	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  003c7	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1313 : 			break;
; 1314 : 		}
; 1315 : 		return nRet;

  003ca	8b c7		 mov	 eax, edi
  003cc	5f		 pop	 edi
  003cd	5e		 pop	 esi
  003ce	5b		 pop	 ebx

; 1321 : }

  003cf	8b e5		 mov	 esp, ebp
  003d1	5d		 pop	 ebp
  003d2	c3		 ret	 0
$LN4@OnCGInvite:

; 1300 : 			break;
; 1301 : 		case ENEWPVP::E_ALREADY_DUELLING:
; 1302 : 			GCServerMsgStringSend(lMsg.Get(1184), aIndex, 1);

  003d3	8b 75 0c	 mov	 esi, DWORD PTR _aIndex$[ebp]
  003d6	6a 01		 push	 1
  003d8	56		 push	 esi
  003d9	68 a0 04 00 00	 push	 1184			; 000004a0H

; 1303 : 			GCServerMsgStringSend(lMsg.Get(1185), aIndex, 1);
; 1304 : 			break;

  003de	eb bc		 jmp	 SHORT $LN62@OnCGInvite
$LN3@OnCGInvite:

; 1305 : 		case ENEWPVP::E_ALREADY_DUELREQUESTED_1:
; 1306 : 			GCServerMsgStringSendEx(aIndex, 1, lMsg.Get(1193), lpResponsor->Name);

  003e0	56		 push	 esi
  003e1	68 a9 04 00 00	 push	 1193			; 000004a9H
  003e6	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  003eb	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  003f0	50		 push	 eax
  003f1	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  003f4	6a 01		 push	 1
  003f6	50		 push	 eax

; 1310 : 			break;
; 1311 : 		case ENEWPVP::E_ALREADY_DUELLING_1:
; 1312 : 			GCServerMsgStringSendEx(aIndex, 1, lMsg.Get(1195), lpResponsor->Name);

  003f7	e8 00 00 00 00	 call	 ?GCServerMsgStringSendEx@@YAXHEPADZZ ; GCServerMsgStringSendEx
  003fc	83 c4 10	 add	 esp, 16			; 00000010H

; 1313 : 			break;
; 1314 : 		}
; 1315 : 		return nRet;

  003ff	8b c7		 mov	 eax, edi
  00401	5f		 pop	 edi
  00402	5e		 pop	 esi
  00403	5b		 pop	 ebx

; 1321 : }

  00404	8b e5		 mov	 esp, ebp
  00406	5d		 pop	 ebp
  00407	c3		 ret	 0
$LN2@OnCGInvite:

; 1307 : 			break;
; 1308 : 		case ENEWPVP::E_ALREADY_DUELRESERVED_1:			
; 1309 : 			GCServerMsgStringSendEx(aIndex, 1, lMsg.Get(1194), lpResponsor->Name);

  00408	56		 push	 esi
  00409	68 aa 04 00 00	 push	 1194			; 000004aaH
  0040e	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  00413	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  00418	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  0041b	50		 push	 eax
  0041c	6a 01		 push	 1
  0041e	51		 push	 ecx

; 1310 : 			break;
; 1311 : 		case ENEWPVP::E_ALREADY_DUELLING_1:
; 1312 : 			GCServerMsgStringSendEx(aIndex, 1, lMsg.Get(1195), lpResponsor->Name);

  0041f	e8 00 00 00 00	 call	 ?GCServerMsgStringSendEx@@YAXHEPADZZ ; GCServerMsgStringSendEx
  00424	83 c4 10	 add	 esp, 16			; 00000010H

; 1313 : 			break;
; 1314 : 		}
; 1315 : 		return nRet;

  00427	8b c7		 mov	 eax, edi
  00429	5f		 pop	 edi
  0042a	5e		 pop	 esi
  0042b	5b		 pop	 ebx

; 1321 : }

  0042c	8b e5		 mov	 esp, ebp
  0042e	5d		 pop	 ebp
  0042f	c3		 ret	 0
$LN1@OnCGInvite:

; 1310 : 			break;
; 1311 : 		case ENEWPVP::E_ALREADY_DUELLING_1:
; 1312 : 			GCServerMsgStringSendEx(aIndex, 1, lMsg.Get(1195), lpResponsor->Name);

  00430	56		 push	 esi
  00431	68 ab 04 00 00	 push	 1195			; 000004abH
  00436	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  0043b	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  00440	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  00443	50		 push	 eax
  00444	6a 01		 push	 1
  00446	52		 push	 edx
  00447	e8 00 00 00 00	 call	 ?GCServerMsgStringSendEx@@YAXHEPADZZ ; GCServerMsgStringSendEx
  0044c	83 c4 10	 add	 esp, 16			; 00000010H
$LN6@OnCGInvite:

; 1313 : 			break;
; 1314 : 		}
; 1315 : 		return nRet;

  0044f	8b c7		 mov	 eax, edi
  00451	5f		 pop	 edi
  00452	5e		 pop	 esi
  00453	5b		 pop	 ebx

; 1321 : }

  00454	8b e5		 mov	 esp, ebp
  00456	5d		 pop	 ebp
  00457	c3		 ret	 0
$LN8@OnCGInvite:

; 1316 : 	}
; 1317 : 	
; 1318 : 	GCServerMsgStringSendEx(aIndex, 1, lMsg.Get(1196), lpResponsor->Name);

  00458	56		 push	 esi
  00459	68 ac 04 00 00	 push	 1196			; 000004acH
  0045e	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  00463	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  00468	50		 push	 eax
  00469	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  0046c	6a 01		 push	 1
  0046e	50		 push	 eax
  0046f	e8 00 00 00 00	 call	 ?GCServerMsgStringSendEx@@YAXHEPADZZ ; GCServerMsgStringSendEx

; 1319 : 	LogAddTD("[Duel] [%s][%s] Requested to Start Duel to [%s][%s]", lpRequester->AccountID, lpRequester->Name, lpResponsor->AccountID, lpResponsor->Name);

  00474	8b 45 08	 mov	 eax, DWORD PTR _lpRequester$[ebp]
  00477	56		 push	 esi
  00478	83 c3 52	 add	 ebx, 82			; 00000052H
  0047b	53		 push	 ebx
  0047c	8d 48 5d	 lea	 ecx, DWORD PTR [eax+93]
  0047f	51		 push	 ecx
  00480	83 c0 52	 add	 eax, 82			; 00000052H
  00483	50		 push	 eax
  00484	68 00 00 00 00	 push	 OFFSET ??_C@_0DE@MJGAINFG@?$FLDuel?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Requested?5to?5Sta@
  00489	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0048f	83 c4 24	 add	 esp, 36			; 00000024H
  00492	5f		 pop	 edi
  00493	5e		 pop	 esi

; 1320 : 	return ENEWPVP::E_NO_ERROR;

  00494	33 c0		 xor	 eax, eax
  00496	5b		 pop	 ebx

; 1321 : }

  00497	8b e5		 mov	 esp, ebp
  00499	5d		 pop	 ebp
  0049a	c3		 ret	 0
$LN11@OnCGInvite:

; 1278 : 	{
; 1279 : 		GCServerMsgStringSend(lMsg.Get(1190), aIndex, 1);

  0049b	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  0049e	6a 01		 push	 1
  004a0	52		 push	 edx
  004a1	68 a6 04 00 00	 push	 1190			; 000004a6H
$LN66@OnCGInvite:
  004a6	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  004ab	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  004b0	50		 push	 eax
  004b1	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  004b6	83 c4 0c	 add	 esp, 12			; 0000000cH
  004b9	5f		 pop	 edi
  004ba	5e		 pop	 esi

; 1280 : 		return ENEWPVP::E_INVALID_MAP;

  004bb	b8 08 00 00 00	 mov	 eax, 8
  004c0	5b		 pop	 ebx

; 1321 : }

  004c1	8b e5		 mov	 esp, ebp
  004c3	5d		 pop	 ebp
  004c4	c3		 ret	 0
$LN13@OnCGInvite:

; 1273 : 	{
; 1274 : 		GCServerMsgStringSend(lMsg.Get(1204), aIndex, 1);

  004c5	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  004c8	6a 01		 push	 1
  004ca	50		 push	 eax
  004cb	68 b4 04 00 00	 push	 1204			; 000004b4H

; 1275 : 		return ENEWPVP::E_INVALID_MAP;

  004d0	eb d4		 jmp	 SHORT $LN66@OnCGInvite
$LN15@OnCGInvite:

; 1268 : 	{
; 1269 : 		GCServerMsgStringSend(lMsg.Get(1231), aIndex, 1);

  004d2	8b 4d 0c	 mov	 ecx, DWORD PTR _aIndex$[ebp]
  004d5	6a 01		 push	 1
  004d7	51		 push	 ecx
  004d8	68 cf 04 00 00	 push	 1231			; 000004cfH

; 1270 : 		return ENEWPVP::E_INVALID_MAP;

  004dd	eb c7		 jmp	 SHORT $LN66@OnCGInvite
$LN17@OnCGInvite:

; 1263 : 	{
; 1264 : 		GCServerMsgStringSend(lMsg.Get(1213), aIndex, 1);

  004df	8b 55 0c	 mov	 edx, DWORD PTR _aIndex$[ebp]
  004e2	6a 01		 push	 1
  004e4	52		 push	 edx
  004e5	68 bd 04 00 00	 push	 1213			; 000004bdH
  004ea	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  004ef	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  004f4	50		 push	 eax
  004f5	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  004fa	83 c4 0c	 add	 esp, 12			; 0000000cH
  004fd	5f		 pop	 edi
  004fe	5e		 pop	 esi

; 1265 : 		return ENEWPVP::E_SELFDEFENSE;

  004ff	b8 0d 00 00 00	 mov	 eax, 13			; 0000000dH
  00504	5b		 pop	 ebx

; 1321 : }

  00505	8b e5		 mov	 esp, ebp
  00507	5d		 pop	 ebp
  00508	c3		 ret	 0
  00509	8d 49 00	 npad	 3
$LN67@OnCGInvite:
  0050c	00 00 00 00	 DD	 $LN5@OnCGInvite
  00510	00 00 00 00	 DD	 $LN4@OnCGInvite
  00514	00 00 00 00	 DD	 $LN3@OnCGInvite
  00518	00 00 00 00	 DD	 $LN2@OnCGInvite
  0051c	00 00 00 00	 DD	 $LN1@OnCGInvite
?OnCGInviteDuel@@YAHPAU_tagPMSG_REQ_DUEL_INVITE@@H@Z ENDP ; OnCGInviteDuel
_TEXT	ENDS
PUBLIC	?OnCGLeaveDuel@@YAHPAU_tagPMSG_REQ_DUEL_EXIT@@H@Z ; OnCGLeaveDuel
; Function compile flags: /Ogtp
;	COMDAT ?OnCGLeaveDuel@@YAHPAU_tagPMSG_REQ_DUEL_EXIT@@H@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?OnCGLeaveDuel@@YAHPAU_tagPMSG_REQ_DUEL_EXIT@@H@Z PROC	; OnCGLeaveDuel, COMDAT

; 1387 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1388 : 	if( gObj[aIndex].CloseType != -1 )	return ENEWPVP::E_DISCONNECT;

  00003	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00006	69 c0 40 27 00
	00		 imul	 eax, 10048		; 00002740H
  0000c	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00012	80 78 0d ff	 cmp	 BYTE PTR [eax+13], -1
  00016	74 07		 je	 SHORT $LN2@OnCGLeaveD
  00018	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH

; 1390 : 	if( nRet != ENEWPVP::E_NO_ERROR )	return nRet;
; 1391 : 	return ENEWPVP::E_NO_ERROR;
; 1392 : }

  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
$LN2@OnCGLeaveD:

; 1389 : 	int nRet = g_NewPVP.Leave(gObj[aIndex]);

  0001f	50		 push	 eax
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_NewPVP@@3VCNewPVP@@A ; g_NewPVP
  00025	e8 00 00 00 00	 call	 ?Leave@CNewPVP@@QAEHAAUOBJECTSTRUCT@@@Z ; CNewPVP::Leave

; 1390 : 	if( nRet != ENEWPVP::E_NO_ERROR )	return nRet;
; 1391 : 	return ENEWPVP::E_NO_ERROR;
; 1392 : }

  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
?OnCGLeaveDuel@@YAHPAU_tagPMSG_REQ_DUEL_EXIT@@H@Z ENDP	; OnCGLeaveDuel
_TEXT	ENDS
PUBLIC	??1?$_Tree@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::~_Tree<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$??1?$_Tree@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Tree@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Tree@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Tree@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
xdata$x	ENDS
;	COMDAT ??1?$_Tree@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T202858 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Tree@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::~_Tree<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >, COMDAT
; _this$ = ecx

; 790  : 		{	// destroy tree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$_Tree@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	56		 push	 esi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00026	8b f1		 mov	 esi, ecx
  00028	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi

; 791  : 		_Tidy();

  0002b	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0002e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00030	50		 push	 eax
  00031	51		 push	 ecx
  00032	8d 45 ec	 lea	 eax, DWORD PTR $T202858[ebp]
  00035	50		 push	 eax
  00036	8b ce		 mov	 ecx, esi
  00038	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0003f	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::erase

; 792  : 		}

  00044	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00047	51		 push	 ecx
  00048	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0004d	83 c4 04	 add	 esp, 4
  00050	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00053	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005a	59		 pop	 ecx
  0005b	5e		 pop	 esi
  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Tree@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::~_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >
__ehhandler$??1?$_Tree@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@QAE@XZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$_Tree@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@QAE@XZ
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$_Tree@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::~_Tree<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >
PUBLIC	??1?$_Tree@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::~_Tree<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$??1?$_Tree@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Tree@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Tree@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Tree@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
xdata$x	ENDS
;	COMDAT ??1?$_Tree@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T202998 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Tree@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::~_Tree<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >, COMDAT
; _this$ = ecx

; 790  : 		{	// destroy tree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$_Tree@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	56		 push	 esi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00026	8b f1		 mov	 esi, ecx
  00028	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi

; 791  : 		_Tidy();

  0002b	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0002e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00030	50		 push	 eax
  00031	51		 push	 ecx
  00032	8d 45 ec	 lea	 eax, DWORD PTR $T202998[ebp]
  00035	50		 push	 eax
  00036	8b ce		 mov	 ecx, esi
  00038	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0003f	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::erase

; 792  : 		}

  00044	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00047	51		 push	 ecx
  00048	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0004d	83 c4 04	 add	 esp, 4
  00050	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00053	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005a	59		 pop	 ecx
  0005b	5e		 pop	 esi
  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Tree@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::~_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >
__ehhandler$??1?$_Tree@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@QAE@XZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$_Tree@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@QAE@XZ
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$_Tree@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::~_Tree<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >
PUBLIC	??1?$map@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@@std@@QAE@XZ ; std::map<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> > >::~map<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> > >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$map@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$map@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@@std@@QAE@XZ$1
__ehfuncinfo$??1?$map@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$map@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
xdata$x	ENDS
;	COMDAT ??1?$map@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@@std@@QAE@XZ
_TEXT	SEGMENT
$T203181 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$map@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@@std@@QAE@XZ PROC ; std::map<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> > >::~map<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$map@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	56		 push	 esi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00026	8b f1		 mov	 esi, ecx
  00028	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  0002b	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0002e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00030	50		 push	 eax
  00031	51		 push	 ecx
  00032	8d 45 ec	 lea	 eax, DWORD PTR $T203181[ebp]
  00035	50		 push	 eax
  00036	8b ce		 mov	 ecx, esi
  00038	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0003f	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::erase
  00044	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00047	51		 push	 ecx
  00048	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0004d	83 c4 04	 add	 esp, 4
  00050	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00053	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005a	59		 pop	 ecx
  0005b	5e		 pop	 esi
  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$map@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@@std@@QAE@XZ$1:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::~_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >
__ehhandler$??1?$map@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@@std@@QAE@XZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$map@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@@std@@QAE@XZ
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$map@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@@std@@QAE@XZ ENDP ; std::map<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> > >::~map<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> > >
PUBLIC	??1?$map@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@@std@@QAE@XZ ; std::map<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> > >::~map<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> > >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$map@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$map@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@@std@@QAE@XZ$1
__ehfuncinfo$??1?$map@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$map@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
xdata$x	ENDS
;	COMDAT ??1?$map@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@@std@@QAE@XZ
_TEXT	SEGMENT
$T203361 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$map@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@@std@@QAE@XZ PROC ; std::map<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> > >::~map<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$map@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	56		 push	 esi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00026	8b f1		 mov	 esi, ecx
  00028	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  0002b	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0002e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00030	50		 push	 eax
  00031	51		 push	 ecx
  00032	8d 45 ec	 lea	 eax, DWORD PTR $T203361[ebp]
  00035	50		 push	 eax
  00036	8b ce		 mov	 ecx, esi
  00038	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0003f	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::erase
  00044	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00047	51		 push	 ecx
  00048	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0004d	83 c4 04	 add	 esp, 4
  00050	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00053	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005a	59		 pop	 ecx
  0005b	5e		 pop	 esi
  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$map@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@@std@@QAE@XZ$1:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::~_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >
__ehhandler$??1?$map@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@@std@@QAE@XZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$map@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@@std@@QAE@XZ
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$map@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@@std@@QAE@XZ ENDP ; std::map<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> > >::~map<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> > >
PUBLIC	??_7CNewPVP@@6B@				; CNewPVP::`vftable'
PUBLIC	??1CNewPVP@@UAE@XZ				; CNewPVP::~CNewPVP
PUBLIC	??_R4CNewPVP@@6B@				; CNewPVP::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCNewPVP@@@8				; CNewPVP `RTTI Type Descriptor'
PUBLIC	??_R3CNewPVP@@8					; CNewPVP::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CNewPVP@@8					; CNewPVP::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CNewPVP@@8			; CNewPVP::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_ECNewPVP@@UAEPAXI@Z:PROC			; CNewPVP::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@CNewPVP@@8
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
rdata$r	SEGMENT
??_R1A@?0A@EA@CNewPVP@@8 DD FLAT:??_R0?AVCNewPVP@@@8	; CNewPVP::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CNewPVP@@8
rdata$r	ENDS
;	COMDAT ??_R2CNewPVP@@8
rdata$r	SEGMENT
??_R2CNewPVP@@8 DD FLAT:??_R1A@?0A@EA@CNewPVP@@8	; CNewPVP::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CNewPVP@@8
rdata$r	SEGMENT
??_R3CNewPVP@@8 DD 00H					; CNewPVP::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CNewPVP@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCNewPVP@@@8
_DATA	SEGMENT
??_R0?AVCNewPVP@@@8 DD FLAT:??_7type_info@@6B@		; CNewPVP `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCNewPVP@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CNewPVP@@6B@
rdata$r	SEGMENT
??_R4CNewPVP@@6B@ DD 00H				; CNewPVP::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCNewPVP@@@8
	DD	FLAT:??_R3CNewPVP@@8
rdata$r	ENDS
;	COMDAT ??_7CNewPVP@@6B@
CONST	SEGMENT
??_7CNewPVP@@6B@ DD FLAT:??_R4CNewPVP@@6B@		; CNewPVP::`vftable'
	DD	FLAT:??_ECNewPVP@@UAEPAXI@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1CNewPVP@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CNewPVP@@UAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1CNewPVP@@UAE@XZ$1
	DD	00H
	DD	FLAT:__unwindfunclet$??1CNewPVP@@UAE@XZ$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??1CNewPVP@@UAE@XZ$5
__ehfuncinfo$??1CNewPVP@@UAE@XZ DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??1CNewPVP@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\muserver_dev\development\mu-s8ep2-repack\gameserver\source\newpvp.cpp
xdata$x	ENDS
;	COMDAT ??1CNewPVP@@UAE@XZ
_TEXT	SEGMENT
$T203583 = -24						; size = 4
$T203824 = -24						; size = 4
$T203804 = -20						; size = 4
$T203612 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CNewPVP@@UAE@XZ PROC					; CNewPVP::~CNewPVP, COMDAT
; _this$ = ecx

; 40   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1CNewPVP@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	8b f1		 mov	 esi, ecx
  0002a	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  0002d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7CNewPVP@@6B@

; 41   : 	m_ObserverInfoList.clear();

  00033	8d 8e 24 01 00
	00		 lea	 ecx, DWORD PTR [esi+292]
  00039	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  00040	e8 00 00 00 00	 call	 ?clear@?$_Tree@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::clear

; 42   : 	m_Waiting.clear();

  00045	8d 9e 14 01 00
	00		 lea	 ebx, DWORD PTR [esi+276]
  0004b	8b cb		 mov	 ecx, ebx
  0004d	e8 00 00 00 00	 call	 ?clear@?$_Tree@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::clear

; 43   : }

  00052	81 c6 24 01 00
	00		 add	 esi, 292		; 00000124H
  00058	89 75 ec	 mov	 DWORD PTR $T203612[ebp], esi
  0005b	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0005e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00060	50		 push	 eax
  00061	51		 push	 ecx
  00062	8d 45 e8	 lea	 eax, DWORD PTR $T203583[ebp]
  00065	50		 push	 eax
  00066	8b ce		 mov	 ecx, esi
  00068	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  0006c	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::erase
  00071	8b 76 04	 mov	 esi, DWORD PTR [esi+4]
  00074	56		 push	 esi
  00075	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0007a	8b f3		 mov	 esi, ebx
  0007c	83 c4 04	 add	 esp, 4
  0007f	89 75 e8	 mov	 DWORD PTR $T203824[ebp], esi
  00082	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00085	8b 08		 mov	 ecx, DWORD PTR [eax]
  00087	50		 push	 eax
  00088	51		 push	 ecx
  00089	8d 4d ec	 lea	 ecx, DWORD PTR $T203804[ebp]
  0008c	51		 push	 ecx
  0008d	8b ce		 mov	 ecx, esi
  0008f	c7 45 fc 03 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 3
  00096	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::erase
  0009b	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0009e	52		 push	 edx
  0009f	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000a4	83 c4 04	 add	 esp, 4
  000a7	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000aa	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000b1	59		 pop	 ecx
  000b2	5f		 pop	 edi
  000b3	5e		 pop	 esi
  000b4	5b		 pop	 ebx
  000b5	8b e5		 mov	 esp, ebp
  000b7	5d		 pop	 ebp
  000b8	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CNewPVP@@UAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	81 c1 14 01 00
	00		 add	 ecx, 276		; 00000114H
  00009	e9 00 00 00 00	 jmp	 ??1?$map@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@@std@@QAE@XZ
__unwindfunclet$??1CNewPVP@@UAE@XZ$1:
  0000e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	81 c1 24 01 00
	00		 add	 ecx, 292		; 00000124H
  00017	e9 00 00 00 00	 jmp	 ??1?$map@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@@std@@QAE@XZ
__unwindfunclet$??1CNewPVP@@UAE@XZ$3:
  0001c	8b 4d ec	 mov	 ecx, DWORD PTR $T203612[ebp]
  0001f	e9 00 00 00 00	 jmp	 ??1?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::~_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >
__unwindfunclet$??1CNewPVP@@UAE@XZ$5:
  00024	8b 4d e8	 mov	 ecx, DWORD PTR $T203824[ebp]
  00027	e9 00 00 00 00	 jmp	 ??1?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::~_Tree_val<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >
__ehhandler$??1CNewPVP@@UAE@XZ:
  0002c	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00030	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00033	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  00036	33 c8		 xor	 ecx, eax
  00038	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003d	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1CNewPVP@@UAE@XZ
  00042	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1CNewPVP@@UAE@XZ ENDP					; CNewPVP::~CNewPVP
PUBLIC	?Run@CNewPVP@@QAEXXZ				; CNewPVP::Run
EXTRN	?gObjClearBuffEffect@@YA_NPAUOBJECTSTRUCT@@W4eBuffClearType@@@Z:PROC ; gObjClearBuffEffect
; Function compile flags: /Ogtp
;	COMDAT ?Run@CNewPVP@@QAEXXZ
_TEXT	SEGMENT
tv731 = -12						; size = 4
$T203835 = -12						; size = 4
_responsor$186370 = -8					; size = 4
_dwRemainMsec$186365 = -8				; size = 4
_requester$186362 = -8					; size = 4
_requester$186356 = -8					; size = 4
_dwRemainMsec$186351 = -8				; size = 4
_requester$186369 = -4					; size = 4
_responsor$186363 = -4					; size = 4
_responsor$186357 = -4					; size = 4
?Run@CNewPVP@@QAEXXZ PROC				; CNewPVP::Run, COMDAT
; _this$ = ecx

; 53   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx

; 54   : 	std::map<int, _tagWaiting>::iterator iter = m_Waiting.begin();

  0000a	8b 86 18 01 00
	00		 mov	 eax, DWORD PTR [esi+280]
  00010	57		 push	 edi
  00011	8b 38		 mov	 edi, DWORD PTR [eax]

; 55   : 
; 56   : 	while(iter!=m_Waiting.end())

  00013	3b f8		 cmp	 edi, eax
  00015	0f 84 a8 00 00
	00		 je	 $LN21@Run
  0001b	eb 03 8d 49 00	 npad	 5
$LL22@Run:

; 57   : 	{
; 58   : 		_tagWaiting & waiting = iter->second;
; 59   : 		if(waiting.bExpired == 1)

  00020	83 7f 18 01	 cmp	 DWORD PTR [edi+24], 1
  00024	75 14		 jne	 SHORT $LN20@Run

; 60   : 		{
; 61   : 			iter = m_Waiting.erase(iter);

  00026	57		 push	 edi
  00027	8d 45 f4	 lea	 eax, DWORD PTR $T203835[ebp]
  0002a	50		 push	 eax
  0002b	8d 8e 14 01 00
	00		 lea	 ecx, DWORD PTR [esi+276]
  00031	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::erase
  00036	8b 38		 mov	 edi, DWORD PTR [eax]

; 62   : 			continue;

  00038	eb 7d		 jmp	 SHORT $LN69@Run
$LN20@Run:

; 63   : 		}
; 64   : 
; 65   : 		DWORD dwRemainMsec = GetTickCount() - waiting.dwTime;			

  0003a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00040	2b 47 1c	 sub	 eax, DWORD PTR [edi+28]

; 66   : 		if( dwRemainMsec > 10000 )

  00043	3d 10 27 00 00	 cmp	 eax, 10000		; 00002710H
  00048	76 26		 jbe	 SHORT $LN19@Run

; 67   : 		{
; 68   : 			OBJECTSTRUCT & requester = gObj[waiting.nRequester];
; 69   : 			OBJECTSTRUCT & responsor = gObj[waiting.nResponsor];

  0004a	8b 4f 14	 mov	 ecx, DWORD PTR [edi+20]
  0004d	8b 57 10	 mov	 edx, DWORD PTR [edi+16]
  00050	69 c9 40 27 00
	00		 imul	 ecx, 10048		; 00002740H
  00056	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0005b	69 d2 40 27 00
	00		 imul	 edx, 10048		; 00002740H

; 70   : 			Cancel(requester, responsor, TRUE);

  00061	6a 01		 push	 1
  00063	03 c8		 add	 ecx, eax
  00065	51		 push	 ecx
  00066	03 d0		 add	 edx, eax
  00068	52		 push	 edx
  00069	8b ce		 mov	 ecx, esi
  0006b	e8 00 00 00 00	 call	 ?Cancel@CNewPVP@@QAEXAAUOBJECTSTRUCT@@0H@Z ; CNewPVP::Cancel
$LN19@Run:

; 71   : 		}		
; 72   : 		iter++;

  00070	80 7f 21 00	 cmp	 BYTE PTR [edi+33], 0
  00074	75 41		 jne	 SHORT $LN69@Run
  00076	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  00079	80 78 21 00	 cmp	 BYTE PTR [eax+33], 0
  0007d	75 1d		 jne	 SHORT $LN102@Run
  0007f	8b f8		 mov	 edi, eax
  00081	8b 07		 mov	 eax, DWORD PTR [edi]
  00083	80 78 21 00	 cmp	 BYTE PTR [eax+33], 0
  00087	75 2e		 jne	 SHORT $LN69@Run
  00089	8d a4 24 00 00
	00 00		 npad	 7
$LL84@Run:
  00090	8b f8		 mov	 edi, eax
  00092	8b 07		 mov	 eax, DWORD PTR [edi]
  00094	80 78 21 00	 cmp	 BYTE PTR [eax+33], 0
  00098	74 f6		 je	 SHORT $LL84@Run
  0009a	eb 1b		 jmp	 SHORT $LN69@Run
$LN102@Run:
  0009c	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0009f	80 78 21 00	 cmp	 BYTE PTR [eax+33], 0
  000a3	75 10		 jne	 SHORT $LN67@Run
$LL68@Run:
  000a5	3b 78 08	 cmp	 edi, DWORD PTR [eax+8]
  000a8	75 0b		 jne	 SHORT $LN67@Run
  000aa	8b f8		 mov	 edi, eax
  000ac	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000af	80 78 21 00	 cmp	 BYTE PTR [eax+33], 0
  000b3	74 f0		 je	 SHORT $LL68@Run
$LN67@Run:
  000b5	8b f8		 mov	 edi, eax
$LN69@Run:

; 55   : 
; 56   : 	while(iter!=m_Waiting.end())

  000b7	3b be 18 01 00
	00		 cmp	 edi, DWORD PTR [esi+280]
  000bd	0f 85 5d ff ff
	ff		 jne	 $LL22@Run
$LN21@Run:

; 73   : 	}
; 74   : 	
; 75   : 	for(int i = 0;i < DUEL_CHANNEL_MAX;i++)

  000c3	33 ff		 xor	 edi, edi
  000c5	8d 9e 8c 00 00
	00		 lea	 ebx, DWORD PTR [esi+140]
  000cb	eb 03 8d 49 00	 npad	 5
$LL18@Run:

; 76   : 	{
; 77   : 		int nStatus = m_DuelChannel[i].nStatus;

  000d0	0f b6 43 fa	 movzx	 eax, BYTE PTR [ebx-6]

; 78   : 		switch(nStatus)

  000d4	83 c0 fe	 add	 eax, -2			; fffffffeH
  000d7	89 45 f4	 mov	 DWORD PTR tv731[ebp], eax
  000da	83 f8 03	 cmp	 eax, 3
  000dd	0f 87 dd 01 00
	00		 ja	 $LN107@Run
  000e3	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN110@Run[eax*4]
$LN13@Run:

; 79   : 		{
; 80   : 		case 3:
; 81   : 			if(!CheckUsersOnConnect(i))	continue;

  000ea	57		 push	 edi
  000eb	8b ce		 mov	 ecx, esi
  000ed	e8 00 00 00 00	 call	 ?CheckUsersOnConnect@CNewPVP@@AAEHH@Z ; CNewPVP::CheckUsersOnConnect
  000f2	85 c0		 test	 eax, eax
  000f4	0f 84 d6 01 00
	00		 je	 $LN17@Run

; 82   : 			break;

  000fa	e9 c1 01 00 00	 jmp	 $LN107@Run
$LN11@Run:

; 83   : 		case 2:
; 84   : 			{
; 85   : 				DWORD dwRemainMsec = GetTickCount() - m_DuelChannel[i].dwTime;

  000ff	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00105	8b c8		 mov	 ecx, eax
  00107	2b 4b fc	 sub	 ecx, DWORD PTR [ebx-4]

; 86   : 				int nNotifySec = 6 - dwRemainMsec / 1000;				

  0010a	b8 d3 4d 62 10	 mov	 eax, 274877907		; 10624dd3H
  0010f	f7 e1		 mul	 ecx
  00111	c1 ea 06	 shr	 edx, 6
  00114	b8 06 00 00 00	 mov	 eax, 6
  00119	2b c2		 sub	 eax, edx
  0011b	89 4d f8	 mov	 DWORD PTR _dwRemainMsec$186351[ebp], ecx

; 87   : 				if(nNotifySec < 6 && m_DuelChannel[i].nNotifyCount != nNotifySec )

  0011e	83 f8 06	 cmp	 eax, 6
  00121	7d 1a		 jge	 SHORT $LN10@Run
  00123	0f bf 13	 movsx	 edx, WORD PTR [ebx]
  00126	3b d0		 cmp	 edx, eax
  00128	74 13		 je	 SHORT $LN10@Run

; 88   : 				{
; 89   : 					m_DuelChannel[i].nNotifyCount = nNotifySec;
; 90   : 					BroadcastMessage(i, 3, 0, nNotifySec);

  0012a	50		 push	 eax
  0012b	6a 00		 push	 0
  0012d	6a 03		 push	 3
  0012f	57		 push	 edi
  00130	8b ce		 mov	 ecx, esi
  00132	66 89 03	 mov	 WORD PTR [ebx], ax
  00135	e8 00 00 00 00	 call	 ?BroadcastMessage@CNewPVP@@AAEXHEEH@Z ; CNewPVP::BroadcastMessage
  0013a	8b 4d f8	 mov	 ecx, DWORD PTR _dwRemainMsec$186351[ebp]
$LN10@Run:

; 91   : 				}
; 92   : 				if(dwRemainMsec > 6000)

  0013d	81 f9 70 17 00
	00		 cmp	 ecx, 6000		; 00001770H
  00143	0f 86 77 01 00
	00		 jbe	 $LN107@Run

; 93   : 				{	
; 94   : 					if(!CheckUsersOnConnect(i))	continue;

  00149	57		 push	 edi
  0014a	8b ce		 mov	 ecx, esi
  0014c	e8 00 00 00 00	 call	 ?CheckUsersOnConnect@CNewPVP@@AAEHH@Z ; CNewPVP::CheckUsersOnConnect
  00151	85 c0		 test	 eax, eax
  00153	0f 84 77 01 00
	00		 je	 $LN17@Run

; 95   : 					
; 96   : 					OBJECTSTRUCT &requester = gObj[m_DuelChannel[i].nIndex1];

  00159	8b 43 dc	 mov	 eax, DWORD PTR [ebx-36]

; 97   : 					OBJECTSTRUCT &responsor = gObj[m_DuelChannel[i].nIndex2];

  0015c	8b 4b e0	 mov	 ecx, DWORD PTR [ebx-32]
  0015f	69 c0 40 27 00
	00		 imul	 eax, 10048		; 00002740H
  00165	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0016b	69 c9 40 27 00
	00		 imul	 ecx, 10048		; 00002740H
  00171	03 c2		 add	 eax, edx
  00173	03 ca		 add	 ecx, edx

; 98   : 					
; 99   : 					gObjClearBuffEffect(&requester, CLEAR_TYPE_NON_PCS_ITEM_EFFECT);

  00175	6a 06		 push	 6
  00177	50		 push	 eax
  00178	89 45 f8	 mov	 DWORD PTR _requester$186356[ebp], eax
  0017b	89 4d fc	 mov	 DWORD PTR _responsor$186357[ebp], ecx
  0017e	e8 00 00 00 00	 call	 ?gObjClearBuffEffect@@YA_NPAUOBJECTSTRUCT@@W4eBuffClearType@@@Z ; gObjClearBuffEffect

; 100  : 					gObjClearBuffEffect(&responsor, CLEAR_TYPE_NON_PCS_ITEM_EFFECT);

  00183	8b 45 fc	 mov	 eax, DWORD PTR _responsor$186357[ebp]
  00186	6a 06		 push	 6
  00188	50		 push	 eax
  00189	e8 00 00 00 00	 call	 ?gObjClearBuffEffect@@YA_NPAUOBJECTSTRUCT@@W4eBuffClearType@@@Z ; gObjClearBuffEffect
  0018e	83 c4 10	 add	 esp, 16			; 00000010H
$LN109@Run:

; 101  : 
; 102  : 					ReFill(requester);

  00191	8b 4d f8	 mov	 ecx, DWORD PTR _requester$186356[ebp]
  00194	51		 push	 ecx
  00195	8b ce		 mov	 ecx, esi
  00197	e8 00 00 00 00	 call	 ?ReFill@CNewPVP@@AAEXAAUOBJECTSTRUCT@@@Z ; CNewPVP::ReFill

; 103  : 					ReFill(responsor);

  0019c	8b 55 fc	 mov	 edx, DWORD PTR _responsor$186357[ebp]
  0019f	52		 push	 edx
  001a0	8b ce		 mov	 ecx, esi
  001a2	e8 00 00 00 00	 call	 ?ReFill@CNewPVP@@AAEXAAUOBJECTSTRUCT@@@Z ; CNewPVP::ReFill

; 104  : 
; 105  : 					BroadcastRound(i, 2, FALSE);

  001a7	6a 00		 push	 0
  001a9	6a 02		 push	 2
  001ab	57		 push	 edi
  001ac	8b ce		 mov	 ecx, esi
  001ae	e8 00 00 00 00	 call	 ?BroadcastRound@CNewPVP@@AAEXHEH@Z ; CNewPVP::BroadcastRound

; 106  : 					SetStatus(3, i, requester, responsor);

  001b3	8b 45 fc	 mov	 eax, DWORD PTR _responsor$186357[ebp]
  001b6	8b 4d f8	 mov	 ecx, DWORD PTR _requester$186356[ebp]
  001b9	50		 push	 eax
  001ba	51		 push	 ecx
  001bb	57		 push	 edi
  001bc	6a 03		 push	 3

; 107  : 				}
; 108  : 				break;

  001be	e9 f6 00 00 00	 jmp	 $LN108@Run
$LN7@Run:

; 109  : 			}
; 110  : 		case 4:
; 111  : 			{
; 112  : 				DWORD dwRemainMsec = GetTickCount() - m_DuelChannel[i].dwTime;

  001c3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  001c9	2b 43 fc	 sub	 eax, DWORD PTR [ebx-4]

; 113  : 				if(dwRemainMsec > 5000)

  001cc	3d 88 13 00 00	 cmp	 eax, 5000		; 00001388H
  001d1	0f 86 e9 00 00
	00		 jbe	 $LN107@Run

; 114  : 				{
; 115  : 					if(!CheckUsersOnConnect(i))	continue;

  001d7	57		 push	 edi
  001d8	8b ce		 mov	 ecx, esi
  001da	e8 00 00 00 00	 call	 ?CheckUsersOnConnect@CNewPVP@@AAEHH@Z ; CNewPVP::CheckUsersOnConnect
  001df	85 c0		 test	 eax, eax
  001e1	0f 84 e9 00 00
	00		 je	 $LN17@Run

; 116  : 					
; 117  : 					OBJECTSTRUCT & requester = gObj[m_DuelChannel[i].nIndex1];

  001e7	8b 43 dc	 mov	 eax, DWORD PTR [ebx-36]

; 118  : 					OBJECTSTRUCT & responsor = gObj[m_DuelChannel[i].nIndex2];

  001ea	8b 4b e0	 mov	 ecx, DWORD PTR [ebx-32]
  001ed	69 c0 40 27 00
	00		 imul	 eax, 10048		; 00002740H
  001f3	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001f9	69 c9 40 27 00
	00		 imul	 ecx, 10048		; 00002740H
  001ff	03 c2		 add	 eax, edx
  00201	03 ca		 add	 ecx, edx

; 119  : 
; 120  : 					MoveGate(requester.m_Index, g_GateRequester[i]);

  00203	8b 14 bd 00 00
	00 00		 mov	 edx, DWORD PTR _g_GateRequester[edi*4]
  0020a	89 45 f8	 mov	 DWORD PTR _requester$186362[ebp], eax
  0020d	8b 00		 mov	 eax, DWORD PTR [eax]
  0020f	52		 push	 edx
  00210	89 4d fc	 mov	 DWORD PTR _responsor$186363[ebp], ecx
  00213	50		 push	 eax
  00214	8b ce		 mov	 ecx, esi
  00216	e8 00 00 00 00	 call	 ?MoveGate@CNewPVP@@AAEHHH@Z ; CNewPVP::MoveGate

; 121  : 					MoveGate(responsor.m_Index, g_GateResponsor[i]);

  0021b	8b 0c bd 00 00
	00 00		 mov	 ecx, DWORD PTR _g_GateResponsor[edi*4]
  00222	8b 55 fc	 mov	 edx, DWORD PTR _responsor$186363[ebp]
  00225	8b 02		 mov	 eax, DWORD PTR [edx]
  00227	51		 push	 ecx
  00228	50		 push	 eax
  00229	8b ce		 mov	 ecx, esi
  0022b	e8 00 00 00 00	 call	 ?MoveGate@CNewPVP@@AAEHHH@Z ; CNewPVP::MoveGate

; 122  : 					ReFill( requester);
; 123  : 					ReFill( responsor);
; 124  : 					BroadcastRound( i, 2, FALSE);
; 125  : 					SetStatus(3, i, requester, responsor);
; 126  : 				}
; 127  : 			}
; 128  : 			break;

  00230	e9 5c ff ff ff	 jmp	 $LN109@Run
$LN4@Run:

; 129  : 		case DC_RESERVEDEND:
; 130  : 			{
; 131  : 				DWORD dwRemainMsec  = GetTickCount() - m_DuelChannel[i].dwTime;

  00235	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0023b	8b c8		 mov	 ecx, eax
  0023d	2b 4b fc	 sub	 ecx, DWORD PTR [ebx-4]

; 132  : 				int nNotifySec = 10 - dwRemainMsec / 1000;

  00240	b8 d3 4d 62 10	 mov	 eax, 274877907		; 10624dd3H
  00245	f7 e1		 mul	 ecx
  00247	c1 ea 06	 shr	 edx, 6
  0024a	b8 0a 00 00 00	 mov	 eax, 10			; 0000000aH
  0024f	2b c2		 sub	 eax, edx
  00251	89 4d f8	 mov	 DWORD PTR _dwRemainMsec$186365[ebp], ecx

; 133  : 				if( nNotifySec < 6 && m_DuelChannel[i].nNotifyCount != nNotifySec )

  00254	83 f8 06	 cmp	 eax, 6
  00257	7d 1a		 jge	 SHORT $LN3@Run
  00259	0f bf 13	 movsx	 edx, WORD PTR [ebx]
  0025c	3b d0		 cmp	 edx, eax
  0025e	74 13		 je	 SHORT $LN3@Run

; 134  : 				{
; 135  : 					m_DuelChannel[i].nNotifyCount = nNotifySec;
; 136  : 					BroadcastMessage(i, 3, 2, nNotifySec);

  00260	50		 push	 eax
  00261	6a 02		 push	 2
  00263	6a 03		 push	 3
  00265	57		 push	 edi
  00266	8b ce		 mov	 ecx, esi
  00268	66 89 03	 mov	 WORD PTR [ebx], ax
  0026b	e8 00 00 00 00	 call	 ?BroadcastMessage@CNewPVP@@AAEXHEEH@Z ; CNewPVP::BroadcastMessage
  00270	8b 4d f8	 mov	 ecx, DWORD PTR _dwRemainMsec$186365[ebp]
$LN3@Run:

; 137  : 				}
; 138  : 				if( dwRemainMsec > 10000 )

  00273	81 f9 10 27 00
	00		 cmp	 ecx, 10000		; 00002710H
  00279	76 45		 jbe	 SHORT $LN107@Run

; 139  : 				{
; 140  : 					OBJECTSTRUCT &requester = gObj[m_DuelChannel[i].nIndex1];
; 141  : 				  	OBJECTSTRUCT &responsor = gObj[m_DuelChannel[i].nIndex2];

  0027b	8b 4b e0	 mov	 ecx, DWORD PTR [ebx-32]
  0027e	8b 43 dc	 mov	 eax, DWORD PTR [ebx-36]
  00281	69 c9 40 27 00
	00		 imul	 ecx, 10048		; 00002740H
  00287	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0028d	69 c0 40 27 00
	00		 imul	 eax, 10048		; 00002740H
  00293	03 ca		 add	 ecx, edx
  00295	03 c2		 add	 eax, edx

; 142  : 					Leave( requester, responsor);

  00297	51		 push	 ecx
  00298	89 4d f8	 mov	 DWORD PTR _responsor$186370[ebp], ecx
  0029b	50		 push	 eax
  0029c	8b ce		 mov	 ecx, esi
  0029e	89 45 fc	 mov	 DWORD PTR _requester$186369[ebp], eax
  002a1	e8 00 00 00 00	 call	 ?Leave@CNewPVP@@AAEXAAUOBJECTSTRUCT@@0@Z ; CNewPVP::Leave

; 143  : 					LeaveChannelObserver(i);

  002a6	57		 push	 edi
  002a7	8b ce		 mov	 ecx, esi
  002a9	e8 00 00 00 00	 call	 ?LeaveChannelObserver@CNewPVP@@AAEXH@Z ; CNewPVP::LeaveChannelObserver

; 144  : 					SetStatus(DC_IDLE, i, requester, responsor);

  002ae	8b 45 f8	 mov	 eax, DWORD PTR _responsor$186370[ebp]
  002b1	8b 4d fc	 mov	 ecx, DWORD PTR _requester$186369[ebp]
  002b4	50		 push	 eax
  002b5	51		 push	 ecx
  002b6	57		 push	 edi
  002b7	6a 00		 push	 0
$LN108@Run:
  002b9	8b ce		 mov	 ecx, esi
  002bb	e8 00 00 00 00	 call	 ?SetStatus@CNewPVP@@AAEXHHAAUOBJECTSTRUCT@@0@Z ; CNewPVP::SetStatus
$LN107@Run:

; 145  : 				}
; 146  : 			}
; 147  : 			break;
; 148  : 		}
; 149  : 		if( IS_START(nStatus) )	BroadcastDuelInfo(i, 2);

  002c0	83 7d f4 02	 cmp	 DWORD PTR tv731[ebp], 2
  002c4	77 0a		 ja	 SHORT $LN17@Run
  002c6	6a 02		 push	 2
  002c8	57		 push	 edi
  002c9	8b ce		 mov	 ecx, esi
  002cb	e8 00 00 00 00	 call	 ?BroadcastDuelInfo@CNewPVP@@AAEXHE@Z ; CNewPVP::BroadcastDuelInfo
$LN17@Run:

; 73   : 	}
; 74   : 	
; 75   : 	for(int i = 0;i < DUEL_CHANNEL_MAX;i++)

  002d0	47		 inc	 edi
  002d1	83 c3 2c	 add	 ebx, 44			; 0000002cH
  002d4	83 ff 04	 cmp	 edi, 4
  002d7	0f 8c f3 fd ff
	ff		 jl	 $LL18@Run
  002dd	5f		 pop	 edi
  002de	5e		 pop	 esi
  002df	5b		 pop	 ebx

; 150  : 	}
; 151  : }

  002e0	8b e5		 mov	 esp, ebp
  002e2	5d		 pop	 ebp
  002e3	c3		 ret	 0
$LN110@Run:
  002e4	00 00 00 00	 DD	 $LN11@Run
  002e8	00 00 00 00	 DD	 $LN13@Run
  002ec	00 00 00 00	 DD	 $LN7@Run
  002f0	00 00 00 00	 DD	 $LN4@Run
?Run@CNewPVP@@QAEXXZ ENDP				; CNewPVP::Run
_TEXT	ENDS
PUBLIC	??_C@_0CI@IAEKOLGJ@?$FLNewPVP?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Duel?5Started?5?$FL@ ; `string'
PUBLIC	??_C@_0CE@LJCBPGFB@m_DuelChannel?$FLnId?$FN?4nStatus?$DN?$DNDC_I@ ; `string'
PUBLIC	??_C@_0BK@MOPMHAKE@ENEWPVP?3?3E_NOT_EXIST_USER?$AA@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?Join@CNewPVP@@QAEHAAUOBJECTSTRUCT@@0@Z		; CNewPVP::Join
EXTRN	?GCMoneySend@@YAXHK@Z:PROC			; GCMoneySend
;	COMDAT ??_C@_0CI@IAEKOLGJ@?$FLNewPVP?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Duel?5Started?5?$FL@
; File c:\muserver_dev\development\mu-s8ep2-repack\gameserver\source\newpvp.h
CONST	SEGMENT
??_C@_0CI@IAEKOLGJ@?$FLNewPVP?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Duel?5Started?5?$FL@ DB '['
	DB	'NewPVP] [%s][%s] Duel Started [%s][%s]', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@LJCBPGFB@m_DuelChannel?$FLnId?$FN?4nStatus?$DN?$DNDC_I@
CONST	SEGMENT
??_C@_0CE@LJCBPGFB@m_DuelChannel?$FLnId?$FN?4nStatus?$DN?$DNDC_I@ DB 'm_D'
	DB	'uelChannel[nId].nStatus==DC_IDLE', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@MOPMHAKE@ENEWPVP?3?3E_NOT_EXIST_USER?$AA@
CONST	SEGMENT
??_C@_0BK@MOPMHAKE@ENEWPVP?3?3E_NOT_EXIST_USER?$AA@ DB 'ENEWPVP::E_NOT_EX'
	DB	'IST_USER', 00H				; `string'
; Function compile flags: /Ogtp
; File c:\muserver_dev\development\mu-s8ep2-repack\gameserver\source\newpvp.cpp
CONST	ENDS
;	COMDAT ?Join@CNewPVP@@QAEHAAUOBJECTSTRUCT@@0@Z
_TEXT	SEGMENT
_lpData$ = -32						; size = 4
_iter$ = -32						; size = 4
_nId$ = -28						; size = 4
_res$ = -24						; size = 17
__$ArrayPad$ = -4					; size = 4
_requester$ = 8						; size = 4
_responsor$ = 12					; size = 4
?Join@CNewPVP@@QAEHAAUOBJECTSTRUCT@@0@Z PROC		; CNewPVP::Join, COMDAT
; _this$ = ecx

; 368  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	8b 75 08	 mov	 esi, DWORD PTR _requester$[ebp]

; 369  : 	if( IsDuel(requester) ) return ENEWPVP::E_ALREADY_DUELLING_1;

  00015	8b 86 50 12 00
	00		 mov	 eax, DWORD PTR [esi+4688]
  0001b	57		 push	 edi
  0001c	8b 7d 0c	 mov	 edi, DWORD PTR _responsor$[ebp]
  0001f	8b d9		 mov	 ebx, ecx
  00021	85 c0		 test	 eax, eax
  00023	78 28		 js	 SHORT $LN16@Join
  00025	33 c9		 xor	 ecx, ecx
  00027	3d eb 2c 00 00	 cmp	 eax, 11499		; 00002cebH
  0002c	0f 9e c1	 setle	 cl
  0002f	8b c1		 mov	 eax, ecx
  00031	85 c0		 test	 eax, eax
  00033	74 18		 je	 SHORT $LN16@Join
  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	b8 17 00 00 00	 mov	 eax, 23			; 00000017H
  0003c	5b		 pop	 ebx

; 435  : }

  0003d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00040	33 cd		 xor	 ecx, ebp
  00042	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c2 08 00	 ret	 8
$LN16@Join:

; 370  : 	if( IsDuelReserved(responsor) ) return ENEWPVP::E_ALREADY_DUELRESERVED_1;

  0004d	8b 87 48 12 00
	00		 mov	 eax, DWORD PTR [edi+4680]
  00053	85 c0		 test	 eax, eax
  00055	78 28		 js	 SHORT $LN15@Join
  00057	33 d2		 xor	 edx, edx
  00059	3d eb 2c 00 00	 cmp	 eax, 11499		; 00002cebH
  0005e	0f 9e c2	 setle	 dl
  00061	8b c2		 mov	 eax, edx
  00063	85 c0		 test	 eax, eax
  00065	74 18		 je	 SHORT $LN15@Join
  00067	5f		 pop	 edi
  00068	5e		 pop	 esi
  00069	b8 16 00 00 00	 mov	 eax, 22			; 00000016H
  0006e	5b		 pop	 ebx

; 435  : }

  0006f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00072	33 cd		 xor	 ecx, ebp
  00074	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00079	8b e5		 mov	 esp, ebp
  0007b	5d		 pop	 ebp
  0007c	c2 08 00	 ret	 8
$LN15@Join:

; 371  : 	if( requester.m_iDuelUserReserved != responsor.m_Index ) return ENEWPVP::E_INVITE_MYSELF;

  0007f	8b 86 48 12 00
	00		 mov	 eax, DWORD PTR [esi+4680]
  00085	3b 07		 cmp	 eax, DWORD PTR [edi]
  00087	74 18		 je	 SHORT $LN14@Join
  00089	5f		 pop	 edi
  0008a	5e		 pop	 esi
  0008b	b8 0a 00 00 00	 mov	 eax, 10			; 0000000aH
  00090	5b		 pop	 ebx

; 435  : }

  00091	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00094	33 cd		 xor	 ecx, ebp
  00096	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0009b	8b e5		 mov	 esp, ebp
  0009d	5d		 pop	 ebp
  0009e	c2 08 00	 ret	 8
$LN14@Join:

; 372  : 
; 373  : 	std::map<int, _tagWaiting>::iterator iter = m_Waiting.find(requester.m_Index); 

  000a1	56		 push	 esi
  000a2	8d 4d e0	 lea	 ecx, DWORD PTR _iter$[ebp]
  000a5	51		 push	 ecx
  000a6	8d 8b 14 01 00
	00		 lea	 ecx, DWORD PTR [ebx+276]
  000ac	e8 00 00 00 00	 call	 ?find@?$_Tree@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@$0A@@std@@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> >,0> >::find

; 374  : 	if(!(iter!=m_Waiting.end())){ LogAddTD("%s\t%s\t%s\t%s\t%d","iter!=m_Waiting.end()","ENEWPVP::E_NOT_EXIST_USER","NULL", __FILE__,  __LINE__); return ENEWPVP::E_NOT_EXIST_USER; }

  000b1	8b 45 e0	 mov	 eax, DWORD PTR _iter$[ebp]
  000b4	3b 83 18 01 00
	00		 cmp	 eax, DWORD PTR [ebx+280]
  000ba	75 3f		 jne	 SHORT $LN13@Join
  000bc	68 76 01 00 00	 push	 374			; 00000176H
  000c1	68 00 00 00 00	 push	 OFFSET ??_C@_0L@IGELOCEA@NewPVP?4cpp?$AA@
  000c6	68 00 00 00 00	 push	 OFFSET ??_C@_04HIBGFPH@NULL?$AA@
  000cb	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@MOPMHAKE@ENEWPVP?3?3E_NOT_EXIST_USER?$AA@
  000d0	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@NENFJOPG@iter?$CB?$DNm_Waiting?4end?$CI?$CJ?$AA@
  000d5	68 00 00 00 00	 push	 OFFSET ??_C@_0P@ENJPCMFP@?$CFs?7?$CFs?7?$CFs?7?$CFs?7?$CFd?$AA@
  000da	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  000e0	83 c4 18	 add	 esp, 24			; 00000018H
  000e3	5f		 pop	 edi
  000e4	5e		 pop	 esi
  000e5	b8 1a 00 00 00	 mov	 eax, 26			; 0000001aH
  000ea	5b		 pop	 ebx

; 435  : }

  000eb	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000ee	33 cd		 xor	 ecx, ebp
  000f0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000f5	8b e5		 mov	 esp, ebp
  000f7	5d		 pop	 ebp
  000f8	c2 08 00	 ret	 8
$LN13@Join:

; 375  : 
; 376  : 	_tagWaiting & waiting = iter->second;
; 377  : 	waiting.bExpired = 1;
; 378  : 
; 379  : 	int	nId = GetDuelChannelId();

  000fb	8b cb		 mov	 ecx, ebx
  000fd	c7 40 18 01 00
	00 00		 mov	 DWORD PTR [eax+24], 1
  00104	e8 00 00 00 00	 call	 ?GetDuelChannelId@CNewPVP@@AAEHXZ ; CNewPVP::GetDuelChannelId
  00109	89 45 e4	 mov	 DWORD PTR _nId$[ebp], eax

; 380  : 	if( nId < 0 || nId >= DUEL_CHANNEL_MAX ) return ENEWPVP::E_DUEL_MAX;

  0010c	83 f8 03	 cmp	 eax, 3
  0010f	0f 87 53 02 00
	00		 ja	 $LN11@Join

; 381  : 
; 382  : 	if( m_DuelChannel[nId].nStatus != DC_IDLE ){ LogAddTD(  "%s\t%s\t%s\t%s\t%d","m_DuelChannel[nId].nStatus==DC_IDLE","ENEWPVP::E_INVALID_STATUS","NULL", __FILE__, __LINE__); return ENEWPVP::E_INVALID_STATUS; }

  00115	6b c0 2c	 imul	 eax, 44			; 0000002cH
  00118	80 bc 18 86 00
	00 00 00	 cmp	 BYTE PTR [eax+ebx+134], 0
  00120	74 3f		 je	 SHORT $LN10@Join
  00122	68 7e 01 00 00	 push	 382			; 0000017eH
  00127	68 00 00 00 00	 push	 OFFSET ??_C@_0L@IGELOCEA@NewPVP?4cpp?$AA@
  0012c	68 00 00 00 00	 push	 OFFSET ??_C@_04HIBGFPH@NULL?$AA@
  00131	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@PKKMGGKN@ENEWPVP?3?3E_INVALID_STATUS?$AA@
  00136	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@LJCBPGFB@m_DuelChannel?$FLnId?$FN?4nStatus?$DN?$DNDC_I@
  0013b	68 00 00 00 00	 push	 OFFSET ??_C@_0P@ENJPCMFP@?$CFs?7?$CFs?7?$CFs?7?$CFs?7?$CFd?$AA@
  00140	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00146	83 c4 18	 add	 esp, 24			; 00000018H
  00149	5f		 pop	 edi
  0014a	5e		 pop	 esi
  0014b	b8 11 00 00 00	 mov	 eax, 17			; 00000011H
  00150	5b		 pop	 ebx

; 435  : }

  00151	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00154	33 cd		 xor	 ecx, ebp
  00156	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0015b	8b e5		 mov	 esp, ebp
  0015d	5d		 pop	 ebp
  0015e	c2 08 00	 ret	 8
$LN10@Join:

; 383  : 
; 384  : 	MOVE_COMMAND_DATA * lpData = gMoveCommand.GetMoveCommandData(42);	

  00161	6a 2a		 push	 42			; 0000002aH
  00163	b9 00 00 00 00	 mov	 ecx, OFFSET ?gMoveCommand@@3VCMoveCommand@@A ; gMoveCommand
  00168	e8 00 00 00 00	 call	 ?GetMoveCommandData@CMoveCommand@@QAEPAUMOVE_COMMAND_DATA@@H@Z ; CMoveCommand::GetMoveCommandData
  0016d	89 45 e0	 mov	 DWORD PTR _lpData$[ebp], eax

; 385  : 	if( lpData == NULL ){ LogAddTD("%s\t%s\t%s\t%s\t%d","lpData","ENEWPVP::E_NOT_FOUND_MOVEREQUESTDATA","NULL",__FILE__, __LINE__); return ENEWPVP::E_NOT_FOUND_MOVEREQUESTDATA; }

  00170	85 c0		 test	 eax, eax
  00172	75 3f		 jne	 SHORT $LN9@Join
  00174	68 81 01 00 00	 push	 385			; 00000181H
  00179	68 00 00 00 00	 push	 OFFSET ??_C@_0L@IGELOCEA@NewPVP?4cpp?$AA@
  0017e	68 00 00 00 00	 push	 OFFSET ??_C@_04HIBGFPH@NULL?$AA@
  00183	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@DMFJILEL@ENEWPVP?3?3E_NOT_FOUND_MOVEREQUEST@
  00188	68 00 00 00 00	 push	 OFFSET ??_C@_06CEFAPPFE@lpData?$AA@
  0018d	68 00 00 00 00	 push	 OFFSET ??_C@_0P@ENJPCMFP@?$CFs?7?$CFs?7?$CFs?7?$CFs?7?$CFd?$AA@
  00192	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00198	83 c4 18	 add	 esp, 24			; 00000018H
  0019b	5f		 pop	 edi
  0019c	5e		 pop	 esi
  0019d	b8 1d 00 00 00	 mov	 eax, 29			; 0000001dH
  001a2	5b		 pop	 ebx

; 435  : }

  001a3	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001a6	33 cd		 xor	 ecx, ebp
  001a8	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001ad	8b e5		 mov	 esp, ebp
  001af	5d		 pop	 ebp
  001b0	c2 08 00	 ret	 8
$LN9@Join:

; 386  : 
; 387  : 	if( !CheckLimitLevel(requester.m_Index, g_GateRequester[nId]) )	return ENEWPVP::E_LIMIT_LEVEL;

  001b3	8b 55 e4	 mov	 edx, DWORD PTR _nId$[ebp]
  001b6	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR _g_GateRequester[edx*4]
  001bd	8b 0e		 mov	 ecx, DWORD PTR [esi]
  001bf	50		 push	 eax
  001c0	51		 push	 ecx
  001c1	8b cb		 mov	 ecx, ebx
  001c3	e8 00 00 00 00	 call	 ?CheckLimitLevel@CNewPVP@@AAEHHH@Z ; CNewPVP::CheckLimitLevel
  001c8	85 c0		 test	 eax, eax
  001ca	75 18		 jne	 SHORT $LN8@Join
$LN53@Join:
  001cc	5f		 pop	 edi
  001cd	5e		 pop	 esi
  001ce	b8 1c 00 00 00	 mov	 eax, 28			; 0000001cH
  001d3	5b		 pop	 ebx

; 435  : }

  001d4	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001d7	33 cd		 xor	 ecx, ebp
  001d9	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001de	8b e5		 mov	 esp, ebp
  001e0	5d		 pop	 ebp
  001e1	c2 08 00	 ret	 8
$LN8@Join:

; 388  : 	if( !CheckLimitLevel(responsor.m_Index, g_GateResponsor[nId]) ) return ENEWPVP::E_LIMIT_LEVEL;

  001e4	8b 55 e4	 mov	 edx, DWORD PTR _nId$[ebp]
  001e7	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR _g_GateResponsor[edx*4]
  001ee	8b 0f		 mov	 ecx, DWORD PTR [edi]
  001f0	50		 push	 eax
  001f1	51		 push	 ecx
  001f2	8b cb		 mov	 ecx, ebx
  001f4	e8 00 00 00 00	 call	 ?CheckLimitLevel@CNewPVP@@AAEHHH@Z ; CNewPVP::CheckLimitLevel
  001f9	85 c0		 test	 eax, eax
  001fb	74 cf		 je	 SHORT $LN53@Join

; 389  : 
; 390  : 	if( !IsVulcanusMap(requester.MapNumber) )

  001fd	80 be 23 01 00
	00 3f		 cmp	 BYTE PTR [esi+291], 63	; 0000003fH
  00204	74 27		 je	 SHORT $LN4@Join

; 391  : 	{
; 392  : 		if( requester.Money - lpData->NeedZen >= 0 )

  00206	8b 86 cc 00 00
	00		 mov	 eax, DWORD PTR [esi+204]
  0020c	8b 55 e0	 mov	 edx, DWORD PTR _lpData$[ebp]
  0020f	2b 82 04 02 00
	00		 sub	 eax, DWORD PTR [edx+516]
  00215	0f 88 35 01 00
	00		 js	 $LN5@Join

; 393  : 		{
; 394  : 			requester.Money -= lpData->NeedZen;
; 395  : 			GCMoneySend(requester.m_Index, requester.Money);

  0021b	50		 push	 eax
  0021c	89 86 cc 00 00
	00		 mov	 DWORD PTR [esi+204], eax
  00222	8b 06		 mov	 eax, DWORD PTR [esi]
  00224	50		 push	 eax
  00225	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend
  0022a	83 c4 08	 add	 esp, 8
$LN4@Join:

; 398  :    	}
; 399  : 	
; 400  : 	if( !IsVulcanusMap(responsor.MapNumber) )

  0022d	80 bf 23 01 00
	00 3f		 cmp	 BYTE PTR [edi+291], 63	; 0000003fH
  00234	74 27		 je	 SHORT $LN1@Join

; 401  : 	{
; 402  : 		if( responsor.Money - lpData->NeedZen >= 0 )

  00236	8b 87 cc 00 00
	00		 mov	 eax, DWORD PTR [edi+204]
  0023c	8b 4d e0	 mov	 ecx, DWORD PTR _lpData$[ebp]
  0023f	2b 81 04 02 00
	00		 sub	 eax, DWORD PTR [ecx+516]
  00245	0f 88 05 01 00
	00		 js	 $LN5@Join

; 403  : 		{
; 404  : 			responsor.Money -= lpData->NeedZen;
; 405  : 			GCMoneySend(responsor.m_Index, responsor.Money);

  0024b	8b 17		 mov	 edx, DWORD PTR [edi]
  0024d	50		 push	 eax
  0024e	52		 push	 edx
  0024f	89 87 cc 00 00
	00		 mov	 DWORD PTR [edi+204], eax
  00255	e8 00 00 00 00	 call	 ?GCMoneySend@@YAXHK@Z	; GCMoneySend
  0025a	83 c4 08	 add	 esp, 8
$LN1@Join:

; 406  : 		}
; 407  : 		else return ENEWPVP::E_NOT_ENOUGH_MONEY;
; 408  : 	}
; 409  : 
; 410  : 	SetStatus(2, nId, requester, responsor);

  0025d	8b 45 e4	 mov	 eax, DWORD PTR _nId$[ebp]
  00260	57		 push	 edi
  00261	56		 push	 esi
  00262	50		 push	 eax
  00263	6a 02		 push	 2
  00265	8b cb		 mov	 ecx, ebx
  00267	e8 00 00 00 00	 call	 ?SetStatus@CNewPVP@@AAEXHHAAUOBJECTSTRUCT@@0@Z ; CNewPVP::SetStatus

; 411  : 
; 412  : 	PMSG_ANS_DUEL_INVITE res = {0};
; 413  : 	res.h.c = PMHC_BYTE;
; 414  : 	res.h.size = sizeof(PMSG_ANS_DUEL_INVITE);
; 415  : 	res.h.headcode = 0xAA;
; 416  : 	res.h.subcode = 0x01;
; 417  : 	res.nResult = 0x00;
; 418  : 	memcpy(res.szName, responsor.Name, MAX_IDSTRING);
; 419  : 
; 420  : 	res.NumberH = HIBYTE(requester.m_Index);

  0026c	8a 4e 01	 mov	 cl, BYTE PTR [esi+1]

; 421  : 	res.NumberL = LOBYTE(requester.m_Index);

  0026f	0f b6 16	 movzx	 edx, BYTE PTR [esi]
  00272	33 c0		 xor	 eax, eax
  00274	89 45 e9	 mov	 DWORD PTR _res$[ebp+1], eax
  00277	89 45 ed	 mov	 DWORD PTR _res$[ebp+5], eax
  0027a	89 45 f1	 mov	 DWORD PTR _res$[ebp+9], eax
  0027d	89 45 f5	 mov	 DWORD PTR _res$[ebp+13], eax
  00280	88 45 ec	 mov	 BYTE PTR _res$[ebp+4], al

; 422  : 	memcpy(res.szName, requester.Name, MAX_IDSTRING);

  00283	8b 46 5d	 mov	 eax, DWORD PTR [esi+93]
  00286	88 4d ed	 mov	 BYTE PTR _res$[ebp+5], cl
  00289	8b 4e 61	 mov	 ecx, DWORD PTR [esi+97]
  0028c	89 45 ef	 mov	 DWORD PTR _res$[ebp+7], eax

; 423  : 	DataSend(responsor.m_Index, (LPBYTE)&res,res.h.size);

  0028f	6a 11		 push	 17			; 00000011H
  00291	8d 45 e8	 lea	 eax, DWORD PTR _res$[ebp]
  00294	89 4d f3	 mov	 DWORD PTR _res$[ebp+11], ecx
  00297	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00299	88 55 ee	 mov	 BYTE PTR _res$[ebp+6], dl
  0029c	66 8b 56 65	 mov	 dx, WORD PTR [esi+101]
  002a0	50		 push	 eax
  002a1	51		 push	 ecx
  002a2	c7 45 e8 c1 11
	aa 01		 mov	 DWORD PTR _res$[ebp], 27922881 ; 01aa11c1H
  002a9	66 89 55 f7	 mov	 WORD PTR _res$[ebp+15], dx
  002ad	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 424  : 
; 425  : 	res.NumberH = HIBYTE(responsor.m_Index);

  002b2	0f b6 57 01	 movzx	 edx, BYTE PTR [edi+1]

; 426  : 	res.NumberL = LOBYTE(responsor.m_Index);
; 427  : 	memcpy(res.szName, responsor.Name, MAX_IDSTRING);

  002b6	8b 4f 5d	 mov	 ecx, DWORD PTR [edi+93]
  002b9	8a 07		 mov	 al, BYTE PTR [edi]
  002bb	88 55 ed	 mov	 BYTE PTR _res$[ebp+5], dl
  002be	8b 57 61	 mov	 edx, DWORD PTR [edi+97]
  002c1	89 4d ef	 mov	 DWORD PTR _res$[ebp+7], ecx

; 428  : 	DataSend(requester.m_Index, (LPBYTE)&res, res.h.size);

  002c4	0f b6 4d e9	 movzx	 ecx, BYTE PTR _res$[ebp+1]
  002c8	88 45 ee	 mov	 BYTE PTR _res$[ebp+6], al
  002cb	66 8b 47 65	 mov	 ax, WORD PTR [edi+101]
  002cf	89 55 f3	 mov	 DWORD PTR _res$[ebp+11], edx
  002d2	51		 push	 ecx
  002d3	8d 55 e8	 lea	 edx, DWORD PTR _res$[ebp]
  002d6	66 89 45 f7	 mov	 WORD PTR _res$[ebp+15], ax
  002da	8b 06		 mov	 eax, DWORD PTR [esi]
  002dc	52		 push	 edx
  002dd	50		 push	 eax
  002de	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 429  : 	
; 430  : 	BroadcastScore(nId, 1);

  002e3	8b 4d e4	 mov	 ecx, DWORD PTR _nId$[ebp]
  002e6	83 c4 18	 add	 esp, 24			; 00000018H
  002e9	6a 01		 push	 1
  002eb	51		 push	 ecx
  002ec	8b cb		 mov	 ecx, ebx
  002ee	e8 00 00 00 00	 call	 ?BroadcastScore@CNewPVP@@AAEXHE@Z ; CNewPVP::BroadcastScore

; 431  : 	MoveGate(requester.m_Index, g_GateRequester[nId]);

  002f3	8b 55 e4	 mov	 edx, DWORD PTR _nId$[ebp]
  002f6	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR _g_GateRequester[edx*4]
  002fd	8b 0e		 mov	 ecx, DWORD PTR [esi]
  002ff	50		 push	 eax
  00300	51		 push	 ecx
  00301	8b cb		 mov	 ecx, ebx
  00303	e8 00 00 00 00	 call	 ?MoveGate@CNewPVP@@AAEHHH@Z ; CNewPVP::MoveGate

; 432  : 	MoveGate(responsor.m_Index, g_GateResponsor[nId]);

  00308	8b 55 e4	 mov	 edx, DWORD PTR _nId$[ebp]
  0030b	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR _g_GateResponsor[edx*4]
  00312	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00314	50		 push	 eax
  00315	51		 push	 ecx
  00316	8b cb		 mov	 ecx, ebx
  00318	e8 00 00 00 00	 call	 ?MoveGate@CNewPVP@@AAEHHH@Z ; CNewPVP::MoveGate

; 433  : 	LogAddTD("[NewPVP] [%s][%s] Duel Started [%s][%s]",responsor.AccountID,responsor.Name,requester.AccountID, requester.Name);

  0031d	8d 46 5d	 lea	 eax, DWORD PTR [esi+93]
  00320	50		 push	 eax
  00321	83 c6 52	 add	 esi, 82			; 00000052H
  00324	56		 push	 esi
  00325	8d 47 5d	 lea	 eax, DWORD PTR [edi+93]
  00328	50		 push	 eax
  00329	83 c7 52	 add	 edi, 82			; 00000052H
  0032c	57		 push	 edi
  0032d	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@IAEKOLGJ@?$FLNewPVP?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Duel?5Started?5?$FL@
  00332	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00338	83 c4 14	 add	 esp, 20			; 00000014H
  0033b	5f		 pop	 edi

; 434  : 	return 0;

  0033c	33 c0		 xor	 eax, eax
  0033e	5e		 pop	 esi
  0033f	5b		 pop	 ebx

; 435  : }

  00340	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00343	33 cd		 xor	 ecx, ebp
  00345	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0034a	8b e5		 mov	 esp, ebp
  0034c	5d		 pop	 ebp
  0034d	c2 08 00	 ret	 8
$LN5@Join:
  00350	5f		 pop	 edi
  00351	5e		 pop	 esi

; 396  : 		}
; 397  : 		else return ENEWPVP::E_NOT_ENOUGH_MONEY;

  00352	b8 1e 00 00 00	 mov	 eax, 30			; 0000001eH
  00357	5b		 pop	 ebx

; 435  : }

  00358	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0035b	33 cd		 xor	 ecx, ebp
  0035d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00362	8b e5		 mov	 esp, ebp
  00364	5d		 pop	 ebp
  00365	c2 08 00	 ret	 8
$LN11@Join:
  00368	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0036b	5f		 pop	 edi
  0036c	5e		 pop	 esi
  0036d	33 cd		 xor	 ecx, ebp
  0036f	b8 10 00 00 00	 mov	 eax, 16			; 00000010H
  00374	5b		 pop	 ebx
  00375	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0037a	8b e5		 mov	 esp, ebp
  0037c	5d		 pop	 ebp
  0037d	c2 08 00	 ret	 8
?Join@CNewPVP@@QAEHAAUOBJECTSTRUCT@@0@Z ENDP		; CNewPVP::Join
_TEXT	ENDS
PUBLIC	??_C@_0CL@FOKMMDLI@?$FLNewPVP?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Win?5Duel?0?5Lose@ ; `string'
PUBLIC	?CheckScore@CNewPVP@@QAEXAAUOBJECTSTRUCT@@0@Z	; CNewPVP::CheckScore
EXTRN	?ReSetTarget@CDarkSpirit@@QAEXH@Z:PROC		; CDarkSpirit::ReSetTarget
EXTRN	?gDarkSpirit@@3PAVCDarkSpirit@@A:BYTE		; gDarkSpirit
EXTRN	?gObjAddBuffEffect@@YA_NPAUOBJECTSTRUCT@@H@Z:PROC ; gObjAddBuffEffect
;	COMDAT ??_C@_0CL@FOKMMDLI@?$FLNewPVP?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Win?5Duel?0?5Lose@
CONST	SEGMENT
??_C@_0CL@FOKMMDLI@?$FLNewPVP?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Win?5Duel?0?5Lose@ DB '['
	DB	'NewPVP] [%s][%s] Win Duel, Loser [%s][%s]', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?CheckScore@CNewPVP@@QAEXAAUOBJECTSTRUCT@@0@Z
_TEXT	SEGMENT
_responsor$ = -4					; size = 4
_obj$ = 8						; size = 4
_target$ = 12						; size = 4
?CheckScore@CNewPVP@@QAEXAAUOBJECTSTRUCT@@0@Z PROC	; CNewPVP::CheckScore, COMDAT
; _this$ = ecx

; 542  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 543  : 	int nId = GetDuelChannelId(obj.m_Index);

  00004	8b 45 08	 mov	 eax, DWORD PTR _obj$[ebp]
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000c	57		 push	 edi
  0000d	51		 push	 ecx
  0000e	8b ce		 mov	 ecx, esi
  00010	e8 00 00 00 00	 call	 ?GetDuelChannelId@CNewPVP@@AAEHH@Z ; CNewPVP::GetDuelChannelId
  00015	8b f8		 mov	 edi, eax

; 544  : 	if(nId < 0 || nId >= DUEL_CHANNEL_MAX){ LogAddTD("%s\t%s\t%s\t%s\t%d","nId>=0 && nId<DUEL_CHANNEL_MAX","0","NULL",__FILE__, __LINE__); return; }

  00017	83 ff 03	 cmp	 edi, 3
  0001a	0f 87 35 01 00
	00		 ja	 $LN4@CheckScore

; 545  : 	if( !IS_START(m_DuelChannel[nId].nStatus) ) { LogAddTD("%s\t%s\t%s\t%s\t%d","IS_START(m_DuelChannel[nId].nStatus)", "0","NULL",__FILE__, __LINE__); return; }

  00020	6b c0 2c	 imul	 eax, 44			; 0000002cH
  00023	8a 8c 30 86 00
	00 00		 mov	 cl, BYTE PTR [eax+esi+134]
  0002a	80 f9 02	 cmp	 cl, 2
  0002d	0f 82 f3 00 00
	00		 jb	 $LN2@CheckScore
  00033	80 f9 04	 cmp	 cl, 4
  00036	0f 87 ea 00 00
	00		 ja	 $LN2@CheckScore

; 546  : 
; 547  : 	LPDUEL_CHANNEL lpChannel = &m_DuelChannel[nId];
; 548  : 
; 549  : 	OBJECTSTRUCT & requester = gObj[lpChannel->nIndex1];

  0003c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00042	53		 push	 ebx
  00043	8b 5c 30 68	 mov	 ebx, DWORD PTR [eax+esi+104]

; 550  : 	OBJECTSTRUCT & responsor = gObj[lpChannel->nIndex2];

  00047	8b 44 30 6c	 mov	 eax, DWORD PTR [eax+esi+108]
  0004b	69 db 40 27 00
	00		 imul	 ebx, 10048		; 00002740H
  00051	69 c0 40 27 00
	00		 imul	 eax, 10048		; 00002740H
  00057	03 c1		 add	 eax, ecx
  00059	89 45 fc	 mov	 DWORD PTR _responsor$[ebp], eax

; 551  : 
; 552  : 	if( obj.m_btDuelScore >= 10 )

  0005c	8b 45 08	 mov	 eax, DWORD PTR _obj$[ebp]
  0005f	03 d9		 add	 ebx, ecx
  00061	80 b8 54 12 00
	00 0a		 cmp	 BYTE PTR [eax+4692], 10	; 0000000aH

; 553  :     {
; 554  : 		BroadcastDuelInfo( nId, 2);

  00068	8b ce		 mov	 ecx, esi
  0006a	0f 82 96 00 00
	00		 jb	 $LN1@CheckScore
  00070	6a 02		 push	 2
  00072	57		 push	 edi
  00073	e8 00 00 00 00	 call	 ?BroadcastDuelInfo@CNewPVP@@AAEXHE@Z ; CNewPVP::BroadcastDuelInfo

; 555  :         BroadcastScore( nId, 3);

  00078	6a 03		 push	 3
  0007a	57		 push	 edi
  0007b	8b ce		 mov	 ecx, esi
  0007d	e8 00 00 00 00	 call	 ?BroadcastScore@CNewPVP@@AAEXHE@Z ; CNewPVP::BroadcastScore

; 556  :         SetStatus(DC_RESERVEDEND, nId, requester, responsor);

  00082	8b 4d fc	 mov	 ecx, DWORD PTR _responsor$[ebp]
  00085	51		 push	 ecx
  00086	53		 push	 ebx
  00087	57		 push	 edi
  00088	6a 05		 push	 5
  0008a	8b ce		 mov	 ecx, esi
  0008c	e8 00 00 00 00	 call	 ?SetStatus@CNewPVP@@AAEXHHAAUOBJECTSTRUCT@@0@Z ; CNewPVP::SetStatus

; 557  :         BroadcastResult( nId, 3, obj);

  00091	8b 55 08	 mov	 edx, DWORD PTR _obj$[ebp]
  00094	52		 push	 edx
  00095	6a 03		 push	 3
  00097	57		 push	 edi
  00098	8b ce		 mov	 ecx, esi
  0009a	e8 00 00 00 00	 call	 ?BroadcastResult@CNewPVP@@AAEXHEAAUOBJECTSTRUCT@@@Z ; CNewPVP::BroadcastResult

; 558  : 
; 559  : 		gObjAddBuffEffect(&obj, 103);

  0009f	8b 75 08	 mov	 esi, DWORD PTR _obj$[ebp]
  000a2	6a 67		 push	 103			; 00000067H
  000a4	56		 push	 esi
  000a5	e8 00 00 00 00	 call	 ?gObjAddBuffEffect@@YA_NPAUOBJECTSTRUCT@@H@Z ; gObjAddBuffEffect

; 560  : 
; 561  :         gDarkSpirit[requester.m_Index].ReSetTarget(responsor.m_Index);

  000aa	8b 7d fc	 mov	 edi, DWORD PTR _responsor$[ebp]
  000ad	8b 07		 mov	 eax, DWORD PTR [edi]
  000af	83 c4 08	 add	 esp, 8
  000b2	50		 push	 eax
  000b3	8b 03		 mov	 eax, DWORD PTR [ebx]
  000b5	8d 0c 40	 lea	 ecx, DWORD PTR [eax+eax*2]
  000b8	c1 e1 04	 shl	 ecx, 4
  000bb	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?gDarkSpirit@@3PAVCDarkSpirit@@A ; gDarkSpirit
  000c1	e8 00 00 00 00	 call	 ?ReSetTarget@CDarkSpirit@@QAEXH@Z ; CDarkSpirit::ReSetTarget

; 562  :         gDarkSpirit[responsor.m_Index].ReSetTarget(requester.m_Index);

  000c6	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  000c8	8b 07		 mov	 eax, DWORD PTR [edi]
  000ca	51		 push	 ecx
  000cb	8d 0c 40	 lea	 ecx, DWORD PTR [eax+eax*2]
  000ce	c1 e1 04	 shl	 ecx, 4
  000d1	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?gDarkSpirit@@3PAVCDarkSpirit@@A ; gDarkSpirit
  000d7	e8 00 00 00 00	 call	 ?ReSetTarget@CDarkSpirit@@QAEXH@Z ; CDarkSpirit::ReSetTarget

; 563  :         
; 564  : 		LogAdd("[NewPVP] [%s][%s] Win Duel, Loser [%s][%s]", obj.AccountID, obj.Name, target.AccountID, target.Name);   

  000dc	8b 45 0c	 mov	 eax, DWORD PTR _target$[ebp]
  000df	8d 50 5d	 lea	 edx, DWORD PTR [eax+93]
  000e2	52		 push	 edx
  000e3	83 c0 52	 add	 eax, 82			; 00000052H
  000e6	50		 push	 eax
  000e7	8d 46 5d	 lea	 eax, DWORD PTR [esi+93]
  000ea	50		 push	 eax
  000eb	83 c6 52	 add	 esi, 82			; 00000052H
  000ee	56		 push	 esi
  000ef	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@FOKMMDLI@?$FLNewPVP?$FN?5?$FL?$CFs?$FN?$FL?$CFs?$FN?5Win?5Duel?0?5Lose@
  000f4	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  000fa	83 c4 14	 add	 esp, 20			; 00000014H
  000fd	5b		 pop	 ebx
  000fe	5f		 pop	 edi
  000ff	5e		 pop	 esi

; 570  : }

  00100	8b e5		 mov	 esp, ebp
  00102	5d		 pop	 ebp
  00103	c2 08 00	 ret	 8
$LN1@CheckScore:

; 565  : 		return;
; 566  : 	}
; 567  : 
; 568  : 	BroadcastScore(nId, 3);

  00106	6a 03		 push	 3
  00108	57		 push	 edi
  00109	e8 00 00 00 00	 call	 ?BroadcastScore@CNewPVP@@AAEXHE@Z ; CNewPVP::BroadcastScore

; 569  :     SetStatus(4, nId, requester, responsor);

  0010e	8b 4d fc	 mov	 ecx, DWORD PTR _responsor$[ebp]
  00111	51		 push	 ecx
  00112	53		 push	 ebx
  00113	57		 push	 edi
  00114	6a 04		 push	 4
  00116	8b ce		 mov	 ecx, esi
  00118	e8 00 00 00 00	 call	 ?SetStatus@CNewPVP@@AAEXHHAAUOBJECTSTRUCT@@0@Z ; CNewPVP::SetStatus
  0011d	5b		 pop	 ebx
  0011e	5f		 pop	 edi
  0011f	5e		 pop	 esi

; 570  : }

  00120	8b e5		 mov	 esp, ebp
  00122	5d		 pop	 ebp
  00123	c2 08 00	 ret	 8
$LN2@CheckScore:

; 545  : 	if( !IS_START(m_DuelChannel[nId].nStatus) ) { LogAddTD("%s\t%s\t%s\t%s\t%d","IS_START(m_DuelChannel[nId].nStatus)", "0","NULL",__FILE__, __LINE__); return; }

  00126	68 21 02 00 00	 push	 545			; 00000221H
  0012b	68 00 00 00 00	 push	 OFFSET ??_C@_0L@IGELOCEA@NewPVP?4cpp?$AA@
  00130	68 00 00 00 00	 push	 OFFSET ??_C@_04HIBGFPH@NULL?$AA@
  00135	68 00 00 00 00	 push	 OFFSET ??_C@_01GBGANLPD@0?$AA@
  0013a	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@CINMDLEF@IS_START?$CIm_DuelChannel?$FLnId?$FN?4nSta@
  0013f	68 00 00 00 00	 push	 OFFSET ??_C@_0P@ENJPCMFP@?$CFs?7?$CFs?7?$CFs?7?$CFs?7?$CFd?$AA@
  00144	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0014a	83 c4 18	 add	 esp, 24			; 00000018H
  0014d	5f		 pop	 edi
  0014e	5e		 pop	 esi

; 570  : }

  0014f	8b e5		 mov	 esp, ebp
  00151	5d		 pop	 ebp
  00152	c2 08 00	 ret	 8
$LN4@CheckScore:

; 544  : 	if(nId < 0 || nId >= DUEL_CHANNEL_MAX){ LogAddTD("%s\t%s\t%s\t%s\t%d","nId>=0 && nId<DUEL_CHANNEL_MAX","0","NULL",__FILE__, __LINE__); return; }

  00155	68 20 02 00 00	 push	 544			; 00000220H
  0015a	68 00 00 00 00	 push	 OFFSET ??_C@_0L@IGELOCEA@NewPVP?4cpp?$AA@
  0015f	68 00 00 00 00	 push	 OFFSET ??_C@_04HIBGFPH@NULL?$AA@
  00164	68 00 00 00 00	 push	 OFFSET ??_C@_01GBGANLPD@0?$AA@
  00169	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@OMAPJGHA@nId?$DO?$DN0?5?$CG?$CG?5nId?$DMDUEL_CHANNEL_MAX?$AA@
  0016e	68 00 00 00 00	 push	 OFFSET ??_C@_0P@ENJPCMFP@?$CFs?7?$CFs?7?$CFs?7?$CFs?7?$CFd?$AA@
  00173	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00179	83 c4 18	 add	 esp, 24			; 00000018H
  0017c	5f		 pop	 edi
  0017d	5e		 pop	 esi

; 570  : }

  0017e	8b e5		 mov	 esp, ebp
  00180	5d		 pop	 ebp
  00181	c2 08 00	 ret	 8
?CheckScore@CNewPVP@@QAEXAAUOBJECTSTRUCT@@0@Z ENDP	; CNewPVP::CheckScore
_TEXT	ENDS
PUBLIC	??_C@_02PCIJFNDE@?$AN?6?$AA@			; `string'
PUBLIC	??_C@_03CGNBMCEI@?$CFs?0?$AA@			; `string'
PUBLIC	??_C@_07LCGEGCHP@?$CFs?$CI?$CFd?$CJ?3?$AA@	; `string'
PUBLIC	??_C@_0CF@OEOKBHOF@?$FLNewPVP?$FN?5ChannelId?$FL?$CFd?$FN?5Count?$FL?$CFd?$FN@ ; `string'
PUBLIC	??_C@_0BF@JEHEGAMC@?$CBIsDuelReserved?$CIobj?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0CA@KJOHBDGM@ENEWPVP?3?3E_ALREADY_DUELRESERVED?$AA@ ; `string'
PUBLIC	??_C@_0BG@JFAHKGBO@?$CBIsDuelRequested?$CIobj?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0CB@MKBHDMEM@ENEWPVP?3?3E_ALREADY_DUELREQUESTED@ ; `string'
PUBLIC	??_C@_0N@MNKFLCMC@?$CBIsDuel?$CIobj?$CJ?$AA@	; `string'
PUBLIC	??_C@_0BM@HJFACEHP@ENEWPVP?3?3E_ALREADY_DUELLING?$AA@ ; `string'
PUBLIC	_obj$GSCopy$
PUBLIC	_this$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?JoinChannel@CNewPVP@@QAEHHAAUOBJECTSTRUCT@@@Z	; CNewPVP::JoinChannel
;	COMDAT ??_C@_02PCIJFNDE@?$AN?6?$AA@
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
CONST	SEGMENT
??_C@_02PCIJFNDE@?$AN?6?$AA@ DB 0dH, 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03CGNBMCEI@?$CFs?0?$AA@
CONST	SEGMENT
??_C@_03CGNBMCEI@?$CFs?0?$AA@ DB '%s,', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07LCGEGCHP@?$CFs?$CI?$CFd?$CJ?3?$AA@
CONST	SEGMENT
??_C@_07LCGEGCHP@?$CFs?$CI?$CFd?$CJ?3?$AA@ DB '%s(%d):', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@OEOKBHOF@?$FLNewPVP?$FN?5ChannelId?$FL?$CFd?$FN?5Count?$FL?$CFd?$FN@
CONST	SEGMENT
??_C@_0CF@OEOKBHOF@?$FLNewPVP?$FN?5ChannelId?$FL?$CFd?$FN?5Count?$FL?$CFd?$FN@ DB '['
	DB	'NewPVP] ChannelId[%d] Count[%d][%d]', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@JEHEGAMC@?$CBIsDuelReserved?$CIobj?$CJ?$AA@
CONST	SEGMENT
??_C@_0BF@JEHEGAMC@?$CBIsDuelReserved?$CIobj?$CJ?$AA@ DB '!IsDuelReserved'
	DB	'(obj)', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@KJOHBDGM@ENEWPVP?3?3E_ALREADY_DUELRESERVED?$AA@
CONST	SEGMENT
??_C@_0CA@KJOHBDGM@ENEWPVP?3?3E_ALREADY_DUELRESERVED?$AA@ DB 'ENEWPVP::E_'
	DB	'ALREADY_DUELRESERVED', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@JFAHKGBO@?$CBIsDuelRequested?$CIobj?$CJ?$AA@
CONST	SEGMENT
??_C@_0BG@JFAHKGBO@?$CBIsDuelRequested?$CIobj?$CJ?$AA@ DB '!IsDuelRequest'
	DB	'ed(obj)', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@MKBHDMEM@ENEWPVP?3?3E_ALREADY_DUELREQUESTED@
CONST	SEGMENT
??_C@_0CB@MKBHDMEM@ENEWPVP?3?3E_ALREADY_DUELREQUESTED@ DB 'ENEWPVP::E_ALR'
	DB	'EADY_DUELREQUESTED', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@MNKFLCMC@?$CBIsDuel?$CIobj?$CJ?$AA@
CONST	SEGMENT
??_C@_0N@MNKFLCMC@?$CBIsDuel?$CIobj?$CJ?$AA@ DB '!IsDuel(obj)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@HJFACEHP@ENEWPVP?3?3E_ALREADY_DUELLING?$AA@
CONST	SEGMENT
??_C@_0BM@HJFACEHP@ENEWPVP?3?3E_ALREADY_DUELLING?$AA@ DB 'ENEWPVP::E_ALRE'
	DB	'ADY_DUELLING', 00H				; `string'
; Function compile flags: /Ogtp
; File c:\muserver_dev\development\mu-s8ep2-repack\gameserver\source\newpvp.cpp
CONST	ENDS
;	COMDAT ?JoinChannel@CNewPVP@@QAEHHAAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
$T188319 = -204						; size = 24
_pair$ = -180						; size = 8
_iter$ = -176						; size = 4
_info$ = -172						; size = 20
tv631 = -152						; size = 4
_obj$GSCopy$ = -152					; size = 4
_this$GSCopy$ = -148					; size = 4
_n$188390 = -148					; size = 4
_Msg$ = -144						; size = 105
_res$ = -36						; size = 30
__$ArrayPad$ = -4					; size = 4
_nId$ = 8						; size = 4
_obj$ = 12						; size = 4
?JoinChannel@CNewPVP@@QAEHHAAUOBJECTSTRUCT@@@Z PROC	; CNewPVP::JoinChannel, COMDAT
; _this$ = ecx

; 763  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	8b 5d 08	 mov	 ebx, DWORD PTR _nId$[ebp]
  00017	56		 push	 esi
  00018	8b 75 0c	 mov	 esi, DWORD PTR _obj$[ebp]

; 764  : 	if( IsDuel(obj) ){ LogAddTD("%s\t%s\t%s\t%s\t%d","!IsDuel(obj)","ENEWPVP::E_ALREADY_DUELLING", "NULL", __FILE__,  __LINE__); return ENEWPVP::E_ALREADY_DUELLING; }

  0001b	8b 86 50 12 00
	00		 mov	 eax, DWORD PTR [esi+4688]

; 825  : 	}
; 826  : 	
; 827  : 	CheckChannelListInfo( nId);

  00021	89 8d 6c ff ff
	ff		 mov	 DWORD PTR _this$GSCopy$[ebp], ecx
  00027	89 b5 68 ff ff
	ff		 mov	 DWORD PTR _obj$GSCopy$[ebp], esi
  0002d	85 c0		 test	 eax, eax
  0002f	78 4e		 js	 SHORT $LN15@JoinChanne

; 764  : 	if( IsDuel(obj) ){ LogAddTD("%s\t%s\t%s\t%s\t%d","!IsDuel(obj)","ENEWPVP::E_ALREADY_DUELLING", "NULL", __FILE__,  __LINE__); return ENEWPVP::E_ALREADY_DUELLING; }

  00031	33 d2		 xor	 edx, edx
  00033	3d eb 2c 00 00	 cmp	 eax, 11499		; 00002cebH
  00038	0f 9e c2	 setle	 dl
  0003b	8b c2		 mov	 eax, edx
  0003d	85 c0		 test	 eax, eax
  0003f	74 3e		 je	 SHORT $LN15@JoinChanne
  00041	68 fc 02 00 00	 push	 764			; 000002fcH
  00046	68 00 00 00 00	 push	 OFFSET ??_C@_0L@IGELOCEA@NewPVP?4cpp?$AA@
  0004b	68 00 00 00 00	 push	 OFFSET ??_C@_04HIBGFPH@NULL?$AA@
  00050	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@HJFACEHP@ENEWPVP?3?3E_ALREADY_DUELLING?$AA@
  00055	68 00 00 00 00	 push	 OFFSET ??_C@_0N@MNKFLCMC@?$CBIsDuel?$CIobj?$CJ?$AA@
  0005a	68 00 00 00 00	 push	 OFFSET ??_C@_0P@ENJPCMFP@?$CFs?7?$CFs?7?$CFs?7?$CFs?7?$CFd?$AA@
  0005f	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00065	83 c4 18	 add	 esp, 24			; 00000018H
  00068	5e		 pop	 esi
  00069	b8 14 00 00 00	 mov	 eax, 20			; 00000014H
  0006e	5b		 pop	 ebx

; 833  : }

  0006f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00072	33 cd		 xor	 ecx, ebp
  00074	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00079	8b e5		 mov	 esp, ebp
  0007b	5d		 pop	 ebp
  0007c	c2 08 00	 ret	 8
$LN15@JoinChanne:

; 765  : 	if( IsDuelRequested(obj) ){ LogAddTD("%s\t%s\t%s\t%s\t%d","!IsDuelRequested(obj)","ENEWPVP::E_ALREADY_DUELREQUESTED","NULL",  __FILE__,  __LINE__); return ENEWPVP::E_ALREADY_DUELREQUESTED; }

  0007f	8b 86 4c 12 00
	00		 mov	 eax, DWORD PTR [esi+4684]
  00085	85 c0		 test	 eax, eax
  00087	78 4e		 js	 SHORT $LN14@JoinChanne
  00089	33 d2		 xor	 edx, edx
  0008b	3d eb 2c 00 00	 cmp	 eax, 11499		; 00002cebH
  00090	0f 9e c2	 setle	 dl
  00093	8b c2		 mov	 eax, edx
  00095	85 c0		 test	 eax, eax
  00097	74 3e		 je	 SHORT $LN14@JoinChanne
  00099	68 fd 02 00 00	 push	 765			; 000002fdH
  0009e	68 00 00 00 00	 push	 OFFSET ??_C@_0L@IGELOCEA@NewPVP?4cpp?$AA@
  000a3	68 00 00 00 00	 push	 OFFSET ??_C@_04HIBGFPH@NULL?$AA@
  000a8	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@MKBHDMEM@ENEWPVP?3?3E_ALREADY_DUELREQUESTED@
  000ad	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@JFAHKGBO@?$CBIsDuelRequested?$CIobj?$CJ?$AA@
  000b2	68 00 00 00 00	 push	 OFFSET ??_C@_0P@ENJPCMFP@?$CFs?7?$CFs?7?$CFs?7?$CFs?7?$CFd?$AA@
  000b7	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  000bd	83 c4 18	 add	 esp, 24			; 00000018H
  000c0	5e		 pop	 esi
  000c1	b8 12 00 00 00	 mov	 eax, 18			; 00000012H
  000c6	5b		 pop	 ebx

; 833  : }

  000c7	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000ca	33 cd		 xor	 ecx, ebp
  000cc	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000d1	8b e5		 mov	 esp, ebp
  000d3	5d		 pop	 ebp
  000d4	c2 08 00	 ret	 8
$LN14@JoinChanne:

; 766  : 	if( IsDuelReserved(obj) ){ LogAddTD("%s\t%s\t%s\t%s\t%d","!IsDuelReserved(obj)","ENEWPVP::E_ALREADY_DUELRESERVED","NULL", __FILE__,  __LINE__); return ENEWPVP::E_ALREADY_DUELRESERVED; }

  000d7	8b 86 48 12 00
	00		 mov	 eax, DWORD PTR [esi+4680]
  000dd	85 c0		 test	 eax, eax
  000df	78 4e		 js	 SHORT $LN13@JoinChanne
  000e1	33 d2		 xor	 edx, edx
  000e3	3d eb 2c 00 00	 cmp	 eax, 11499		; 00002cebH
  000e8	0f 9e c2	 setle	 dl
  000eb	8b c2		 mov	 eax, edx
  000ed	85 c0		 test	 eax, eax
  000ef	74 3e		 je	 SHORT $LN13@JoinChanne
  000f1	68 fe 02 00 00	 push	 766			; 000002feH
  000f6	68 00 00 00 00	 push	 OFFSET ??_C@_0L@IGELOCEA@NewPVP?4cpp?$AA@
  000fb	68 00 00 00 00	 push	 OFFSET ??_C@_04HIBGFPH@NULL?$AA@
  00100	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@KJOHBDGM@ENEWPVP?3?3E_ALREADY_DUELRESERVED?$AA@
  00105	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@JEHEGAMC@?$CBIsDuelReserved?$CIobj?$CJ?$AA@
  0010a	68 00 00 00 00	 push	 OFFSET ??_C@_0P@ENJPCMFP@?$CFs?7?$CFs?7?$CFs?7?$CFs?7?$CFd?$AA@
  0010f	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00115	83 c4 18	 add	 esp, 24			; 00000018H
  00118	5e		 pop	 esi
  00119	b8 13 00 00 00	 mov	 eax, 19			; 00000013H
  0011e	5b		 pop	 ebx

; 833  : }

  0011f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00122	33 cd		 xor	 ecx, ebp
  00124	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00129	8b e5		 mov	 esp, ebp
  0012b	5d		 pop	 ebp
  0012c	c2 08 00	 ret	 8
$LN13@JoinChanne:

; 767  : 	if(nId < 0 || nId >= DUEL_CHANNEL_MAX){ LogAddTD("%s\t%s\t%s\t%s\t%d","nId>=0 && nId<DUEL_CHANNEL_MAX","ENEWPVP::E_INVALID_CHANNELID","NULL",__FILE__, __LINE__); return ENEWPVP::E_INVALID_CHANNELID; }

  0012f	83 fb 03	 cmp	 ebx, 3
  00132	0f 87 75 03 00
	00		 ja	 $LN11@JoinChanne

; 768  : 	if( !IS_START(m_DuelChannel[nId].nStatus) ){ LogAddTD("%s\t%s\t%s\t%s\t%d","IS_START(m_DuelChannel[nId].nStatus)", "ENEWPVP::E_INVALID_STATUS","NULL",__FILE__, __LINE__); return ENEWPVP::E_INVALID_STATUS; }

  00138	8b c3		 mov	 eax, ebx
  0013a	6b c0 2c	 imul	 eax, 44			; 0000002cH
  0013d	57		 push	 edi
  0013e	8d 3c 08	 lea	 edi, DWORD PTR [eax+ecx]
  00141	8a 87 86 00 00
	00		 mov	 al, BYTE PTR [edi+134]
  00147	3c 02		 cmp	 al, 2
  00149	0f 82 1f 03 00
	00		 jb	 $LN9@JoinChanne
  0014f	3c 04		 cmp	 al, 4
  00151	0f 87 17 03 00
	00		 ja	 $LN9@JoinChanne

; 769  : 	if( m_ObserverCount[nId] + 1 > 10 )	return ENEWPVP::E_OBSERVER_MAX;

  00157	8b 94 99 34 01
	00 00		 mov	 edx, DWORD PTR [ecx+ebx*4+308]
  0015e	42		 inc	 edx
  0015f	83 fa 0a	 cmp	 edx, 10			; 0000000aH
  00162	7e 18		 jle	 SHORT $LN8@JoinChanne
  00164	5f		 pop	 edi
  00165	5e		 pop	 esi
  00166	b8 1b 00 00 00	 mov	 eax, 27			; 0000001bH
  0016b	5b		 pop	 ebx

; 833  : }

  0016c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0016f	33 cd		 xor	 ecx, ebp
  00171	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00176	8b e5		 mov	 esp, ebp
  00178	5d		 pop	 ebp
  00179	c2 08 00	 ret	 8
$LN8@JoinChanne:

; 770  : 	if( !CheckLimitLevel(obj.m_Index, g_GateObserver[nId]) )	return ENEWPVP::E_LIMIT_LEVEL;

  0017c	8b 04 9d 00 00
	00 00		 mov	 eax, DWORD PTR _g_GateObserver[ebx*4]
  00183	8b 16		 mov	 edx, DWORD PTR [esi]
  00185	50		 push	 eax
  00186	52		 push	 edx
  00187	e8 00 00 00 00	 call	 ?CheckLimitLevel@CNewPVP@@AAEHHH@Z ; CNewPVP::CheckLimitLevel
  0018c	85 c0		 test	 eax, eax
  0018e	75 18		 jne	 SHORT $LN7@JoinChanne
  00190	5f		 pop	 edi
  00191	5e		 pop	 esi
  00192	b8 1c 00 00 00	 mov	 eax, 28			; 0000001cH
  00197	5b		 pop	 ebx

; 833  : }

  00198	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0019b	33 cd		 xor	 ecx, ebp
  0019d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001a2	8b e5		 mov	 esp, ebp
  001a4	5d		 pop	 ebp
  001a5	c2 08 00	 ret	 8
$LN7@JoinChanne:

; 771  : 
; 772  : 	std::map<int, _tagObserverInfo>::iterator iter = m_ObserverInfoList.find(obj.m_Index); 

  001a8	8b 8d 6c ff ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  001ae	56		 push	 esi
  001af	8d 85 50 ff ff
	ff		 lea	 eax, DWORD PTR _iter$[ebp]
  001b5	81 c1 24 01 00
	00		 add	 ecx, 292		; 00000124H
  001bb	50		 push	 eax
  001bc	e8 00 00 00 00	 call	 ?find@?$_Tree@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::find

; 773  : 	if( !(iter==m_ObserverInfoList.end()) )	return ENEWPVP::E_FAILED_ENTER;

  001c1	8b 8d 50 ff ff
	ff		 mov	 ecx, DWORD PTR _iter$[ebp]
  001c7	8b 95 6c ff ff
	ff		 mov	 edx, DWORD PTR _this$GSCopy$[ebp]
  001cd	3b 8a 28 01 00
	00		 cmp	 ecx, DWORD PTR [edx+296]
  001d3	0f 85 c2 00 00
	00		 jne	 $LN50@JoinChanne

; 774  : 
; 775  : 	OBJECTSTRUCT & requester = gObj[m_DuelChannel[nId].nIndex1];

  001d9	8b 77 68	 mov	 esi, DWORD PTR [edi+104]

; 776  :     OBJECTSTRUCT & responsor = gObj[m_DuelChannel[nId].nIndex2];

  001dc	8b 7f 6c	 mov	 edi, DWORD PTR [edi+108]
  001df	69 f6 40 27 00
	00		 imul	 esi, 10048		; 00002740H
  001e5	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  001ea	69 ff 40 27 00
	00		 imul	 edi, 10048		; 00002740H
  001f0	03 f0		 add	 esi, eax
  001f2	03 f8		 add	 edi, eax

; 777  : 	
; 778  : 	BroadcastJoinChannel(nId, obj);

  001f4	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _obj$GSCopy$[ebp]
  001fa	50		 push	 eax
  001fb	53		 push	 ebx
  001fc	8b ca		 mov	 ecx, edx
  001fe	e8 00 00 00 00	 call	 ?BroadcastJoinChannel@CNewPVP@@AAEXHAAUOBJECTSTRUCT@@@Z ; CNewPVP::BroadcastJoinChannel

; 779  : 
; 780  : 	ObserverInfo info = {0};

  00203	33 c0		 xor	 eax, eax
  00205	89 85 58 ff ff
	ff		 mov	 DWORD PTR _info$[ebp+4], eax
  0020b	89 85 5c ff ff
	ff		 mov	 DWORD PTR _info$[ebp+8], eax
  00211	89 85 60 ff ff
	ff		 mov	 DWORD PTR _info$[ebp+12], eax
  00217	89 85 64 ff ff
	ff		 mov	 DWORD PTR _info$[ebp+16], eax

; 781  : 	info.nId = nId;
; 782  :     info.nIndex = obj.m_Index;

  0021d	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _obj$GSCopy$[ebp]
  00223	8b 08		 mov	 ecx, DWORD PTR [eax]

; 783  : 	memcpy(info.szName, obj.Name, MAX_IDSTRING);

  00225	8b 50 5d	 mov	 edx, DWORD PTR [eax+93]
  00228	89 8d 58 ff ff
	ff		 mov	 DWORD PTR _info$[ebp+4], ecx
  0022e	8b 48 61	 mov	 ecx, DWORD PTR [eax+97]
  00231	89 95 5c ff ff
	ff		 mov	 DWORD PTR _info$[ebp+8], edx
  00237	66 8b 50 65	 mov	 dx, WORD PTR [eax+101]
  0023b	89 8d 60 ff ff
	ff		 mov	 DWORD PTR _info$[ebp+12], ecx

; 784  : 
; 785  : 	std::pair< std::map<int,_tagObserverInfo>::iterator, bool > pair = m_ObserverInfoList.insert( std::make_pair(obj.m_Index,  info) );

  00241	8d 8d 54 ff ff
	ff		 lea	 ecx, DWORD PTR _info$[ebp]
  00247	51		 push	 ecx
  00248	66 89 95 64 ff
	ff ff		 mov	 WORD PTR _info$[ebp+16], dx
  0024f	50		 push	 eax
  00250	8d 95 34 ff ff
	ff		 lea	 edx, DWORD PTR $T188319[ebp]
  00256	52		 push	 edx
  00257	89 9d 54 ff ff
	ff		 mov	 DWORD PTR _info$[ebp], ebx
  0025d	e8 00 00 00 00	 call	 ??$make_pair@AAHAAU_tagObserverInfo@@@std@@YA?AU?$pair@HU_tagObserverInfo@@@0@AAHAAU_tagObserverInfo@@@Z ; std::make_pair<int &,_tagObserverInfo &>
  00262	8b 8d 6c ff ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  00268	83 c4 0c	 add	 esp, 12			; 0000000cH
  0026b	6a 00		 push	 0
  0026d	50		 push	 eax
  0026e	81 c1 24 01 00
	00		 add	 ecx, 292		; 00000124H
  00274	e8 00 00 00 00	 call	 ??$_Buynode@U?$pair@HU_tagObserverInfo@@@std@@@?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@HU_tagObserverInfo@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::_Buynode<std::pair<int,_tagObserverInfo> >
  00279	8b 8d 6c ff ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$[ebp]
  0027f	50		 push	 eax
  00280	8d 85 4c ff ff
	ff		 lea	 eax, DWORD PTR _pair$[ebp]
  00286	50		 push	 eax
  00287	81 c1 24 01 00
	00		 add	 ecx, 292		; 00000124H
  0028d	e8 00 00 00 00	 call	 ?_Linsert@?$_Tree@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@std@@_N@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@2@_N@Z ; std::_Tree<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::_Linsert

; 786  : 	if(pair.second == false)	return ENEWPVP::E_FAILED_ENTER;

  00292	80 bd 50 ff ff
	ff 00		 cmp	 BYTE PTR _pair$[ebp+4], 0
  00299	75 18		 jne	 SHORT $LN5@JoinChanne
$LN50@JoinChanne:
  0029b	5f		 pop	 edi
  0029c	5e		 pop	 esi
  0029d	b8 19 00 00 00	 mov	 eax, 25			; 00000019H
  002a2	5b		 pop	 ebx

; 833  : }

  002a3	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002a6	33 cd		 xor	 ecx, ebp
  002a8	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002ad	8b e5		 mov	 esp, ebp
  002af	5d		 pop	 ebp
  002b0	c2 08 00	 ret	 8
$LN5@JoinChanne:

; 787  : 
; 788  : 	m_ObserverCount[nId]++;

  002b3	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR _this$GSCopy$[ebp]
  002b9	ff 84 98 34 01
	00 00		 inc	 DWORD PTR [eax+ebx*4+308]

; 789  : 
; 790  : 	PMSG_ANS_DUEL_JOINCNANNEL res = {0};

  002c0	33 c0		 xor	 eax, eax
  002c2	89 45 f5	 mov	 DWORD PTR _res$[ebp+25], eax
  002c5	89 45 dd	 mov	 DWORD PTR _res$[ebp+1], eax
  002c8	89 45 e1	 mov	 DWORD PTR _res$[ebp+5], eax
  002cb	89 45 e9	 mov	 DWORD PTR _res$[ebp+13], eax
  002ce	89 45 e5	 mov	 DWORD PTR _res$[ebp+9], eax
  002d1	89 45 ed	 mov	 DWORD PTR _res$[ebp+17], eax
  002d4	89 45 f1	 mov	 DWORD PTR _res$[ebp+21], eax
  002d7	88 45 f9	 mov	 BYTE PTR _res$[ebp+29], al

; 791  : 	res.h.c = PMHC_BYTE;
; 792  :     res.h.headcode = 0xAA;
; 793  :     res.h.subcode = 0x07;
; 794  :     res.h.size = sizeof(PMSG_ANS_DUEL_JOINCNANNEL);
; 795  : 	res.nResult = 0x00;

  002da	88 45 e0	 mov	 BYTE PTR _res$[ebp+4], al
  002dd	c7 45 dc c1 1e
	aa 07		 mov	 DWORD PTR _res$[ebp], 128589505 ; 07aa1ec1H

; 796  :     res.nChannelId = nId;

  002e4	88 5d e1	 mov	 BYTE PTR _res$[ebp+5], bl

; 797  : 	res.NumberH1 = HIBYTE(requester.m_Index);

  002e7	0f b6 4e 01	 movzx	 ecx, BYTE PTR [esi+1]
  002eb	88 4d f6	 mov	 BYTE PTR _res$[ebp+26], cl

; 798  :     res.NumberL1 = LOBYTE(requester.m_Index);

  002ee	8a 16		 mov	 dl, BYTE PTR [esi]
  002f0	88 55 f7	 mov	 BYTE PTR _res$[ebp+27], dl

; 799  :     res.NumberH2 = HIBYTE(responsor.m_Index);

  002f3	8a 47 01	 mov	 al, BYTE PTR [edi+1]
  002f6	88 45 f8	 mov	 BYTE PTR _res$[ebp+28], al

; 800  :     res.NumberL2 = LOBYTE(responsor.m_Index);

  002f9	0f b6 0f	 movzx	 ecx, BYTE PTR [edi]
  002fc	88 4d f9	 mov	 BYTE PTR _res$[ebp+29], cl

; 801  :     memcpy(res.szName1, requester.Name, MAX_IDSTRING);

  002ff	8b 56 5d	 mov	 edx, DWORD PTR [esi+93]
  00302	89 55 e2	 mov	 DWORD PTR _res$[ebp+6], edx
  00305	8b 46 61	 mov	 eax, DWORD PTR [esi+97]
  00308	89 45 e6	 mov	 DWORD PTR _res$[ebp+10], eax
  0030b	0f b7 4e 65	 movzx	 ecx, WORD PTR [esi+101]
  0030f	66 89 4d ea	 mov	 WORD PTR _res$[ebp+14], cx

; 802  :     memcpy(res.szName2, responsor.Name, MAX_IDSTRING);

  00313	8b 57 5d	 mov	 edx, DWORD PTR [edi+93]
  00316	89 55 ec	 mov	 DWORD PTR _res$[ebp+16], edx
  00319	8b 47 61	 mov	 eax, DWORD PTR [edi+97]
  0031c	89 45 f0	 mov	 DWORD PTR _res$[ebp+20], eax
  0031f	0f b7 4f 65	 movzx	 ecx, WORD PTR [edi+101]

; 803  :     DataSend(obj.m_Index, (LPBYTE)&res,res.h.size);

  00323	8b bd 68 ff ff
	ff		 mov	 edi, DWORD PTR _obj$GSCopy$[ebp]
  00329	8b 07		 mov	 eax, DWORD PTR [edi]
  0032b	6a 1e		 push	 30			; 0000001eH
  0032d	8d 55 dc	 lea	 edx, DWORD PTR _res$[ebp]
  00330	52		 push	 edx
  00331	50		 push	 eax
  00332	66 89 4d f4	 mov	 WORD PTR _res$[ebp+24], cx
  00336	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 804  : 
; 805  : 	PMSG_DUEL_OBSERVERLIST_BROADCAST Msg = {0};

  0033b	6a 68		 push	 104			; 00000068H
  0033d	8d 8d 71 ff ff
	ff		 lea	 ecx, DWORD PTR _Msg$[ebp+1]
  00343	6a 00		 push	 0
  00345	51		 push	 ecx
  00346	e8 00 00 00 00	 call	 _memset

; 806  : 	Msg.h.c = PMHC_BYTE;
; 807  : 	Msg.h.headcode = 0xAA;
; 808  : 	Msg.h.subcode = 0x0B;
; 809  : 	Msg.h.size = sizeof(PMSG_DUEL_OBSERVERLIST_BROADCAST);
; 810  : 
; 811  : 	GetObserverList(nId, Msg);

  0034b	8b b5 6c ff ff
	ff		 mov	 esi, DWORD PTR _this$GSCopy$[ebp]
  00351	83 c4 18	 add	 esp, 24			; 00000018H
  00354	8d 95 70 ff ff
	ff		 lea	 edx, DWORD PTR _Msg$[ebp]
  0035a	52		 push	 edx
  0035b	53		 push	 ebx
  0035c	8b ce		 mov	 ecx, esi
  0035e	c7 85 70 ff ff
	ff c1 69 aa 0b	 mov	 DWORD PTR _Msg$[ebp], 195717569 ; 0baa69c1H
  00368	e8 00 00 00 00	 call	 ?GetObserverList@CNewPVP@@AAEXHAAU_tagPMSG_DUEL_OBSERVERLIST_BROADCAST@@@Z ; CNewPVP::GetObserverList

; 812  : 
; 813  : 	DataSend(obj.m_Index, (LPBYTE)&Msg, Msg.h.size);

  0036d	0f b6 85 71 ff
	ff ff		 movzx	 eax, BYTE PTR _Msg$[ebp+1]
  00374	8b 17		 mov	 edx, DWORD PTR [edi]
  00376	50		 push	 eax
  00377	8d 8d 70 ff ff
	ff		 lea	 ecx, DWORD PTR _Msg$[ebp]
  0037d	51		 push	 ecx
  0037e	52		 push	 edx
  0037f	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 814  : 
; 815  : 	if( Msg.nCount!=m_ObserverCount[nId] )

  00384	0f b6 85 74 ff
	ff ff		 movzx	 eax, BYTE PTR _Msg$[ebp+4]
  0038b	8b 8c 9e 34 01
	00 00		 mov	 ecx, DWORD PTR [esi+ebx*4+308]
  00392	83 c4 0c	 add	 esp, 12			; 0000000cH
  00395	3b c1		 cmp	 eax, ecx
  00397	0f 84 86 00 00
	00		 je	 $LN4@JoinChanne

; 816  :     {
; 817  : 		LogAddTD("[NewPVP] ChannelId[%d] Count[%d][%d]", nId, Msg.nCount, m_ObserverCount[nId]);

  0039d	51		 push	 ecx
  0039e	50		 push	 eax
  0039f	53		 push	 ebx
  003a0	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@OEOKBHOF@?$FLNewPVP?$FN?5ChannelId?$FL?$CFd?$FN?5Count?$FL?$CFd?$FN@
  003a5	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 818  : 		
; 819  : 		DebugLog("%s(%d):",obj.Name,Msg.nCount);

  003ab	0f b6 85 74 ff
	ff ff		 movzx	 eax, BYTE PTR _Msg$[ebp+4]
  003b2	50		 push	 eax
  003b3	8d 47 5d	 lea	 eax, DWORD PTR [edi+93]
  003b6	50		 push	 eax
  003b7	68 00 00 00 00	 push	 OFFSET ??_C@_07LCGEGCHP@?$CFs?$CI?$CFd?$CJ?3?$AA@
  003bc	e8 00 00 00 00	 call	 ?DebugLog@@YAXPADZZ	; DebugLog
  003c1	83 c4 1c	 add	 esp, 28			; 0000001cH

; 820  : 		for(int n = 0; n < Msg.nCount; n++)

  003c4	80 bd 74 ff ff
	ff 00		 cmp	 BYTE PTR _Msg$[ebp+4], 0
  003cb	c7 85 6c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _n$188390[ebp], 0
  003d5	76 3f		 jbe	 SHORT $LN1@JoinChanne

; 816  :     {
; 817  : 		LogAddTD("[NewPVP] ChannelId[%d] Count[%d][%d]", nId, Msg.nCount, m_ObserverCount[nId]);

  003d7	8d 8d 75 ff ff
	ff		 lea	 ecx, DWORD PTR _Msg$[ebp+5]
  003dd	89 8d 68 ff ff
	ff		 mov	 DWORD PTR tv631[ebp], ecx
$LL48@JoinChanne:

; 821  : 		{
; 822  : 			DebugLog("%s,",Msg.user[n].szName);

  003e3	8b 95 68 ff ff
	ff		 mov	 edx, DWORD PTR tv631[ebp]
  003e9	52		 push	 edx
  003ea	68 00 00 00 00	 push	 OFFSET ??_C@_03CGNBMCEI@?$CFs?0?$AA@
  003ef	e8 00 00 00 00	 call	 ?DebugLog@@YAXPADZZ	; DebugLog
  003f4	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR _n$188390[ebp]
  003fa	0f b6 8d 74 ff
	ff ff		 movzx	 ecx, BYTE PTR _Msg$[ebp+4]
  00401	83 85 68 ff ff
	ff 0a		 add	 DWORD PTR tv631[ebp], 10 ; 0000000aH
  00408	40		 inc	 eax
  00409	83 c4 08	 add	 esp, 8
  0040c	89 85 6c ff ff
	ff		 mov	 DWORD PTR _n$188390[ebp], eax
  00412	3b c1		 cmp	 eax, ecx
  00414	7c cd		 jl	 SHORT $LL48@JoinChanne
$LN1@JoinChanne:

; 823  : 		}
; 824  : 		DebugLog("\r\n");

  00416	68 00 00 00 00	 push	 OFFSET ??_C@_02PCIJFNDE@?$AN?6?$AA@
  0041b	e8 00 00 00 00	 call	 ?DebugLog@@YAXPADZZ	; DebugLog
  00420	83 c4 04	 add	 esp, 4
$LN4@JoinChanne:

; 825  : 	}
; 826  : 	
; 827  : 	CheckChannelListInfo( nId);

  00423	53		 push	 ebx
  00424	8b ce		 mov	 ecx, esi
  00426	e8 00 00 00 00	 call	 ?CheckChannelListInfo@CNewPVP@@AAEXH@Z ; CNewPVP::CheckChannelListInfo

; 828  :     BroadcastDuelInfo(nId, 2);

  0042b	6a 02		 push	 2
  0042d	53		 push	 ebx
  0042e	e8 00 00 00 00	 call	 ?BroadcastDuelInfo@CNewPVP@@AAEXHE@Z ; CNewPVP::BroadcastDuelInfo

; 829  :     BroadcastScore(nId, 2);

  00433	6a 02		 push	 2
  00435	53		 push	 ebx
  00436	8b ce		 mov	 ecx, esi
  00438	e8 00 00 00 00	 call	 ?BroadcastScore@CNewPVP@@AAEXHE@Z ; CNewPVP::BroadcastScore

; 830  :     SetBuff(obj, TRUE);

  0043d	6a 01		 push	 1
  0043f	57		 push	 edi
  00440	8b ce		 mov	 ecx, esi
  00442	e8 00 00 00 00	 call	 ?SetBuff@CNewPVP@@QAEXAAUOBJECTSTRUCT@@H@Z ; CNewPVP::SetBuff

; 831  :     MoveGate(obj.m_Index, g_GateObserver[nId]);

  00447	8b 14 9d 00 00
	00 00		 mov	 edx, DWORD PTR _g_GateObserver[ebx*4]
  0044e	8b 07		 mov	 eax, DWORD PTR [edi]
  00450	52		 push	 edx
  00451	50		 push	 eax
  00452	8b ce		 mov	 ecx, esi
  00454	e8 00 00 00 00	 call	 ?MoveGate@CNewPVP@@AAEHHH@Z ; CNewPVP::MoveGate
  00459	5f		 pop	 edi
  0045a	5e		 pop	 esi

; 832  : 	return 0;

  0045b	33 c0		 xor	 eax, eax
  0045d	5b		 pop	 ebx

; 833  : }

  0045e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00461	33 cd		 xor	 ecx, ebp
  00463	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00468	8b e5		 mov	 esp, ebp
  0046a	5d		 pop	 ebp
  0046b	c2 08 00	 ret	 8
$LN9@JoinChanne:

; 768  : 	if( !IS_START(m_DuelChannel[nId].nStatus) ){ LogAddTD("%s\t%s\t%s\t%s\t%d","IS_START(m_DuelChannel[nId].nStatus)", "ENEWPVP::E_INVALID_STATUS","NULL",__FILE__, __LINE__); return ENEWPVP::E_INVALID_STATUS; }

  0046e	68 00 03 00 00	 push	 768			; 00000300H
  00473	68 00 00 00 00	 push	 OFFSET ??_C@_0L@IGELOCEA@NewPVP?4cpp?$AA@
  00478	68 00 00 00 00	 push	 OFFSET ??_C@_04HIBGFPH@NULL?$AA@
  0047d	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@PKKMGGKN@ENEWPVP?3?3E_INVALID_STATUS?$AA@
  00482	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@CINMDLEF@IS_START?$CIm_DuelChannel?$FLnId?$FN?4nSta@
  00487	68 00 00 00 00	 push	 OFFSET ??_C@_0P@ENJPCMFP@?$CFs?7?$CFs?7?$CFs?7?$CFs?7?$CFd?$AA@
  0048c	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00492	83 c4 18	 add	 esp, 24			; 00000018H
  00495	5f		 pop	 edi
  00496	5e		 pop	 esi
  00497	b8 11 00 00 00	 mov	 eax, 17			; 00000011H
  0049c	5b		 pop	 ebx

; 833  : }

  0049d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  004a0	33 cd		 xor	 ecx, ebp
  004a2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  004a7	8b e5		 mov	 esp, ebp
  004a9	5d		 pop	 ebp
  004aa	c2 08 00	 ret	 8
$LN11@JoinChanne:

; 767  : 	if(nId < 0 || nId >= DUEL_CHANNEL_MAX){ LogAddTD("%s\t%s\t%s\t%s\t%d","nId>=0 && nId<DUEL_CHANNEL_MAX","ENEWPVP::E_INVALID_CHANNELID","NULL",__FILE__, __LINE__); return ENEWPVP::E_INVALID_CHANNELID; }

  004ad	68 ff 02 00 00	 push	 767			; 000002ffH
  004b2	68 00 00 00 00	 push	 OFFSET ??_C@_0L@IGELOCEA@NewPVP?4cpp?$AA@
  004b7	68 00 00 00 00	 push	 OFFSET ??_C@_04HIBGFPH@NULL?$AA@
  004bc	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@CPLOFFJH@ENEWPVP?3?3E_INVALID_CHANNELID?$AA@
  004c1	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@OMAPJGHA@nId?$DO?$DN0?5?$CG?$CG?5nId?$DMDUEL_CHANNEL_MAX?$AA@
  004c6	68 00 00 00 00	 push	 OFFSET ??_C@_0P@ENJPCMFP@?$CFs?7?$CFs?7?$CFs?7?$CFs?7?$CFd?$AA@
  004cb	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 833  : }

  004d1	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  004d4	83 c4 18	 add	 esp, 24			; 00000018H
  004d7	5e		 pop	 esi
  004d8	33 cd		 xor	 ecx, ebp
  004da	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  004df	5b		 pop	 ebx
  004e0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  004e5	8b e5		 mov	 esp, ebp
  004e7	5d		 pop	 ebp
  004e8	c2 08 00	 ret	 8
?JoinChannel@CNewPVP@@QAEHHAAUOBJECTSTRUCT@@@Z ENDP	; CNewPVP::JoinChannel
_TEXT	ENDS
PUBLIC	?LeaveChannel@CNewPVP@@QAEHHAAUOBJECTSTRUCT@@@Z	; CNewPVP::LeaveChannel
; Function compile flags: /Ogtp
;	COMDAT ?LeaveChannel@CNewPVP@@QAEHHAAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_res$188425 = -8					; size = 5
$T204342 = 8						; size = 4
_iter$ = 8						; size = 4
_nId$ = 8						; size = 4
_obj$ = 12						; size = 4
?LeaveChannel@CNewPVP@@QAEHHAAUOBJECTSTRUCT@@@Z PROC	; CNewPVP::LeaveChannel, COMDAT
; _this$ = ecx

; 837  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx

; 838  : 	if(nId < 0 || nId >= DUEL_CHANNEL_MAX){ LogAddTD("%s\t%s\t%s\t%s\t%d","nId>=0 && nId<DUEL_CHANNEL_MAX","ENEWPVP::E_INVALID_CHANNELID","NULL",__FILE__, __LINE__); return ENEWPVP::E_INVALID_CHANNELID; }

  00007	8b 5d 08	 mov	 ebx, DWORD PTR _nId$[ebp]
  0000a	56		 push	 esi
  0000b	8b f1		 mov	 esi, ecx
  0000d	83 fb 03	 cmp	 ebx, 3
  00010	0f 87 02 01 00
	00		 ja	 $LN6@LeaveChann@2

; 839  : 	if( !IS_START(m_DuelChannel[nId].nStatus) ){ LogAddTD("%s\t%s\t%s\t%s\t%d","IS_START(m_DuelChannel[nId].nStatus)", "ENEWPVP::E_INVALID_STATUS","NULL",__FILE__, __LINE__); return ENEWPVP::E_INVALID_STATUS; }	

  00016	8b c3		 mov	 eax, ebx
  00018	6b c0 2c	 imul	 eax, 44			; 0000002cH
  0001b	8a 84 30 86 00
	00 00		 mov	 al, BYTE PTR [eax+esi+134]
  00022	3c 02		 cmp	 al, 2
  00024	0f 82 ba 00 00
	00		 jb	 $LN4@LeaveChann@2
  0002a	3c 04		 cmp	 al, 4
  0002c	0f 87 b2 00 00
	00		 ja	 $LN4@LeaveChann@2

; 840  : 
; 841  : 	std::map<int, _tagObserverInfo>::iterator iter = m_ObserverInfoList.find(obj.m_Index); 

  00032	57		 push	 edi
  00033	8b 7d 0c	 mov	 edi, DWORD PTR _obj$[ebp]
  00036	57		 push	 edi
  00037	8d 55 08	 lea	 edx, DWORD PTR _iter$[ebp]
  0003a	8d 8e 24 01 00
	00		 lea	 ecx, DWORD PTR [esi+292]
  00040	52		 push	 edx
  00041	e8 00 00 00 00	 call	 ?find@?$_Tree@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::find

; 842  : 	if(!(iter!=m_ObserverInfoList.end()))	return ENEWPVP::E_NOT_EXIST_USER;

  00046	8b 45 08	 mov	 eax, DWORD PTR _iter$[ebp]
  00049	3b 86 28 01 00
	00		 cmp	 eax, DWORD PTR [esi+296]
  0004f	75 0e		 jne	 SHORT $LN3@LeaveChann@2
  00051	5f		 pop	 edi
  00052	5e		 pop	 esi
  00053	b8 1a 00 00 00	 mov	 eax, 26			; 0000001aH
  00058	5b		 pop	 ebx

; 867  : }

  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c2 08 00	 ret	 8
$LN3@LeaveChann@2:

; 843  : 	m_ObserverInfoList.erase(iter);

  0005f	50		 push	 eax
  00060	8d 45 08	 lea	 eax, DWORD PTR $T204342[ebp]
  00063	50		 push	 eax
  00064	8d 8e 24 01 00
	00		 lea	 ecx, DWORD PTR [esi+292]
  0006a	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::erase

; 844  : 	m_ObserverCount[nId]--;

  0006f	ff 8c 9e 34 01
	00 00		 dec	 DWORD PTR [esi+ebx*4+308]

; 845  : 
; 846  : 	BroadcastLeaveChannel( nId, obj);

  00076	57		 push	 edi
  00077	53		 push	 ebx
  00078	8b ce		 mov	 ecx, esi
  0007a	e8 00 00 00 00	 call	 ?BroadcastLeaveChannel@CNewPVP@@AAEXHAAUOBJECTSTRUCT@@@Z ; CNewPVP::BroadcastLeaveChannel

; 847  : 
; 848  : 	if( gObjIsConnected(&obj) )

  0007f	57		 push	 edi
  00080	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHPAUOBJECTSTRUCT@@@Z ; gObjIsConnected
  00085	83 c4 04	 add	 esp, 4
  00088	85 c0		 test	 eax, eax
  0008a	74 45		 je	 SHORT $LN2@LeaveChann@2

; 849  :     {
; 850  : 		PMSG_ANS_DUEL_LEAVECNANNEL res = {0};
; 851  : 		res.h.c = PMHC_BYTE;
; 852  : 		res.h.headcode = 0xAA;
; 853  : 		res.h.subcode = 0x09;
; 854  : 		res.h.size = sizeof(PMSG_ANS_DUEL_LEAVECNANNEL);
; 855  : 		res.nResult = 0x00;		
; 856  : 		DataSend(obj.m_Index, (LPBYTE)&res, res.h.size);

  0008c	8b 17		 mov	 edx, DWORD PTR [edi]
  0008e	6a 05		 push	 5
  00090	8d 4d f8	 lea	 ecx, DWORD PTR _res$188425[ebp]
  00093	51		 push	 ecx
  00094	c7 45 f9 00 00
	00 00		 mov	 DWORD PTR _res$188425[ebp+1], 0
  0009b	52		 push	 edx
  0009c	c7 45 f8 c1 05
	aa 09		 mov	 DWORD PTR _res$188425[ebp], 162137537 ; 09aa05c1H
  000a3	c6 45 fc 00	 mov	 BYTE PTR _res$188425[ebp+4], 0
  000a7	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  000ac	83 c4 0c	 add	 esp, 12			; 0000000cH

; 857  :           
; 858  : 		if( IsPKFieldMap(obj.MapNumber) )

  000af	80 bf 23 01 00
	00 40		 cmp	 BYTE PTR [edi+291], 64	; 00000040H
  000b6	75 0f		 jne	 SHORT $LN1@LeaveChann@2

; 859  : 		{
; 860  :             MoveGate(obj.m_Index, 294);

  000b8	8b 07		 mov	 eax, DWORD PTR [edi]
  000ba	68 26 01 00 00	 push	 294			; 00000126H
  000bf	50		 push	 eax
  000c0	8b ce		 mov	 ecx, esi
  000c2	e8 00 00 00 00	 call	 ?MoveGate@CNewPVP@@AAEHHH@Z ; CNewPVP::MoveGate
$LN1@LeaveChann@2:

; 861  : 		}
; 862  : 
; 863  : 		SetBuff(obj, FALSE);

  000c7	6a 00		 push	 0
  000c9	57		 push	 edi
  000ca	8b ce		 mov	 ecx, esi
  000cc	e8 00 00 00 00	 call	 ?SetBuff@CNewPVP@@QAEXAAUOBJECTSTRUCT@@H@Z ; CNewPVP::SetBuff
$LN2@LeaveChann@2:

; 864  :     }
; 865  : 	CheckChannelListInfo( nId);

  000d1	53		 push	 ebx
  000d2	8b ce		 mov	 ecx, esi
  000d4	e8 00 00 00 00	 call	 ?CheckChannelListInfo@CNewPVP@@AAEXH@Z ; CNewPVP::CheckChannelListInfo
  000d9	5f		 pop	 edi
  000da	5e		 pop	 esi

; 866  : 	return 0;

  000db	33 c0		 xor	 eax, eax
  000dd	5b		 pop	 ebx

; 867  : }

  000de	8b e5		 mov	 esp, ebp
  000e0	5d		 pop	 ebp
  000e1	c2 08 00	 ret	 8
$LN4@LeaveChann@2:

; 839  : 	if( !IS_START(m_DuelChannel[nId].nStatus) ){ LogAddTD("%s\t%s\t%s\t%s\t%d","IS_START(m_DuelChannel[nId].nStatus)", "ENEWPVP::E_INVALID_STATUS","NULL",__FILE__, __LINE__); return ENEWPVP::E_INVALID_STATUS; }	

  000e4	68 47 03 00 00	 push	 839			; 00000347H
  000e9	68 00 00 00 00	 push	 OFFSET ??_C@_0L@IGELOCEA@NewPVP?4cpp?$AA@
  000ee	68 00 00 00 00	 push	 OFFSET ??_C@_04HIBGFPH@NULL?$AA@
  000f3	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@PKKMGGKN@ENEWPVP?3?3E_INVALID_STATUS?$AA@
  000f8	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@CINMDLEF@IS_START?$CIm_DuelChannel?$FLnId?$FN?4nSta@
  000fd	68 00 00 00 00	 push	 OFFSET ??_C@_0P@ENJPCMFP@?$CFs?7?$CFs?7?$CFs?7?$CFs?7?$CFd?$AA@
  00102	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00108	83 c4 18	 add	 esp, 24			; 00000018H
  0010b	5e		 pop	 esi
  0010c	b8 11 00 00 00	 mov	 eax, 17			; 00000011H
  00111	5b		 pop	 ebx

; 867  : }

  00112	8b e5		 mov	 esp, ebp
  00114	5d		 pop	 ebp
  00115	c2 08 00	 ret	 8
$LN6@LeaveChann@2:

; 838  : 	if(nId < 0 || nId >= DUEL_CHANNEL_MAX){ LogAddTD("%s\t%s\t%s\t%s\t%d","nId>=0 && nId<DUEL_CHANNEL_MAX","ENEWPVP::E_INVALID_CHANNELID","NULL",__FILE__, __LINE__); return ENEWPVP::E_INVALID_CHANNELID; }

  00118	68 46 03 00 00	 push	 838			; 00000346H
  0011d	68 00 00 00 00	 push	 OFFSET ??_C@_0L@IGELOCEA@NewPVP?4cpp?$AA@
  00122	68 00 00 00 00	 push	 OFFSET ??_C@_04HIBGFPH@NULL?$AA@
  00127	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@CPLOFFJH@ENEWPVP?3?3E_INVALID_CHANNELID?$AA@
  0012c	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@OMAPJGHA@nId?$DO?$DN0?5?$CG?$CG?5nId?$DMDUEL_CHANNEL_MAX?$AA@
  00131	68 00 00 00 00	 push	 OFFSET ??_C@_0P@ENJPCMFP@?$CFs?7?$CFs?7?$CFs?7?$CFs?7?$CFd?$AA@
  00136	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0013c	83 c4 18	 add	 esp, 24			; 00000018H
  0013f	5e		 pop	 esi
  00140	b8 18 00 00 00	 mov	 eax, 24			; 00000018H
  00145	5b		 pop	 ebx

; 867  : }

  00146	8b e5		 mov	 esp, ebp
  00148	5d		 pop	 ebp
  00149	c2 08 00	 ret	 8
?LeaveChannel@CNewPVP@@QAEHHAAUOBJECTSTRUCT@@@Z ENDP	; CNewPVP::LeaveChannel
_TEXT	ENDS
PUBLIC	_aIndex$GSCopy$
PUBLIC	_lpMsg$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?OnCGAnswerDuel@@YAHPAU_tagPMSG_ANS_DUEL_ANSWER@@H@Z ; OnCGAnswerDuel
; Function compile flags: /Ogtp
;	COMDAT ?OnCGAnswerDuel@@YAHPAU_tagPMSG_ANS_DUEL_ANSWER@@H@Z
_TEXT	SEGMENT
_lpMsg$GSCopy$ = -32					; size = 4
_aIndex$GSCopy$ = -28					; size = 4
_res$ = -24						; size = 17
__$ArrayPad$ = -4					; size = 4
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?OnCGAnswerDuel@@YAHPAU_tagPMSG_ANS_DUEL_ANSWER@@H@Z PROC ; OnCGAnswerDuel, COMDAT

; 1324 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 08	 mov	 eax, DWORD PTR _lpMsg$[ebp]

; 1325 : 	LPOBJ lpRequester = NULL;
; 1326 : 	LPOBJ lpResponsor = (LPOBJ)&gObj[aIndex];
; 1327 : 	int nRequester = MAKEWORD(lpMsg->NumberL, lpMsg->NumberH);

  00013	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  00017	0f b6 50 06	 movzx	 edx, BYTE PTR [eax+6]
  0001b	53		 push	 ebx
  0001c	8b 5d 0c	 mov	 ebx, DWORD PTR _aIndex$[ebp]
  0001f	56		 push	 esi
  00020	8b f3		 mov	 esi, ebx
  00022	69 f6 40 27 00
	00		 imul	 esi, 10048		; 00002740H
  00028	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0002e	57		 push	 edi
  0002f	66 c1 e1 08	 shl	 cx, 8
  00033	0f b7 f9	 movzx	 edi, cx
  00036	0b fa		 or	 edi, edx

; 1328 : 
; 1329 : 	if( !gObjIsConnected(nRequester) )	return ENEWPVP::E_DISCONNECT;

  00038	57		 push	 edi

; 1346 : 	{
; 1347 : 		g_NewPVP.Cancel(*lpRequester, *lpResponsor, FALSE);

  00039	89 45 e0	 mov	 DWORD PTR _lpMsg$GSCopy$[ebp], eax

; 1376 : 		}
; 1377 : 		res.nResult = nRet;

  0003c	89 5d e4	 mov	 DWORD PTR _aIndex$GSCopy$[ebp], ebx
  0003f	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00044	83 c4 04	 add	 esp, 4
  00047	85 c0		 test	 eax, eax
  00049	75 16		 jne	 SHORT $LN10@OnCGAnswer

; 1328 : 
; 1329 : 	if( !gObjIsConnected(nRequester) )	return ENEWPVP::E_DISCONNECT;

  0004b	5f		 pop	 edi
  0004c	5e		 pop	 esi
  0004d	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH
  00052	5b		 pop	 ebx

; 1384 : }

  00053	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00056	33 cd		 xor	 ecx, ebp
  00058	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0005d	8b e5		 mov	 esp, ebp
  0005f	5d		 pop	 ebp
  00060	c3		 ret	 0
$LN10@OnCGAnswer:

; 1330 : 	lpRequester = (LPOBJ)&gObj[nRequester];
; 1331 : 
; 1332 : 	PMSG_ANS_DUEL_INVITE res = {0};

  00061	33 c0		 xor	 eax, eax
  00063	69 ff 40 27 00
	00		 imul	 edi, 10048		; 00002740H
  00069	03 3d 00 00 00
	00		 add	 edi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0006f	89 45 e9	 mov	 DWORD PTR _res$[ebp+1], eax
  00072	89 45 f1	 mov	 DWORD PTR _res$[ebp+9], eax
  00075	89 45 f5	 mov	 DWORD PTR _res$[ebp+13], eax
  00078	89 45 ed	 mov	 DWORD PTR _res$[ebp+5], eax

; 1333 : 	res.h.c = PMHC_BYTE;

  0007b	c7 45 e8 c1 11
	aa 01		 mov	 DWORD PTR _res$[ebp], 27922881 ; 01aa11c1H

; 1334 : 	res.h.size = sizeof(PMSG_ANS_DUEL_INVITE);
; 1335 : 	res.h.headcode = 0xAA;
; 1336 : 	res.h.subcode = 0x01;	
; 1337 : 	memcpy(res.szName, lpResponsor->Name, MAX_IDSTRING);

  00082	8b 46 5d	 mov	 eax, DWORD PTR [esi+93]
  00085	89 45 ef	 mov	 DWORD PTR _res$[ebp+7], eax
  00088	8b 4e 61	 mov	 ecx, DWORD PTR [esi+97]
  0008b	89 4d f3	 mov	 DWORD PTR _res$[ebp+11], ecx
  0008e	66 8b 56 65	 mov	 dx, WORD PTR [esi+101]
  00092	66 89 55 f7	 mov	 WORD PTR _res$[ebp+15], dx

; 1338 : 	if( lpResponsor->CloseType != -1 )

  00096	80 7e 0d ff	 cmp	 BYTE PTR [esi+13], -1
  0009a	74 3a		 je	 SHORT $LN9@OnCGAnswer

; 1339 : 	{
; 1340 : 		g_NewPVP.Cancel(*lpRequester, *lpResponsor, FALSE);

  0009c	6a 00		 push	 0
  0009e	56		 push	 esi
  0009f	57		 push	 edi
  000a0	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_NewPVP@@3VCNewPVP@@A ; g_NewPVP
  000a5	e8 00 00 00 00	 call	 ?Cancel@CNewPVP@@QAEXAAUOBJECTSTRUCT@@0H@Z ; CNewPVP::Cancel

; 1341 : 		res.nResult = ENEWPVP::E_CONNECTION_CLOSING;
; 1342 : 		DataSend(aIndex, (LPBYTE)&res, res.h.size);

  000aa	0f b6 45 e9	 movzx	 eax, BYTE PTR _res$[ebp+1]
  000ae	50		 push	 eax
  000af	8d 4d e8	 lea	 ecx, DWORD PTR _res$[ebp]
  000b2	51		 push	 ecx
  000b3	53		 push	 ebx
  000b4	c6 45 ec 05	 mov	 BYTE PTR _res$[ebp+4], 5
  000b8	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  000bd	83 c4 0c	 add	 esp, 12			; 0000000cH
  000c0	5f		 pop	 edi
  000c1	5e		 pop	 esi

; 1343 : 		return ENEWPVP::E_CONNECTION_CLOSING;

  000c2	b8 05 00 00 00	 mov	 eax, 5
  000c7	5b		 pop	 ebx

; 1384 : }

  000c8	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000cb	33 cd		 xor	 ecx, ebp
  000cd	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000d2	8b e5		 mov	 esp, ebp
  000d4	5d		 pop	 ebp
  000d5	c3		 ret	 0
$LN9@OnCGAnswer:

; 1344 : 	}
; 1345 : 	if( !lpMsg->bDuelOK )

  000d6	8b 55 e0	 mov	 edx, DWORD PTR _lpMsg$GSCopy$[ebp]
  000d9	80 7a 04 00	 cmp	 BYTE PTR [edx+4], 0
  000dd	75 3a		 jne	 SHORT $LN8@OnCGAnswer

; 1346 : 	{
; 1347 : 		g_NewPVP.Cancel(*lpRequester, *lpResponsor, FALSE);

  000df	6a 00		 push	 0
  000e1	56		 push	 esi
  000e2	57		 push	 edi
  000e3	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_NewPVP@@3VCNewPVP@@A ; g_NewPVP
  000e8	e8 00 00 00 00	 call	 ?Cancel@CNewPVP@@QAEXAAUOBJECTSTRUCT@@0H@Z ; CNewPVP::Cancel

; 1348 : 		res.nResult = ENEWPVP::E_REFUSE_INVATE;
; 1349 : 		DataSend(aIndex, (LPBYTE)&res, res.h.size);

  000ed	0f b6 45 e9	 movzx	 eax, BYTE PTR _res$[ebp+1]
  000f1	50		 push	 eax
  000f2	8d 4d e8	 lea	 ecx, DWORD PTR _res$[ebp]
  000f5	51		 push	 ecx
  000f6	53		 push	 ebx
  000f7	c6 45 ec 0f	 mov	 BYTE PTR _res$[ebp+4], 15 ; 0000000fH
  000fb	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00100	83 c4 0c	 add	 esp, 12			; 0000000cH
  00103	5f		 pop	 edi
  00104	5e		 pop	 esi

; 1350 : 		return ENEWPVP::E_REFUSE_INVATE;

  00105	b8 0f 00 00 00	 mov	 eax, 15			; 0000000fH
  0010a	5b		 pop	 ebx

; 1384 : }

  0010b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0010e	33 cd		 xor	 ecx, ebp
  00110	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00115	8b e5		 mov	 esp, ebp
  00117	5d		 pop	 ebp
  00118	c3		 ret	 0
$LN8@OnCGAnswer:

; 1351 : 	}
; 1352 : 	if( BC_MAP_RANGE(lpRequester->MapNumber) ||
; 1353 : 		CC_MAP_RANGE(lpRequester->MapNumber) ||
; 1354 : 		DS_MAP_RANGE(lpRequester->MapNumber) )

  00119	8a 87 23 01 00
	00		 mov	 al, BYTE PTR [edi+291]
  0011f	3c 34		 cmp	 al, 52			; 00000034H
  00121	0f 84 09 01 00
	00		 je	 $LN6@OnCGAnswer
  00127	3c 0b		 cmp	 al, 11			; 0000000bH
  00129	72 0d		 jb	 SHORT $LN23@OnCGAnswer
  0012b	b2 11		 mov	 dl, 17			; 00000011H
  0012d	3a d0		 cmp	 dl, al
  0012f	1b c9		 sbb	 ecx, ecx
  00131	41		 inc	 ecx
  00132	0f 85 f8 00 00
	00		 jne	 $LN6@OnCGAnswer
$LN23@OnCGAnswer:
  00138	3c 35		 cmp	 al, 53			; 00000035H
  0013a	0f 84 f0 00 00
	00		 je	 $LN6@OnCGAnswer
  00140	3c 12		 cmp	 al, 18			; 00000012H
  00142	72 10		 jb	 SHORT $LN24@OnCGAnswer
  00144	b9 17 00 00 00	 mov	 ecx, 23			; 00000017H
  00149	3a c8		 cmp	 cl, al
  0014b	1b c9		 sbb	 ecx, ecx
  0014d	41		 inc	 ecx
  0014e	0f 85 dc 00 00
	00		 jne	 $LN6@OnCGAnswer
$LN24@OnCGAnswer:
  00154	3c 09		 cmp	 al, 9
  00156	0f 84 d4 00 00
	00		 je	 $LN6@OnCGAnswer
  0015c	33 d2		 xor	 edx, edx
  0015e	3c 20		 cmp	 al, 32			; 00000020H
  00160	0f 94 c2	 sete	 dl
  00163	8b c2		 mov	 eax, edx
  00165	85 c0		 test	 eax, eax
  00167	0f 85 c3 00 00
	00		 jne	 $LN6@OnCGAnswer

; 1362 : 		return ENEWPVP::E_INVALID_MAP;
; 1363 : 	}
; 1364 : 	int nRet = g_NewPVP.Join(*lpRequester, *lpResponsor);

  0016d	56		 push	 esi
  0016e	57		 push	 edi
  0016f	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_NewPVP@@3VCNewPVP@@A ; g_NewPVP
  00174	e8 00 00 00 00	 call	 ?Join@CNewPVP@@QAEHAAUOBJECTSTRUCT@@0@Z ; CNewPVP::Join
  00179	8b d8		 mov	 ebx, eax

; 1365 : 	if( nRet != ENEWPVP::E_NO_ERROR )

  0017b	85 db		 test	 ebx, ebx
  0017d	0f 84 9a 00 00
	00		 je	 $LN5@OnCGAnswer

; 1366 : 	{
; 1367 : 		switch( nRet )

  00183	83 e8 16	 sub	 eax, 22			; 00000016H
  00186	74 2e		 je	 SHORT $LN2@OnCGAnswer
  00188	48		 dec	 eax
  00189	75 49		 jne	 SHORT $LN3@OnCGAnswer

; 1371 : 			break;
; 1372 : 		case ENEWPVP::E_ALREADY_DUELLING_1:
; 1373 : 			GCServerMsgStringSend(lMsg.Get(1184), aIndex, 1);

  0018b	8b 45 e4	 mov	 eax, DWORD PTR _aIndex$GSCopy$[ebp]
  0018e	6a 01		 push	 1
  00190	50		 push	 eax
  00191	68 a0 04 00 00	 push	 1184			; 000004a0H
  00196	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  0019b	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  001a0	50		 push	 eax
  001a1	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend

; 1374 : 			GCServerMsgStringSend(lMsg.Get(1185), aIndex, 1);

  001a6	8b 4d e4	 mov	 ecx, DWORD PTR _aIndex$GSCopy$[ebp]
  001a9	83 c4 0c	 add	 esp, 12			; 0000000cH
  001ac	6a 01		 push	 1
  001ae	51		 push	 ecx
  001af	68 a1 04 00 00	 push	 1185			; 000004a1H

; 1375 : 			break;

  001b4	eb 0b		 jmp	 SHORT $LN25@OnCGAnswer
$LN2@OnCGAnswer:

; 1368 : 		{
; 1369 : 		case ENEWPVP::E_ALREADY_DUELRESERVED_1:
; 1370 : 			GCServerMsgStringSend(lMsg.Get(1197), aIndex, 1);

  001b6	8b 55 e4	 mov	 edx, DWORD PTR _aIndex$GSCopy$[ebp]
  001b9	6a 01		 push	 1
  001bb	52		 push	 edx
  001bc	68 ad 04 00 00	 push	 1197			; 000004adH
$LN25@OnCGAnswer:
  001c1	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  001c6	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  001cb	50		 push	 eax
  001cc	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend
  001d1	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN3@OnCGAnswer:

; 1378 : 		DataSend(lpRequester->m_Index, (LPBYTE)&res, res.h.size);

  001d4	0f b6 45 e9	 movzx	 eax, BYTE PTR _res$[ebp+1]
  001d8	50		 push	 eax
  001d9	8d 4d e8	 lea	 ecx, DWORD PTR _res$[ebp]
  001dc	88 5d ec	 mov	 BYTE PTR _res$[ebp+4], bl
  001df	8b 17		 mov	 edx, DWORD PTR [edi]
  001e1	51		 push	 ecx
  001e2	52		 push	 edx
  001e3	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 1379 : 		DataSend(lpResponsor->m_Index, (LPBYTE)&res, res.h.size);

  001e8	0f b6 45 e9	 movzx	 eax, BYTE PTR _res$[ebp+1]
  001ec	8b 16		 mov	 edx, DWORD PTR [esi]
  001ee	50		 push	 eax
  001ef	8d 4d e8	 lea	 ecx, DWORD PTR _res$[ebp]
  001f2	51		 push	 ecx
  001f3	52		 push	 edx
  001f4	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  001f9	83 c4 18	 add	 esp, 24			; 00000018H

; 1380 : 		g_NewPVP.Cancel(*lpRequester, *lpResponsor, FALSE);

  001fc	6a 00		 push	 0
  001fe	56		 push	 esi
  001ff	57		 push	 edi
  00200	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_NewPVP@@3VCNewPVP@@A ; g_NewPVP
  00205	e8 00 00 00 00	 call	 ?Cancel@CNewPVP@@QAEXAAUOBJECTSTRUCT@@0H@Z ; CNewPVP::Cancel
  0020a	5f		 pop	 edi
  0020b	5e		 pop	 esi

; 1381 : 		return nRet;

  0020c	8b c3		 mov	 eax, ebx
  0020e	5b		 pop	 ebx

; 1384 : }

  0020f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00212	33 cd		 xor	 ecx, ebp
  00214	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00219	8b e5		 mov	 esp, ebp
  0021b	5d		 pop	 ebp
  0021c	c3		 ret	 0
$LN5@OnCGAnswer:
  0021d	5f		 pop	 edi
  0021e	5e		 pop	 esi

; 1382 : 	}
; 1383 : 	return ENEWPVP::E_NO_ERROR;

  0021f	33 c0		 xor	 eax, eax
  00221	5b		 pop	 ebx

; 1384 : }

  00222	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00225	33 cd		 xor	 ecx, ebp
  00227	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0022c	8b e5		 mov	 esp, ebp
  0022e	5d		 pop	 ebp
  0022f	c3		 ret	 0
$LN6@OnCGAnswer:

; 1355 : 	{
; 1356 : 		g_NewPVP.Cancel(*lpRequester, *lpResponsor, FALSE);

  00230	6a 00		 push	 0
  00232	56		 push	 esi
  00233	57		 push	 edi
  00234	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_NewPVP@@3VCNewPVP@@A ; g_NewPVP
  00239	e8 00 00 00 00	 call	 ?Cancel@CNewPVP@@QAEXAAUOBJECTSTRUCT@@0H@Z ; CNewPVP::Cancel

; 1357 : 		GCServerMsgStringSend(lMsg.Get(1231), lpResponsor->m_Index, 1);

  0023e	8b 06		 mov	 eax, DWORD PTR [esi]
  00240	6a 01		 push	 1
  00242	50		 push	 eax
  00243	68 cf 04 00 00	 push	 1231			; 000004cfH
  00248	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  0024d	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  00252	50		 push	 eax
  00253	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend

; 1358 : 		GCServerMsgStringSend(lMsg.Get(1231), lpRequester->m_Index, 1);

  00258	8b 0f		 mov	 ecx, DWORD PTR [edi]
  0025a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0025d	6a 01		 push	 1
  0025f	51		 push	 ecx
  00260	68 cf 04 00 00	 push	 1231			; 000004cfH
  00265	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  0026a	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  0026f	50		 push	 eax
  00270	e8 00 00 00 00	 call	 ?GCServerMsgStringSend@@YAXPADHE@Z ; GCServerMsgStringSend

; 1359 : 		res.nResult = ENEWPVP::E_INVALID_MAP;
; 1360 : 		DataSend(lpResponsor->m_Index, (LPBYTE)&res, res.h.size);

  00275	0f b6 55 e9	 movzx	 edx, BYTE PTR _res$[ebp+1]
  00279	52		 push	 edx
  0027a	8d 45 e8	 lea	 eax, DWORD PTR _res$[ebp]
  0027d	c6 45 ec 08	 mov	 BYTE PTR _res$[ebp+4], 8
  00281	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00283	50		 push	 eax
  00284	51		 push	 ecx
  00285	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 1361 : 		DataSend(lpRequester->m_Index, (LPBYTE)&res, res.h.size);

  0028a	0f b6 55 e9	 movzx	 edx, BYTE PTR _res$[ebp+1]
  0028e	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00290	52		 push	 edx
  00291	8d 45 e8	 lea	 eax, DWORD PTR _res$[ebp]
  00294	50		 push	 eax
  00295	51		 push	 ecx
  00296	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 1384 : }

  0029b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0029e	83 c4 24	 add	 esp, 36			; 00000024H
  002a1	5f		 pop	 edi
  002a2	5e		 pop	 esi
  002a3	33 cd		 xor	 ecx, ebp
  002a5	b8 08 00 00 00	 mov	 eax, 8
  002aa	5b		 pop	 ebx
  002ab	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002b0	8b e5		 mov	 esp, ebp
  002b2	5d		 pop	 ebp
  002b3	c3		 ret	 0
?OnCGAnswerDuel@@YAHPAU_tagPMSG_ANS_DUEL_ANSWER@@H@Z ENDP ; OnCGAnswerDuel
_TEXT	ENDS
PUBLIC	?OnDuelChannelJoin@@YAHPAU_tagPMSG_REQ_DUEL_JOINCNANNEL@@H@Z ; OnDuelChannelJoin
; Function compile flags: /Ogtp
;	COMDAT ?OnDuelChannelJoin@@YAHPAU_tagPMSG_REQ_DUEL_JOINCNANNEL@@H@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?OnDuelChannelJoin@@YAHPAU_tagPMSG_REQ_DUEL_JOINCNANNEL@@H@Z PROC ; OnDuelChannelJoin, COMDAT

; 1395 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1396 : 	if( gObj[aIndex].CloseType != -1 )	return ENEWPVP::E_DISCONNECT;

  00003	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00006	69 c0 40 27 00
	00		 imul	 eax, 10048		; 00002740H
  0000c	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00012	80 78 0d ff	 cmp	 BYTE PTR [eax+13], -1
  00016	74 07		 je	 SHORT $LN2@OnDuelChan
  00018	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH

; 1398 : 	if( nRet != ENEWPVP::E_NO_ERROR )	return nRet;
; 1399 : 	return ENEWPVP::E_NO_ERROR;
; 1400 : }

  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
$LN2@OnDuelChan:

; 1397 : 	int nRet = g_NewPVP.JoinChannel(lpMsg->nChannelId, gObj[aIndex]);

  0001f	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  00022	50		 push	 eax
  00023	0f b6 42 04	 movzx	 eax, BYTE PTR [edx+4]
  00027	50		 push	 eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_NewPVP@@3VCNewPVP@@A ; g_NewPVP
  0002d	e8 00 00 00 00	 call	 ?JoinChannel@CNewPVP@@QAEHHAAUOBJECTSTRUCT@@@Z ; CNewPVP::JoinChannel

; 1398 : 	if( nRet != ENEWPVP::E_NO_ERROR )	return nRet;
; 1399 : 	return ENEWPVP::E_NO_ERROR;
; 1400 : }

  00032	5d		 pop	 ebp
  00033	c3		 ret	 0
?OnDuelChannelJoin@@YAHPAU_tagPMSG_REQ_DUEL_JOINCNANNEL@@H@Z ENDP ; OnDuelChannelJoin
_TEXT	ENDS
PUBLIC	?OnDuelChannelLeave@@YAHPAU_tagPMSG_REQ_DUEL_LEAVECNANNEL@@H@Z ; OnDuelChannelLeave
; Function compile flags: /Ogtp
;	COMDAT ?OnDuelChannelLeave@@YAHPAU_tagPMSG_REQ_DUEL_LEAVECNANNEL@@H@Z
_TEXT	SEGMENT
_lpMsg$ = 8						; size = 4
_aIndex$ = 12						; size = 4
?OnDuelChannelLeave@@YAHPAU_tagPMSG_REQ_DUEL_LEAVECNANNEL@@H@Z PROC ; OnDuelChannelLeave, COMDAT

; 1403 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1404 : 	if( gObj[aIndex].CloseType != -1 )	return ENEWPVP::E_DISCONNECT;

  00003	8b 45 0c	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00006	69 c0 40 27 00
	00		 imul	 eax, 10048		; 00002740H
  0000c	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  00012	80 78 0d ff	 cmp	 BYTE PTR [eax+13], -1
  00016	74 07		 je	 SHORT $LN2@OnDuelChan@2
  00018	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH

; 1406 : 	if( nRet != ENEWPVP::E_NO_ERROR )	return nRet;
; 1407 : 	return ENEWPVP::E_NO_ERROR;
; 1408 : }

  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
$LN2@OnDuelChan@2:

; 1405 : 	int nRet = g_NewPVP.LeaveChannel(lpMsg->nChannelId, gObj[aIndex]);

  0001f	8b 55 08	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  00022	50		 push	 eax
  00023	0f b6 42 04	 movzx	 eax, BYTE PTR [edx+4]
  00027	50		 push	 eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_NewPVP@@3VCNewPVP@@A ; g_NewPVP
  0002d	e8 00 00 00 00	 call	 ?LeaveChannel@CNewPVP@@QAEHHAAUOBJECTSTRUCT@@@Z ; CNewPVP::LeaveChannel

; 1406 : 	if( nRet != ENEWPVP::E_NO_ERROR )	return nRet;
; 1407 : 	return ENEWPVP::E_NO_ERROR;
; 1408 : }

  00032	5d		 pop	 ebp
  00033	c3		 ret	 0
?OnDuelChannelLeave@@YAHPAU_tagPMSG_REQ_DUEL_LEAVECNANNEL@@H@Z ENDP ; OnDuelChannelLeave
_TEXT	ENDS
PUBLIC	??0?$map@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@@std@@QAE@XZ ; std::map<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> > >::map<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\map
;	COMDAT ??0?$map@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@@std@@QAE@XZ
_TEXT	SEGMENT
$T204561 = -16						; size = 12
$T204459 = -4						; size = 4
??0?$map@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@@std@@QAE@XZ PROC ; std::map<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> > >::map<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> > >, COMDAT
; _this$ = ecx

; 106  : 		{	// construct empty map from defaults

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	6a 24		 push	 36			; 00000024H
  0000b	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00012	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00017	83 c4 04	 add	 esp, 4
  0001a	85 c0		 test	 eax, eax
  0001c	74 26		 je	 SHORT $LN25@map
  0001e	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00021	89 00		 mov	 DWORD PTR [eax], eax
  00023	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00026	89 40 04	 mov	 DWORD PTR [eax+4], eax
  00029	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0002c	89 40 08	 mov	 DWORD PTR [eax+8], eax
  0002f	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00032	b0 01		 mov	 al, 1
  00034	88 41 20	 mov	 BYTE PTR [ecx+32], al
  00037	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0003a	88 42 21	 mov	 BYTE PTR [edx+33], al

; 107  : 		}

  0003d	8b c6		 mov	 eax, esi
  0003f	5e		 pop	 esi
  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c3		 ret	 0

; 106  : 		{	// construct empty map from defaults

$LN25@map:
  00044	8d 45 fc	 lea	 eax, DWORD PTR $T204459[ebp]
  00047	50		 push	 eax
  00048	8d 4d f0	 lea	 ecx, DWORD PTR $T204561[ebp]
  0004b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T204459[ebp], 0
  00052	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00057	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0005c	8d 4d f0	 lea	 ecx, DWORD PTR $T204561[ebp]
  0005f	51		 push	 ecx
  00060	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T204561[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00067	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN49@map:
$LN48@map:
  0006c	cc		 int	 3
??0?$map@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@@std@@QAE@XZ ENDP ; std::map<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> > >::map<int,_tagWaiting,std::less<int>,std::allocator<std::pair<int const ,_tagWaiting> > >
_TEXT	ENDS
PUBLIC	??0?$map@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@@std@@QAE@XZ ; std::map<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> > >::map<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> > >
; Function compile flags: /Ogtp
;	COMDAT ??0?$map@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@@std@@QAE@XZ
_TEXT	SEGMENT
$T204732 = -16						; size = 12
$T204630 = -4						; size = 4
??0?$map@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@@std@@QAE@XZ PROC ; std::map<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> > >::map<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> > >, COMDAT
; _this$ = ecx

; 106  : 		{	// construct empty map from defaults

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	6a 28		 push	 40			; 00000028H
  0000b	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00012	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00017	83 c4 04	 add	 esp, 4
  0001a	85 c0		 test	 eax, eax
  0001c	74 26		 je	 SHORT $LN25@map@2
  0001e	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00021	89 00		 mov	 DWORD PTR [eax], eax
  00023	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00026	89 40 04	 mov	 DWORD PTR [eax+4], eax
  00029	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0002c	89 40 08	 mov	 DWORD PTR [eax+8], eax
  0002f	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00032	b0 01		 mov	 al, 1
  00034	88 41 24	 mov	 BYTE PTR [ecx+36], al
  00037	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0003a	88 42 25	 mov	 BYTE PTR [edx+37], al

; 107  : 		}

  0003d	8b c6		 mov	 eax, esi
  0003f	5e		 pop	 esi
  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c3		 ret	 0

; 106  : 		{	// construct empty map from defaults

$LN25@map@2:
  00044	8d 45 fc	 lea	 eax, DWORD PTR $T204630[ebp]
  00047	50		 push	 eax
  00048	8d 4d f0	 lea	 ecx, DWORD PTR $T204732[ebp]
  0004b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T204630[ebp], 0
  00052	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00057	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0005c	8d 4d f0	 lea	 ecx, DWORD PTR $T204732[ebp]
  0005f	51		 push	 ecx
  00060	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T204732[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00067	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN49@map@2:
$LN48@map@2:
  0006c	cc		 int	 3
??0?$map@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@@std@@QAE@XZ ENDP ; std::map<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> > >::map<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> > >
_TEXT	ENDS
PUBLIC	??0CNewPVP@@QAE@XZ				; CNewPVP::CNewPVP
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
xdata$x	SEGMENT
__unwindtable$??0CNewPVP@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CNewPVP@@QAE@XZ$0
__ehfuncinfo$??0CNewPVP@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0CNewPVP@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\muserver_dev\development\mu-s8ep2-repack\gameserver\source\newpvp.cpp
xdata$x	ENDS
;	COMDAT ??0CNewPVP@@QAE@XZ
_TEXT	SEGMENT
$T204927 = -48						; size = 12
$T205165 = -36						; size = 12
_this$ = -24						; size = 4
$T204804 = -20						; size = 4
$T205019 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CNewPVP@@QAE@XZ PROC					; CNewPVP::CNewPVP, COMDAT
; _this$ = ecx

; 28   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0CNewPVP@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 24	 sub	 esp, 36			; 00000024H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	8b f1		 mov	 esi, ecx
  0002a	89 75 e8	 mov	 DWORD PTR _this$[ebp], esi
  0002d	33 ff		 xor	 edi, edi
  0002f	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7CNewPVP@@6B@
  00035	89 7e 04	 mov	 DWORD PTR [esi+4], edi
  00038	6a 24		 push	 36			; 00000024H
  0003a	89 be 1c 01 00
	00		 mov	 DWORD PTR [esi+284], edi
  00040	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00045	83 c4 04	 add	 esp, 4
  00048	3b c7		 cmp	 eax, edi
  0004a	0f 84 fa 00 00
	00		 je	 $LN29@CNewPVP
  00050	89 86 18 01 00
	00		 mov	 DWORD PTR [esi+280], eax
  00056	89 00		 mov	 DWORD PTR [eax], eax
  00058	8b 86 18 01 00
	00		 mov	 eax, DWORD PTR [esi+280]
  0005e	89 40 04	 mov	 DWORD PTR [eax+4], eax
  00061	8b 86 18 01 00
	00		 mov	 eax, DWORD PTR [esi+280]
  00067	89 40 08	 mov	 DWORD PTR [eax+8], eax
  0006a	8b 86 18 01 00
	00		 mov	 eax, DWORD PTR [esi+280]
  00070	bb 01 00 00 00	 mov	 ebx, 1
  00075	88 58 20	 mov	 BYTE PTR [eax+32], bl
  00078	8b 8e 18 01 00
	00		 mov	 ecx, DWORD PTR [esi+280]
  0007e	88 59 21	 mov	 BYTE PTR [ecx+33], bl
  00081	6a 28		 push	 40			; 00000028H
  00083	89 7d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], edi
  00086	89 be 2c 01 00
	00		 mov	 DWORD PTR [esi+300], edi
  0008c	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00091	83 c4 04	 add	 esp, 4
  00094	3b c7		 cmp	 eax, edi
  00096	0f 84 8a 00 00
	00		 je	 $LN76@CNewPVP
  0009c	89 86 28 01 00
	00		 mov	 DWORD PTR [esi+296], eax
  000a2	89 00		 mov	 DWORD PTR [eax], eax
  000a4	8b 86 28 01 00
	00		 mov	 eax, DWORD PTR [esi+296]
  000aa	89 40 04	 mov	 DWORD PTR [eax+4], eax
  000ad	8b 86 28 01 00
	00		 mov	 eax, DWORD PTR [esi+296]
  000b3	89 40 08	 mov	 DWORD PTR [eax+8], eax
  000b6	8b 96 28 01 00
	00		 mov	 edx, DWORD PTR [esi+296]

; 29   : 	memset(&m_DuelChannelList, 0, sizeof(m_DuelChannelList));

  000bc	6a 5c		 push	 92			; 0000005cH
  000be	88 5a 24	 mov	 BYTE PTR [edx+36], bl
  000c1	8b 86 28 01 00
	00		 mov	 eax, DWORD PTR [esi+296]
  000c7	8d 7e 08	 lea	 edi, DWORD PTR [esi+8]
  000ca	6a 00		 push	 0
  000cc	57		 push	 edi
  000cd	88 58 25	 mov	 BYTE PTR [eax+37], bl
  000d0	e8 00 00 00 00	 call	 _memset

; 30   : 	memset(m_DuelChannel, 0, sizeof(m_DuelChannel));

  000d5	68 b0 00 00 00	 push	 176			; 000000b0H
  000da	8d 4e 64	 lea	 ecx, DWORD PTR [esi+100]
  000dd	6a 00		 push	 0
  000df	51		 push	 ecx
  000e0	e8 00 00 00 00	 call	 _memset
  000e5	83 c4 18	 add	 esp, 24			; 00000018H

; 31   : 	memset(&m_ObserverCount, 0, sizeof(m_ObserverCount));

  000e8	33 c0		 xor	 eax, eax
  000ea	89 86 34 01 00
	00		 mov	 DWORD PTR [esi+308], eax
  000f0	89 86 38 01 00
	00		 mov	 DWORD PTR [esi+312], eax
  000f6	89 86 3c 01 00
	00		 mov	 DWORD PTR [esi+316], eax
  000fc	89 86 40 01 00
	00		 mov	 DWORD PTR [esi+320], eax

; 32   : 	m_DuelChannelList.h.c = PMHC_BYTE;

  00102	c6 07 c1	 mov	 BYTE PTR [edi], 193	; 000000c1H

; 33   : 	m_DuelChannelList.h.headcode = 0xAA;

  00105	66 c7 46 0a aa
	06		 mov	 WORD PTR [esi+10], 1706	; 000006aaH

; 34   : 	m_DuelChannelList.h.subcode = 0x06;
; 35   : 	m_DuelChannelList.h.size = sizeof(PMSG_ANS_DUEL_CHANNELLIST);

  0010b	c6 46 09 5c	 mov	 BYTE PTR [esi+9], 92	; 0000005cH

; 36   : 	m_bNewPVP = true;

  0010f	89 5e 04	 mov	 DWORD PTR [esi+4], ebx

; 37   : }

  00112	8b c6		 mov	 eax, esi
  00114	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00117	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0011e	59		 pop	 ecx
  0011f	5f		 pop	 edi
  00120	5e		 pop	 esi
  00121	5b		 pop	 ebx
  00122	8b e5		 mov	 esp, ebp
  00124	5d		 pop	 ebp
  00125	c3		 ret	 0

; 28   : {

$LN76@CNewPVP:
  00126	8d 55 f0	 lea	 edx, DWORD PTR $T205019[ebp]
  00129	52		 push	 edx
  0012a	8d 4d dc	 lea	 ecx, DWORD PTR $T205165[ebp]
  0012d	89 7d f0	 mov	 DWORD PTR $T205019[ebp], edi
  00130	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00135	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0013a	8d 45 dc	 lea	 eax, DWORD PTR $T205165[ebp]
  0013d	50		 push	 eax
  0013e	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR $T205165[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00145	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN102@CNewPVP:
$LN29@CNewPVP:
  0014a	8d 4d ec	 lea	 ecx, DWORD PTR $T204804[ebp]
  0014d	51		 push	 ecx
  0014e	8d 4d d0	 lea	 ecx, DWORD PTR $T204927[ebp]
  00151	89 7d ec	 mov	 DWORD PTR $T204804[ebp], edi
  00154	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00159	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0015e	8d 55 d0	 lea	 edx, DWORD PTR $T204927[ebp]
  00161	52		 push	 edx
  00162	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR $T204927[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00169	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN103@CNewPVP:
$LN101@CNewPVP:
  0016e	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CNewPVP@@QAE@XZ$0:
  00000	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	81 c1 14 01 00
	00		 add	 ecx, 276		; 00000114H
  00009	e9 00 00 00 00	 jmp	 ??1?$map@HU_tagWaiting@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagWaiting@@@std@@@3@@std@@QAE@XZ
__ehhandler$??0CNewPVP@@QAE@XZ:
  0000e	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00012	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00015	8b 4a cc	 mov	 ecx, DWORD PTR [edx-52]
  00018	33 c8		 xor	 ecx, eax
  0001a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001f	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0CNewPVP@@QAE@XZ
  00024	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0CNewPVP@@QAE@XZ ENDP					; CNewPVP::CNewPVP
; Function compile flags: /Ogtp
;	COMDAT ??_GCNewPVP@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCNewPVP@@UAEPAXI@Z PROC				; CNewPVP::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1CNewPVP@@UAE@XZ	; CNewPVP::~CNewPVP
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 09		 je	 SHORT $LN4@scalar@2
  00011	56		 push	 esi
  00012	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00017	83 c4 04	 add	 esp, 4
$LN4@scalar@2:
  0001a	8b c6		 mov	 eax, esi
  0001c	5e		 pop	 esi
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
??_GCNewPVP@@UAEPAXI@Z ENDP				; CNewPVP::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?Reset@CNewPVP@@QAEXAAUOBJECTSTRUCT@@@Z		; CNewPVP::Reset
; Function compile flags: /Ogtp
;	COMDAT ?Reset@CNewPVP@@QAEXAAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_iter$187781 = 8					; size = 4
_obj$ = 8						; size = 4
?Reset@CNewPVP@@QAEXAAUOBJECTSTRUCT@@@Z PROC		; CNewPVP::Reset, COMDAT
; _this$ = ecx

; 731  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 732  : 	if( IsDuelRequested(obj) )	Cancel(obj, gObj[obj.m_iDuelUserRequested], TRUE);

  00004	8b 75 08	 mov	 esi, DWORD PTR _obj$[ebp]
  00007	8b 86 4c 12 00
	00		 mov	 eax, DWORD PTR [esi+4684]
  0000d	57		 push	 edi
  0000e	8b f9		 mov	 edi, ecx
  00010	85 c0		 test	 eax, eax
  00012	78 25		 js	 SHORT $LN4@Reset
  00014	33 c9		 xor	 ecx, ecx
  00016	3d eb 2c 00 00	 cmp	 eax, 11499		; 00002cebH
  0001b	0f 9e c1	 setle	 cl
  0001e	85 c9		 test	 ecx, ecx
  00020	74 17		 je	 SHORT $LN4@Reset
  00022	69 c0 40 27 00
	00		 imul	 eax, 10048		; 00002740H
  00028	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj
  0002e	6a 01		 push	 1
  00030	50		 push	 eax
  00031	56		 push	 esi
  00032	8b cf		 mov	 ecx, edi
  00034	e8 00 00 00 00	 call	 ?Cancel@CNewPVP@@QAEXAAUOBJECTSTRUCT@@0H@Z ; CNewPVP::Cancel
$LN4@Reset:

; 733  : 	if( IsDuel(obj) )	Leave(obj);

  00039	8b 86 50 12 00
	00		 mov	 eax, DWORD PTR [esi+4688]
  0003f	85 c0		 test	 eax, eax
  00041	78 18		 js	 SHORT $LN3@Reset
  00043	33 c9		 xor	 ecx, ecx
  00045	3d eb 2c 00 00	 cmp	 eax, 11499		; 00002cebH
  0004a	0f 9e c1	 setle	 cl
  0004d	8b c1		 mov	 eax, ecx
  0004f	85 c0		 test	 eax, eax
  00051	74 08		 je	 SHORT $LN3@Reset
  00053	56		 push	 esi
  00054	8b cf		 mov	 ecx, edi
  00056	e8 00 00 00 00	 call	 ?Leave@CNewPVP@@QAEHAAUOBJECTSTRUCT@@@Z ; CNewPVP::Leave
$LN3@Reset:

; 734  : 
; 735  : 	if( IsObserver(obj) )

  0005b	56		 push	 esi
  0005c	8b cf		 mov	 ecx, edi
  0005e	e8 00 00 00 00	 call	 ?IsObserver@CNewPVP@@QAEHAAUOBJECTSTRUCT@@@Z ; CNewPVP::IsObserver
  00063	85 c0		 test	 eax, eax
  00065	74 27		 je	 SHORT $LN2@Reset

; 736  : 	{
; 737  : 		std::map<int, _tagObserverInfo>::iterator iter = m_ObserverInfoList.find(obj.m_Index);

  00067	56		 push	 esi
  00068	8d 55 08	 lea	 edx, DWORD PTR _iter$187781[ebp]
  0006b	52		 push	 edx
  0006c	8d 8f 24 01 00
	00		 lea	 ecx, DWORD PTR [edi+292]
  00072	e8 00 00 00 00	 call	 ?find@?$_Tree@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HU_tagObserverInfo@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHU_tagObserverInfo@@@std@@@3@$0A@@std@@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,_tagObserverInfo,std::less<int>,std::allocator<std::pair<int const ,_tagObserverInfo> >,0> >::find

; 738  : 		if(!(iter!=m_ObserverInfoList.end()))	return;

  00077	8b 45 08	 mov	 eax, DWORD PTR _iter$187781[ebp]
  0007a	3b 87 28 01 00
	00		 cmp	 eax, DWORD PTR [edi+296]
  00080	74 0c		 je	 SHORT $LN2@Reset

; 739  : 		ObserverInfo & info = iter->second;
; 740  : 		LeaveChannel(info.nId, obj);

  00082	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00085	56		 push	 esi
  00086	50		 push	 eax
  00087	8b cf		 mov	 ecx, edi
  00089	e8 00 00 00 00	 call	 ?LeaveChannel@CNewPVP@@QAEHHAAUOBJECTSTRUCT@@@Z ; CNewPVP::LeaveChannel
$LN2@Reset:
  0008e	5f		 pop	 edi
  0008f	5e		 pop	 esi

; 741  : 	}
; 742  : }

  00090	5d		 pop	 ebp
  00091	c2 04 00	 ret	 4
?Reset@CNewPVP@@QAEXAAUOBJECTSTRUCT@@@Z ENDP		; CNewPVP::Reset
_TEXT	ENDS
EXTRN	_atexit:PROC
; Function compile flags: /Ogtp
;	COMDAT ??__Eg_NewPVP@@YAXXZ
text$yc	SEGMENT
??__Eg_NewPVP@@YAXXZ PROC				; `dynamic initializer for 'g_NewPVP'', COMDAT

; 25   : CNewPVP g_NewPVP;

  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_NewPVP@@3VCNewPVP@@A ; g_NewPVP
  00005	e8 00 00 00 00	 call	 ??0CNewPVP@@QAE@XZ	; CNewPVP::CNewPVP
  0000a	68 00 00 00 00	 push	 OFFSET ??__Fg_NewPVP@@YAXXZ ; `dynamic atexit destructor for 'g_NewPVP''
  0000f	e8 00 00 00 00	 call	 _atexit
  00014	59		 pop	 ecx
  00015	c3		 ret	 0
??__Eg_NewPVP@@YAXXZ ENDP				; `dynamic initializer for 'g_NewPVP''
; Function compile flags: /Ogtp
text$yc	ENDS
;	COMDAT ??__Fg_NewPVP@@YAXXZ
text$yd	SEGMENT
??__Fg_NewPVP@@YAXXZ PROC				; `dynamic atexit destructor for 'g_NewPVP'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_NewPVP@@3VCNewPVP@@A ; g_NewPVP
  00005	e9 00 00 00 00	 jmp	 ??1CNewPVP@@UAE@XZ	; CNewPVP::~CNewPVP
??__Fg_NewPVP@@YAXXZ ENDP				; `dynamic atexit destructor for 'g_NewPVP''
text$yd	ENDS
PUBLIC	?g_NewPVP@@3VCNewPVP@@A				; g_NewPVP
_BSS	SEGMENT
?g_NewPVP@@3VCNewPVP@@A DB 0144H DUP (?)		; g_NewPVP
_BSS	ENDS
CRT$XCU	SEGMENT
_g_NewPVP$initializer$ DD FLAT:??__Eg_NewPVP@@YAXXZ
CRT$XCU	ENDS
END
