; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	C:\muserver_dev\development\MU-S8EP2-Repack\GameServer\Source\LargeRand.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??_7CLargeRand@@6B@				; CLargeRand::`vftable'
PUBLIC	??0CLargeRand@@QAE@XZ				; CLargeRand::CLargeRand
PUBLIC	??_R4CLargeRand@@6B@				; CLargeRand::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCLargeRand@@@8				; CLargeRand `RTTI Type Descriptor'
PUBLIC	??_R3CLargeRand@@8				; CLargeRand::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CLargeRand@@8				; CLargeRand::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CLargeRand@@8			; CLargeRand::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_ECLargeRand@@UAEPAXI@Z:PROC			; CLargeRand::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@CLargeRand@@8
; File c:\muserver_dev\development\mu-s8ep2-repack\gameserver\source\largerand.cpp
rdata$r	SEGMENT
??_R1A@?0A@EA@CLargeRand@@8 DD FLAT:??_R0?AVCLargeRand@@@8 ; CLargeRand::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CLargeRand@@8
rdata$r	ENDS
;	COMDAT ??_R2CLargeRand@@8
rdata$r	SEGMENT
??_R2CLargeRand@@8 DD FLAT:??_R1A@?0A@EA@CLargeRand@@8	; CLargeRand::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CLargeRand@@8
rdata$r	SEGMENT
??_R3CLargeRand@@8 DD 00H				; CLargeRand::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CLargeRand@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCLargeRand@@@8
_DATA	SEGMENT
??_R0?AVCLargeRand@@@8 DD FLAT:??_7type_info@@6B@	; CLargeRand `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCLargeRand@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CLargeRand@@6B@
rdata$r	SEGMENT
??_R4CLargeRand@@6B@ DD 00H				; CLargeRand::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCLargeRand@@@8
	DD	FLAT:??_R3CLargeRand@@8
rdata$r	ENDS
;	COMDAT ??_7CLargeRand@@6B@
CONST	SEGMENT
??_7CLargeRand@@6B@ DD FLAT:??_R4CLargeRand@@6B@	; CLargeRand::`vftable'
	DD	FLAT:??_ECLargeRand@@UAEPAXI@Z
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ??0CLargeRand@@QAE@XZ
_TEXT	SEGMENT
??0CLargeRand@@QAE@XZ PROC				; CLargeRand::CLargeRand, COMDAT
; _this$ = ecx

; 13   : {

  00000	8b c1		 mov	 eax, ecx
  00002	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CLargeRand@@6B@

; 14   : 	this->left = -1;

  00008	c7 80 cc 09 00
	00 ff ff ff ff	 mov	 DWORD PTR [eax+2508], -1

; 15   : }

  00012	c3		 ret	 0
??0CLargeRand@@QAE@XZ ENDP				; CLargeRand::CLargeRand
_TEXT	ENDS
PUBLIC	??1CLargeRand@@UAE@XZ				; CLargeRand::~CLargeRand
; Function compile flags: /Ogtp
;	COMDAT ??1CLargeRand@@UAE@XZ
_TEXT	SEGMENT
??1CLargeRand@@UAE@XZ PROC				; CLargeRand::~CLargeRand, COMDAT
; _this$ = ecx

; 20   : {

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7CLargeRand@@6B@

; 21   : 	return;
; 22   : }

  00006	c3		 ret	 0
??1CLargeRand@@UAE@XZ ENDP				; CLargeRand::~CLargeRand
_TEXT	ENDS
PUBLIC	?seedMT@CLargeRand@@QAEXK@Z			; CLargeRand::seedMT
; Function compile flags: /Ogtp
;	COMDAT ?seedMT@CLargeRand@@QAEXK@Z
_TEXT	SEGMENT
_seed$ = 8						; size = 4
?seedMT@CLargeRand@@QAEXK@Z PROC			; CLargeRand::seedMT, COMDAT
; _this$ = ecx

; 26   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 27   : 	DWORD x = seed | 1;

  00003	8b 45 08	 mov	 eax, DWORD PTR _seed$[ebp]

; 28   : 	DWORD * s = this->state;

  00006	8d 51 04	 lea	 edx, DWORD PTR [ecx+4]
  00009	83 c8 01	 or	 eax, 1

; 29   : 	this->left = 0;

  0000c	c7 81 cc 09 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+2508], 0

; 30   : 	*s = x;

  00016	89 02		 mov	 DWORD PTR [edx], eax

; 31   : 	s++;

  00018	83 c2 04	 add	 edx, 4

; 32   : 
; 33   : 	for ( int j = MAX_LARGE_RAND_STATE-1 ; --j != 0 ;  x *= 69069, *s = x, s++);

  0001b	b9 6f 02 00 00	 mov	 ecx, 623		; 0000026fH
$LL3@seedMT:
  00020	69 c0 cd 0d 01
	00		 imul	 eax, 69069		; 00010dcdH
  00026	89 02		 mov	 DWORD PTR [edx], eax
  00028	83 c2 04	 add	 edx, 4
  0002b	49		 dec	 ecx
  0002c	75 f2		 jne	 SHORT $LL3@seedMT

; 34   : }

  0002e	5d		 pop	 ebp
  0002f	c2 04 00	 ret	 4
?seedMT@CLargeRand@@QAEXK@Z ENDP			; CLargeRand::seedMT
_TEXT	ENDS
PUBLIC	?reloadMT@CLargeRand@@QAEKXZ			; CLargeRand::reloadMT
; Function compile flags: /Ogtp
;	COMDAT ?reloadMT@CLargeRand@@QAEKXZ
_TEXT	SEGMENT
tv194 = -12						; size = 4
tv192 = -8						; size = 4
_j$ = -4						; size = 4
?reloadMT@CLargeRand@@QAEKXZ PROC			; CLargeRand::reloadMT, COMDAT
; _this$ = ecx

; 39   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx
  00007	8b d9		 mov	 ebx, ecx

; 40   : 	DWORD * p0 = this->state;
; 41   : 	DWORD * p2 = &this->state[2];
; 42   : 	DWORD * pM = &this->state[397];
; 43   : 
; 44   : 	if ( this->left < -1 )

  00009	83 bb cc 09 00
	00 ff		 cmp	 DWORD PTR [ebx+2508], -1
  00010	56		 push	 esi
  00011	8d 4b 04	 lea	 ecx, DWORD PTR [ebx+4]
  00014	8d 83 38 06 00
	00		 lea	 eax, DWORD PTR [ebx+1592]
  0001a	57		 push	 edi
  0001b	89 4d f8	 mov	 DWORD PTR tv192[ebp], ecx
  0001e	8b f9		 mov	 edi, ecx
  00020	8d 73 0c	 lea	 esi, DWORD PTR [ebx+12]
  00023	89 45 f4	 mov	 DWORD PTR tv194[ebp], eax
  00026	7d 0e		 jge	 SHORT $LN7@reloadMT

; 45   : 		this->seedMT(0x1105);

  00028	68 05 11 00 00	 push	 4357			; 00001105H
  0002d	8b cb		 mov	 ecx, ebx
  0002f	e8 00 00 00 00	 call	 ?seedMT@CLargeRand@@QAEXK@Z ; CLargeRand::seedMT
  00034	8b cf		 mov	 ecx, edi
$LN7@reloadMT:

; 46   : 
; 47   : 	this->left = MAX_LARGE_RAND_STATE-2;
; 48   : 	this->next = &this->state[1];
; 49   : 	DWORD s0 = this->state[0];	

  00036	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00038	8d 43 08	 lea	 eax, DWORD PTR [ebx+8]
  0003b	89 83 c8 09 00
	00		 mov	 DWORD PTR [ebx+2504], eax

; 50   : 	DWORD s1 = this->state[1];

  00041	8b 00		 mov	 eax, DWORD PTR [eax]
  00043	c7 83 cc 09 00
	00 6f 02 00 00	 mov	 DWORD PTR [ebx+2508], 623 ; 0000026fH

; 51   : 
; 52   : 	int j;
; 53   : 	for ( j= 228; --j != 0 ; s0 = s1, s1 = *p2, p2++)

  0004d	8b 5d f4	 mov	 ebx, DWORD PTR tv194[ebp]
  00050	c7 45 fc e3 00
	00 00		 mov	 DWORD PTR _j$[ebp], 227	; 000000e3H
  00057	2b de		 sub	 ebx, esi
  00059	8d a4 24 00 00
	00 00		 npad	 7
$LL6@reloadMT:

; 54   : 	{
; 55   : 		*p0++ = (*pM++ ^ (((s0 & 0x80000000) | (s1 & 0x7FFFFFFF)) >> 1)) ^ ((((s1&1)!=0)?-1:0)&0x9908B0DF);

  00060	8b d0		 mov	 edx, eax
  00062	33 d1		 xor	 edx, ecx
  00064	81 e2 fe ff ff
	7f		 and	 edx, 2147483646		; 7ffffffeH
  0006a	33 d1		 xor	 edx, ecx
  0006c	8b c8		 mov	 ecx, eax
  0006e	80 e1 01	 and	 cl, 1
  00071	0f b6 c9	 movzx	 ecx, cl
  00074	d1 ea		 shr	 edx, 1
  00076	f7 d9		 neg	 ecx
  00078	1b c9		 sbb	 ecx, ecx
  0007a	81 e1 df b0 08
	99		 and	 ecx, -1727483681	; 9908b0dfH
  00080	33 d1		 xor	 edx, ecx
  00082	33 14 33	 xor	 edx, DWORD PTR [ebx+esi]
  00085	8b c8		 mov	 ecx, eax
  00087	89 17		 mov	 DWORD PTR [edi], edx
  00089	8b 06		 mov	 eax, DWORD PTR [esi]
  0008b	83 c7 04	 add	 edi, 4
  0008e	83 c6 04	 add	 esi, 4
  00091	ff 4d fc	 dec	 DWORD PTR _j$[ebp]
  00094	75 ca		 jne	 SHORT $LL6@reloadMT

; 56   : 	}
; 57   : 
; 58   : 	pM = this->state;

  00096	8b 5d f8	 mov	 ebx, DWORD PTR tv192[ebp]

; 59   : 
; 60   : 	for( j=397 ; --j != 0 ; s0=s1 , s1 = *p2 , p2++ )

  00099	c7 45 fc 8c 01
	00 00		 mov	 DWORD PTR _j$[ebp], 396	; 0000018cH
$LL3@reloadMT:

; 61   : 	{
; 62   : 		*p0++ = (*pM++ ^ (((s0 & 0x80000000) | (s1 & 0x7FFFFFFF)) >> 1)) ^ ((((s1&1)!=0)?-1:0)&0x9908B0DF);

  000a0	8b d0		 mov	 edx, eax
  000a2	33 d1		 xor	 edx, ecx
  000a4	81 e2 fe ff ff
	7f		 and	 edx, 2147483646		; 7ffffffeH
  000aa	33 d1		 xor	 edx, ecx
  000ac	8b c8		 mov	 ecx, eax
  000ae	80 e1 01	 and	 cl, 1
  000b1	0f b6 c9	 movzx	 ecx, cl
  000b4	d1 ea		 shr	 edx, 1
  000b6	f7 d9		 neg	 ecx
  000b8	1b c9		 sbb	 ecx, ecx
  000ba	81 e1 df b0 08
	99		 and	 ecx, -1727483681	; 9908b0dfH
  000c0	33 d1		 xor	 edx, ecx
  000c2	33 13		 xor	 edx, DWORD PTR [ebx]
  000c4	8b c8		 mov	 ecx, eax
  000c6	89 17		 mov	 DWORD PTR [edi], edx
  000c8	8b 06		 mov	 eax, DWORD PTR [esi]
  000ca	83 c7 04	 add	 edi, 4
  000cd	83 c3 04	 add	 ebx, 4
  000d0	83 c6 04	 add	 esi, 4
  000d3	ff 4d fc	 dec	 DWORD PTR _j$[ebp]
  000d6	75 c8		 jne	 SHORT $LL3@reloadMT

; 63   : 	}
; 64   : 
; 65   : 	s1 = this->state[0];

  000d8	8b 55 f8	 mov	 edx, DWORD PTR tv192[ebp]
  000db	8b 12		 mov	 edx, DWORD PTR [edx]

; 66   : 	*p0 = (*pM ^ (((s0 & 0x80000000) | (s1 & 0x7FFFFFFF)) >> 1)) ^ ((((s1&1)!=0)?-1:0)&0x9908B0DF);

  000dd	8b c2		 mov	 eax, edx
  000df	33 c1		 xor	 eax, ecx
  000e1	25 fe ff ff 7f	 and	 eax, 2147483646		; 7ffffffeH
  000e6	33 c1		 xor	 eax, ecx
  000e8	8b ca		 mov	 ecx, edx
  000ea	80 e1 01	 and	 cl, 1
  000ed	d1 e8		 shr	 eax, 1
  000ef	0f b6 c9	 movzx	 ecx, cl
  000f2	f7 d9		 neg	 ecx
  000f4	1b c9		 sbb	 ecx, ecx
  000f6	81 e1 df b0 08
	99		 and	 ecx, -1727483681	; 9908b0dfH
  000fc	33 c1		 xor	 eax, ecx
  000fe	33 03		 xor	 eax, DWORD PTR [ebx]
  00100	89 07		 mov	 DWORD PTR [edi], eax

; 67   : 	s1 ^= s1 >> 11;

  00102	8b c2		 mov	 eax, edx
  00104	c1 e8 0b	 shr	 eax, 11			; 0000000bH
  00107	33 d0		 xor	 edx, eax

; 68   : 	s1 ^= (s1 << 7) & 0x9D2C5680;

  00109	8b ca		 mov	 ecx, edx
  0010b	81 e1 ad 58 3a
	ff		 and	 ecx, -12953427		; ff3a58adH
  00111	c1 e1 07	 shl	 ecx, 7
  00114	33 d1		 xor	 edx, ecx

; 69   : 	s1 ^= (s1 << 15) & 0xEFC60000;

  00116	8b c2		 mov	 eax, edx
  00118	25 8c df ff ff	 and	 eax, -8308		; ffffdf8cH
  0011d	c1 e0 0f	 shl	 eax, 15			; 0000000fH
  00120	33 d0		 xor	 edx, eax
  00122	5f		 pop	 edi

; 70   : 
; 71   : 	return s1 ^ ( s1 >> 18 );

  00123	8b c2		 mov	 eax, edx
  00125	c1 e8 12	 shr	 eax, 18			; 00000012H
  00128	5e		 pop	 esi
  00129	33 c2		 xor	 eax, edx
  0012b	5b		 pop	 ebx

; 72   : }

  0012c	8b e5		 mov	 esp, ebp
  0012e	5d		 pop	 ebp
  0012f	c3		 ret	 0
?reloadMT@CLargeRand@@QAEKXZ ENDP			; CLargeRand::reloadMT
_TEXT	ENDS
PUBLIC	?Init0@CRandomMersenne@@AAEXH@Z			; CRandomMersenne::Init0
; Function compile flags: /Ogtp
;	COMDAT ?Init0@CRandomMersenne@@AAEXH@Z
_TEXT	SEGMENT
_seed$ = 8						; size = 4
?Init0@CRandomMersenne@@AAEXH@Z PROC			; CRandomMersenne::Init0, COMDAT
; _this$ = ecx

; 77   : void CRandomMersenne::Init0(int seed) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 78   :    // Seed generator
; 79   :    const DWORD factor = 1812433253UL;
; 80   :    mt[0]= seed;

  00003	8b 45 08	 mov	 eax, DWORD PTR _seed$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 81   :    for (mti=1; mti < MERS_N; mti++) {

  00008	c7 81 c0 09 00
	00 01 00 00 00	 mov	 DWORD PTR [ecx+2496], 1
  00012	53		 push	 ebx
$LL3@Init0:

; 82   :       mt[mti] = (factor * (mt[mti-1] ^ (mt[mti-1] >> 30)) + mti);

  00013	8b 81 c0 09 00
	00		 mov	 eax, DWORD PTR [ecx+2496]
  00019	8b 54 81 fc	 mov	 edx, DWORD PTR [ecx+eax*4-4]
  0001d	8b da		 mov	 ebx, edx
  0001f	c1 eb 1e	 shr	 ebx, 30			; 0000001eH
  00022	33 da		 xor	 ebx, edx
  00024	69 db 65 89 07
	6c		 imul	 ebx, 1812433253		; 6c078965H
  0002a	03 d8		 add	 ebx, eax
  0002c	89 1c 81	 mov	 DWORD PTR [ecx+eax*4], ebx
  0002f	ff 81 c0 09 00
	00		 inc	 DWORD PTR [ecx+2496]
  00035	81 b9 c0 09 00
	00 70 02 00 00	 cmp	 DWORD PTR [ecx+2496], 624 ; 00000270H
  0003f	7c d2		 jl	 SHORT $LL3@Init0
  00041	5b		 pop	 ebx

; 83   :    }
; 84   : }

  00042	5d		 pop	 ebp
  00043	c2 04 00	 ret	 4
?Init0@CRandomMersenne@@AAEXH@Z ENDP			; CRandomMersenne::Init0
_TEXT	ENDS
PUBLIC	?BRandom@CRandomMersenne@@QAEKXZ		; CRandomMersenne::BRandom
;	COMDAT ?mag01@?4??BRandom@CRandomMersenne@@QAEKXZ@4QBKB
CONST	SEGMENT
?mag01@?4??BRandom@CRandomMersenne@@QAEKXZ@4QBKB DD 00H	; `CRandomMersenne::BRandom'::`5'::mag01
	DD	09908b0dfH
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?BRandom@CRandomMersenne@@QAEKXZ
_TEXT	SEGMENT
?BRandom@CRandomMersenne@@QAEKXZ PROC			; CRandomMersenne::BRandom, COMDAT
; _this$ = ecx

; 124  :    // Generate 32 random bits
; 125  :    DWORD y;
; 126  : 
; 127  :    if (mti >= MERS_N) {

  00000	81 b9 c0 09 00
	00 70 02 00 00	 cmp	 DWORD PTR [ecx+2496], 624 ; 00000270H
  0000a	0f 8c ac 00 00
	00		 jl	 $LN7@BRandom

; 128  :       // Generate MERS_N words at one time
; 129  :       const DWORD LOWER_MASK = (1LU << MERS_R) - 1;       // Lower MERS_R bits
; 130  :       const DWORD UPPER_MASK = 0xFFFFFFFF << MERS_R;      // Upper (32 - MERS_R) bits
; 131  :       static const DWORD mag01[2] = {0, MERS_A};
; 132  : 
; 133  :       int kk;
; 134  :       for (kk=0; kk < MERS_N-MERS_M; kk++) {    

  00010	33 c0		 xor	 eax, eax
  00012	56		 push	 esi
$LL6@BRandom:

; 135  :          y = (mt[kk] & UPPER_MASK) | (mt[kk+1] & LOWER_MASK);

  00013	8b 54 81 04	 mov	 edx, DWORD PTR [ecx+eax*4+4]
  00017	33 14 81	 xor	 edx, DWORD PTR [ecx+eax*4]
  0001a	40		 inc	 eax
  0001b	81 e2 ff ff ff
	7f		 and	 edx, 2147483647		; 7fffffffH
  00021	33 54 81 fc	 xor	 edx, DWORD PTR [ecx+eax*4-4]

; 136  :          mt[kk] = mt[kk+MERS_M] ^ (y >> 1) ^ mag01[y & 1];}

  00025	8b f2		 mov	 esi, edx
  00027	d1 ea		 shr	 edx, 1
  00029	83 e6 01	 and	 esi, 1
  0002c	33 14 b5 00 00
	00 00		 xor	 edx, DWORD PTR ?mag01@?4??BRandom@CRandomMersenne@@QAEKXZ@4QBKB[esi*4]
  00033	33 94 81 30 06
	00 00		 xor	 edx, DWORD PTR [ecx+eax*4+1584]
  0003a	89 54 81 fc	 mov	 DWORD PTR [ecx+eax*4-4], edx
  0003e	3d e3 00 00 00	 cmp	 eax, 227		; 000000e3H
  00043	7c ce		 jl	 SHORT $LL6@BRandom

; 137  : 
; 138  :       for (; kk < MERS_N-1; kk++) {    

  00045	3d 6f 02 00 00	 cmp	 eax, 623		; 0000026fH
  0004a	7d 36		 jge	 SHORT $LN1@BRandom
  0004c	8d 64 24 00	 npad	 4
$LL3@BRandom:

; 139  :          y = (mt[kk] & UPPER_MASK) | (mt[kk+1] & LOWER_MASK);

  00050	8b 54 81 04	 mov	 edx, DWORD PTR [ecx+eax*4+4]
  00054	33 14 81	 xor	 edx, DWORD PTR [ecx+eax*4]
  00057	40		 inc	 eax
  00058	81 e2 ff ff ff
	7f		 and	 edx, 2147483647		; 7fffffffH
  0005e	33 54 81 fc	 xor	 edx, DWORD PTR [ecx+eax*4-4]

; 140  :          mt[kk] = mt[kk+(MERS_M-MERS_N)] ^ (y >> 1) ^ mag01[y & 1];}      

  00062	8b f2		 mov	 esi, edx
  00064	d1 ea		 shr	 edx, 1
  00066	83 e6 01	 and	 esi, 1
  00069	33 14 b5 00 00
	00 00		 xor	 edx, DWORD PTR ?mag01@?4??BRandom@CRandomMersenne@@QAEKXZ@4QBKB[esi*4]
  00070	33 94 81 70 fc
	ff ff		 xor	 edx, DWORD PTR [ecx+eax*4-912]
  00077	89 54 81 fc	 mov	 DWORD PTR [ecx+eax*4-4], edx
  0007b	3d 6f 02 00 00	 cmp	 eax, 623		; 0000026fH
  00080	7c ce		 jl	 SHORT $LL3@BRandom
$LN1@BRandom:

; 141  : 
; 142  :       y = (mt[MERS_N-1] & UPPER_MASK) | (mt[0] & LOWER_MASK);

  00082	8b 81 bc 09 00
	00		 mov	 eax, DWORD PTR [ecx+2492]
  00088	33 01		 xor	 eax, DWORD PTR [ecx]
  0008a	5e		 pop	 esi
  0008b	25 ff ff ff 7f	 and	 eax, 2147483647		; 7fffffffH
  00090	33 81 bc 09 00
	00		 xor	 eax, DWORD PTR [ecx+2492]

; 143  :       mt[MERS_N-1] = mt[MERS_M-1] ^ (y >> 1) ^ mag01[y & 1];

  00096	8b d0		 mov	 edx, eax
  00098	83 e2 01	 and	 edx, 1
  0009b	8b 14 95 00 00
	00 00		 mov	 edx, DWORD PTR ?mag01@?4??BRandom@CRandomMersenne@@QAEKXZ@4QBKB[edx*4]
  000a2	33 91 30 06 00
	00		 xor	 edx, DWORD PTR [ecx+1584]
  000a8	d1 e8		 shr	 eax, 1
  000aa	33 d0		 xor	 edx, eax
  000ac	89 91 bc 09 00
	00		 mov	 DWORD PTR [ecx+2492], edx

; 144  :       mti = 0;

  000b2	c7 81 c0 09 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+2496], 0
$LN7@BRandom:

; 145  :    }
; 146  :    y = mt[mti++];

  000bc	8b 81 c0 09 00
	00		 mov	 eax, DWORD PTR [ecx+2496]
  000c2	8b 14 81	 mov	 edx, DWORD PTR [ecx+eax*4]
  000c5	40		 inc	 eax
  000c6	89 81 c0 09 00
	00		 mov	 DWORD PTR [ecx+2496], eax

; 147  : 
; 148  :    // Tempering (May be omitted):
; 149  :    y ^=  y >> MERS_U;

  000cc	8b c2		 mov	 eax, edx
  000ce	c1 e8 0b	 shr	 eax, 11			; 0000000bH
  000d1	33 d0		 xor	 edx, eax

; 150  :    y ^= (y << MERS_S) & MERS_B;

  000d3	8b ca		 mov	 ecx, edx
  000d5	81 e1 ad 58 3a
	ff		 and	 ecx, -12953427		; ff3a58adH
  000db	c1 e1 07	 shl	 ecx, 7
  000de	33 d1		 xor	 edx, ecx

; 151  :    y ^= (y << MERS_T) & MERS_C;

  000e0	8b c2		 mov	 eax, edx
  000e2	25 8c df ff ff	 and	 eax, -8308		; ffffdf8cH
  000e7	c1 e0 0f	 shl	 eax, 15			; 0000000fH
  000ea	33 d0		 xor	 edx, eax

; 152  :    y ^=  y >> MERS_L;

  000ec	8b c2		 mov	 eax, edx
  000ee	c1 e8 12	 shr	 eax, 18			; 00000012H
  000f1	33 c2		 xor	 eax, edx

; 153  : 
; 154  :    return y;
; 155  : }

  000f3	c3		 ret	 0
?BRandom@CRandomMersenne@@QAEKXZ ENDP			; CRandomMersenne::BRandom
_TEXT	ENDS
PUBLIC	__real@3df0000000000000
PUBLIC	__real@41f0000000000000
PUBLIC	?Random@CRandomMersenne@@QAENXZ			; CRandomMersenne::Random
EXTRN	__fltused:DWORD
;	COMDAT __real@3df0000000000000
CONST	SEGMENT
__real@3df0000000000000 DQ 03df0000000000000r	; 2.32831e-010
CONST	ENDS
;	COMDAT __real@41f0000000000000
CONST	SEGMENT
__real@41f0000000000000 DQ 041f0000000000000r	; 4.29497e+009
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?Random@CRandomMersenne@@QAENXZ
_TEXT	SEGMENT
tv69 = -4						; size = 4
?Random@CRandomMersenne@@QAENXZ PROC			; CRandomMersenne::Random, COMDAT
; _this$ = ecx

; 158  : double CRandomMersenne::Random() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 159  :    // Output random float number in the interval 0 <= x < 1
; 160  :    // Multiply by 2^(-32)
; 161  :    return (double)BRandom() * (1./(65536.*65536.));

  00004	e8 00 00 00 00	 call	 ?BRandom@CRandomMersenne@@QAEKXZ ; CRandomMersenne::BRandom
  00009	89 45 fc	 mov	 DWORD PTR tv69[ebp], eax
  0000c	db 45 fc	 fild	 DWORD PTR tv69[ebp]
  0000f	85 c0		 test	 eax, eax
  00011	79 06		 jns	 SHORT $LN3@Random
  00013	dc 05 00 00 00
	00		 fadd	 QWORD PTR __real@41f0000000000000
$LN3@Random:
  00019	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@3df0000000000000

; 162  : }

  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c3		 ret	 0
?Random@CRandomMersenne@@QAENXZ ENDP			; CRandomMersenne::Random
_TEXT	ENDS
PUBLIC	?IRandom@CRandomMersenne@@QAEHHH@Z		; CRandomMersenne::IRandom
EXTRN	__ftol2_sse:PROC
; Function compile flags: /Ogtp
;	COMDAT ?IRandom@CRandomMersenne@@QAEHHH@Z
_TEXT	SEGMENT
_min$ = 8						; size = 4
tv138 = 12						; size = 4
_max$ = 12						; size = 4
?IRandom@CRandomMersenne@@QAEHHH@Z PROC			; CRandomMersenne::IRandom, COMDAT
; _this$ = ecx

; 165  : int CRandomMersenne::IRandom(int min, int max) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 166  :    // Output random integer in the interval min <= x <= max
; 167  :    // Relative error on frequencies < 2^-32
; 168  :    if (max <= min) {

  00004	8b 75 0c	 mov	 esi, DWORD PTR _max$[ebp]
  00007	57		 push	 edi
  00008	8b 7d 08	 mov	 edi, DWORD PTR _min$[ebp]
  0000b	3b f7		 cmp	 esi, edi
  0000d	7f 15		 jg	 SHORT $LN2@IRandom

; 169  :       if (max == min) return min; else return 0x80000000;

  0000f	75 08		 jne	 SHORT $LN3@IRandom
  00011	8b c7		 mov	 eax, edi
  00013	5f		 pop	 edi
  00014	5e		 pop	 esi

; 174  :    return r;
; 175  : }

  00015	5d		 pop	 ebp
  00016	c2 08 00	 ret	 8
$LN3@IRandom:
  00019	5f		 pop	 edi

; 169  :       if (max == min) return min; else return 0x80000000;

  0001a	b8 00 00 00 80	 mov	 eax, -2147483648	; 80000000H
  0001f	5e		 pop	 esi

; 174  :    return r;
; 175  : }

  00020	5d		 pop	 ebp
  00021	c2 08 00	 ret	 8
$LN2@IRandom:

; 170  :    }
; 171  :    // Multiply interval with random and truncate
; 172  :    int r = int((double)(DWORD)(max - min + 1) * Random() + min); 

  00024	e8 00 00 00 00	 call	 ?Random@CRandomMersenne@@QAENXZ ; CRandomMersenne::Random
  00029	8b c6		 mov	 eax, esi
  0002b	2b c7		 sub	 eax, edi
  0002d	40		 inc	 eax
  0002e	89 45 0c	 mov	 DWORD PTR tv138[ebp], eax
  00031	db 45 0c	 fild	 DWORD PTR tv138[ebp]
  00034	79 06		 jns	 SHORT $LN7@IRandom
  00036	dc 05 00 00 00
	00		 fadd	 QWORD PTR __real@41f0000000000000
$LN7@IRandom:
  0003c	de c9		 fmulp	 ST(1), ST(0)
  0003e	da 45 08	 fiadd	 DWORD PTR _min$[ebp]
  00041	e8 00 00 00 00	 call	 __ftol2_sse

; 173  :    if (r > max) r = max;

  00046	3b c6		 cmp	 eax, esi
  00048	7e 02		 jle	 SHORT $LN5@IRandom
  0004a	8b c6		 mov	 eax, esi
$LN5@IRandom:
  0004c	5f		 pop	 edi
  0004d	5e		 pop	 esi

; 174  :    return r;
; 175  : }

  0004e	5d		 pop	 ebp
  0004f	c2 08 00	 ret	 8
?IRandom@CRandomMersenne@@QAEHHH@Z ENDP			; CRandomMersenne::IRandom
_TEXT	ENDS
PUBLIC	?IRandom@CRandomMersenne@@QAEHH@Z		; CRandomMersenne::IRandom
; Function compile flags: /Ogtp
;	COMDAT ?IRandom@CRandomMersenne@@QAEHH@Z
_TEXT	SEGMENT
tv130 = 8						; size = 4
_max$ = 8						; size = 4
?IRandom@CRandomMersenne@@QAEHH@Z PROC			; CRandomMersenne::IRandom, COMDAT
; _this$ = ecx

; 177  : int CRandomMersenne::IRandom(int max) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 178  :    // Multiply interval with random and truncate
; 179  :    int r = int((double)(DWORD)(max) * Random()); 

  00004	e8 00 00 00 00	 call	 ?Random@CRandomMersenne@@QAENXZ ; CRandomMersenne::Random
  00009	8b 75 08	 mov	 esi, DWORD PTR _max$[ebp]
  0000c	8b c6		 mov	 eax, esi
  0000e	89 45 08	 mov	 DWORD PTR tv130[ebp], eax
  00011	db 45 08	 fild	 DWORD PTR tv130[ebp]
  00014	85 c0		 test	 eax, eax
  00016	79 06		 jns	 SHORT $LN5@IRandom@2
  00018	dc 05 00 00 00
	00		 fadd	 QWORD PTR __real@41f0000000000000
$LN5@IRandom@2:
  0001e	de c9		 fmulp	 ST(1), ST(0)
  00020	e8 00 00 00 00	 call	 __ftol2_sse

; 180  :    if (r >= max) r = max-1;

  00025	3b c6		 cmp	 eax, esi
  00027	7c 03		 jl	 SHORT $LN1@IRandom@2
  00029	8d 46 ff	 lea	 eax, DWORD PTR [esi-1]
$LN1@IRandom@2:
  0002c	5e		 pop	 esi

; 181  :    return r;
; 182  : }

  0002d	5d		 pop	 ebp
  0002e	c2 04 00	 ret	 4
?IRandom@CRandomMersenne@@QAEHH@Z ENDP			; CRandomMersenne::IRandom
_TEXT	ENDS
PUBLIC	?IRandomX@CRandomMersenne@@QAEHHH@Z		; CRandomMersenne::IRandomX
EXTRN	__allmul:PROC
EXTRN	__aulldiv:PROC
; Function compile flags: /Ogtp
;	COMDAT ?IRandomX@CRandomMersenne@@QAEHHH@Z
_TEXT	SEGMENT
_min$ = 8						; size = 4
_max$ = 12						; size = 4
?IRandomX@CRandomMersenne@@QAEHHH@Z PROC		; CRandomMersenne::IRandomX, COMDAT
; _this$ = ecx

; 184  : int CRandomMersenne::IRandomX(int min, int max) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 185  :    // Output random integer in the interval min <= x <= max
; 186  :    // Each output value has exactly the same probability.
; 187  :    // This is obtained by rejecting certain bit values so that the number
; 188  :    // of possible bit values is divisible by the interval length
; 189  :    if (max <= min) {

  00003	8b 45 08	 mov	 eax, DWORD PTR _min$[ebp]
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	8b 7d 0c	 mov	 edi, DWORD PTR _max$[ebp]
  0000b	8b f1		 mov	 esi, ecx
  0000d	3b f8		 cmp	 edi, eax
  0000f	7f 0d		 jg	 SHORT $LN5@IRandomX

; 190  :       if (max == min) return min; else return 0x80000000;

  00011	74 54		 je	 SHORT $LN8@IRandomX
  00013	5f		 pop	 edi
  00014	b8 00 00 00 80	 mov	 eax, -2147483648	; 80000000H
  00019	5e		 pop	 esi

; 214  : }

  0001a	5d		 pop	 ebp
  0001b	c2 08 00	 ret	 8
$LN5@IRandomX:

; 191  :    }
; 192  : 
; 193  :    // 64 bit integers available. Use multiply and shift method
; 194  :    unsigned __int32 interval;                    // Length of interval
; 195  :    unsigned __int64 longran;                     // Random bits * interval
; 196  :    unsigned __int32 iran;                        // Longran / 2^32
; 197  :    unsigned __int32 remainder;                   // Longran % 2^32
; 198  : 
; 199  :    interval = (DWORD)(max - min + 1);

  0001e	2b f8		 sub	 edi, eax
  00020	47		 inc	 edi

; 200  :    if (interval != LastInterval) {

  00021	3b be c4 09 00
	00		 cmp	 edi, DWORD PTR [esi+2500]
  00027	74 1c		 je	 SHORT $LN10@IRandomX

; 201  :       // Interval length has changed. Must calculate rejection limit
; 202  :       // Reject when remainder >= 2^32 / interval * interval
; 203  :       // RLimit will be 0 if interval is a power of 2. No rejection then
; 204  :       RLimit = DWORD(((unsigned __int64)1 << 32) / interval) * interval - 1;

  00029	6a 00		 push	 0
  0002b	57		 push	 edi
  0002c	6a 01		 push	 1
  0002e	6a 00		 push	 0
  00030	e8 00 00 00 00	 call	 __aulldiv
  00035	0f af c7	 imul	 eax, edi
  00038	48		 dec	 eax
  00039	89 86 c8 09 00
	00		 mov	 DWORD PTR [esi+2504], eax

; 205  :       LastInterval = interval;

  0003f	89 be c4 09 00
	00		 mov	 DWORD PTR [esi+2500], edi
$LN10@IRandomX:

; 209  :       iran = (DWORD)(longran >> 32);
; 210  :       remainder = (DWORD)longran;
; 211  :    } while (remainder > RLimit);

  00045	53		 push	 ebx
  00046	33 db		 xor	 ebx, ebx
$LL3@IRandomX:

; 206  :    }
; 207  :    do { // Rejection loop
; 208  :       longran  = (unsigned __int64)BRandom() * interval;

  00048	8b ce		 mov	 ecx, esi
  0004a	e8 00 00 00 00	 call	 ?BRandom@CRandomMersenne@@QAEKXZ ; CRandomMersenne::BRandom
  0004f	53		 push	 ebx
  00050	57		 push	 edi
  00051	6a 00		 push	 0
  00053	50		 push	 eax
  00054	e8 00 00 00 00	 call	 __allmul

; 209  :       iran = (DWORD)(longran >> 32);
; 210  :       remainder = (DWORD)longran;
; 211  :    } while (remainder > RLimit);

  00059	3b 86 c8 09 00
	00		 cmp	 eax, DWORD PTR [esi+2504]
  0005f	77 e7		 ja	 SHORT $LL3@IRandomX

; 212  :    // Convert back to signed and return result
; 213  :    return (__int32)iran + min;

  00061	8b 45 08	 mov	 eax, DWORD PTR _min$[ebp]
  00064	03 c2		 add	 eax, edx
  00066	5b		 pop	 ebx
$LN8@IRandomX:
  00067	5f		 pop	 edi
  00068	5e		 pop	 esi

; 214  : }

  00069	5d		 pop	 ebp
  0006a	c2 08 00	 ret	 8
?IRandomX@CRandomMersenne@@QAEHHH@Z ENDP		; CRandomMersenne::IRandomX
_TEXT	ENDS
PUBLIC	?IRandomX@CRandomMersenne@@QAEHH@Z		; CRandomMersenne::IRandomX
; Function compile flags: /Ogtp
;	COMDAT ?IRandomX@CRandomMersenne@@QAEHH@Z
_TEXT	SEGMENT
_max$ = 8						; size = 4
?IRandomX@CRandomMersenne@@QAEHH@Z PROC			; CRandomMersenne::IRandomX, COMDAT
; _this$ = ecx

; 216  : int CRandomMersenne::IRandomX(int max) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	57		 push	 edi

; 217  :    // 64 bit integers available. Use multiply and shift method
; 218  :    unsigned __int32 interval;                    // Length of interval
; 219  :    unsigned __int64 longran;                     // Random bits * interval
; 220  :    unsigned __int32 iran;                        // Longran / 2^32
; 221  :    unsigned __int32 remainder;                   // Longran % 2^32
; 222  : 
; 223  :    interval = (DWORD)(max);
; 224  :    if (interval != LastInterval) {

  00006	8b 7d 08	 mov	 edi, DWORD PTR _max$[ebp]
  00009	8b f1		 mov	 esi, ecx
  0000b	3b be c4 09 00
	00		 cmp	 edi, DWORD PTR [esi+2500]
  00011	74 1c		 je	 SHORT $LN7@IRandomX@2

; 225  :       // Interval length has changed. Must calculate rejection limit
; 226  :       // Reject when remainder >= 2^32 / interval * interval
; 227  :       // RLimit will be 0 if interval is a power of 2. No rejection then
; 228  :       RLimit = DWORD(((unsigned __int64)1 << 32) / interval) * interval - 1;

  00013	6a 00		 push	 0
  00015	57		 push	 edi
  00016	6a 01		 push	 1
  00018	6a 00		 push	 0
  0001a	e8 00 00 00 00	 call	 __aulldiv
  0001f	0f af c7	 imul	 eax, edi
  00022	48		 dec	 eax
  00023	89 86 c8 09 00
	00		 mov	 DWORD PTR [esi+2504], eax

; 229  :       LastInterval = interval;

  00029	89 be c4 09 00
	00		 mov	 DWORD PTR [esi+2500], edi
$LN7@IRandomX@2:

; 233  :       iran = (DWORD)(longran >> 32);
; 234  :       remainder = (DWORD)longran;
; 235  :    } while (remainder > RLimit);

  0002f	33 db		 xor	 ebx, ebx
$LL3@IRandomX@2:

; 230  :    }
; 231  :    do { // Rejection loop
; 232  :       longran  = (unsigned __int64)BRandom() * interval;

  00031	8b ce		 mov	 ecx, esi
  00033	e8 00 00 00 00	 call	 ?BRandom@CRandomMersenne@@QAEKXZ ; CRandomMersenne::BRandom
  00038	53		 push	 ebx
  00039	57		 push	 edi
  0003a	6a 00		 push	 0
  0003c	50		 push	 eax
  0003d	e8 00 00 00 00	 call	 __allmul

; 233  :       iran = (DWORD)(longran >> 32);
; 234  :       remainder = (DWORD)longran;
; 235  :    } while (remainder > RLimit);

  00042	3b 86 c8 09 00
	00		 cmp	 eax, DWORD PTR [esi+2504]
  00048	77 e7		 ja	 SHORT $LL3@IRandomX@2

; 236  :    // Convert back to signed and return result
; 237  :    return (__int32)iran;

  0004a	5f		 pop	 edi
  0004b	5e		 pop	 esi
  0004c	8b c2		 mov	 eax, edx
  0004e	5b		 pop	 ebx

; 238  : }

  0004f	5d		 pop	 ebp
  00050	c2 04 00	 ret	 4
?IRandomX@CRandomMersenne@@QAEHH@Z ENDP			; CRandomMersenne::IRandomX
_TEXT	ENDS
EXTRN	__time64:PROC
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\time.inl
;	COMDAT _time
_TEXT	SEGMENT
_time	PROC						; COMDAT
; __Time$ = eax

; 133  :     return _time64(_Time);

  00000	50		 push	 eax
  00001	e8 00 00 00 00	 call	 __time64
  00006	83 c4 04	 add	 esp, 4

; 134  : }

  00009	c3		 ret	 0
_time	ENDP
_TEXT	ENDS
PUBLIC	?randomMT@CLargeRand@@QAEKXZ			; CLargeRand::randomMT
; Function compile flags: /Ogtp
; File c:\muserver_dev\development\mu-s8ep2-repack\gameserver\source\largerand.h
;	COMDAT ?randomMT@CLargeRand@@QAEKXZ
_TEXT	SEGMENT
?randomMT@CLargeRand@@QAEKXZ PROC			; CLargeRand::randomMT, COMDAT
; _this$ = ecx

; 22   : 		this->left--;

  00000	ff 89 cc 09 00
	00		 dec	 DWORD PTR [ecx+2508]

; 23   : 
; 24   : 		if ( this->left< 0 )

  00006	79 05		 jns	 SHORT $LN1@randomMT

; 25   : 		{
; 26   : 			return this->reloadMT();

  00008	e9 00 00 00 00	 jmp	 ?reloadMT@CLargeRand@@QAEKXZ ; CLargeRand::reloadMT
$LN1@randomMT:

; 27   : 		}
; 28   : 
; 29   : 		DWORD y = *next;

  0000d	8b 81 c8 09 00
	00		 mov	 eax, DWORD PTR [ecx+2504]
  00013	8b 10		 mov	 edx, DWORD PTR [eax]

; 30   : 		next++;

  00015	83 c0 04	 add	 eax, 4
  00018	89 81 c8 09 00
	00		 mov	 DWORD PTR [ecx+2504], eax

; 31   : 		y ^= ( (DWORD)y >> (DWORD)11 );

  0001e	8b c2		 mov	 eax, edx
  00020	c1 e8 0b	 shr	 eax, 11			; 0000000bH
  00023	33 d0		 xor	 edx, eax

; 32   : 		y ^= ( y << 7 ) & 2636928640;

  00025	8b ca		 mov	 ecx, edx
  00027	81 e1 ad 58 3a
	ff		 and	 ecx, -12953427		; ff3a58adH
  0002d	c1 e1 07	 shl	 ecx, 7
  00030	33 d1		 xor	 edx, ecx

; 33   : 		y ^= ( y << 15 ) & 4022730752;

  00032	8b c2		 mov	 eax, edx
  00034	25 8c df ff ff	 and	 eax, -8308		; ffffdf8cH
  00039	c1 e0 0f	 shl	 eax, 15			; 0000000fH
  0003c	33 d0		 xor	 edx, eax

; 34   : 
; 35   : 		return y ^ ( y >> 18 );

  0003e	8b c2		 mov	 eax, edx
  00040	c1 e8 12	 shr	 eax, 18			; 00000012H
  00043	33 c2		 xor	 eax, edx

; 36   : 	};

  00045	c3		 ret	 0
?randomMT@CLargeRand@@QAEKXZ ENDP			; CLargeRand::randomMT
_TEXT	ENDS
PUBLIC	?GetLargeRand@@YAKXZ				; GetLargeRand
; Function compile flags: /Ogtp
; File c:\muserver_dev\development\mu-s8ep2-repack\gameserver\source\largerand.cpp
;	COMDAT ?GetLargeRand@@YAKXZ
_TEXT	SEGMENT
?GetLargeRand@@YAKXZ PROC				; GetLargeRand, COMDAT

; 8    : 	return g_LargLand.randomMT();

  00000	ff 0d cc 09 00
	00		 dec	 DWORD PTR ?g_LargLand@@3VCLargeRand@@A+2508
  00006	79 0a		 jns	 SHORT $LN3@GetLargeRa
  00008	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_LargLand@@3VCLargeRand@@A ; g_LargLand
  0000d	e9 00 00 00 00	 jmp	 ?reloadMT@CLargeRand@@QAEKXZ ; CLargeRand::reloadMT
$LN3@GetLargeRa:
  00012	a1 c8 09 00 00	 mov	 eax, DWORD PTR ?g_LargLand@@3VCLargeRand@@A+2504
  00017	8b 08		 mov	 ecx, DWORD PTR [eax]
  00019	83 c0 04	 add	 eax, 4
  0001c	a3 c8 09 00 00	 mov	 DWORD PTR ?g_LargLand@@3VCLargeRand@@A+2504, eax
  00021	8b c1		 mov	 eax, ecx
  00023	c1 e8 0b	 shr	 eax, 11			; 0000000bH
  00026	33 c8		 xor	 ecx, eax
  00028	8b d1		 mov	 edx, ecx
  0002a	81 e2 ad 58 3a
	ff		 and	 edx, -12953427		; ff3a58adH
  00030	c1 e2 07	 shl	 edx, 7
  00033	33 ca		 xor	 ecx, edx
  00035	8b c1		 mov	 eax, ecx
  00037	25 8c df ff ff	 and	 eax, -8308		; ffffdf8cH
  0003c	c1 e0 0f	 shl	 eax, 15			; 0000000fH
  0003f	33 c8		 xor	 ecx, eax
  00041	8b c1		 mov	 eax, ecx
  00043	c1 e8 12	 shr	 eax, 18			; 00000012H
  00046	33 c1		 xor	 eax, ecx

; 9    : }

  00048	c3		 ret	 0
?GetLargeRand@@YAKXZ ENDP				; GetLargeRand
_TEXT	ENDS
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Ogtp
;	COMDAT ??_GCLargeRand@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCLargeRand@@UAEPAXI@Z PROC				; CLargeRand::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1CLargeRand@@UAE@XZ	; CLargeRand::~CLargeRand
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 09		 je	 SHORT $LN4@scalar
  00011	56		 push	 esi
  00012	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00017	83 c4 04	 add	 esp, 4
$LN4@scalar:
  0001a	8b c6		 mov	 eax, esi
  0001c	5e		 pop	 esi
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
??_GCLargeRand@@UAEPAXI@Z ENDP				; CLargeRand::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?RandomInit@CRandomMersenne@@QAEXH@Z		; CRandomMersenne::RandomInit
; Function compile flags: /Ogtp
;	COMDAT ?RandomInit@CRandomMersenne@@QAEXH@Z
_TEXT	SEGMENT
_seed$ = 8						; size = 4
?RandomInit@CRandomMersenne@@QAEXH@Z PROC		; CRandomMersenne::RandomInit, COMDAT
; _this$ = ecx

; 86   : void CRandomMersenne::RandomInit(int seed) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 87   :    // Initialize and seed
; 88   :    Init0(seed);

  00003	8b 45 08	 mov	 eax, DWORD PTR _seed$[ebp]
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	50		 push	 eax
  00009	8b f1		 mov	 esi, ecx
  0000b	e8 00 00 00 00	 call	 ?Init0@CRandomMersenne@@AAEXH@Z ; CRandomMersenne::Init0
  00010	bf 25 00 00 00	 mov	 edi, 37			; 00000025H
$LL3@RandomInit:

; 89   : 
; 90   :    // Randomize some more
; 91   :    for (int i = 0; i < 37; i++) BRandom();

  00015	8b ce		 mov	 ecx, esi
  00017	e8 00 00 00 00	 call	 ?BRandom@CRandomMersenne@@QAEKXZ ; CRandomMersenne::BRandom
  0001c	4f		 dec	 edi
  0001d	75 f6		 jne	 SHORT $LL3@RandomInit
  0001f	5f		 pop	 edi
  00020	5e		 pop	 esi

; 92   : }

  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
?RandomInit@CRandomMersenne@@QAEXH@Z ENDP		; CRandomMersenne::RandomInit
_TEXT	ENDS
PUBLIC	?RandomInitByArray@CRandomMersenne@@QAEXQBHH@Z	; CRandomMersenne::RandomInitByArray
; Function compile flags: /Ogtp
;	COMDAT ?RandomInitByArray@CRandomMersenne@@QAEXQBHH@Z
_TEXT	SEGMENT
_k$ = -4						; size = 4
_seeds$ = 8						; size = 4
_NumSeeds$ = 12						; size = 4
?RandomInitByArray@CRandomMersenne@@QAEXQBHH@Z PROC	; CRandomMersenne::RandomInitByArray, COMDAT
; _this$ = ecx

; 95   : void CRandomMersenne::RandomInitByArray(int const seeds[], int NumSeeds) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi

; 96   :    // Seed by more than 32 bits
; 97   :    int i, j, k;
; 98   : 
; 99   :    // Initialize
; 100  :    Init0(19650218);

  00005	68 aa d6 2b 01	 push	 19650218		; 012bd6aaH
  0000a	8b f1		 mov	 esi, ecx
  0000c	e8 00 00 00 00	 call	 ?Init0@CRandomMersenne@@AAEXH@Z ; CRandomMersenne::Init0

; 101  : 
; 102  :    if (NumSeeds <= 0) return;

  00011	8b 55 0c	 mov	 edx, DWORD PTR _NumSeeds$[ebp]
  00014	85 d2		 test	 edx, edx
  00016	0f 8e b6 00 00
	00		 jle	 $LN1@RandomInit@2

; 103  : 
; 104  :    // Randomize mt[] using whole seeds[] array
; 105  :    i = 1;  j = 0;

  0001c	33 c9		 xor	 ecx, ecx
  0001e	b8 01 00 00 00	 mov	 eax, 1

; 106  :    k = (MERS_N > NumSeeds ? MERS_N : NumSeeds);

  00023	c7 45 fc 70 02
	00 00		 mov	 DWORD PTR _k$[ebp], 624	; 00000270H
  0002a	81 fa 70 02 00
	00		 cmp	 edx, 624		; 00000270H
  00030	7c 03		 jl	 SHORT $LN28@RandomInit@2
  00032	89 55 fc	 mov	 DWORD PTR _k$[ebp], edx
$LN28@RandomInit@2:
  00035	57		 push	 edi
  00036	8b 7d 08	 mov	 edi, DWORD PTR _seeds$[ebp]
  00039	53		 push	 ebx
  0003a	8d 9b 00 00 00
	00		 npad	 6
$LL25@RandomInit@2:

; 108  :       mt[i] = (mt[i] ^ ((mt[i-1] ^ (mt[i-1] >> 30)) * 1664525UL)) + (DWORD)seeds[j] + j;

  00040	8b 54 86 fc	 mov	 edx, DWORD PTR [esi+eax*4-4]
  00044	8b da		 mov	 ebx, edx
  00046	c1 eb 1e	 shr	 ebx, 30			; 0000001eH
  00049	33 da		 xor	 ebx, edx
  0004b	69 db 0d 66 19
	00		 imul	 ebx, 1664525		; 0019660dH
  00051	33 1c 86	 xor	 ebx, DWORD PTR [esi+eax*4]

; 109  :       i++; j++;

  00054	40		 inc	 eax
  00055	03 1c 8f	 add	 ebx, DWORD PTR [edi+ecx*4]
  00058	03 d9		 add	 ebx, ecx
  0005a	89 5c 86 fc	 mov	 DWORD PTR [esi+eax*4-4], ebx
  0005e	41		 inc	 ecx

; 110  :       if (i >= MERS_N) {mt[0] = mt[MERS_N-1]; i=1;}

  0005f	3d 70 02 00 00	 cmp	 eax, 624		; 00000270H
  00064	7c 0d		 jl	 SHORT $LN9@RandomInit@2
  00066	8b 86 bc 09 00
	00		 mov	 eax, DWORD PTR [esi+2492]
  0006c	89 06		 mov	 DWORD PTR [esi], eax
  0006e	b8 01 00 00 00	 mov	 eax, 1
$LN9@RandomInit@2:

; 111  :       if (j >= NumSeeds) j=0;}

  00073	3b 4d 0c	 cmp	 ecx, DWORD PTR _NumSeeds$[ebp]
  00076	7c 02		 jl	 SHORT $LN11@RandomInit@2
  00078	33 c9		 xor	 ecx, ecx
$LN11@RandomInit@2:

; 107  :    for (; k; k--) {

  0007a	ff 4d fc	 dec	 DWORD PTR _k$[ebp]
  0007d	75 c1		 jne	 SHORT $LL25@RandomInit@2

; 112  :    for (k = MERS_N-1; k; k--) {

  0007f	ba 6f 02 00 00	 mov	 edx, 623		; 0000026fH
  00084	5b		 pop	 ebx
$LL7@RandomInit@2:

; 113  :       mt[i] = (mt[i] ^ ((mt[i-1] ^ (mt[i-1] >> 30)) * 1566083941UL)) - i;

  00085	8b 4c 86 fc	 mov	 ecx, DWORD PTR [esi+eax*4-4]
  00089	8b f9		 mov	 edi, ecx
  0008b	c1 ef 1e	 shr	 edi, 30			; 0000001eH
  0008e	33 f9		 xor	 edi, ecx
  00090	69 ff 65 8b 58
	5d		 imul	 edi, 1566083941		; 5d588b65H
  00096	33 3c 86	 xor	 edi, DWORD PTR [esi+eax*4]
  00099	2b f8		 sub	 edi, eax
  0009b	89 3c 86	 mov	 DWORD PTR [esi+eax*4], edi

; 114  :       if (++i >= MERS_N) {mt[0] = mt[MERS_N-1]; i=1;}}

  0009e	40		 inc	 eax
  0009f	3d 70 02 00 00	 cmp	 eax, 624		; 00000270H
  000a4	7c 0d		 jl	 SHORT $LN6@RandomInit@2
  000a6	8b 8e bc 09 00
	00		 mov	 ecx, DWORD PTR [esi+2492]
  000ac	89 0e		 mov	 DWORD PTR [esi], ecx
  000ae	b8 01 00 00 00	 mov	 eax, 1
$LN6@RandomInit@2:

; 112  :    for (k = MERS_N-1; k; k--) {

  000b3	4a		 dec	 edx
  000b4	75 cf		 jne	 SHORT $LL7@RandomInit@2

; 115  :    mt[0] = 0x80000000UL;  // MSB is 1; assuring non-zero initial array

  000b6	c7 06 00 00 00
	80		 mov	 DWORD PTR [esi], -2147483648 ; 80000000H

; 116  : 
; 117  :    // Randomize some more
; 118  :    mti = 0;

  000bc	89 96 c0 09 00
	00		 mov	 DWORD PTR [esi+2496], edx
  000c2	bf 71 02 00 00	 mov	 edi, 625		; 00000271H
$LL3@RandomInit@2:

; 119  :    for ( i = 0; i <= MERS_N; i++) BRandom();

  000c7	8b ce		 mov	 ecx, esi
  000c9	e8 00 00 00 00	 call	 ?BRandom@CRandomMersenne@@QAEKXZ ; CRandomMersenne::BRandom
  000ce	4f		 dec	 edi
  000cf	75 f6		 jne	 SHORT $LL3@RandomInit@2
  000d1	5f		 pop	 edi
$LN1@RandomInit@2:
  000d2	5e		 pop	 esi

; 120  : }

  000d3	8b e5		 mov	 esp, ebp
  000d5	5d		 pop	 ebp
  000d6	c2 08 00	 ret	 8
?RandomInitByArray@CRandomMersenne@@QAEXQBHH@Z ENDP	; CRandomMersenne::RandomInitByArray
_TEXT	ENDS
PUBLIC	??0CRandomMersenne@@QAE@H@Z			; CRandomMersenne::CRandomMersenne
; Function compile flags: /Ogtp
; File c:\muserver_dev\development\mu-s8ep2-repack\gameserver\source\largerand.h
;	COMDAT ??0CRandomMersenne@@QAE@H@Z
_TEXT	SEGMENT
_seed$ = 8						; size = 4
??0CRandomMersenne@@QAE@H@Z PROC			; CRandomMersenne::CRandomMersenne, COMDAT
; _this$ = ecx

; 62   :    CRandomMersenne(int seed) {         // Constructor

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 63   :       RandomInit(seed); LastInterval = 0;}

  00003	8b 45 08	 mov	 eax, DWORD PTR _seed$[ebp]
  00006	56		 push	 esi
  00007	50		 push	 eax
  00008	8b f1		 mov	 esi, ecx
  0000a	e8 00 00 00 00	 call	 ?RandomInit@CRandomMersenne@@QAEXH@Z ; CRandomMersenne::RandomInit
  0000f	c7 86 c4 09 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+2500], 0
  00019	8b c6		 mov	 eax, esi
  0001b	5e		 pop	 esi
  0001c	5d		 pop	 ebp
  0001d	c2 04 00	 ret	 4
??0CRandomMersenne@@QAE@H@Z ENDP			; CRandomMersenne::CRandomMersenne
_TEXT	ENDS
EXTRN	_atexit:PROC
; Function compile flags: /Ogtp
; File c:\muserver_dev\development\mu-s8ep2-repack\gameserver\source\largerand.cpp
;	COMDAT ??__Eg_LargLand@@YAXXZ
text$yc	SEGMENT
??__Eg_LargLand@@YAXXZ PROC				; `dynamic initializer for 'g_LargLand'', COMDAT

; 4    : CLargeRand g_LargLand;

  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_LargLand@@3VCLargeRand@@A ; g_LargLand
  00005	e8 00 00 00 00	 call	 ??0CLargeRand@@QAE@XZ	; CLargeRand::CLargeRand
  0000a	68 00 00 00 00	 push	 OFFSET ??__Fg_LargLand@@YAXXZ ; `dynamic atexit destructor for 'g_LargLand''
  0000f	e8 00 00 00 00	 call	 _atexit
  00014	59		 pop	 ecx
  00015	c3		 ret	 0
??__Eg_LargLand@@YAXXZ ENDP				; `dynamic initializer for 'g_LargLand''
; Function compile flags: /Ogtp
text$yc	ENDS
;	COMDAT ??__Eg_MersenneRand@@YAXXZ
text$yc	SEGMENT
??__Eg_MersenneRand@@YAXXZ PROC				; `dynamic initializer for 'g_MersenneRand'', COMDAT

; 75   : CRandomMersenne g_MersenneRand((int)time(NULL));

  00000	6a 00		 push	 0
  00002	e8 00 00 00 00	 call	 __time64
  00007	83 c4 04	 add	 esp, 4
  0000a	50		 push	 eax
  0000b	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_MersenneRand@@3VCRandomMersenne@@A ; g_MersenneRand
  00010	e8 00 00 00 00	 call	 ?RandomInit@CRandomMersenne@@QAEXH@Z ; CRandomMersenne::RandomInit
  00015	c7 05 c4 09 00
	00 00 00 00 00	 mov	 DWORD PTR ?g_MersenneRand@@3VCRandomMersenne@@A+2500, 0
  0001f	c3		 ret	 0
??__Eg_MersenneRand@@YAXXZ ENDP				; `dynamic initializer for 'g_MersenneRand''
; Function compile flags: /Ogtp
text$yc	ENDS
;	COMDAT ??__Fg_LargLand@@YAXXZ
text$yd	SEGMENT
??__Fg_LargLand@@YAXXZ PROC				; `dynamic atexit destructor for 'g_LargLand'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_LargLand@@3VCLargeRand@@A ; g_LargLand
  00005	e9 00 00 00 00	 jmp	 ??1CLargeRand@@UAE@XZ	; CLargeRand::~CLargeRand
??__Fg_LargLand@@YAXXZ ENDP				; `dynamic atexit destructor for 'g_LargLand''
text$yd	ENDS
PUBLIC	?g_MersenneRand@@3VCRandomMersenne@@A		; g_MersenneRand
PUBLIC	?g_LargLand@@3VCLargeRand@@A			; g_LargLand
_BSS	SEGMENT
?g_MersenneRand@@3VCRandomMersenne@@A DB 09ccH DUP (?)	; g_MersenneRand
?g_LargLand@@3VCLargeRand@@A DB 09d0H DUP (?)		; g_LargLand
_BSS	ENDS
CRT$XCU	SEGMENT
_g_LargLand$initializer$ DD FLAT:??__Eg_LargLand@@YAXXZ
_g_MersenneRand$initializer$ DD FLAT:??__Eg_MersenneRand@@YAXXZ
CRT$XCU	ENDS
END
