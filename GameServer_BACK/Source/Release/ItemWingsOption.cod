; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	C:\muserver_dev\development\MU-S8EP2-Repack\GameServer\Source\ItemWingsOption.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?Read@ItemWingsOption@@QAEXPBD@Z		; ItemWingsOption::Read
; Function compile flags: /Ogtp
; File c:\muserver_dev\development\mu-s8ep2-repack\gameserver\source\itemwingsoption.cpp
;	COMDAT ?Read@ItemWingsOption@@QAEXPBD@Z
_TEXT	SEGMENT
_File$ = 8						; size = 4
?Read@ItemWingsOption@@QAEXPBD@Z PROC			; ItemWingsOption::Read, COMDAT
; _this$ = ecx

; 21   : 	
; 22   : }

  00000	c2 04 00	 ret	 4
?Read@ItemWingsOption@@QAEXPBD@Z ENDP			; ItemWingsOption::Read
_TEXT	ENDS
PUBLIC	?capacity@?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@QBEIXZ ; std::vector<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> >::capacity
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?capacity@?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@QBEIXZ PROC ; std::vector<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> >::capacity, COMDAT
; _this$ = ecx

; 777  : 		return (this->_Myend - this->_Myfirst);

  00000	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00003	2b 11		 sub	 edx, DWORD PTR [ecx]
  00005	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0000a	f7 ea		 imul	 edx
  0000c	8b c2		 mov	 eax, edx
  0000e	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00011	03 c2		 add	 eax, edx

; 778  : 		}

  00013	c3		 ret	 0
?capacity@?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@QBEIXZ ENDP ; std::vector<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> >::capacity
_TEXT	ENDS
PUBLIC	??2@YAPAXIPAX@Z					; operator new
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\new.h
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 81   :         {return (_Where); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]
  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
PUBLIC	??3@YAXPAX0@Z					; operator delete
; Function compile flags: /Ogtp
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 83   :         {return; }

  00000	c3		 ret	 0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@QAE@XZ ; std::_Vector_val<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> >::~_Vector_val<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??1?$_Vector_val@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> >::~_Vector_val<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> >, COMDAT
; _this$ = ecx

; 434  : 		}

  00000	c3		 ret	 0
??1?$_Vector_val@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> >::~_Vector_val<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> >
_TEXT	ENDS
PUBLIC	??0?$allocator@UItemWingsOptionInfo@@@std@@QAE@XZ ; std::allocator<ItemWingsOptionInfo>::allocator<ItemWingsOptionInfo>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??0?$allocator@UItemWingsOptionInfo@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@UItemWingsOptionInfo@@@std@@QAE@XZ PROC	; std::allocator<ItemWingsOptionInfo>::allocator<ItemWingsOptionInfo>, COMDAT
; _this$ = ecx

; 161  : 	_ALLOCATOR() _THROW0()

  00000	8b c1		 mov	 eax, ecx

; 162  : 		{	// construct default allocator (do nothing)
; 163  : 		}

  00002	c3		 ret	 0
??0?$allocator@UItemWingsOptionInfo@@@std@@QAE@XZ ENDP	; std::allocator<ItemWingsOptionInfo>::allocator<ItemWingsOptionInfo>
_TEXT	ENDS
PUBLIC	??0?$allocator@UItemWingsOptionInfo@@@std@@QAE@ABV01@@Z ; std::allocator<ItemWingsOptionInfo>::allocator<ItemWingsOptionInfo>
; Function compile flags: /Ogtp
;	COMDAT ??0?$allocator@UItemWingsOptionInfo@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@UItemWingsOptionInfo@@@std@@QAE@ABV01@@Z PROC ; std::allocator<ItemWingsOptionInfo>::allocator<ItemWingsOptionInfo>, COMDAT
; _this$ = ecx

; 165  : 	_ALLOCATOR(const _ALLOCATOR<_Ty>&) _THROW0()

  00000	8b c1		 mov	 eax, ecx

; 166  : 		{	// construct by copying (do nothing)
; 167  : 		}

  00002	c2 04 00	 ret	 4
??0?$allocator@UItemWingsOptionInfo@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<ItemWingsOptionInfo>::allocator<ItemWingsOptionInfo>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@UItemWingsOptionInfo@@@std@@QAEXPAUItemWingsOptionInfo@@I@Z ; std::allocator<ItemWingsOptionInfo>::deallocate
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Ogtp
;	COMDAT ?deallocate@?$allocator@UItemWingsOptionInfo@@@std@@QAEXPAUItemWingsOptionInfo@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@UItemWingsOptionInfo@@@std@@QAEXPAUItemWingsOptionInfo@@I@Z PROC ; std::allocator<ItemWingsOptionInfo>::deallocate, COMDAT
; _this$ = ecx

; 181  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 182  : 		::operator delete(_Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000c	83 c4 04	 add	 esp, 4

; 183  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 08 00	 ret	 8
?deallocate@?$allocator@UItemWingsOptionInfo@@@std@@QAEXPAUItemWingsOptionInfo@@I@Z ENDP ; std::allocator<ItemWingsOptionInfo>::deallocate
_TEXT	ENDS
PUBLIC	?get_allocator@?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@QBE?AV?$allocator@UItemWingsOptionInfo@@@2@XZ ; std::vector<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> >::get_allocator
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?get_allocator@?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@QBE?AV?$allocator@UItemWingsOptionInfo@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?get_allocator@?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@QBE?AV?$allocator@UItemWingsOptionInfo@@@2@XZ PROC ; std::vector<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> >::get_allocator, COMDAT
; _this$ = ecx

; 893  : 		{	// return allocator object for values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 894  : 		return (this->_Alval);

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 895  : 		}

  00006	5d		 pop	 ebp
  00007	c2 04 00	 ret	 4
?get_allocator@?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@QBE?AV?$allocator@UItemWingsOptionInfo@@@2@XZ ENDP ; std::vector<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> >::get_allocator
_TEXT	ENDS
PUBLIC	?_Inside@?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@IBE_NPBUItemWingsOptionInfo@@@Z ; std::vector<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> >::_Inside
; Function compile flags: /Ogtp
;	COMDAT ?_Inside@?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@IBE_NPBUItemWingsOptionInfo@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?_Inside@?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@IBE_NPBUItemWingsOptionInfo@@@Z PROC ; std::vector<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> >::_Inside, COMDAT
; _this$ = ecx

; 1285 : 		{	// test if _Ptr points inside vector

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1286 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  00009	73 0d		 jae	 SHORT $LN3@Inside
  0000b	39 01		 cmp	 DWORD PTR [ecx], eax
  0000d	77 09		 ja	 SHORT $LN3@Inside
  0000f	b8 01 00 00 00	 mov	 eax, 1

; 1287 : 		}

  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
$LN3@Inside:

; 1286 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  00018	33 c0		 xor	 eax, eax

; 1287 : 		}

  0001a	5d		 pop	 ebp
  0001b	c2 04 00	 ret	 4
?_Inside@?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@IBE_NPBUItemWingsOptionInfo@@@Z ENDP ; std::vector<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> >::_Inside
_TEXT	ENDS
PUBLIC	?_Orphan_range@?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@IBEXPAUItemWingsOptionInfo@@0@Z ; std::vector<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> >::_Orphan_range
; Function compile flags: /Ogtp
;	COMDAT ?_Orphan_range@?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@IBEXPAUItemWingsOptionInfo@@0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?_Orphan_range@?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@IBEXPAUItemWingsOptionInfo@@0@Z PROC ; std::vector<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> >::_Orphan_range, COMDAT
; _this$ = ecx

; 1454 : 		}

  00000	c2 08 00	 ret	 8
?_Orphan_range@?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@IBEXPAUItemWingsOptionInfo@@0@Z ENDP ; std::vector<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> >::_Orphan_range
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@@std@@QBEABUItemWingsOptionInfo@@XZ ; std::_Vector_const_iterator<std::_Vector_val<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> > >::operator*
; Function compile flags: /Ogtp
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@@std@@QBEABUItemWingsOptionInfo@@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@V?$_Vector_val@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@@std@@QBEABUItemWingsOptionInfo@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> > >::operator*, COMDAT
; _this$ = ecx

; 64   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 65   : 		if (this->_Getcont() == 0
; 66   : 			|| this->_Ptr == 0
; 67   : 			|| this->_Ptr < ((_Myvec *)this->_Getcont())->_Myfirst
; 68   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 69   : 			{	// report error
; 70   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 71   : 			_SCL_SECURE_OUT_OF_RANGE;
; 72   : 			}
; 73   : 
; 74   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 75   : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 76   : 		_SCL_SECURE_VALIDATE_RANGE(
; 77   : 			this->_Ptr != 0
; 78   : 			&& ((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr
; 79   : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 80   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 81   : 
; 82   : 		__analysis_assume(this->_Ptr != 0);
; 83   : 
; 84   : 		return (*this->_Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 85   : 		}

  00002	c3		 ret	 0
??D?$_Vector_const_iterator@V?$_Vector_val@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@@std@@QBEABUItemWingsOptionInfo@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> > >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@V?$_Vector_val@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> > >::operator++
; Function compile flags: /Ogtp
;	COMDAT ??E?$_Vector_const_iterator@V?$_Vector_val@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@V?$_Vector_val@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> > >::operator++, COMDAT
; _this$ = ecx

; 93   : 		{	// preincrement

  00000	8b c1		 mov	 eax, ecx

; 94   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 95   : 		if (this->_Getcont() == 0
; 96   : 			|| this->_Ptr == 0
; 97   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 98   : 			{	// report error
; 99   : 			_DEBUG_ERROR("vector iterator not incrementable");
; 100  : 			_SCL_SECURE_OUT_OF_RANGE;
; 101  : 			}
; 102  : 
; 103  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 104  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 105  : 		_SCL_SECURE_VALIDATE_RANGE(
; 106  : 			this->_Ptr != 0
; 107  : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 108  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 109  : 
; 110  : 		++this->_Ptr;

  00002	83 00 06	 add	 DWORD PTR [eax], 6

; 111  : 		return (*this);
; 112  : 		}

  00005	c3		 ret	 0
??E?$_Vector_const_iterator@V?$_Vector_val@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> > >::operator++
_TEXT	ENDS
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> > >::_Compat
; Function compile flags: /Ogtp
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> > >::_Compat, COMDAT
; _this$ = ecx

; 253  : 		}

  00000	c2 04 00	 ret	 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> > >::_Compat
_TEXT	ENDS
PUBLIC	?size@?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@QBEIXZ ; std::vector<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> >::size
; Function compile flags: /Ogtp
;	COMDAT ?size@?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@QBEIXZ PROC ; std::vector<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> >::size, COMDAT
; _this$ = ecx

; 879  : 		return (this->_Mylast - this->_Myfirst);

  00000	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00003	2b 11		 sub	 edx, DWORD PTR [ecx]
  00005	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0000a	f7 ea		 imul	 edx
  0000c	8b c2		 mov	 eax, edx
  0000e	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00011	03 c2		 add	 eax, edx

; 880  : 		}

  00013	c3		 ret	 0
?size@?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@QBEIXZ ENDP ; std::vector<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> >::size
_TEXT	ENDS
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?_Xlen@?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@IBEXXZ ; std::vector<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> >::_Xlen
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?_Xlen@?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
?_Xlen@?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@IBEXXZ PROC ; std::vector<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> >::_Xlen, COMDAT
; _this$ = ecx

; 1427 : 		_Xlength_error("vector<T> too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN4@Xlen:
$LN3@Xlen:
  0000a	cc		 int	 3
?_Xlen@?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@IBEXXZ ENDP ; std::vector<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> >::_Xlen
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@UItemWingsOptionInfo@@@std@@QBEIXZ ; std::allocator<ItemWingsOptionInfo>::max_size
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?max_size@?$allocator@UItemWingsOptionInfo@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@UItemWingsOptionInfo@@@std@@QBEIXZ PROC ; std::allocator<ItemWingsOptionInfo>::max_size, COMDAT
; _this$ = ecx

; 218  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 219  : 		return (0 < _Count ? _Count : 1);

  00000	b8 aa aa aa 2a	 mov	 eax, 715827882		; 2aaaaaaaH

; 220  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@UItemWingsOptionInfo@@@std@@QBEIXZ ENDP ; std::allocator<ItemWingsOptionInfo>::max_size
_TEXT	ENDS
PUBLIC	??$?8UItemWingsOptionInfo@@U0@@std@@YA_NABV?$allocator@UItemWingsOptionInfo@@@0@0@Z ; std::operator==<ItemWingsOptionInfo,ItemWingsOptionInfo>
; Function compile flags: /Ogtp
;	COMDAT ??$?8UItemWingsOptionInfo@@U0@@std@@YA_NABV?$allocator@UItemWingsOptionInfo@@@0@0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$?8UItemWingsOptionInfo@@U0@@std@@YA_NABV?$allocator@UItemWingsOptionInfo@@@0@0@Z PROC ; std::operator==<ItemWingsOptionInfo,ItemWingsOptionInfo>, COMDAT

; 263  : 	return (true);

  00000	b0 01		 mov	 al, 1

; 264  : 	}

  00002	c3		 ret	 0
??$?8UItemWingsOptionInfo@@U0@@std@@YA_NABV?$allocator@UItemWingsOptionInfo@@@0@0@Z ENDP ; std::operator==<ItemWingsOptionInfo,ItemWingsOptionInfo>
_TEXT	ENDS
PUBLIC	??$_Move@AAV?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@@std@@YA$$QAV?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@0@AAV10@@Z ; std::_Move<std::vector<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> > &>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$_Move@AAV?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@@std@@YA$$QAV?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$_Move@AAV?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@@std@@YA$$QAV?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@0@AAV10@@Z PROC ; std::_Move<std::vector<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> > &>, COMDAT

; 94   : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 95   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 96   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Move@AAV?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@@std@@YA$$QAV?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@0@AAV10@@Z ENDP ; std::_Move<std::vector<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> > &>
_TEXT	ENDS
PUBLIC	??$forward@V?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@@std@@YA$$QAV?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@0@AAV10@@Z ; std::forward<std::vector<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> > >
; Function compile flags: /Ogtp
;	COMDAT ??$forward@V?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@@std@@YA$$QAV?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@@std@@YA$$QAV?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@0@AAV10@@Z PROC ; std::forward<std::vector<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> > >, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@V?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@@std@@YA$$QAV?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@0@AAV10@@Z ENDP ; std::forward<std::vector<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> > >
_TEXT	ENDS
PUBLIC	??$?9UItemWingsOptionInfo@@U0@@std@@YA_NABV?$allocator@UItemWingsOptionInfo@@@0@0@Z ; std::operator!=<ItemWingsOptionInfo,ItemWingsOptionInfo>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$?9UItemWingsOptionInfo@@U0@@std@@YA_NABV?$allocator@UItemWingsOptionInfo@@@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?9UItemWingsOptionInfo@@U0@@std@@YA_NABV?$allocator@UItemWingsOptionInfo@@@0@0@Z PROC ; std::operator!=<ItemWingsOptionInfo,ItemWingsOptionInfo>, COMDAT

; 271  : 	return (!(_Left == _Right));

  00000	32 c0		 xor	 al, al

; 272  : 	}

  00002	c3		 ret	 0
??$?9UItemWingsOptionInfo@@U0@@std@@YA_NABV?$allocator@UItemWingsOptionInfo@@@0@0@Z ENDP ; std::operator!=<ItemWingsOptionInfo,ItemWingsOptionInfo>
_TEXT	ENDS
PUBLIC	??$forward@UItemWingsOptionInfo@@@std@@YA$$QAUItemWingsOptionInfo@@AAU1@@Z ; std::forward<ItemWingsOptionInfo>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$forward@UItemWingsOptionInfo@@@std@@YA$$QAUItemWingsOptionInfo@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@UItemWingsOptionInfo@@@std@@YA$$QAUItemWingsOptionInfo@@AAU1@@Z PROC ; std::forward<ItemWingsOptionInfo>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@UItemWingsOptionInfo@@@std@@YA$$QAUItemWingsOptionInfo@@AAU1@@Z ENDP ; std::forward<ItemWingsOptionInfo>
_TEXT	ENDS
PUBLIC	??$addressof@UItemWingsOptionInfo@@@std@@YAPAUItemWingsOptionInfo@@AAU1@@Z ; std::addressof<ItemWingsOptionInfo>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$addressof@UItemWingsOptionInfo@@@std@@YAPAUItemWingsOptionInfo@@AAU1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@UItemWingsOptionInfo@@@std@@YAPAUItemWingsOptionInfo@@AAU1@@Z PROC ; std::addressof<ItemWingsOptionInfo>, COMDAT

; 110  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 111  : 	return ((_Ty *) &(char&)_Val);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 112  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@UItemWingsOptionInfo@@@std@@YAPAUItemWingsOptionInfo@@AAU1@@Z ENDP ; std::addressof<ItemWingsOptionInfo>
_TEXT	ENDS
PUBLIC	?construct@?$allocator@UItemWingsOptionInfo@@@std@@QAEXPAUItemWingsOptionInfo@@$$QAU3@@Z ; std::allocator<ItemWingsOptionInfo>::construct
; Function compile flags: /Ogtp
;	COMDAT ?construct@?$allocator@UItemWingsOptionInfo@@@std@@QAEXPAUItemWingsOptionInfo@@$$QAU3@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@UItemWingsOptionInfo@@@std@@QAEXPAUItemWingsOptionInfo@@$$QAU3@@Z PROC ; std::allocator<ItemWingsOptionInfo>::construct, COMDAT
; _this$ = ecx

; 201  : 		{	// construct object at _Ptr with value _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 202  : 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Ty>(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 0f		 je	 SHORT $LN3@construct
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0000d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000f	89 10		 mov	 DWORD PTR [eax], edx
  00011	66 8b 49 04	 mov	 cx, WORD PTR [ecx+4]
  00015	66 89 48 04	 mov	 WORD PTR [eax+4], cx
$LN3@construct:

; 203  : 		}

  00019	5d		 pop	 ebp
  0001a	c2 08 00	 ret	 8
?construct@?$allocator@UItemWingsOptionInfo@@@std@@QAEXPAUItemWingsOptionInfo@@$$QAU3@@Z ENDP ; std::allocator<ItemWingsOptionInfo>::construct
_TEXT	ENDS
PUBLIC	??$_Move@AAPAUItemWingsOptionInfo@@@std@@YA$$QAPAUItemWingsOptionInfo@@AAPAU1@@Z ; std::_Move<ItemWingsOptionInfo * &>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$_Move@AAPAUItemWingsOptionInfo@@@std@@YA$$QAPAUItemWingsOptionInfo@@AAPAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$_Move@AAPAUItemWingsOptionInfo@@@std@@YA$$QAPAUItemWingsOptionInfo@@AAPAU1@@Z PROC ; std::_Move<ItemWingsOptionInfo * &>, COMDAT

; 94   : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 95   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 96   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Move@AAPAUItemWingsOptionInfo@@@std@@YA$$QAPAUItemWingsOptionInfo@@AAPAU1@@Z ENDP ; std::_Move<ItemWingsOptionInfo * &>
_TEXT	ENDS
PUBLIC	??$_Ptr_cat@UItemWingsOptionInfo@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUItemWingsOptionInfo@@0@Z ; std::_Ptr_cat<ItemWingsOptionInfo,ItemWingsOptionInfo>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@UItemWingsOptionInfo@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUItemWingsOptionInfo@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@UItemWingsOptionInfo@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUItemWingsOptionInfo@@0@Z PROC ; std::_Ptr_cat<ItemWingsOptionInfo,ItemWingsOptionInfo>, COMDAT

; 516  : 	{	// return pointer category from pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 517  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::_Type _Cat;
; 518  : 	return (_Cat);

  00004	8a 45 ff	 mov	 al, BYTE PTR __Cat$[ebp]

; 519  : 	}

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??$_Ptr_cat@UItemWingsOptionInfo@@U1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAUItemWingsOptionInfo@@0@Z ENDP ; std::_Ptr_cat<ItemWingsOptionInfo,ItemWingsOptionInfo>
_TEXT	ENDS
PUBLIC	??$move@AAUItemWingsOptionInfo@@@std@@YA$$QAUItemWingsOptionInfo@@AAU1@@Z ; std::move<ItemWingsOptionInfo &>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$move@AAUItemWingsOptionInfo@@@std@@YA$$QAUItemWingsOptionInfo@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAUItemWingsOptionInfo@@@std@@YA$$QAUItemWingsOptionInfo@@AAU1@@Z PROC ; std::move<ItemWingsOptionInfo &>, COMDAT

; 86   : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 87   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 88   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAUItemWingsOptionInfo@@@std@@YA$$QAUItemWingsOptionInfo@@AAU1@@Z ENDP ; std::move<ItemWingsOptionInfo &>
_TEXT	ENDS
PUBLIC	??$_Val_type@PAUItemWingsOptionInfo@@@std@@YAPAUItemWingsOptionInfo@@PAU1@@Z ; std::_Val_type<ItemWingsOptionInfo *>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??$_Val_type@PAUItemWingsOptionInfo@@@std@@YAPAUItemWingsOptionInfo@@PAU1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$_Val_type@PAUItemWingsOptionInfo@@@std@@YAPAUItemWingsOptionInfo@@PAU1@@Z PROC ; std::_Val_type<ItemWingsOptionInfo *>, COMDAT

; 790  : 	return (0);

  00000	33 c0		 xor	 eax, eax

; 791  : 	}

  00002	c3		 ret	 0
??$_Val_type@PAUItemWingsOptionInfo@@@std@@YAPAUItemWingsOptionInfo@@PAU1@@Z ENDP ; std::_Val_type<ItemWingsOptionInfo *>
_TEXT	ENDS
PUBLIC	??$_Destroy@UItemWingsOptionInfo@@@std@@YAXPAUItemWingsOptionInfo@@@Z ; std::_Destroy<ItemWingsOptionInfo>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Destroy@UItemWingsOptionInfo@@@std@@YAXPAUItemWingsOptionInfo@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@UItemWingsOptionInfo@@@std@@YAXPAUItemWingsOptionInfo@@@Z PROC ; std::_Destroy<ItemWingsOptionInfo>, COMDAT

; 63   : 	_Ptr->~_Ty();
; 64   : 	}

  00000	c3		 ret	 0
??$_Destroy@UItemWingsOptionInfo@@@std@@YAXPAUItemWingsOptionInfo@@@Z ENDP ; std::_Destroy<ItemWingsOptionInfo>
_TEXT	ENDS
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??0bad_alloc@std@@QAE@PBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
EXTRN	??0exception@std@@QAE@ABQBD@Z:PROC		; std::exception::exception
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R2exception@std@@8
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\exception
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@PBD@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0bad_alloc@std@@QAE@PBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 345  : 		{	// construct from message string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8d 45 08	 lea	 eax, DWORD PTR __Message$[ebp]
  00007	50		 push	 eax
  00008	8b f1		 mov	 esi, ecx
  0000a	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  0000f	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@

; 346  : 		}

  00015	8b c6		 mov	 eax, esi
  00017	5e		 pop	 esi
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@PBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
EXTRN	??1exception@std@@UAE@XZ:PROC			; std::exception::~exception
; Function compile flags: /Ogtp
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 354  : 		{	// destroy the object

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@

; 355  : 		}

  00006	e9 00 00 00 00	 jmp	 ??1exception@std@@UAE@XZ ; std::exception::~exception
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
  0000c	e8 00 00 00 00	 call	 ??1exception@std@@UAE@XZ ; std::exception::~exception
  00011	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00015	74 09		 je	 SHORT $LN6@scalar
  00017	56		 push	 esi
  00018	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0001d	83 c4 04	 add	 esp, 4
$LN6@scalar:
  00020	8b c6		 mov	 eax, esi
  00022	5e		 pop	 esi
  00023	5d		 pop	 ebp
  00024	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?_Orphan_all@_Container_base0@std@@QAEXXZ	; std::_Container_base0::_Orphan_all
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ?_Orphan_all@_Container_base0@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@_Container_base0@std@@QAEXXZ PROC		; std::_Container_base0::_Orphan_all, COMDAT
; _this$ = ecx

; 38   : 		}

  00000	c3		 ret	 0
?_Orphan_all@_Container_base0@std@@QAEXXZ ENDP		; std::_Container_base0::_Orphan_all
_TEXT	ENDS
PUBLIC	?_Swap_all@_Container_base0@std@@QAEXAAU12@@Z	; std::_Container_base0::_Swap_all
; Function compile flags: /Ogtp
;	COMDAT ?_Swap_all@_Container_base0@std@@QAEXAAU12@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Swap_all@_Container_base0@std@@QAEXAAU12@@Z PROC	; std::_Container_base0::_Swap_all, COMDAT
; _this$ = ecx

; 42   : 		}

  00000	c2 04 00	 ret	 4
?_Swap_all@_Container_base0@std@@QAEXAAU12@@Z ENDP	; std::_Container_base0::_Swap_all
_TEXT	ENDS
PUBLIC	?_Adopt@_Iterator_base0@std@@QAEXPBX@Z		; std::_Iterator_base0::_Adopt
; Function compile flags: /Ogtp
;	COMDAT ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z PROC		; std::_Iterator_base0::_Adopt, COMDAT
; _this$ = ecx

; 49   : 		}

  00000	c2 04 00	 ret	 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ENDP		; std::_Iterator_base0::_Adopt
_TEXT	ENDS
PUBLIC	??0?$_Vector_val@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@QAE@V?$allocator@UItemWingsOptionInfo@@@1@@Z ; std::_Vector_val<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> >::_Vector_val<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??0?$_Vector_val@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@QAE@V?$allocator@UItemWingsOptionInfo@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@QAE@V?$allocator@UItemWingsOptionInfo@@@1@@Z PROC ; std::_Vector_val<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> >::_Vector_val<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> >, COMDAT
; _this$ = ecx

; 426  : 		{	// construct allocator from _Al

  00000	8b c1		 mov	 eax, ecx

; 427  : 		_Myfirst = 0;

  00002	33 c9		 xor	 ecx, ecx
  00004	89 08		 mov	 DWORD PTR [eax], ecx

; 428  : 		_Mylast = 0;

  00006	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 429  : 		_Myend = 0;

  00009	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 430  : 		}

  0000c	c2 04 00	 ret	 4
??0?$_Vector_val@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@QAE@V?$allocator@UItemWingsOptionInfo@@@1@@Z ENDP ; std::_Vector_val<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> >::_Vector_val<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> >
_TEXT	ENDS
PUBLIC	??D?$_Vector_iterator@V?$_Vector_val@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@@std@@QBEAAUItemWingsOptionInfo@@XZ ; std::_Vector_iterator<std::_Vector_val<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> > >::operator*
; Function compile flags: /Ogtp
;	COMDAT ??D?$_Vector_iterator@V?$_Vector_val@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@@std@@QBEAAUItemWingsOptionInfo@@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@V?$_Vector_val@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@@std@@QBEAAUItemWingsOptionInfo@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> > >::operator*, COMDAT
; _this$ = ecx

; 322  : 		return ((reference)**(_Mybase *)this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 323  : 		}

  00002	c3		 ret	 0
??D?$_Vector_iterator@V?$_Vector_val@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@@std@@QBEAAUItemWingsOptionInfo@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> > >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_iterator@V?$_Vector_val@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<std::_Vector_val<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> > >::operator++
; Function compile flags: /Ogtp
;	COMDAT ??E?$_Vector_iterator@V?$_Vector_val@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_iterator@V?$_Vector_val@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<std::_Vector_val<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> > >::operator++, COMDAT
; _this$ = ecx

; 331  : 		{	// preincrement

  00000	8b c1		 mov	 eax, ecx

; 332  : 		++*(_Mybase *)this;

  00002	83 00 06	 add	 DWORD PTR [eax], 6

; 333  : 		return (*this);
; 334  : 		}

  00005	c3		 ret	 0
??E?$_Vector_iterator@V?$_Vector_val@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> > >::operator++
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@@std@@QAE@PAUItemWingsOptionInfo@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> > >::_Vector_const_iterator<std::_Vector_val<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> > >
; Function compile flags: /Ogtp
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@@std@@QAE@PAUItemWingsOptionInfo@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@@std@@QAE@PAUItemWingsOptionInfo@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> > >::_Vector_const_iterator<std::_Vector_val<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> > >, COMDAT
; _this$ = ecx

; 45   : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 46   : 		this->_Adopt(_Pvector);
; 47   : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@@std@@QAE@PAUItemWingsOptionInfo@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> > >::_Vector_const_iterator<std::_Vector_val<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> > >
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> > >::operator==
; Function compile flags: /Ogtp
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@V?$_Vector_val@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> > >::operator==, COMDAT
; _this$ = ecx

; 201  : 		{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 202  : 		_Compat(_Right);
; 203  : 		return (this->_Ptr == _Right._Ptr);

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00008	33 c9		 xor	 ecx, ecx
  0000a	3b 02		 cmp	 eax, DWORD PTR [edx]
  0000c	0f 94 c0	 sete	 al

; 204  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??8?$_Vector_const_iterator@V?$_Vector_val@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> > >::operator==
_TEXT	ENDS
PUBLIC	?max_size@?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@QBEIXZ ; std::vector<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> >::max_size
; Function compile flags: /Ogtp
;	COMDAT ?max_size@?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@QBEIXZ PROC ; std::vector<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> >::max_size, COMDAT
; _this$ = ecx

; 884  : 		return (this->_Alval.max_size());

  00000	b8 aa aa aa 2a	 mov	 eax, 715827882		; 2aaaaaaaH

; 885  : 		}

  00005	c3		 ret	 0
?max_size@?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@QBEIXZ ENDP ; std::vector<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> >::max_size
_TEXT	ENDS
PUBLIC	?_Grow_to@?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@IBEII@Z ; std::vector<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> >::_Grow_to
; Function compile flags: /Ogtp
;	COMDAT ?_Grow_to@?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@IBEII@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Grow_to@?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@IBEII@Z PROC ; std::vector<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> >::_Grow_to, COMDAT
; _this$ = ecx

; 1274 : 		{	// grow by 50% or at least to _Count

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1275 : 		size_type _Capacity = capacity();

  00003	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00006	2b 11		 sub	 edx, DWORD PTR [ecx]
  00008	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0000d	f7 ea		 imul	 edx
  0000f	8b c2		 mov	 eax, edx
  00011	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00014	03 c2		 add	 eax, edx

; 1276 : 
; 1277 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1278 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00016	8b c8		 mov	 ecx, eax
  00018	d1 e9		 shr	 ecx, 1
  0001a	ba aa aa aa 2a	 mov	 edx, 715827882		; 2aaaaaaaH
  0001f	2b d1		 sub	 edx, ecx
  00021	3b d0		 cmp	 edx, eax
  00023	73 04		 jae	 SHORT $LN4@Grow_to
  00025	33 c0		 xor	 eax, eax
  00027	eb 02		 jmp	 SHORT $LN5@Grow_to
$LN4@Grow_to:
  00029	03 c1		 add	 eax, ecx
$LN5@Grow_to:

; 1279 : 		if (_Capacity < _Count)

  0002b	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  0002e	3b c1		 cmp	 eax, ecx
  00030	73 02		 jae	 SHORT $LN1@Grow_to

; 1280 : 			_Capacity = _Count;
; 1281 : 		return (_Capacity);

  00032	8b c1		 mov	 eax, ecx
$LN1@Grow_to:

; 1282 : 		}

  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4
?_Grow_to@?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@IBEII@Z ENDP ; std::vector<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> >::_Grow_to
_TEXT	ENDS
PUBLIC	??$swap@PAUItemWingsOptionInfo@@@std@@YAXAAPAUItemWingsOptionInfo@@0@Z ; std::swap<ItemWingsOptionInfo *>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$swap@PAUItemWingsOptionInfo@@@std@@YAXAAPAUItemWingsOptionInfo@@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@PAUItemWingsOptionInfo@@@std@@YAXAAPAUItemWingsOptionInfo@@0@Z PROC ; std::swap<ItemWingsOptionInfo *>, COMDAT

; 101  : 	{	// exchange values stored at _Left and _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 102  : 	_Ty _Tmp = _Move(_Left);
; 103  : 	_Left = _Move(_Right);

  00003	8b 55 0c	 mov	 edx, DWORD PTR __Right$[ebp]
  00006	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  00009	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000b	56		 push	 esi
  0000c	8b 32		 mov	 esi, DWORD PTR [edx]
  0000e	89 30		 mov	 DWORD PTR [eax], esi

; 104  : 	_Right = _Move(_Tmp);

  00010	89 0a		 mov	 DWORD PTR [edx], ecx
  00012	5e		 pop	 esi

; 105  : 	}

  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
??$swap@PAUItemWingsOptionInfo@@@std@@YAXAAPAUItemWingsOptionInfo@@0@Z ENDP ; std::swap<ItemWingsOptionInfo *>
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@UItemWingsOptionInfo@@@std@@UItemWingsOptionInfo@@U3@@std@@YAXAAV?$allocator@UItemWingsOptionInfo@@@0@PAUItemWingsOptionInfo@@$$QAU2@@Z ; std::_Cons_val<std::allocator<ItemWingsOptionInfo>,ItemWingsOptionInfo,ItemWingsOptionInfo>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Cons_val@V?$allocator@UItemWingsOptionInfo@@@std@@UItemWingsOptionInfo@@U3@@std@@YAXAAV?$allocator@UItemWingsOptionInfo@@@0@PAUItemWingsOptionInfo@@$$QAU2@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@UItemWingsOptionInfo@@@std@@UItemWingsOptionInfo@@U3@@std@@YAXAAV?$allocator@UItemWingsOptionInfo@@@0@PAUItemWingsOptionInfo@@$$QAU2@@Z PROC ; std::_Cons_val<std::allocator<ItemWingsOptionInfo>,ItemWingsOptionInfo,ItemWingsOptionInfo>, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Pdest$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 0f		 je	 SHORT $LN7@Cons_val
  0000a	8b 4d 10	 mov	 ecx, DWORD PTR __Src$[ebp]
  0000d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000f	89 10		 mov	 DWORD PTR [eax], edx
  00011	66 8b 49 04	 mov	 cx, WORD PTR [ecx+4]
  00015	66 89 48 04	 mov	 WORD PTR [eax+4], cx
$LN7@Cons_val:

; 281  : 	}

  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??$_Cons_val@V?$allocator@UItemWingsOptionInfo@@@std@@UItemWingsOptionInfo@@U3@@std@@YAXAAV?$allocator@UItemWingsOptionInfo@@@0@PAUItemWingsOptionInfo@@$$QAU2@@Z ENDP ; std::_Cons_val<std::allocator<ItemWingsOptionInfo>,ItemWingsOptionInfo,ItemWingsOptionInfo>
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??$_Allocate@UItemWingsOptionInfo@@@std@@YAPAUItemWingsOptionInfo@@IPAU1@@Z ; std::_Allocate<ItemWingsOptionInfo>
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	__CxxThrowException@8:PROC
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\exception
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ??$_Allocate@UItemWingsOptionInfo@@@std@@YAPAUItemWingsOptionInfo@@IPAU1@@Z
_TEXT	SEGMENT
$T157268 = -12						; size = 12
$T157273 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@UItemWingsOptionInfo@@@std@@YAPAUItemWingsOptionInfo@@IPAU1@@Z PROC ; std::_Allocate<ItemWingsOptionInfo>, COMDAT

; 30   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 31   : 	void *_Ptr = 0;
; 32   : 
; 33   : 	if (_Count <= 0)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00009	33 c0		 xor	 eax, eax
  0000b	85 c9		 test	 ecx, ecx

; 34   : 		_Count = 0;
; 35   : 	else if (((_SIZT)(-1) / sizeof (_Ty) < _Count)

  0000d	74 42		 je	 SHORT $LN5@Allocate

; 36   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000f	81 f9 aa aa aa
	2a		 cmp	 ecx, 715827882		; 2aaaaaaaH
  00015	77 12		 ja	 SHORT $LN1@Allocate
  00017	8d 04 49	 lea	 eax, DWORD PTR [ecx+ecx*2]
  0001a	03 c0		 add	 eax, eax
  0001c	50		 push	 eax
  0001d	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00022	83 c4 04	 add	 esp, 4
  00025	85 c0		 test	 eax, eax

; 38   : 
; 39   : 	return ((_Ty _FARQ *)_Ptr);

  00027	75 28		 jne	 SHORT $LN5@Allocate
$LN1@Allocate:

; 37   : 		_THROW_NCEE(bad_alloc, 0);

  00029	8d 4d 08	 lea	 ecx, DWORD PTR $T157273[ebp]
  0002c	51		 push	 ecx
  0002d	8d 4d f4	 lea	 ecx, DWORD PTR $T157268[ebp]
  00030	c7 45 08 00 00
	00 00		 mov	 DWORD PTR $T157273[ebp], 0
  00037	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  0003c	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00041	8d 55 f4	 lea	 edx, DWORD PTR $T157268[ebp]
  00044	52		 push	 edx
  00045	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T157268[ebp], OFFSET ??_7bad_alloc@std@@6B@
  0004c	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN10@Allocate:
$LN5@Allocate:

; 40   : 	}

  00051	8b e5		 mov	 esp, ebp
  00053	5d		 pop	 ebp
  00054	c3		 ret	 0
$LN9@Allocate:
??$_Allocate@UItemWingsOptionInfo@@@std@@YAPAUItemWingsOptionInfo@@IPAU1@@Z ENDP ; std::_Allocate<ItemWingsOptionInfo>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  00006	56		 push	 esi
  00007	50		 push	 eax
  00008	8b f1		 mov	 esi, ecx
  0000a	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  0000f	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
  00015	8b c6		 mov	 eax, esi
  00017	5e		 pop	 esi
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	??$_Move@PAUItemWingsOptionInfo@@PAU1@@std@@YAPAUItemWingsOptionInfo@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Move<ItemWingsOptionInfo *,ItemWingsOptionInfo *>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??$_Move@PAUItemWingsOptionInfo@@PAU1@@std@@YAPAUItemWingsOptionInfo@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Move@PAUItemWingsOptionInfo@@PAU1@@std@@YAPAUItemWingsOptionInfo@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Move<ItemWingsOptionInfo *,ItemWingsOptionInfo *>, COMDAT

; 2512 : 	{	// move [_First, _Last) to [_Dest, ...), arbitrary iterators

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2513 : 	for (; _First != _Last; ++_Dest, ++_First)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00006	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  00009	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0000c	3b ca		 cmp	 ecx, edx
  0000e	74 18		 je	 SHORT $LN1@Move
  00010	56		 push	 esi
$LL3@Move:

; 2514 : 		*_Dest = _STD move(*_First);

  00011	8b 31		 mov	 esi, DWORD PTR [ecx]
  00013	89 30		 mov	 DWORD PTR [eax], esi
  00015	66 8b 71 04	 mov	 si, WORD PTR [ecx+4]
  00019	66 89 70 04	 mov	 WORD PTR [eax+4], si
  0001d	83 c1 06	 add	 ecx, 6
  00020	83 c0 06	 add	 eax, 6
  00023	3b ca		 cmp	 ecx, edx
  00025	75 ea		 jne	 SHORT $LL3@Move
  00027	5e		 pop	 esi
$LN1@Move:

; 2515 : 	return (_Dest);
; 2516 : 	}

  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
??$_Move@PAUItemWingsOptionInfo@@PAU1@@std@@YAPAUItemWingsOptionInfo@@PAU1@00U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Move<ItemWingsOptionInfo *,ItemWingsOptionInfo *>
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@UItemWingsOptionInfo@@@std@@QAEXPAUItemWingsOptionInfo@@@Z ; std::allocator<ItemWingsOptionInfo>::destroy
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?destroy@?$allocator@UItemWingsOptionInfo@@@std@@QAEXPAUItemWingsOptionInfo@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@UItemWingsOptionInfo@@@std@@QAEXPAUItemWingsOptionInfo@@@Z PROC ; std::allocator<ItemWingsOptionInfo>::destroy, COMDAT
; _this$ = ecx

; 213  : 		_Destroy(_Ptr);
; 214  : 		}

  00000	c2 04 00	 ret	 4
?destroy@?$allocator@UItemWingsOptionInfo@@@std@@QAEXPAUItemWingsOptionInfo@@@Z ENDP ; std::allocator<ItemWingsOptionInfo>::destroy
_TEXT	ENDS
PUBLIC	??0?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@QAE@XZ ; std::vector<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> >::vector<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??0?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@QAE@XZ PROC ; std::vector<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> >::vector<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> >, COMDAT
; _this$ = ecx

; 507  : 		{	// construct empty vector

  00000	8b c1		 mov	 eax, ecx
  00002	33 c9		 xor	 ecx, ecx
  00004	89 08		 mov	 DWORD PTR [eax], ecx
  00006	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00009	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 508  : 		}

  0000c	c3		 ret	 0
??0?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@QAE@XZ ENDP ; std::vector<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> >::vector<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@@std@@QAE@PAUItemWingsOptionInfo@@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> > >::_Vector_iterator<std::_Vector_val<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> > >
; Function compile flags: /Ogtp
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@@std@@QAE@PAUItemWingsOptionInfo@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@@std@@QAE@PAUItemWingsOptionInfo@@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> > >::_Vector_iterator<std::_Vector_val<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> > >, COMDAT
; _this$ = ecx

; 304  : 		{	// construct with pointer _Parg

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 305  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Vector_iterator@V?$_Vector_val@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@@std@@QAE@PAUItemWingsOptionInfo@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> > >::_Vector_iterator<std::_Vector_val<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> > >
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@V?$_Vector_val@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> > >::operator!=
; Function compile flags: /Ogtp
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@V?$_Vector_val@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> > >::operator!=, COMDAT
; _this$ = ecx

; 207  : 		{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 208  : 		return (!(*this == _Right));

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00008	33 c9		 xor	 ecx, ecx
  0000a	3b 02		 cmp	 eax, DWORD PTR [edx]
  0000c	0f 95 c0	 setne	 al

; 209  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??9?$_Vector_const_iterator@V?$_Vector_val@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> > >::operator!=
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@UItemWingsOptionInfo@@@std@@QAEPAUItemWingsOptionInfo@@I@Z ; std::allocator<ItemWingsOptionInfo>::allocate
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@UItemWingsOptionInfo@@@std@@QAEPAUItemWingsOptionInfo@@I@Z
_TEXT	SEGMENT
$T157345 = -12						; size = 12
$T157337 = 8						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@UItemWingsOptionInfo@@@std@@QAEPAUItemWingsOptionInfo@@I@Z PROC ; std::allocator<ItemWingsOptionInfo>::allocate, COMDAT
; _this$ = ecx

; 186  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 187  : 		return (_Allocate(_Count, (pointer)0));

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00009	33 c0		 xor	 eax, eax
  0000b	85 c9		 test	 ecx, ecx
  0000d	74 42		 je	 SHORT $LN1@allocate
  0000f	81 f9 aa aa aa
	2a		 cmp	 ecx, 715827882		; 2aaaaaaaH
  00015	77 12		 ja	 SHORT $LN3@allocate
  00017	8d 04 49	 lea	 eax, DWORD PTR [ecx+ecx*2]
  0001a	03 c0		 add	 eax, eax
  0001c	50		 push	 eax
  0001d	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00022	83 c4 04	 add	 esp, 4
  00025	85 c0		 test	 eax, eax
  00027	75 28		 jne	 SHORT $LN1@allocate
$LN3@allocate:
  00029	8d 4d 08	 lea	 ecx, DWORD PTR $T157337[ebp]
  0002c	51		 push	 ecx
  0002d	8d 4d f4	 lea	 ecx, DWORD PTR $T157345[ebp]
  00030	c7 45 08 00 00
	00 00		 mov	 DWORD PTR $T157337[ebp], 0
  00037	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  0003c	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00041	8d 55 f4	 lea	 edx, DWORD PTR $T157345[ebp]
  00044	52		 push	 edx
  00045	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T157345[ebp], OFFSET ??_7bad_alloc@std@@6B@
  0004c	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN13@allocate:
$LN1@allocate:

; 188  : 		}

  00051	8b e5		 mov	 esp, ebp
  00053	5d		 pop	 ebp
  00054	c2 04 00	 ret	 4
$LN12@allocate:
?allocate@?$allocator@UItemWingsOptionInfo@@@std@@QAEPAUItemWingsOptionInfo@@I@Z ENDP ; std::allocator<ItemWingsOptionInfo>::allocate
_TEXT	ENDS
PUBLIC	??$_Move@PAUItemWingsOptionInfo@@PAU1@@std@@YAPAUItemWingsOptionInfo@@PAU1@00@Z ; std::_Move<ItemWingsOptionInfo *,ItemWingsOptionInfo *>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ??$_Move@PAUItemWingsOptionInfo@@PAU1@@std@@YAPAUItemWingsOptionInfo@@PAU1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Move@PAUItemWingsOptionInfo@@PAU1@@std@@YAPAUItemWingsOptionInfo@@PAU1@00@Z PROC ; std::_Move<ItemWingsOptionInfo *,ItemWingsOptionInfo *>, COMDAT

; 2533 : 	{	// move [_First, _Last) to [_Dest, ...), unchecked

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2534 : 	return (_Move(_First, _Last,
; 2535 : 		_Dest, _Ptr_cat(_First, _Dest)));

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00006	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  00009	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0000c	3b ca		 cmp	 ecx, edx
  0000e	74 18		 je	 SHORT $LN5@Move@2
  00010	56		 push	 esi
$LL7@Move@2:
  00011	8b 31		 mov	 esi, DWORD PTR [ecx]
  00013	89 30		 mov	 DWORD PTR [eax], esi
  00015	66 8b 71 04	 mov	 si, WORD PTR [ecx+4]
  00019	66 89 70 04	 mov	 WORD PTR [eax+4], si
  0001d	83 c1 06	 add	 ecx, 6
  00020	83 c0 06	 add	 eax, 6
  00023	3b ca		 cmp	 ecx, edx
  00025	75 ea		 jne	 SHORT $LL7@Move@2
  00027	5e		 pop	 esi
$LN5@Move@2:

; 2536 : 	}

  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
??$_Move@PAUItemWingsOptionInfo@@PAU1@@std@@YAPAUItemWingsOptionInfo@@PAU1@00@Z ENDP ; std::_Move<ItemWingsOptionInfo *,ItemWingsOptionInfo *>
_TEXT	ENDS
PUBLIC	??$_Dest_val@V?$allocator@UItemWingsOptionInfo@@@std@@UItemWingsOptionInfo@@@std@@YAXAAV?$allocator@UItemWingsOptionInfo@@@0@PAUItemWingsOptionInfo@@@Z ; std::_Dest_val<std::allocator<ItemWingsOptionInfo>,ItemWingsOptionInfo>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Dest_val@V?$allocator@UItemWingsOptionInfo@@@std@@UItemWingsOptionInfo@@@std@@YAXAAV?$allocator@UItemWingsOptionInfo@@@0@PAUItemWingsOptionInfo@@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
??$_Dest_val@V?$allocator@UItemWingsOptionInfo@@@std@@UItemWingsOptionInfo@@@std@@YAXAAV?$allocator@UItemWingsOptionInfo@@@0@PAUItemWingsOptionInfo@@@Z PROC ; std::_Dest_val<std::allocator<ItemWingsOptionInfo>,ItemWingsOptionInfo>, COMDAT

; 287  : 	_Alval.destroy(_Pdest);
; 288  : 	}

  00000	c3		 ret	 0
??$_Dest_val@V?$allocator@UItemWingsOptionInfo@@@std@@UItemWingsOptionInfo@@@std@@YAXAAV?$allocator@UItemWingsOptionInfo@@@0@PAUItemWingsOptionInfo@@@Z ENDP ; std::_Dest_val<std::allocator<ItemWingsOptionInfo>,ItemWingsOptionInfo>
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAUItemWingsOptionInfo@@PAU1@V?$allocator@UItemWingsOptionInfo@@@std@@U1@@std@@YAPAUItemWingsOptionInfo@@PAU1@00AAV?$allocator@UItemWingsOptionInfo@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<ItemWingsOptionInfo *,ItemWingsOptionInfo *,std::allocator<ItemWingsOptionInfo>,ItemWingsOptionInfo>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\memory
;	COMDAT ??$_Uninit_move@PAUItemWingsOptionInfo@@PAU1@V?$allocator@UItemWingsOptionInfo@@@std@@U1@@std@@YAPAUItemWingsOptionInfo@@PAU1@00AAV?$allocator@UItemWingsOptionInfo@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 4
___formal$ = 28						; size = 1
??$_Uninit_move@PAUItemWingsOptionInfo@@PAU1@V?$allocator@UItemWingsOptionInfo@@@std@@U1@@std@@YAPAUItemWingsOptionInfo@@PAU1@00AAV?$allocator@UItemWingsOptionInfo@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_move<ItemWingsOptionInfo *,ItemWingsOptionInfo *,std::allocator<ItemWingsOptionInfo>,ItemWingsOptionInfo>, COMDAT

; 424  : 	{	// move [_First, _Last) to raw _Dest, using _Al, arbitrary type

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 425  : 	_DEBUG_RANGE(_First, _Last);
; 426  : 	_DEBUG_POINTER(_Dest);
; 427  : 	_FwdIt _Next = _Dest;
; 428  : 
; 429  : 	_TRY_BEGIN
; 430  : 	for (; _First != _Last; ++_Dest, ++_First)

  00004	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  00007	56		 push	 esi
  00008	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000b	3b f3		 cmp	 esi, ebx
  0000d	74 23		 je	 SHORT $LN17@Uninit_mov
  0000f	57		 push	 edi
  00010	8b 7d 10	 mov	 edi, DWORD PTR __Dest$[ebp]
$LL6@Uninit_mov:

; 431  : 		_Cons_val(_Al, _Dest, (_Valty &&)*_First);

  00013	8b 45 14	 mov	 eax, DWORD PTR __Al$[ebp]
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@UItemWingsOptionInfo@@@std@@UItemWingsOptionInfo@@U3@@std@@YAXAAV?$allocator@UItemWingsOptionInfo@@@0@PAUItemWingsOptionInfo@@$$QAU2@@Z ; std::_Cons_val<std::allocator<ItemWingsOptionInfo>,ItemWingsOptionInfo,ItemWingsOptionInfo>
  0001e	83 c6 06	 add	 esi, 6
  00021	83 c4 0c	 add	 esp, 12			; 0000000cH
  00024	83 c7 06	 add	 edi, 6
  00027	3b f3		 cmp	 esi, ebx
  00029	75 e8		 jne	 SHORT $LL6@Uninit_mov

; 432  : 	_CATCH_ALL
; 433  : 	for (; _Next != _Dest; ++_Next)
; 434  : 		_Dest_val(_Al, _Next);
; 435  : 	_RERAISE;
; 436  : 	_CATCH_END
; 437  : 	return (_Dest);

  0002b	8b c7		 mov	 eax, edi
  0002d	5f		 pop	 edi
  0002e	5e		 pop	 esi
  0002f	5b		 pop	 ebx

; 438  : 	}

  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
$LN17@Uninit_mov:

; 432  : 	_CATCH_ALL
; 433  : 	for (; _Next != _Dest; ++_Next)
; 434  : 		_Dest_val(_Al, _Next);
; 435  : 	_RERAISE;
; 436  : 	_CATCH_END
; 437  : 	return (_Dest);

  00032	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00035	5e		 pop	 esi
  00036	5b		 pop	 ebx

; 438  : 	}

  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
??$_Uninit_move@PAUItemWingsOptionInfo@@PAU1@V?$allocator@UItemWingsOptionInfo@@@std@@U1@@std@@YAPAUItemWingsOptionInfo@@PAU1@00AAV?$allocator@UItemWingsOptionInfo@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_move<ItemWingsOptionInfo *,ItemWingsOptionInfo *,std::allocator<ItemWingsOptionInfo>,ItemWingsOptionInfo>
_TEXT	ENDS
PUBLIC	?begin@?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@@2@XZ ; std::vector<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> >::begin
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?begin@?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@@2@XZ PROC ; std::vector<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> >::begin, COMDAT
; _this$ = ecx

; 781  : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 782  : 		return (iterator(this->_Myfirst, this));

  00003	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00005	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 783  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
?begin@?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@@2@XZ ENDP ; std::vector<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> >::begin
_TEXT	ENDS
PUBLIC	?end@?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@@2@XZ ; std::vector<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> >::end
; Function compile flags: /Ogtp
;	COMDAT ?end@?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@@2@XZ PROC ; std::vector<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> >::end, COMDAT
; _this$ = ecx

; 791  : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 792  : 		return (iterator(this->_Mylast, this));

  00003	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00006	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 793  : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
?end@?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@@2@XZ ENDP ; std::vector<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> >::end
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@@2@@Z ; std::vector<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> >::_Make_iter
; Function compile flags: /Ogtp
;	COMDAT ?_Make_iter@?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?_Make_iter@?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@@2@@Z PROC ; std::vector<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> >::_Make_iter, COMDAT
; _this$ = ecx

; 801  : 		{	// make iterator from const_iterator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 802  : 		return (iterator(_Where._Ptr, this));

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Where$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 803  : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 08 00	 ret	 8
?_Make_iter@?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@@2@@Z ENDP ; std::vector<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> >::_Make_iter
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@YAXPAUItemWingsOptionInfo@@0AAV?$allocator@UItemWingsOptionInfo@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<ItemWingsOptionInfo> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@YAXPAUItemWingsOptionInfo@@0AAV?$allocator@UItemWingsOptionInfo@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@YAXPAUItemWingsOptionInfo@@0AAV?$allocator@UItemWingsOptionInfo@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<ItemWingsOptionInfo> >, COMDAT

; 96   : 	for (; _First != _Last; ++_First)
; 97   : 		_Dest_val(_Al, _First);
; 98   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@YAXPAUItemWingsOptionInfo@@0AAV?$allocator@UItemWingsOptionInfo@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<ItemWingsOptionInfo> >
_TEXT	ENDS
PUBLIC	??$_Uninitialized_move@PAUItemWingsOptionInfo@@PAU1@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@YAPAUItemWingsOptionInfo@@PAU1@00AAV?$allocator@UItemWingsOptionInfo@@@0@@Z ; std::_Uninitialized_move<ItemWingsOptionInfo *,ItemWingsOptionInfo *,std::allocator<ItemWingsOptionInfo> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\memory
;	COMDAT ??$_Uninitialized_move@PAUItemWingsOptionInfo@@PAU1@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@YAPAUItemWingsOptionInfo@@PAU1@00AAV?$allocator@UItemWingsOptionInfo@@@0@@Z
_TEXT	SEGMENT
__Cat$157456 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAUItemWingsOptionInfo@@PAU1@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@YAPAUItemWingsOptionInfo@@PAU1@00AAV?$allocator@UItemWingsOptionInfo@@@0@@Z PROC ; std::_Uninitialized_move<ItemWingsOptionInfo *,ItemWingsOptionInfo *,std::allocator<ItemWingsOptionInfo> >, COMDAT

; 469  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 470  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,
; 471  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

  00004	8b 45 fc	 mov	 eax, DWORD PTR __Cat$157456[ebp]
  00007	8b 4d 14	 mov	 ecx, DWORD PTR __Al$[ebp]
  0000a	8b 55 10	 mov	 edx, DWORD PTR __Dest$[ebp]
  0000d	50		 push	 eax
  0000e	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00011	6a 00		 push	 0
  00013	51		 push	 ecx
  00014	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00017	52		 push	 edx
  00018	50		 push	 eax
  00019	51		 push	 ecx
  0001a	e8 00 00 00 00	 call	 ??$_Uninit_move@PAUItemWingsOptionInfo@@PAU1@V?$allocator@UItemWingsOptionInfo@@@std@@U1@@std@@YAPAUItemWingsOptionInfo@@PAU1@00AAV?$allocator@UItemWingsOptionInfo@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<ItemWingsOptionInfo *,ItemWingsOptionInfo *,std::allocator<ItemWingsOptionInfo>,ItemWingsOptionInfo>
  0001f	83 c4 18	 add	 esp, 24			; 00000018H

; 472  : 	}

  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
??$_Uninitialized_move@PAUItemWingsOptionInfo@@PAU1@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@YAPAUItemWingsOptionInfo@@PAU1@00AAV?$allocator@UItemWingsOptionInfo@@@0@@Z ENDP ; std::_Uninitialized_move<ItemWingsOptionInfo *,ItemWingsOptionInfo *,std::allocator<ItemWingsOptionInfo> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@YAXPAUItemWingsOptionInfo@@0AAV?$allocator@UItemWingsOptionInfo@@@0@@Z ; std::_Destroy_range<std::allocator<ItemWingsOptionInfo> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@YAXPAUItemWingsOptionInfo@@0AAV?$allocator@UItemWingsOptionInfo@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@YAXPAUItemWingsOptionInfo@@0AAV?$allocator@UItemWingsOptionInfo@@@0@@Z PROC ; std::_Destroy_range<std::allocator<ItemWingsOptionInfo> >, COMDAT

; 88   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 89   : 	}

  00000	c3		 ret	 0
??$_Destroy_range@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@YAXPAUItemWingsOptionInfo@@0AAV?$allocator@UItemWingsOptionInfo@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<ItemWingsOptionInfo> >
_TEXT	ENDS
PUBLIC	??$_Umove@PAUItemWingsOptionInfo@@@?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@IAEPAUItemWingsOptionInfo@@PAU2@00@Z ; std::vector<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> >::_Umove<ItemWingsOptionInfo *>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ??$_Umove@PAUItemWingsOptionInfo@@@?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@IAEPAUItemWingsOptionInfo@@PAU2@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Cat$157484 = 16					; size = 1
__Ptr$ = 16						; size = 4
??$_Umove@PAUItemWingsOptionInfo@@@?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@IAEPAUItemWingsOptionInfo@@PAU2@00@Z PROC ; std::vector<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> >::_Umove<ItemWingsOptionInfo *>, COMDAT
; _this$ = ecx

; 1322 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1323 : 		{	// move initializing [_First, _Last), using allocator
; 1324 : 		return (_Uninitialized_move(_First, _Last,
; 1325 : 			_Ptr, this->_Alval));

  00003	8b 45 10	 mov	 eax, DWORD PTR __Cat$157484[ebp]
  00006	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  00009	50		 push	 eax
  0000a	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0000d	6a 00		 push	 0
  0000f	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00012	51		 push	 ecx
  00013	8b 4d 10	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00016	51		 push	 ecx
  00017	52		 push	 edx
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 ??$_Uninit_move@PAUItemWingsOptionInfo@@PAU1@V?$allocator@UItemWingsOptionInfo@@@std@@U1@@std@@YAPAUItemWingsOptionInfo@@PAU1@00AAV?$allocator@UItemWingsOptionInfo@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<ItemWingsOptionInfo *,ItemWingsOptionInfo *,std::allocator<ItemWingsOptionInfo>,ItemWingsOptionInfo>
  0001e	83 c4 18	 add	 esp, 24			; 00000018H

; 1326 : 		}

  00021	5d		 pop	 ebp
  00022	c2 0c 00	 ret	 12			; 0000000cH
??$_Umove@PAUItemWingsOptionInfo@@@?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@IAEPAUItemWingsOptionInfo@@PAU2@00@Z ENDP ; std::vector<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> >::_Umove<ItemWingsOptionInfo *>
_TEXT	ENDS
PUBLIC	?_Destroy@?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@IAEXPAUItemWingsOptionInfo@@0@Z ; std::vector<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> >::_Destroy
; Function compile flags: /Ogtp
;	COMDAT ?_Destroy@?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@IAEXPAUItemWingsOptionInfo@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@IAEXPAUItemWingsOptionInfo@@0@Z PROC ; std::vector<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> >::_Destroy, COMDAT
; _this$ = ecx

; 1270 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1271 : 		}

  00000	c2 08 00	 ret	 8
?_Destroy@?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@IAEXPAUItemWingsOptionInfo@@0@Z ENDP ; std::vector<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> >::_Destroy
_TEXT	ENDS
PUBLIC	?reserve@?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@QAEXI@Z ; std::vector<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> >::reserve
EXTRN	___security_cookie:DWORD
EXTRN	___CxxFrameHandler3:PROC
EXTRN	@__security_check_cookie@4:PROC
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
xdata$x	SEGMENT
__catchsym$?reserve@?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@QAEXI@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?reserve@?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@QAEXI@Z$0
__unwindtable$?reserve@?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@QAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?reserve@?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@QAEXI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?reserve@?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@QAEXI@Z$2
__ehfuncinfo$?reserve@?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@QAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?reserve@?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@QAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?reserve@?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@QAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?reserve@?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
__Ptr$156476 = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Cat$157544 = 8					; size = 1
__Count$ = 8						; size = 4
?reserve@?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@QAEXI@Z PROC ; std::vector<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> >::reserve, COMDAT
; _this$ = ecx

; 746  : 		{	// determine new minimum length of allocated storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?reserve@?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@QAEXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002b	8b f1		 mov	 esi, ecx

; 747  : 		if (max_size() < _Count)

  0002d	8b 5d 08	 mov	 ebx, DWORD PTR __Count$[ebp]
  00030	81 fb aa aa aa
	2a		 cmp	 ebx, 715827882		; 2aaaaaaaH
  00036	76 0a		 jbe	 SHORT $LN5@reserve

; 748  : 			_Xlen();	// result too long

  00038	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  0003d	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN42@reserve:
$LN5@reserve:

; 749  : 		else if (capacity() < _Count)

  00042	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00045	2b 0e		 sub	 ecx, DWORD PTR [esi]
  00047	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0004c	f7 e9		 imul	 ecx
  0004e	8b c2		 mov	 eax, edx
  00050	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00053	03 c2		 add	 eax, edx
  00055	3b c3		 cmp	 eax, ebx
  00057	73 68		 jae	 SHORT $LN3@reserve

; 750  : 			{	// not enough room, reallocate
; 751  : 			pointer _Ptr = this->_Alval.allocate(_Count);

  00059	8d 7e 0c	 lea	 edi, DWORD PTR [esi+12]
  0005c	53		 push	 ebx
  0005d	8b cf		 mov	 ecx, edi
  0005f	e8 00 00 00 00	 call	 ?allocate@?$allocator@UItemWingsOptionInfo@@@std@@QAEPAUItemWingsOptionInfo@@I@Z ; std::allocator<ItemWingsOptionInfo>::allocate

; 752  : 
; 753  : 			_TRY_BEGIN
; 754  : 			_Umove(this->_Myfirst, this->_Mylast, _Ptr);

  00064	8b 5d 08	 mov	 ebx, DWORD PTR __Cat$157544[ebp]
  00067	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0006a	8b 16		 mov	 edx, DWORD PTR [esi]
  0006c	53		 push	 ebx
  0006d	6a 00		 push	 0
  0006f	57		 push	 edi
  00070	50		 push	 eax
  00071	51		 push	 ecx
  00072	52		 push	 edx
  00073	89 45 ec	 mov	 DWORD PTR __Ptr$156476[ebp], eax
  00076	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  0007d	e8 00 00 00 00	 call	 ??$_Uninit_move@PAUItemWingsOptionInfo@@PAU1@V?$allocator@UItemWingsOptionInfo@@@std@@U1@@std@@YAPAUItemWingsOptionInfo@@PAU1@00AAV?$allocator@UItemWingsOptionInfo@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<ItemWingsOptionInfo *,ItemWingsOptionInfo *,std::allocator<ItemWingsOptionInfo>,ItemWingsOptionInfo>

; 758  : 			_CATCH_END
; 759  : 
; 760  : 			size_type _Size = size();

  00082	8b 1e		 mov	 ebx, DWORD PTR [esi]
  00084	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00087	2b cb		 sub	 ecx, ebx
  00089	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0008e	f7 e9		 imul	 ecx
  00090	8b fa		 mov	 edi, edx
  00092	c1 ef 1f	 shr	 edi, 31			; 0000001fH
  00095	83 c4 18	 add	 esp, 24			; 00000018H
  00098	03 fa		 add	 edi, edx

; 761  : 			if (this->_Myfirst != 0)

  0009a	85 db		 test	 ebx, ebx
  0009c	74 09		 je	 SHORT $LN35@reserve

; 762  : 				{	// destroy and deallocate old array
; 763  : 				_Destroy(this->_Myfirst, this->_Mylast);
; 764  : 				this->_Alval.deallocate(this->_Myfirst,
; 765  : 					this->_Myend - this->_Myfirst);

  0009e	53		 push	 ebx
  0009f	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000a4	83 c4 04	 add	 esp, 4
$LN35@reserve:

; 766  : 				}
; 767  : 
; 768  : 			this->_Orphan_all();
; 769  : 			this->_Myend = _Ptr + _Count;

  000a7	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  000aa	8d 0c 40	 lea	 ecx, DWORD PTR [eax+eax*2]
  000ad	8b 45 ec	 mov	 eax, DWORD PTR __Ptr$156476[ebp]
  000b0	8d 14 48	 lea	 edx, DWORD PTR [eax+ecx*2]

; 770  : 			this->_Mylast = _Ptr + _Size;

  000b3	8d 0c 7f	 lea	 ecx, DWORD PTR [edi+edi*2]
  000b6	89 56 08	 mov	 DWORD PTR [esi+8], edx
  000b9	8d 14 48	 lea	 edx, DWORD PTR [eax+ecx*2]
  000bc	89 56 04	 mov	 DWORD PTR [esi+4], edx

; 771  : 			this->_Myfirst = _Ptr;

  000bf	89 06		 mov	 DWORD PTR [esi], eax
$LN3@reserve:

; 772  : 			}
; 773  : 		}

  000c1	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000c4	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000cb	59		 pop	 ecx
  000cc	5f		 pop	 edi
  000cd	5e		 pop	 esi
  000ce	5b		 pop	 ebx
  000cf	8b e5		 mov	 esp, ebp
  000d1	5d		 pop	 ebp
  000d2	c2 04 00	 ret	 4
__catch$?reserve@?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@QAEXI@Z$0:

; 755  : 			_CATCH_ALL
; 756  : 			this->_Alval.deallocate(_Ptr, _Count);

  000d5	8b 45 ec	 mov	 eax, DWORD PTR __Ptr$156476[ebp]
  000d8	50		 push	 eax
  000d9	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  000de	83 c4 04	 add	 esp, 4

; 757  : 			_RERAISE;

  000e1	6a 00		 push	 0
  000e3	6a 00		 push	 0
  000e5	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN43@reserve:
$LN41@reserve:
  000ea	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?reserve@?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@QAEXI@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?reserve@?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@QAEXI@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?reserve@?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@QAEXI@Z ENDP ; std::vector<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> >::reserve
PUBLIC	?erase@?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@@2@0@Z ; std::vector<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> >::erase
; Function compile flags: /Ogtp
;	COMDAT ?erase@?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@@2@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 4
__Last_arg$ = 16					; size = 4
?erase@?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@@2@0@Z PROC ; std::vector<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> >::erase, COMDAT
; _this$ = ecx

; 1190 : 		{	// erase [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1191 : 		iterator _First = _Make_iter(_First_arg);

  00003	8b 55 0c	 mov	 edx, DWORD PTR __First_arg$[ebp]

; 1192 : 		iterator _Last = _Make_iter(_Last_arg);
; 1193 : 
; 1194 : 		if (_First != _Last)

  00006	8b 45 10	 mov	 eax, DWORD PTR __Last_arg$[ebp]
  00009	57		 push	 edi
  0000a	8b fa		 mov	 edi, edx
  0000c	3b d0		 cmp	 edx, eax
  0000e	74 2b		 je	 SHORT $LN47@erase

; 1195 : 			{	// worth doing, copy down over hole
; 1196 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1197 : 			if (_Last < _First || _VICONT(_First) != this
; 1198 : 				|| _VIPTR(_First) < this->_Myfirst
; 1199 : 				|| this->_Mylast < _VIPTR(_Last))
; 1200 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1201 : 			pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1202 : 				_VIPTR(_First));
; 1203 : 			_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1204 : 
; 1205 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1206 : 			pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1207 : 				_VIPTR(_First));

  00010	56		 push	 esi
  00011	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  00014	3b c6		 cmp	 eax, esi
  00016	74 1f		 je	 SHORT $LN30@erase
  00018	53		 push	 ebx
  00019	8d a4 24 00 00
	00 00		 npad	 7
$LL32@erase:
  00020	8b 18		 mov	 ebx, DWORD PTR [eax]
  00022	89 1a		 mov	 DWORD PTR [edx], ebx
  00024	66 8b 58 04	 mov	 bx, WORD PTR [eax+4]
  00028	66 89 5a 04	 mov	 WORD PTR [edx+4], bx
  0002c	83 c0 06	 add	 eax, 6
  0002f	83 c2 06	 add	 edx, 6
  00032	3b c6		 cmp	 eax, esi
  00034	75 ea		 jne	 SHORT $LL32@erase
  00036	5b		 pop	 ebx
$LN30@erase:

; 1208 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1209 : 
; 1210 : 			_Destroy(_Ptr, this->_Mylast);
; 1211 : 			this->_Mylast = _Ptr;

  00037	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  0003a	5e		 pop	 esi
$LN47@erase:

; 1212 : 			}
; 1213 : 		return (_Make_iter(_First));

  0003b	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0003e	89 38		 mov	 DWORD PTR [eax], edi
  00040	5f		 pop	 edi

; 1214 : 		}

  00041	5d		 pop	 ebp
  00042	c2 0c 00	 ret	 12			; 0000000cH
?erase@?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@@2@0@Z ENDP ; std::vector<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> >::erase
_TEXT	ENDS
PUBLIC	?_Tidy@?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@IAEXXZ ; std::vector<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> >::_Tidy
; Function compile flags: /Ogtp
;	COMDAT ?_Tidy@?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@IAEXXZ PROC ; std::vector<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> >::_Tidy, COMDAT
; _this$ = ecx

; 1301 : 		{	// free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1302 : 		if (this->_Myfirst != 0)

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 09		 je	 SHORT $LN6@Tidy

; 1303 : 			{	// something to free, destroy and deallocate it
; 1304 : 			this->_Orphan_all();
; 1305 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1306 : 			this->_Alval.deallocate(this->_Myfirst,
; 1307 : 				this->_Myend - this->_Myfirst);

  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
$LN6@Tidy:

; 1308 : 			}
; 1309 : 		this->_Myfirst = 0;

  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 1310 : 		this->_Mylast = 0;

  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1311 : 		this->_Myend = 0;

  0001f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00026	5e		 pop	 esi

; 1312 : 		}

  00027	c3		 ret	 0
?_Tidy@?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@IAEXXZ ENDP ; std::vector<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> >::_Tidy
_TEXT	ENDS
PUBLIC	?_Reserve@?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@IAEXI@Z ; std::vector<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> >::_Reserve
; Function compile flags: /Ogtp
;	COMDAT ?_Reserve@?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Reserve@?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@IAEXI@Z PROC ; std::vector<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> >::_Reserve, COMDAT
; _this$ = ecx

; 1290 : 		{	// ensure room for _Count new elements, grow exponentially

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1291 : 		size_type _Size = size();

  00003	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	8b 39		 mov	 edi, DWORD PTR [ecx]
  0000a	2b d7		 sub	 edx, edi
  0000c	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00011	f7 ea		 imul	 edx

; 1292 : 		if (max_size() - _Count < _Size)

  00013	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00016	8b f2		 mov	 esi, edx
  00018	c1 ee 1f	 shr	 esi, 31			; 0000001fH
  0001b	03 f2		 add	 esi, edx
  0001d	ba aa aa aa 2a	 mov	 edx, 715827882		; 2aaaaaaaH
  00022	2b d0		 sub	 edx, eax
  00024	3b d6		 cmp	 edx, esi
  00026	73 0a		 jae	 SHORT $LN4@Reserve

; 1293 : 			_Xlen();

  00028	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  0002d	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN34@Reserve:
$LN4@Reserve:

; 1294 : 		else if ((_Size += _Count) <= capacity())

  00032	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00035	03 f0		 add	 esi, eax
  00037	2b d7		 sub	 edx, edi
  00039	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0003e	f7 ea		 imul	 edx
  00040	8b c2		 mov	 eax, edx
  00042	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00045	03 c2		 add	 eax, edx
  00047	3b f0		 cmp	 esi, eax
  00049	76 21		 jbe	 SHORT $LN1@Reserve

; 1295 : 			;
; 1296 : 		else
; 1297 : 			reserve(_Grow_to(_Size));

  0004b	8b d0		 mov	 edx, eax
  0004d	d1 ea		 shr	 edx, 1
  0004f	bf aa aa aa 2a	 mov	 edi, 715827882		; 2aaaaaaaH
  00054	2b fa		 sub	 edi, edx
  00056	3b f8		 cmp	 edi, eax
  00058	73 04		 jae	 SHORT $LN23@Reserve
  0005a	33 c0		 xor	 eax, eax
  0005c	eb 02		 jmp	 SHORT $LN24@Reserve
$LN23@Reserve:
  0005e	03 c2		 add	 eax, edx
$LN24@Reserve:
  00060	3b c6		 cmp	 eax, esi
  00062	73 02		 jae	 SHORT $LN20@Reserve
  00064	8b c6		 mov	 eax, esi
$LN20@Reserve:
  00066	50		 push	 eax
  00067	e8 00 00 00 00	 call	 ?reserve@?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@QAEXI@Z ; std::vector<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> >::reserve
$LN1@Reserve:
  0006c	5f		 pop	 edi
  0006d	5e		 pop	 esi

; 1298 : 		}

  0006e	5d		 pop	 ebp
  0006f	c2 04 00	 ret	 4
$LN33@Reserve:
?_Reserve@?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@IAEXI@Z ENDP ; std::vector<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> >::_Reserve
_TEXT	ENDS
PUBLIC	??1?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@QAE@XZ ; std::vector<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> >::~vector<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> >
; Function compile flags: /Ogtp
;	COMDAT ??1?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@QAE@XZ PROC ; std::vector<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> >::~vector<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> >, COMDAT
; _this$ = ecx

; 704  : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 705  : 		_Tidy();

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 09		 je	 SHORT $LN8@vector
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
$LN8@vector:
  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0001f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00026	5e		 pop	 esi

; 706  : 		}

  00027	c3		 ret	 0
??1?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@QAE@XZ ENDP ; std::vector<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> >::~vector<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> >
_TEXT	ENDS
PUBLIC	?clear@?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@QAEXXZ ; std::vector<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> >::clear
; Function compile flags: /Ogtp
;	COMDAT ?clear@?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@QAEXXZ PROC ; std::vector<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> >::clear, COMDAT
; _this$ = ecx

; 1218 : 		erase(begin(), end());

  00000	8b 11		 mov	 edx, DWORD PTR [ecx]
  00002	56		 push	 esi
  00003	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  00006	3b d6		 cmp	 edx, esi
  00008	74 21		 je	 SHORT $LN19@clear
  0000a	8b c6		 mov	 eax, esi
  0000c	3b f6		 cmp	 esi, esi
  0000e	74 18		 je	 SHORT $LN48@clear
  00010	57		 push	 edi
$LL50@clear:
  00011	8b 38		 mov	 edi, DWORD PTR [eax]
  00013	89 3a		 mov	 DWORD PTR [edx], edi
  00015	66 8b 78 04	 mov	 di, WORD PTR [eax+4]
  00019	66 89 7a 04	 mov	 WORD PTR [edx+4], di
  0001d	83 c0 06	 add	 eax, 6
  00020	83 c2 06	 add	 edx, 6
  00023	3b c6		 cmp	 eax, esi
  00025	75 ea		 jne	 SHORT $LL50@clear
  00027	5f		 pop	 edi
$LN48@clear:
  00028	89 51 04	 mov	 DWORD PTR [ecx+4], edx
$LN19@clear:
  0002b	5e		 pop	 esi

; 1219 : 		}

  0002c	c3		 ret	 0
?clear@?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@QAEXXZ ENDP ; std::vector<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> >::clear
_TEXT	ENDS
PUBLIC	?push_back@?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@QAEX$$QAUItemWingsOptionInfo@@@Z ; std::vector<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> >::push_back
; Function compile flags: /Ogtp
;	COMDAT ?push_back@?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@QAEX$$QAUItemWingsOptionInfo@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@QAEX$$QAUItemWingsOptionInfo@@@Z PROC ; std::vector<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> >::push_back, COMDAT
; _this$ = ecx

; 631  : 		{	// insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 632  : 		if (_Inside(_STD addressof(_Val)))

  00006	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00009	57		 push	 edi
  0000a	8b 7d 08	 mov	 edi, DWORD PTR __Val$[ebp]
  0000d	3b f9		 cmp	 edi, ecx
  0000f	73 47		 jae	 SHORT $LN4@push_back
  00011	8b 06		 mov	 eax, DWORD PTR [esi]
  00013	3b c7		 cmp	 eax, edi
  00015	77 41		 ja	 SHORT $LN4@push_back

; 633  : 			{	// push back an element
; 634  : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;

  00017	2b f8		 sub	 edi, eax
  00019	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0001e	f7 ef		 imul	 edi
  00020	8b fa		 mov	 edi, edx
  00022	c1 ef 1f	 shr	 edi, 31			; 0000001fH
  00025	03 fa		 add	 edi, edx

; 635  : 			if (this->_Mylast == this->_Myend)

  00027	3b 4e 08	 cmp	 ecx, DWORD PTR [esi+8]
  0002a	75 09		 jne	 SHORT $LN3@push_back

; 636  : 				_Reserve(1);

  0002c	6a 01		 push	 1
  0002e	8b ce		 mov	 ecx, esi
  00030	e8 00 00 00 00	 call	 ?_Reserve@?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@IAEXI@Z ; std::vector<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> >::_Reserve
$LN3@push_back:

; 637  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 638  : 			_Cons_val(this->_Alval,
; 639  : 				this->_Mylast,
; 640  : 				_STD forward<_Ty>(this->_Myfirst[_Idx]));

  00035	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00037	8d 04 7f	 lea	 eax, DWORD PTR [edi+edi*2]
  0003a	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  0003d	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00040	52		 push	 edx
  00041	50		 push	 eax
  00042	8d 4e 0c	 lea	 ecx, DWORD PTR [esi+12]
  00045	51		 push	 ecx

; 647  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 648  : 			_Cons_val(this->_Alval,
; 649  : 				this->_Mylast,
; 650  : 				_STD forward<_Ty>(_Val));

  00046	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@UItemWingsOptionInfo@@@std@@UItemWingsOptionInfo@@U3@@std@@YAXAAV?$allocator@UItemWingsOptionInfo@@@0@PAUItemWingsOptionInfo@@$$QAU2@@Z ; std::_Cons_val<std::allocator<ItemWingsOptionInfo>,ItemWingsOptionInfo,ItemWingsOptionInfo>
  0004b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 651  : 			++this->_Mylast;

  0004e	83 46 04 06	 add	 DWORD PTR [esi+4], 6
  00052	5f		 pop	 edi
  00053	5e		 pop	 esi

; 652  : 			}
; 653  : 		}

  00054	5d		 pop	 ebp
  00055	c2 04 00	 ret	 4
$LN4@push_back:

; 641  : 			++this->_Mylast;
; 642  : 			}
; 643  : 		else
; 644  : 			{	// push back a non-element
; 645  : 			if (this->_Mylast == this->_Myend)

  00058	3b 4e 08	 cmp	 ecx, DWORD PTR [esi+8]
  0005b	75 09		 jne	 SHORT $LN1@push_back

; 646  : 				_Reserve(1);

  0005d	6a 01		 push	 1
  0005f	8b ce		 mov	 ecx, esi
  00061	e8 00 00 00 00	 call	 ?_Reserve@?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@IAEXI@Z ; std::vector<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> >::_Reserve
$LN1@push_back:

; 647  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 648  : 			_Cons_val(this->_Alval,
; 649  : 				this->_Mylast,
; 650  : 				_STD forward<_Ty>(_Val));

  00066	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00069	57		 push	 edi
  0006a	52		 push	 edx
  0006b	8d 46 0c	 lea	 eax, DWORD PTR [esi+12]
  0006e	50		 push	 eax
  0006f	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@UItemWingsOptionInfo@@@std@@UItemWingsOptionInfo@@U3@@std@@YAXAAV?$allocator@UItemWingsOptionInfo@@@0@PAUItemWingsOptionInfo@@$$QAU2@@Z ; std::_Cons_val<std::allocator<ItemWingsOptionInfo>,ItemWingsOptionInfo,ItemWingsOptionInfo>
  00074	83 c4 0c	 add	 esp, 12			; 0000000cH

; 651  : 			++this->_Mylast;

  00077	83 46 04 06	 add	 DWORD PTR [esi+4], 6
  0007b	5f		 pop	 edi
  0007c	5e		 pop	 esi

; 652  : 			}
; 653  : 		}

  0007d	5d		 pop	 ebp
  0007e	c2 04 00	 ret	 4
?push_back@?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@QAEX$$QAUItemWingsOptionInfo@@@Z ENDP ; std::vector<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> >::push_back
_TEXT	ENDS
PUBLIC	??0ItemWingsOption@@QAE@XZ			; ItemWingsOption::ItemWingsOption
; Function compile flags: /Ogtp
; File c:\muserver_dev\development\mu-s8ep2-repack\gameserver\source\itemwingsoption.h
;	COMDAT ??0ItemWingsOption@@QAE@XZ
_TEXT	SEGMENT
??0ItemWingsOption@@QAE@XZ PROC				; ItemWingsOption::ItemWingsOption, COMDAT
; _this$ = ecx

; 15   : 	ItemWingsOption() { };

  00000	8b c1		 mov	 eax, ecx
  00002	33 c9		 xor	 ecx, ecx
  00004	89 08		 mov	 DWORD PTR [eax], ecx
  00006	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00009	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  0000c	c3		 ret	 0
??0ItemWingsOption@@QAE@XZ ENDP				; ItemWingsOption::ItemWingsOption
_TEXT	ENDS
PUBLIC	??1ItemWingsOption@@QAE@XZ			; ItemWingsOption::~ItemWingsOption
; Function compile flags: /Ogtp
;	COMDAT ??1ItemWingsOption@@QAE@XZ
_TEXT	SEGMENT
??1ItemWingsOption@@QAE@XZ PROC				; ItemWingsOption::~ItemWingsOption, COMDAT
; _this$ = ecx

; 16   : 	~ItemWingsOption() { };

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 09		 je	 SHORT $LN11@ItemWingsO
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
$LN11@ItemWingsO:
  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00018	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0001f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00026	5e		 pop	 esi
  00027	c3		 ret	 0
??1ItemWingsOption@@QAE@XZ ENDP				; ItemWingsOption::~ItemWingsOption
_TEXT	ENDS
PUBLIC	?_Assign_rv@?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@QAEX$$QAV12@@Z ; std::vector<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> >::_Assign_rv
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\vector
;	COMDAT ?_Assign_rv@?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@QAEX$$QAV12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?_Assign_rv@?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@QAEX$$QAV12@@Z PROC ; std::vector<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> >::_Assign_rv, COMDAT
; _this$ = ecx

; 606  : 		{	// assign by moving _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 607  : 		if (this == &_Right)

  00005	8b 7d 08	 mov	 edi, DWORD PTR __Right$[ebp]
  00008	8b f1		 mov	 esi, ecx
  0000a	3b f7		 cmp	 esi, edi
  0000c	74 33		 je	 SHORT $LN1@Assign_rv

; 608  : 			;
; 609  : 		else if (get_allocator() != _Right.get_allocator())
; 610  : 			{	// move construct a copy
; 611  : 			clear();
; 612  : 			for (iterator _Next = _Right.begin(); _Next != _Right.end();
; 613  : 				++_Next)
; 614  : 				push_back(_STD forward<_Ty>(*_Next));
; 615  : 			}
; 616  : 		else
; 617  : 			{	// clear this and steal from _Right
; 618  : 			_Tidy();

  0000e	8b 06		 mov	 eax, DWORD PTR [esi]
  00010	53		 push	 ebx
  00011	33 db		 xor	 ebx, ebx
  00013	3b c3		 cmp	 eax, ebx
  00015	74 09		 je	 SHORT $LN124@Assign_rv
  00017	50		 push	 eax
  00018	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0001d	83 c4 04	 add	 esp, 4
$LN124@Assign_rv:
  00020	89 1e		 mov	 DWORD PTR [esi], ebx
  00022	89 5e 04	 mov	 DWORD PTR [esi+4], ebx
  00025	89 5e 08	 mov	 DWORD PTR [esi+8], ebx

; 619  : 			this->_Swap_all((_Myt&)_Right);
; 620  : 			this->_Myfirst = _Right._Myfirst;

  00028	8b 07		 mov	 eax, DWORD PTR [edi]
  0002a	89 06		 mov	 DWORD PTR [esi], eax

; 621  : 			this->_Mylast = _Right._Mylast;

  0002c	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  0002f	89 4e 04	 mov	 DWORD PTR [esi+4], ecx

; 622  : 			this->_Myend = _Right._Myend;

  00032	8b 57 08	 mov	 edx, DWORD PTR [edi+8]
  00035	89 56 08	 mov	 DWORD PTR [esi+8], edx

; 623  : 
; 624  : 			_Right._Myfirst = 0;

  00038	89 1f		 mov	 DWORD PTR [edi], ebx

; 625  : 			_Right._Mylast = 0;

  0003a	89 5f 04	 mov	 DWORD PTR [edi+4], ebx

; 626  : 			_Right._Myend = 0;

  0003d	89 5f 08	 mov	 DWORD PTR [edi+8], ebx
  00040	5b		 pop	 ebx
$LN1@Assign_rv:
  00041	5f		 pop	 edi
  00042	5e		 pop	 esi

; 627  : 			}
; 628  : 		}

  00043	5d		 pop	 ebp
  00044	c2 04 00	 ret	 4
?_Assign_rv@?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@QAEX$$QAV12@@Z ENDP ; std::vector<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> >::_Assign_rv
_TEXT	ENDS
PUBLIC	??0?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@QAE@$$QAV01@@Z ; std::vector<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> >::vector<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> >
; Function compile flags: /Ogtp
;	COMDAT ??0?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@QAE@$$QAV01@@Z PROC ; std::vector<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> >::vector<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> >, COMDAT
; _this$ = ecx

; 595  : 		{	// construct by moving _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx

; 596  : 		_Assign_rv(_STD forward<_Myt>(_Right));

  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00008	33 d2		 xor	 edx, edx
  0000a	89 10		 mov	 DWORD PTR [eax], edx
  0000c	89 50 04	 mov	 DWORD PTR [eax+4], edx
  0000f	89 50 08	 mov	 DWORD PTR [eax+8], edx
  00012	3b c1		 cmp	 eax, ecx
  00014	74 22		 je	 SHORT $LN11@vector@2
  00016	89 10		 mov	 DWORD PTR [eax], edx
  00018	89 50 04	 mov	 DWORD PTR [eax+4], edx
  0001b	89 50 08	 mov	 DWORD PTR [eax+8], edx
  0001e	56		 push	 esi
  0001f	8b 31		 mov	 esi, DWORD PTR [ecx]
  00021	89 30		 mov	 DWORD PTR [eax], esi
  00023	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  00026	89 70 04	 mov	 DWORD PTR [eax+4], esi
  00029	8b 71 08	 mov	 esi, DWORD PTR [ecx+8]
  0002c	89 70 08	 mov	 DWORD PTR [eax+8], esi
  0002f	89 11		 mov	 DWORD PTR [ecx], edx
  00031	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  00034	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  00037	5e		 pop	 esi
$LN11@vector@2:

; 597  : 		}

  00038	5d		 pop	 ebp
  00039	c2 04 00	 ret	 4
??0?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@QAE@$$QAV01@@Z ENDP ; std::vector<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> >::vector<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> >
_TEXT	ENDS
PUBLIC	??4?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@QAEAAV01@$$QAV01@@Z ; std::vector<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> >::operator=
; Function compile flags: /Ogtp
;	COMDAT ??4?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@QAEAAV01@$$QAV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??4?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@QAEAAV01@$$QAV01@@Z PROC ; std::vector<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> >::operator=, COMDAT
; _this$ = ecx

; 600  : 		{	// assign by moving _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 601  : 		_Assign_rv(_STD forward<_Myt>(_Right));

  00005	8b 7d 08	 mov	 edi, DWORD PTR __Right$[ebp]
  00008	8b f1		 mov	 esi, ecx
  0000a	3b f7		 cmp	 esi, edi
  0000c	74 33		 je	 SHORT $LN136@operator
  0000e	8b 06		 mov	 eax, DWORD PTR [esi]
  00010	53		 push	 ebx
  00011	33 db		 xor	 ebx, ebx
  00013	3b c3		 cmp	 eax, ebx
  00015	74 09		 je	 SHORT $LN128@operator
  00017	50		 push	 eax
  00018	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0001d	83 c4 04	 add	 esp, 4
$LN128@operator:
  00020	89 1e		 mov	 DWORD PTR [esi], ebx
  00022	89 5e 04	 mov	 DWORD PTR [esi+4], ebx
  00025	89 5e 08	 mov	 DWORD PTR [esi+8], ebx
  00028	8b 07		 mov	 eax, DWORD PTR [edi]
  0002a	89 06		 mov	 DWORD PTR [esi], eax
  0002c	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  0002f	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  00032	8b 57 08	 mov	 edx, DWORD PTR [edi+8]
  00035	89 56 08	 mov	 DWORD PTR [esi+8], edx
  00038	89 1f		 mov	 DWORD PTR [edi], ebx
  0003a	89 5f 04	 mov	 DWORD PTR [edi+4], ebx
  0003d	89 5f 08	 mov	 DWORD PTR [edi+8], ebx
  00040	5b		 pop	 ebx
$LN136@operator:

; 602  : 		return (*this);

  00041	5f		 pop	 edi
  00042	8b c6		 mov	 eax, esi
  00044	5e		 pop	 esi

; 603  : 		}

  00045	5d		 pop	 ebp
  00046	c2 04 00	 ret	 4
??4?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@QAEAAV01@$$QAV01@@Z ENDP ; std::vector<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> >::operator=
_TEXT	ENDS
PUBLIC	?swap@?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@QAEXAAV12@@Z ; std::vector<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> >::swap
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?swap@?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@QAEXAAV12@@Z DD 0ffffffffH
	DD	00H
__ehfuncinfo$?swap@?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@QAEXAAV12@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?swap@?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@QAEXAAV12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
xdata$x	ENDS
;	COMDAT ?swap@?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@QAEXAAV12@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Right$ = 8						; size = 4
?swap@?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@QAEXAAV12@@Z PROC ; std::vector<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> >::swap, COMDAT
; _this$ = ecx

; 1222 : 		{	// exchange contents with _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?swap@?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@QAEXAAV12@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 1223 : 		if (this == &_Right)

  00023	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00026	3b c8		 cmp	 ecx, eax
  00028	74 26		 je	 SHORT $LL118@swap

; 1224 : 			;	// same object, do nothing
; 1225 : 		else if (this->_Alval == _Right._Alval)
; 1226 : 			{	// same allocator, swap control information
; 1227 : 			this->_Swap_all(_Right);
; 1228 : 			_STD swap(this->_Myfirst, _Right._Myfirst);

  0002a	8b 30		 mov	 esi, DWORD PTR [eax]
  0002c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0002e	89 31		 mov	 DWORD PTR [ecx], esi
  00030	89 10		 mov	 DWORD PTR [eax], edx

; 1229 : 			_STD swap(this->_Mylast, _Right._Mylast);

  00032	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  00035	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00038	89 71 04	 mov	 DWORD PTR [ecx+4], esi
  0003b	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 1230 : 			_STD swap(this->_Myend, _Right._Myend);

  0003e	8b 70 08	 mov	 esi, DWORD PTR [eax+8]
  00041	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00044	89 71 08	 mov	 DWORD PTR [ecx+8], esi
  00047	89 50 08	 mov	 DWORD PTR [eax+8], edx
  0004a	8d 9b 00 00 00
	00		 npad	 6

; 1231 : 			}
; 1232 : 		else
; 1233 : 			{	// different allocator, do multiple assigns
; 1234 : 			_Myt _Ts = _Move(*this);

$LL118@swap:

; 1235 : 
; 1236 : 			*this = _Move(_Right);
; 1237 : 			_Right = _Move(_Ts);
; 1238 : 			}
; 1239 : 		}

  00050	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00053	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005a	59		 pop	 ecx
  0005b	5e		 pop	 esi
  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?swap@?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@QAEXAAV12@@Z:
  00000	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00004	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00007	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000a	33 c8		 xor	 ecx, eax
  0000c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00011	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?swap@?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@QAEXAAV12@@Z
  00016	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?swap@?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@QAEXAAV12@@Z ENDP ; std::vector<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> >::swap
PUBLIC	?Init@ItemWingsOption@@QAEXXZ			; ItemWingsOption::Init
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Init@ItemWingsOption@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Init@ItemWingsOption@@QAEXXZ$0
	DD	00H
	DD	00H
__ehfuncinfo$?Init@ItemWingsOption@@QAEXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?Init@ItemWingsOption@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\muserver_dev\development\mu-s8ep2-repack\gameserver\source\itemwingsoption.cpp
xdata$x	ENDS
;	COMDAT ?Init@ItemWingsOption@@QAEXXZ
_TEXT	SEGMENT
$T162123 = -28						; size = 16
__$EHRec$ = -12						; size = 12
?Init@ItemWingsOption@@QAEXXZ PROC			; ItemWingsOption::Init, COMDAT
; _this$ = ecx

; 13   : void ItemWingsOption::Init() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?Init@ItemWingsOption@@QAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 10	 sub	 esp, 16			; 00000010H
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001b	33 c5		 xor	 eax, ebp
  0001d	50		 push	 eax
  0001e	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00021	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 14   : 	m_OptionInfo.clear();

  00027	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  0002a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0002c	3b d6		 cmp	 edx, esi
  0002e	74 1f		 je	 SHORT $LN23@Init
  00030	8b c6		 mov	 eax, esi
  00032	3b f6		 cmp	 esi, esi
  00034	74 16		 je	 SHORT $LN52@Init
$LL54@Init:
  00036	8b 38		 mov	 edi, DWORD PTR [eax]
  00038	89 3a		 mov	 DWORD PTR [edx], edi
  0003a	66 8b 78 04	 mov	 di, WORD PTR [eax+4]
  0003e	66 89 7a 04	 mov	 WORD PTR [edx+4], di
  00042	83 c0 06	 add	 eax, 6
  00045	83 c2 06	 add	 edx, 6
  00048	3b c6		 cmp	 eax, esi
  0004a	75 ea		 jne	 SHORT $LL54@Init
$LN52@Init:
  0004c	89 51 04	 mov	 DWORD PTR [ecx+4], edx
$LN23@Init:

; 15   : 	if (m_OptionInfo.capacity() > 0) {

  0004f	8b 31		 mov	 esi, DWORD PTR [ecx]
  00051	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00054	2b d6		 sub	 edx, esi
  00056	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0005b	f7 ea		 imul	 edx
  0005d	8b c2		 mov	 eax, edx
  0005f	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00062	03 c2		 add	 eax, edx
  00064	74 1e		 je	 SHORT $LN535@Init

; 16   : 		std::vector<ItemWingsOptionInfo>().swap(m_OptionInfo);

  00066	8d 55 e4	 lea	 edx, DWORD PTR $T162123[ebp]
  00069	3b d1		 cmp	 edx, ecx
  0006b	74 17		 je	 SHORT $LN535@Init
  0006d	33 c0		 xor	 eax, eax
  0006f	89 01		 mov	 DWORD PTR [ecx], eax
  00071	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00074	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  00077	3b f0		 cmp	 esi, eax
  00079	74 09		 je	 SHORT $LN535@Init
  0007b	56		 push	 esi
  0007c	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00081	83 c4 04	 add	 esp, 4
$LN535@Init:

; 17   : 	}
; 18   : }

  00084	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00087	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0008e	59		 pop	 ecx
  0008f	5f		 pop	 edi
  00090	5e		 pop	 esi
  00091	8b e5		 mov	 esp, ebp
  00093	5d		 pop	 ebp
  00094	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Init@ItemWingsOption@@QAEXXZ$0:
  00000	8d 4d e4	 lea	 ecx, DWORD PTR $T162123[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$vector@UItemWingsOptionInfo@@V?$allocator@UItemWingsOptionInfo@@@std@@@std@@QAE@XZ ; std::vector<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> >::~vector<ItemWingsOptionInfo,std::allocator<ItemWingsOptionInfo> >
__ehhandler$?Init@ItemWingsOption@@QAEXXZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Init@ItemWingsOption@@QAEXXZ
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Init@ItemWingsOption@@QAEXXZ ENDP			; ItemWingsOption::Init
PUBLIC	?Load@ItemWingsOption@@QAEXXZ			; ItemWingsOption::Load
; Function compile flags: /Ogtp
;	COMDAT ?Load@ItemWingsOption@@QAEXXZ
_TEXT	SEGMENT
?Load@ItemWingsOption@@QAEXXZ PROC			; ItemWingsOption::Load, COMDAT
; _this$ = ecx

; 9    : 	Init();

  00000	e9 00 00 00 00	 jmp	 ?Init@ItemWingsOption@@QAEXXZ ; ItemWingsOption::Init
?Load@ItemWingsOption@@QAEXXZ ENDP			; ItemWingsOption::Load
_TEXT	ENDS
EXTRN	_atexit:PROC
; Function compile flags: /Ogtp
;	COMDAT ??__Eg_ItemWingsOption@@YAXXZ
text$yc	SEGMENT
??__Eg_ItemWingsOption@@YAXXZ PROC			; `dynamic initializer for 'g_ItemWingsOption'', COMDAT

; 5    : ItemWingsOption g_ItemWingsOption;

  00000	68 00 00 00 00	 push	 OFFSET ??__Fg_ItemWingsOption@@YAXXZ ; `dynamic atexit destructor for 'g_ItemWingsOption''
  00005	e8 00 00 00 00	 call	 _atexit
  0000a	59		 pop	 ecx
  0000b	c3		 ret	 0
??__Eg_ItemWingsOption@@YAXXZ ENDP			; `dynamic initializer for 'g_ItemWingsOption''
; Function compile flags: /Ogtp
text$yc	ENDS
;	COMDAT ??__Fg_ItemWingsOption@@YAXXZ
text$yd	SEGMENT
??__Fg_ItemWingsOption@@YAXXZ PROC			; `dynamic atexit destructor for 'g_ItemWingsOption'', COMDAT
  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?g_ItemWingsOption@@3VItemWingsOption@@A
  00005	85 c0		 test	 eax, eax
  00007	74 09		 je	 SHORT $LN12@dynamic
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000f	83 c4 04	 add	 esp, 4
$LN12@dynamic:
  00012	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?g_ItemWingsOption@@3VItemWingsOption@@A, 0
  0001c	c7 05 04 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?g_ItemWingsOption@@3VItemWingsOption@@A+4, 0
  00026	c7 05 08 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?g_ItemWingsOption@@3VItemWingsOption@@A+8, 0
  00030	c3		 ret	 0
??__Fg_ItemWingsOption@@YAXXZ ENDP			; `dynamic atexit destructor for 'g_ItemWingsOption''
text$yd	ENDS
PUBLIC	?g_ItemWingsOption@@3VItemWingsOption@@A	; g_ItemWingsOption
_BSS	SEGMENT
?g_ItemWingsOption@@3VItemWingsOption@@A DB 010H DUP (?) ; g_ItemWingsOption
_BSS	ENDS
CRT$XCU	SEGMENT
_g_ItemWingsOption$initializer$ DD FLAT:??__Eg_ItemWingsOption@@YAXXZ
CRT$XCU	ENDS
END
