; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	C:\muserver_dev\development\MU-S8EP2-Repack\GameServer\Source\CashShop.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?BLOCKSIZE@?$FixedBlockSize@$07@CryptoPP@@2HB	; CryptoPP::FixedBlockSize<8>::BLOCKSIZE
PUBLIC	?KEYLENGTH@?$FixedKeyLength@$07$03$0A@@CryptoPP@@2HB ; CryptoPP::FixedKeyLength<8,4,0>::KEYLENGTH
PUBLIC	?MIN_KEYLENGTH@?$FixedKeyLength@$07$03$0A@@CryptoPP@@2HB ; CryptoPP::FixedKeyLength<8,4,0>::MIN_KEYLENGTH
PUBLIC	?MAX_KEYLENGTH@?$FixedKeyLength@$07$03$0A@@CryptoPP@@2HB ; CryptoPP::FixedKeyLength<8,4,0>::MAX_KEYLENGTH
PUBLIC	?DEFAULT_KEYLENGTH@?$FixedKeyLength@$07$03$0A@@CryptoPP@@2HB ; CryptoPP::FixedKeyLength<8,4,0>::DEFAULT_KEYLENGTH
PUBLIC	?IV_REQUIREMENT@?$FixedKeyLength@$07$03$0A@@CryptoPP@@2HB ; CryptoPP::FixedKeyLength<8,4,0>::IV_REQUIREMENT
PUBLIC	?IV_LENGTH@?$FixedKeyLength@$07$03$0A@@CryptoPP@@2HB ; CryptoPP::FixedKeyLength<8,4,0>::IV_LENGTH
PUBLIC	?KEYLENGTH@?$FixedKeyLength@$0BA@$03$0A@@CryptoPP@@2HB ; CryptoPP::FixedKeyLength<16,4,0>::KEYLENGTH
PUBLIC	?MIN_KEYLENGTH@?$FixedKeyLength@$0BA@$03$0A@@CryptoPP@@2HB ; CryptoPP::FixedKeyLength<16,4,0>::MIN_KEYLENGTH
PUBLIC	?MAX_KEYLENGTH@?$FixedKeyLength@$0BA@$03$0A@@CryptoPP@@2HB ; CryptoPP::FixedKeyLength<16,4,0>::MAX_KEYLENGTH
PUBLIC	?DEFAULT_KEYLENGTH@?$FixedKeyLength@$0BA@$03$0A@@CryptoPP@@2HB ; CryptoPP::FixedKeyLength<16,4,0>::DEFAULT_KEYLENGTH
PUBLIC	?IV_REQUIREMENT@?$FixedKeyLength@$0BA@$03$0A@@CryptoPP@@2HB ; CryptoPP::FixedKeyLength<16,4,0>::IV_REQUIREMENT
PUBLIC	?IV_LENGTH@?$FixedKeyLength@$0BA@$03$0A@@CryptoPP@@2HB ; CryptoPP::FixedKeyLength<16,4,0>::IV_LENGTH
PUBLIC	?KEYLENGTH@?$FixedKeyLength@$0BI@$03$0A@@CryptoPP@@2HB ; CryptoPP::FixedKeyLength<24,4,0>::KEYLENGTH
PUBLIC	?MIN_KEYLENGTH@?$FixedKeyLength@$0BI@$03$0A@@CryptoPP@@2HB ; CryptoPP::FixedKeyLength<24,4,0>::MIN_KEYLENGTH
PUBLIC	?MAX_KEYLENGTH@?$FixedKeyLength@$0BI@$03$0A@@CryptoPP@@2HB ; CryptoPP::FixedKeyLength<24,4,0>::MAX_KEYLENGTH
PUBLIC	?DEFAULT_KEYLENGTH@?$FixedKeyLength@$0BI@$03$0A@@CryptoPP@@2HB ; CryptoPP::FixedKeyLength<24,4,0>::DEFAULT_KEYLENGTH
PUBLIC	?IV_REQUIREMENT@?$FixedKeyLength@$0BI@$03$0A@@CryptoPP@@2HB ; CryptoPP::FixedKeyLength<24,4,0>::IV_REQUIREMENT
PUBLIC	?IV_LENGTH@?$FixedKeyLength@$0BI@$03$0A@@CryptoPP@@2HB ; CryptoPP::FixedKeyLength<24,4,0>::IV_LENGTH
PUBLIC	?g_bUseCashShop@@3HA				; g_bUseCashShop
PUBLIC	?g_bConnectShopServer@@3HA			; g_bConnectShopServer
PUBLIC	?g_bShopServerConnectState@@3HA			; g_bShopServerConnectState
PUBLIC	?g_ShopServerIP@@3PADA				; g_ShopServerIP
PUBLIC	?g_bUseMoveMapBound@@3HA			; g_bUseMoveMapBound
PUBLIC	?m_lpOldProc@CCashShop@@2P6GJPAUHWND__@@IIJ@ZA	; CCashShop::m_lpOldProc
PUBLIC	?g_ShopserverPort@@3HA				; g_ShopserverPort
_BSS	SEGMENT
?g_bUseCashShop@@3HA DD 01H DUP (?)			; g_bUseCashShop
?g_bConnectShopServer@@3HA DD 01H DUP (?)		; g_bConnectShopServer
?g_bShopServerConnectState@@3HA DD 01H DUP (?)		; g_bShopServerConnectState
?g_ShopServerIP@@3PADA DB 010H DUP (?)			; g_ShopServerIP
?g_bUseMoveMapBound@@3HA DD 01H DUP (?)			; g_bUseMoveMapBound
?m_lpOldProc@CCashShop@@2P6GJPAUHWND__@@IIJ@ZA DD 01H DUP (?) ; CCashShop::m_lpOldProc
?g_ShopserverPort@@3HA DD 01H DUP (?)			; g_ShopserverPort
_BSS	ENDS
;	COMDAT ?IV_LENGTH@?$FixedKeyLength@$0BI@$03$0A@@CryptoPP@@2HB
CONST	SEGMENT
?IV_LENGTH@?$FixedKeyLength@$0BI@$03$0A@@CryptoPP@@2HB DD 00H ; CryptoPP::FixedKeyLength<24,4,0>::IV_LENGTH
CONST	ENDS
;	COMDAT ?IV_REQUIREMENT@?$FixedKeyLength@$0BI@$03$0A@@CryptoPP@@2HB
CONST	SEGMENT
?IV_REQUIREMENT@?$FixedKeyLength@$0BI@$03$0A@@CryptoPP@@2HB DD 04H ; CryptoPP::FixedKeyLength<24,4,0>::IV_REQUIREMENT
CONST	ENDS
;	COMDAT ?DEFAULT_KEYLENGTH@?$FixedKeyLength@$0BI@$03$0A@@CryptoPP@@2HB
CONST	SEGMENT
?DEFAULT_KEYLENGTH@?$FixedKeyLength@$0BI@$03$0A@@CryptoPP@@2HB DD 018H ; CryptoPP::FixedKeyLength<24,4,0>::DEFAULT_KEYLENGTH
CONST	ENDS
;	COMDAT ?MAX_KEYLENGTH@?$FixedKeyLength@$0BI@$03$0A@@CryptoPP@@2HB
CONST	SEGMENT
?MAX_KEYLENGTH@?$FixedKeyLength@$0BI@$03$0A@@CryptoPP@@2HB DD 018H ; CryptoPP::FixedKeyLength<24,4,0>::MAX_KEYLENGTH
CONST	ENDS
;	COMDAT ?MIN_KEYLENGTH@?$FixedKeyLength@$0BI@$03$0A@@CryptoPP@@2HB
CONST	SEGMENT
?MIN_KEYLENGTH@?$FixedKeyLength@$0BI@$03$0A@@CryptoPP@@2HB DD 018H ; CryptoPP::FixedKeyLength<24,4,0>::MIN_KEYLENGTH
CONST	ENDS
;	COMDAT ?KEYLENGTH@?$FixedKeyLength@$0BI@$03$0A@@CryptoPP@@2HB
CONST	SEGMENT
?KEYLENGTH@?$FixedKeyLength@$0BI@$03$0A@@CryptoPP@@2HB DD 018H ; CryptoPP::FixedKeyLength<24,4,0>::KEYLENGTH
CONST	ENDS
;	COMDAT ?IV_LENGTH@?$FixedKeyLength@$0BA@$03$0A@@CryptoPP@@2HB
CONST	SEGMENT
?IV_LENGTH@?$FixedKeyLength@$0BA@$03$0A@@CryptoPP@@2HB DD 00H ; CryptoPP::FixedKeyLength<16,4,0>::IV_LENGTH
CONST	ENDS
;	COMDAT ?IV_REQUIREMENT@?$FixedKeyLength@$0BA@$03$0A@@CryptoPP@@2HB
CONST	SEGMENT
?IV_REQUIREMENT@?$FixedKeyLength@$0BA@$03$0A@@CryptoPP@@2HB DD 04H ; CryptoPP::FixedKeyLength<16,4,0>::IV_REQUIREMENT
CONST	ENDS
;	COMDAT ?DEFAULT_KEYLENGTH@?$FixedKeyLength@$0BA@$03$0A@@CryptoPP@@2HB
CONST	SEGMENT
?DEFAULT_KEYLENGTH@?$FixedKeyLength@$0BA@$03$0A@@CryptoPP@@2HB DD 010H ; CryptoPP::FixedKeyLength<16,4,0>::DEFAULT_KEYLENGTH
CONST	ENDS
;	COMDAT ?MAX_KEYLENGTH@?$FixedKeyLength@$0BA@$03$0A@@CryptoPP@@2HB
CONST	SEGMENT
?MAX_KEYLENGTH@?$FixedKeyLength@$0BA@$03$0A@@CryptoPP@@2HB DD 010H ; CryptoPP::FixedKeyLength<16,4,0>::MAX_KEYLENGTH
CONST	ENDS
;	COMDAT ?MIN_KEYLENGTH@?$FixedKeyLength@$0BA@$03$0A@@CryptoPP@@2HB
CONST	SEGMENT
?MIN_KEYLENGTH@?$FixedKeyLength@$0BA@$03$0A@@CryptoPP@@2HB DD 010H ; CryptoPP::FixedKeyLength<16,4,0>::MIN_KEYLENGTH
CONST	ENDS
;	COMDAT ?KEYLENGTH@?$FixedKeyLength@$0BA@$03$0A@@CryptoPP@@2HB
CONST	SEGMENT
?KEYLENGTH@?$FixedKeyLength@$0BA@$03$0A@@CryptoPP@@2HB DD 010H ; CryptoPP::FixedKeyLength<16,4,0>::KEYLENGTH
CONST	ENDS
;	COMDAT ?IV_LENGTH@?$FixedKeyLength@$07$03$0A@@CryptoPP@@2HB
CONST	SEGMENT
?IV_LENGTH@?$FixedKeyLength@$07$03$0A@@CryptoPP@@2HB DD 00H ; CryptoPP::FixedKeyLength<8,4,0>::IV_LENGTH
CONST	ENDS
;	COMDAT ?IV_REQUIREMENT@?$FixedKeyLength@$07$03$0A@@CryptoPP@@2HB
CONST	SEGMENT
?IV_REQUIREMENT@?$FixedKeyLength@$07$03$0A@@CryptoPP@@2HB DD 04H ; CryptoPP::FixedKeyLength<8,4,0>::IV_REQUIREMENT
CONST	ENDS
;	COMDAT ?DEFAULT_KEYLENGTH@?$FixedKeyLength@$07$03$0A@@CryptoPP@@2HB
CONST	SEGMENT
?DEFAULT_KEYLENGTH@?$FixedKeyLength@$07$03$0A@@CryptoPP@@2HB DD 08H ; CryptoPP::FixedKeyLength<8,4,0>::DEFAULT_KEYLENGTH
CONST	ENDS
;	COMDAT ?MAX_KEYLENGTH@?$FixedKeyLength@$07$03$0A@@CryptoPP@@2HB
CONST	SEGMENT
?MAX_KEYLENGTH@?$FixedKeyLength@$07$03$0A@@CryptoPP@@2HB DD 08H ; CryptoPP::FixedKeyLength<8,4,0>::MAX_KEYLENGTH
CONST	ENDS
;	COMDAT ?MIN_KEYLENGTH@?$FixedKeyLength@$07$03$0A@@CryptoPP@@2HB
CONST	SEGMENT
?MIN_KEYLENGTH@?$FixedKeyLength@$07$03$0A@@CryptoPP@@2HB DD 08H ; CryptoPP::FixedKeyLength<8,4,0>::MIN_KEYLENGTH
CONST	ENDS
;	COMDAT ?KEYLENGTH@?$FixedKeyLength@$07$03$0A@@CryptoPP@@2HB
CONST	SEGMENT
?KEYLENGTH@?$FixedKeyLength@$07$03$0A@@CryptoPP@@2HB DD 08H ; CryptoPP::FixedKeyLength<8,4,0>::KEYLENGTH
CONST	ENDS
;	COMDAT ?BLOCKSIZE@?$FixedBlockSize@$07@CryptoPP@@2HB
CONST	SEGMENT
?BLOCKSIZE@?$FixedBlockSize@$07@CryptoPP@@2HB DD 08H	; CryptoPP::FixedBlockSize<8>::BLOCKSIZE
CONST	ENDS
PUBLIC	??2@YAPAXIPAX@Z					; operator new
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\new.h
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 81   :         {return (_Where); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]
  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
PUBLIC	??3@YAXPAX0@Z					; operator delete
; Function compile flags: /Ogtp
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 83   :         {return; }

  00000	c3		 ret	 0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
PUBLIC	??0MSG_GTOS_USER_CASH_REQ_EX@protocol@@QAE@XZ	; protocol::MSG_GTOS_USER_CASH_REQ_EX::MSG_GTOS_USER_CASH_REQ_EX
; Function compile flags: /Ogtp
; File c:\muserver_dev\development\mu-s8ep2-repack\gameserver\source\pcsprotocol.h
;	COMDAT ??0MSG_GTOS_USER_CASH_REQ_EX@protocol@@QAE@XZ
_TEXT	SEGMENT
??0MSG_GTOS_USER_CASH_REQ_EX@protocol@@QAE@XZ PROC	; protocol::MSG_GTOS_USER_CASH_REQ_EX::MSG_GTOS_USER_CASH_REQ_EX, COMDAT
; _this$ = ecx

; 313  : 		MSG_GTOS_USER_CASH_REQ_EX()

  00000	8b c1		 mov	 eax, ecx

; 314  : 		{
; 315  : 			this->size = sizeof(MSG_GTOS_USER_CASH_REQ_EX);

  00002	c7 00 0c 00 00
	00		 mov	 DWORD PTR [eax], 12	; 0000000cH

; 316  : 			this->hdrid.category = 0x100;

  00008	c7 40 04 00 01
	01 00		 mov	 DWORD PTR [eax+4], 65792 ; 00010100H

; 317  : 			this->hdrid.messageID = 1;
; 318  : 		};	// line : 74

  0000f	c3		 ret	 0
??0MSG_GTOS_USER_CASH_REQ_EX@protocol@@QAE@XZ ENDP	; protocol::MSG_GTOS_USER_CASH_REQ_EX::MSG_GTOS_USER_CASH_REQ_EX
_TEXT	ENDS
PUBLIC	??1MSG_GTOS_USER_CASH_REQ_EX@protocol@@QAE@XZ	; protocol::MSG_GTOS_USER_CASH_REQ_EX::~MSG_GTOS_USER_CASH_REQ_EX
; Function compile flags: /Ogtp
;	COMDAT ??1MSG_GTOS_USER_CASH_REQ_EX@protocol@@QAE@XZ
_TEXT	SEGMENT
??1MSG_GTOS_USER_CASH_REQ_EX@protocol@@QAE@XZ PROC	; protocol::MSG_GTOS_USER_CASH_REQ_EX::~MSG_GTOS_USER_CASH_REQ_EX, COMDAT
; _this$ = ecx

; 322  : 		};

  00000	c3		 ret	 0
??1MSG_GTOS_USER_CASH_REQ_EX@protocol@@QAE@XZ ENDP	; protocol::MSG_GTOS_USER_CASH_REQ_EX::~MSG_GTOS_USER_CASH_REQ_EX
_TEXT	ENDS
PUBLIC	??0MSG_GTOS_ITEM_LIST_REQ_EX@protocol@@QAE@XZ	; protocol::MSG_GTOS_ITEM_LIST_REQ_EX::MSG_GTOS_ITEM_LIST_REQ_EX
; Function compile flags: /Ogtp
;	COMDAT ??0MSG_GTOS_ITEM_LIST_REQ_EX@protocol@@QAE@XZ
_TEXT	SEGMENT
??0MSG_GTOS_ITEM_LIST_REQ_EX@protocol@@QAE@XZ PROC	; protocol::MSG_GTOS_ITEM_LIST_REQ_EX::MSG_GTOS_ITEM_LIST_REQ_EX, COMDAT
; _this$ = ecx

; 349  : 		MSG_GTOS_ITEM_LIST_REQ_EX()

  00000	8b c1		 mov	 eax, ecx

; 350  : 		{
; 351  : 			this->size = sizeof(MSG_GTOS_ITEM_LIST_REQ_EX);

  00002	c7 00 10 00 00
	00		 mov	 DWORD PTR [eax], 16	; 00000010H

; 352  : 			this->hdrid.category = 0x300;

  00008	c7 40 04 00 03
	01 00		 mov	 DWORD PTR [eax+4], 66304 ; 00010300H

; 353  : 			this->hdrid.messageID = 1;
; 354  : 		};

  0000f	c3		 ret	 0
??0MSG_GTOS_ITEM_LIST_REQ_EX@protocol@@QAE@XZ ENDP	; protocol::MSG_GTOS_ITEM_LIST_REQ_EX::MSG_GTOS_ITEM_LIST_REQ_EX
_TEXT	ENDS
PUBLIC	??1MSG_GTOS_ITEM_LIST_REQ_EX@protocol@@QAE@XZ	; protocol::MSG_GTOS_ITEM_LIST_REQ_EX::~MSG_GTOS_ITEM_LIST_REQ_EX
; Function compile flags: /Ogtp
;	COMDAT ??1MSG_GTOS_ITEM_LIST_REQ_EX@protocol@@QAE@XZ
_TEXT	SEGMENT
??1MSG_GTOS_ITEM_LIST_REQ_EX@protocol@@QAE@XZ PROC	; protocol::MSG_GTOS_ITEM_LIST_REQ_EX::~MSG_GTOS_ITEM_LIST_REQ_EX, COMDAT
; _this$ = ecx

; 358  : 		};

  00000	c3		 ret	 0
??1MSG_GTOS_ITEM_LIST_REQ_EX@protocol@@QAE@XZ ENDP	; protocol::MSG_GTOS_ITEM_LIST_REQ_EX::~MSG_GTOS_ITEM_LIST_REQ_EX
_TEXT	ENDS
PUBLIC	??0MSG_GTOS_ITEM_USE_REQ_EX@protocol@@QAE@XZ	; protocol::MSG_GTOS_ITEM_USE_REQ_EX::MSG_GTOS_ITEM_USE_REQ_EX
; Function compile flags: /Ogtp
;	COMDAT ??0MSG_GTOS_ITEM_USE_REQ_EX@protocol@@QAE@XZ
_TEXT	SEGMENT
??0MSG_GTOS_ITEM_USE_REQ_EX@protocol@@QAE@XZ PROC	; protocol::MSG_GTOS_ITEM_USE_REQ_EX::MSG_GTOS_ITEM_USE_REQ_EX, COMDAT
; _this$ = ecx

; 407  : 		MSG_GTOS_ITEM_USE_REQ_EX()

  00000	8b c1		 mov	 eax, ecx

; 408  : 		{
; 409  : 			this->size = sizeof(MSG_GTOS_ITEM_USE_REQ_EX);

  00002	c7 00 1c 00 00
	00		 mov	 DWORD PTR [eax], 28	; 0000001cH

; 410  : 			this->hdrid.category = 0x500;

  00008	c7 40 04 00 05
	01 00		 mov	 DWORD PTR [eax+4], 66816 ; 00010500H

; 411  : 			this->hdrid.messageID = 1;
; 412  : 		};

  0000f	c3		 ret	 0
??0MSG_GTOS_ITEM_USE_REQ_EX@protocol@@QAE@XZ ENDP	; protocol::MSG_GTOS_ITEM_USE_REQ_EX::MSG_GTOS_ITEM_USE_REQ_EX
_TEXT	ENDS
PUBLIC	??1MSG_GTOS_ITEM_USE_REQ_EX@protocol@@QAE@XZ	; protocol::MSG_GTOS_ITEM_USE_REQ_EX::~MSG_GTOS_ITEM_USE_REQ_EX
; Function compile flags: /Ogtp
;	COMDAT ??1MSG_GTOS_ITEM_USE_REQ_EX@protocol@@QAE@XZ
_TEXT	SEGMENT
??1MSG_GTOS_ITEM_USE_REQ_EX@protocol@@QAE@XZ PROC	; protocol::MSG_GTOS_ITEM_USE_REQ_EX::~MSG_GTOS_ITEM_USE_REQ_EX, COMDAT
; _this$ = ecx

; 416  : 		};

  00000	c3		 ret	 0
??1MSG_GTOS_ITEM_USE_REQ_EX@protocol@@QAE@XZ ENDP	; protocol::MSG_GTOS_ITEM_USE_REQ_EX::~MSG_GTOS_ITEM_USE_REQ_EX
_TEXT	ENDS
PUBLIC	??0MSG_GTOS_GIFT_LIST_REQ_EX@protocol@@QAE@XZ	; protocol::MSG_GTOS_GIFT_LIST_REQ_EX::MSG_GTOS_GIFT_LIST_REQ_EX
; Function compile flags: /Ogtp
;	COMDAT ??0MSG_GTOS_GIFT_LIST_REQ_EX@protocol@@QAE@XZ
_TEXT	SEGMENT
??0MSG_GTOS_GIFT_LIST_REQ_EX@protocol@@QAE@XZ PROC	; protocol::MSG_GTOS_GIFT_LIST_REQ_EX::MSG_GTOS_GIFT_LIST_REQ_EX, COMDAT
; _this$ = ecx

; 459  : 		MSG_GTOS_GIFT_LIST_REQ_EX()

  00000	8b c1		 mov	 eax, ecx

; 460  : 		{
; 461  : 			this->size = sizeof(MSG_GTOS_GIFT_LIST_REQ_EX);

  00002	c7 00 10 00 00
	00		 mov	 DWORD PTR [eax], 16	; 00000010H

; 462  : 			this->hdrid.category = 0x700;

  00008	c7 40 04 00 07
	01 00		 mov	 DWORD PTR [eax+4], 67328 ; 00010700H

; 463  : 			this->hdrid.messageID = 1;
; 464  : 		};

  0000f	c3		 ret	 0
??0MSG_GTOS_GIFT_LIST_REQ_EX@protocol@@QAE@XZ ENDP	; protocol::MSG_GTOS_GIFT_LIST_REQ_EX::MSG_GTOS_GIFT_LIST_REQ_EX
_TEXT	ENDS
PUBLIC	??1MSG_GTOS_GIFT_LIST_REQ_EX@protocol@@QAE@XZ	; protocol::MSG_GTOS_GIFT_LIST_REQ_EX::~MSG_GTOS_GIFT_LIST_REQ_EX
; Function compile flags: /Ogtp
;	COMDAT ??1MSG_GTOS_GIFT_LIST_REQ_EX@protocol@@QAE@XZ
_TEXT	SEGMENT
??1MSG_GTOS_GIFT_LIST_REQ_EX@protocol@@QAE@XZ PROC	; protocol::MSG_GTOS_GIFT_LIST_REQ_EX::~MSG_GTOS_GIFT_LIST_REQ_EX, COMDAT
; _this$ = ecx

; 468  : 		};

  00000	c3		 ret	 0
??1MSG_GTOS_GIFT_LIST_REQ_EX@protocol@@QAE@XZ ENDP	; protocol::MSG_GTOS_GIFT_LIST_REQ_EX::~MSG_GTOS_GIFT_LIST_REQ_EX
_TEXT	ENDS
PUBLIC	??0MSG_GTOS_BUY_ITEM_REQ_EX@protocol@@QAE@XZ	; protocol::MSG_GTOS_BUY_ITEM_REQ_EX::MSG_GTOS_BUY_ITEM_REQ_EX
; Function compile flags: /Ogtp
;	COMDAT ??0MSG_GTOS_BUY_ITEM_REQ_EX@protocol@@QAE@XZ
_TEXT	SEGMENT
??0MSG_GTOS_BUY_ITEM_REQ_EX@protocol@@QAE@XZ PROC	; protocol::MSG_GTOS_BUY_ITEM_REQ_EX::MSG_GTOS_BUY_ITEM_REQ_EX, COMDAT
; _this$ = ecx

; 516  : 		MSG_GTOS_BUY_ITEM_REQ_EX()

  00000	8b c1		 mov	 eax, ecx

; 517  : 		{
; 518  : 			this->size = sizeof(MSG_GTOS_BUY_ITEM_REQ_EX);

  00002	c7 00 30 00 00
	00		 mov	 DWORD PTR [eax], 48	; 00000030H

; 519  : 			this->hdrid.category = 0x900;

  00008	c7 40 04 00 09
	01 00		 mov	 DWORD PTR [eax+4], 67840 ; 00010900H

; 520  : 			this->hdrid.messageID = 1;
; 521  : 		};

  0000f	c3		 ret	 0
??0MSG_GTOS_BUY_ITEM_REQ_EX@protocol@@QAE@XZ ENDP	; protocol::MSG_GTOS_BUY_ITEM_REQ_EX::MSG_GTOS_BUY_ITEM_REQ_EX
_TEXT	ENDS
PUBLIC	??1MSG_GTOS_BUY_ITEM_REQ_EX@protocol@@QAE@XZ	; protocol::MSG_GTOS_BUY_ITEM_REQ_EX::~MSG_GTOS_BUY_ITEM_REQ_EX
; Function compile flags: /Ogtp
;	COMDAT ??1MSG_GTOS_BUY_ITEM_REQ_EX@protocol@@QAE@XZ
_TEXT	SEGMENT
??1MSG_GTOS_BUY_ITEM_REQ_EX@protocol@@QAE@XZ PROC	; protocol::MSG_GTOS_BUY_ITEM_REQ_EX::~MSG_GTOS_BUY_ITEM_REQ_EX, COMDAT
; _this$ = ecx

; 525  : 		};

  00000	c3		 ret	 0
??1MSG_GTOS_BUY_ITEM_REQ_EX@protocol@@QAE@XZ ENDP	; protocol::MSG_GTOS_BUY_ITEM_REQ_EX::~MSG_GTOS_BUY_ITEM_REQ_EX
_TEXT	ENDS
PUBLIC	??0MSG_GTOS_USE_ITEM_NTF_EX@protocol@@QAE@XZ	; protocol::MSG_GTOS_USE_ITEM_NTF_EX::MSG_GTOS_USE_ITEM_NTF_EX
; Function compile flags: /Ogtp
;	COMDAT ??0MSG_GTOS_USE_ITEM_NTF_EX@protocol@@QAE@XZ
_TEXT	SEGMENT
??0MSG_GTOS_USE_ITEM_NTF_EX@protocol@@QAE@XZ PROC	; protocol::MSG_GTOS_USE_ITEM_NTF_EX::MSG_GTOS_USE_ITEM_NTF_EX, COMDAT
; _this$ = ecx

; 555  : 		MSG_GTOS_USE_ITEM_NTF_EX()

  00000	8b c1		 mov	 eax, ecx

; 556  : 		{
; 557  : 			this->size = sizeof(MSG_GTOS_USE_ITEM_NTF_EX);

  00002	c7 00 10 00 00
	00		 mov	 DWORD PTR [eax], 16	; 00000010H

; 558  : 			this->hdrid.category = 0xB00;

  00008	c7 40 04 00 0b
	01 00		 mov	 DWORD PTR [eax+4], 68352 ; 00010b00H

; 559  : 			this->hdrid.messageID = 1;
; 560  : 		};

  0000f	c3		 ret	 0
??0MSG_GTOS_USE_ITEM_NTF_EX@protocol@@QAE@XZ ENDP	; protocol::MSG_GTOS_USE_ITEM_NTF_EX::MSG_GTOS_USE_ITEM_NTF_EX
_TEXT	ENDS
PUBLIC	??1MSG_GTOS_USE_ITEM_NTF_EX@protocol@@QAE@XZ	; protocol::MSG_GTOS_USE_ITEM_NTF_EX::~MSG_GTOS_USE_ITEM_NTF_EX
; Function compile flags: /Ogtp
;	COMDAT ??1MSG_GTOS_USE_ITEM_NTF_EX@protocol@@QAE@XZ
_TEXT	SEGMENT
??1MSG_GTOS_USE_ITEM_NTF_EX@protocol@@QAE@XZ PROC	; protocol::MSG_GTOS_USE_ITEM_NTF_EX::~MSG_GTOS_USE_ITEM_NTF_EX, COMDAT
; _this$ = ecx

; 565  : 		};

  00000	c3		 ret	 0
??1MSG_GTOS_USE_ITEM_NTF_EX@protocol@@QAE@XZ ENDP	; protocol::MSG_GTOS_USE_ITEM_NTF_EX::~MSG_GTOS_USE_ITEM_NTF_EX
_TEXT	ENDS
PUBLIC	??0MSG_GTOS_GIFT_ITEM_REQ_EX@protocol@@QAE@XZ	; protocol::MSG_GTOS_GIFT_ITEM_REQ_EX::MSG_GTOS_GIFT_ITEM_REQ_EX
; Function compile flags: /Ogtp
;	COMDAT ??0MSG_GTOS_GIFT_ITEM_REQ_EX@protocol@@QAE@XZ
_TEXT	SEGMENT
??0MSG_GTOS_GIFT_ITEM_REQ_EX@protocol@@QAE@XZ PROC	; protocol::MSG_GTOS_GIFT_ITEM_REQ_EX::MSG_GTOS_GIFT_ITEM_REQ_EX, COMDAT
; _this$ = ecx

; 587  : 		MSG_GTOS_GIFT_ITEM_REQ_EX()

  00000	8b c1		 mov	 eax, ecx

; 588  : 		{
; 589  : 			this->size = sizeof(MSG_GTOS_GIFT_ITEM_REQ_EX);

  00002	c7 00 04 01 00
	00		 mov	 DWORD PTR [eax], 260	; 00000104H

; 590  : 			this->hdrid.category = 0xD00;

  00008	c7 40 04 00 0d
	01 00		 mov	 DWORD PTR [eax+4], 68864 ; 00010d00H

; 591  : 			this->hdrid.messageID = 1;
; 592  : 		};

  0000f	c3		 ret	 0
??0MSG_GTOS_GIFT_ITEM_REQ_EX@protocol@@QAE@XZ ENDP	; protocol::MSG_GTOS_GIFT_ITEM_REQ_EX::MSG_GTOS_GIFT_ITEM_REQ_EX
_TEXT	ENDS
PUBLIC	??1MSG_GTOS_GIFT_ITEM_REQ_EX@protocol@@QAE@XZ	; protocol::MSG_GTOS_GIFT_ITEM_REQ_EX::~MSG_GTOS_GIFT_ITEM_REQ_EX
; Function compile flags: /Ogtp
;	COMDAT ??1MSG_GTOS_GIFT_ITEM_REQ_EX@protocol@@QAE@XZ
_TEXT	SEGMENT
??1MSG_GTOS_GIFT_ITEM_REQ_EX@protocol@@QAE@XZ PROC	; protocol::MSG_GTOS_GIFT_ITEM_REQ_EX::~MSG_GTOS_GIFT_ITEM_REQ_EX, COMDAT
; _this$ = ecx

; 596  : 		};

  00000	c3		 ret	 0
??1MSG_GTOS_GIFT_ITEM_REQ_EX@protocol@@QAE@XZ ENDP	; protocol::MSG_GTOS_GIFT_ITEM_REQ_EX::~MSG_GTOS_GIFT_ITEM_REQ_EX
_TEXT	ENDS
PUBLIC	??1OBJECTSTRUCT@@QAE@XZ				; OBJECTSTRUCT::~OBJECTSTRUCT
EXTRN	??1CSkillDelay@@UAE@XZ:PROC			; CSkillDelay::~CSkillDelay
EXTRN	??1TMonsterAIAgro@@UAE@XZ:PROC			; TMonsterAIAgro::~TMonsterAIAgro
EXTRN	___security_cookie:DWORD
EXTRN	___CxxFrameHandler3:PROC
EXTRN	@__security_check_cookie@4:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1OBJECTSTRUCT@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1OBJECTSTRUCT@@QAE@XZ$0
__ehfuncinfo$??1OBJECTSTRUCT@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1OBJECTSTRUCT@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
xdata$x	ENDS
;	COMDAT ??1OBJECTSTRUCT@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1OBJECTSTRUCT@@QAE@XZ PROC				; OBJECTSTRUCT::~OBJECTSTRUCT, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1OBJECTSTRUCT@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b f1		 mov	 esi, ecx
  00026	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  00029	8d 8e ec 20 00
	00		 lea	 ecx, DWORD PTR [esi+8428]
  0002f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00036	e8 00 00 00 00	 call	 ??1TMonsterAIAgro@@UAE@XZ ; TMonsterAIAgro::~TMonsterAIAgro
  0003b	8d 8e 0c 16 00
	00		 lea	 ecx, DWORD PTR [esi+5644]
  00041	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00048	e8 00 00 00 00	 call	 ??1CSkillDelay@@UAE@XZ	; CSkillDelay::~CSkillDelay
  0004d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00050	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00057	59		 pop	 ecx
  00058	5e		 pop	 esi
  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1OBJECTSTRUCT@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	81 c1 0c 16 00
	00		 add	 ecx, 5644		; 0000160cH
  00009	e9 00 00 00 00	 jmp	 ??1CSkillDelay@@UAE@XZ	; CSkillDelay::~CSkillDelay
__ehhandler$??1OBJECTSTRUCT@@QAE@XZ:
  0000e	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00012	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00015	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00018	33 c8		 xor	 ecx, eax
  0001a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001f	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1OBJECTSTRUCT@@QAE@XZ
  00024	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1OBJECTSTRUCT@@QAE@XZ ENDP				; OBJECTSTRUCT::~OBJECTSTRUCT
EXTRN	__time64:PROC
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\time.inl
;	COMDAT _time
_TEXT	SEGMENT
_time	PROC						; COMDAT
; __Time$ = eax

; 133  :     return _time64(_Time);

  00000	50		 push	 eax
  00001	e8 00 00 00 00	 call	 __time64
  00006	83 c4 04	 add	 esp, 4

; 134  : }

  00009	c3		 ret	 0
_time	ENDP
_TEXT	ENDS
PUBLIC	?Initialize@CCashShop@@QAEXXZ			; CCashShop::Initialize
; Function compile flags: /Ogtp
; File c:\muserver_dev\development\mu-s8ep2-repack\gameserver\source\cashshop.cpp
;	COMDAT ?Initialize@CCashShop@@QAEXXZ
_TEXT	SEGMENT
?Initialize@CCashShop@@QAEXXZ PROC			; CCashShop::Initialize, COMDAT
; _this$ = ecx

; 62   : 	this->bCashItemListReload = FALSE;

  00000	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 63   : 	//this->MapUserObject.clear();
; 64   : }

  00007	c3		 ret	 0
?Initialize@CCashShop@@QAEXXZ ENDP			; CCashShop::Initialize
_TEXT	ENDS
PUBLIC	??_C@_0CI@EGPLJBH@?$FLShopServer?$FN?5?9?5Connect?5To?5Shop?5S@ ; `string'
PUBLIC	??_C@_0CN@INENFGAA@?$FLShopServer?$FN?5?9?5Disconnect?5From?5S@ ; `string'
PUBLIC	?ParentWndProc@CCashShop@@SAJPAUHWND__@@IIJ@Z	; CCashShop::ParentWndProc
EXTRN	?DataRecv@wsShopServerCli@@QAEHXZ:PROC		; wsShopServerCli::DataRecv
EXTRN	?LogAddTD@@3P6AXPADZZA:DWORD			; LogAddTD
EXTRN	?LogAddC@@3P6AXEPADZZA:DWORD			; LogAddC
EXTRN	?Close@MyWinsockBase@@QAEHXZ:PROC		; MyWinsockBase::Close
EXTRN	__imp__CallWindowProcA@20:PROC
;	COMDAT ??_C@_0CI@EGPLJBH@?$FLShopServer?$FN?5?9?5Connect?5To?5Shop?5S@
CONST	SEGMENT
??_C@_0CI@EGPLJBH@?$FLShopServer?$FN?5?9?5Connect?5To?5Shop?5S@ DB '[Shop'
	DB	'Server] - Connect To Shop Server!!', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@INENFGAA@?$FLShopServer?$FN?5?9?5Disconnect?5From?5S@
CONST	SEGMENT
??_C@_0CN@INENFGAA@?$FLShopServer?$FN?5?9?5Disconnect?5From?5S@ DB '[Shop'
	DB	'Server] - Disconnect From Shop Server!!', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?ParentWndProc@CCashShop@@SAJPAUHWND__@@IIJ@Z
_TEXT	SEGMENT
_hWnd$ = 8						; size = 4
_iMessage$ = 12						; size = 4
_wParam$ = 16						; size = 4
_lParam$ = 20						; size = 4
?ParentWndProc@CCashShop@@SAJPAUHWND__@@IIJ@Z PROC	; CCashShop::ParentWndProc, COMDAT

; 161  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 162  : 	switch( iMessage )

  00003	8b 45 0c	 mov	 eax, DWORD PTR _iMessage$[ebp]
  00006	3d 1e 04 00 00	 cmp	 eax, 1054		; 0000041eH
  0000b	74 1c		 je	 SHORT $LN7@ParentWndP

; 184  : 
; 185  : 		default:
; 186  : 			return CallWindowProc(CCashShop::m_lpOldProc, hWnd, iMessage, wParam, lParam);

  0000d	8b 4d 14	 mov	 ecx, DWORD PTR _lParam$[ebp]
  00010	8b 55 10	 mov	 edx, DWORD PTR _wParam$[ebp]
  00013	51		 push	 ecx
  00014	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?m_lpOldProc@CCashShop@@2P6GJPAUHWND__@@IIJ@ZA ; CCashShop::m_lpOldProc
  0001a	52		 push	 edx
  0001b	50		 push	 eax
  0001c	8b 45 08	 mov	 eax, DWORD PTR _hWnd$[ebp]
  0001f	50		 push	 eax
  00020	51		 push	 ecx
  00021	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CallWindowProcA@20

; 187  : 	}
; 188  : }

  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
$LN7@ParentWndP:

; 163  : 	{
; 164  : 		case 0x41E:
; 165  : 			switch ( lParam & 0xFFFF & 0xFFFF )

  00029	8b 45 14	 mov	 eax, DWORD PTR _lParam$[ebp]
  0002c	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00031	48		 dec	 eax
  00032	74 4e		 je	 SHORT $LN4@ParentWndP
  00034	83 e8 0f	 sub	 eax, 15			; 0000000fH
  00037	74 2d		 je	 SHORT $LN3@ParentWndP
  00039	83 e8 10	 sub	 eax, 16			; 00000010H

; 180  : 					return 0;
; 181  : 
; 182  : 			}
; 183  : 			return 0;

  0003c	75 4e		 jne	 SHORT $LN12@ParentWndP

; 174  : 					return 0;
; 175  : 
; 176  : 				case 32:
; 177  : 					g_ShopServerClient.Close();

  0003e	b9 04 00 00 00	 mov	 ecx, OFFSET ?g_ShopServerClient@@3VwsShopServerCli@@A+4
  00043	e8 00 00 00 00	 call	 ?Close@MyWinsockBase@@QAEHXZ ; MyWinsockBase::Close

; 178  : 					LogAddC(2, "[ShopServer] - Disconnect From Shop Server!!");

  00048	68 00 00 00 00	 push	 OFFSET ??_C@_0CN@INENFGAA@?$FLShopServer?$FN?5?9?5Disconnect?5From?5S@
  0004d	6a 02		 push	 2
  0004f	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  00055	83 c4 08	 add	 esp, 8

; 179  : 					g_bShopServerConnectState = FALSE;

  00058	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?g_bShopServerConnectState@@3HA, 0 ; g_bShopServerConnectState
  00062	33 c0		 xor	 eax, eax

; 187  : 	}
; 188  : }

  00064	5d		 pop	 ebp
  00065	c3		 ret	 0
$LN3@ParentWndP:

; 170  : 
; 171  : 				case 16:
; 172  : 					LogAddTD("[ShopServer] - Connect To Shop Server!!");

  00066	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@EGPLJBH@?$FLShopServer?$FN?5?9?5Connect?5To?5Shop?5S@
  0006b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00071	83 c4 04	 add	 esp, 4

; 173  : 					g_bShopServerConnectState = TRUE;

  00074	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?g_bShopServerConnectState@@3HA, 1 ; g_bShopServerConnectState
  0007e	33 c0		 xor	 eax, eax

; 187  : 	}
; 188  : }

  00080	5d		 pop	 ebp
  00081	c3		 ret	 0
$LN4@ParentWndP:

; 166  : 			{
; 167  : 				case 1:
; 168  : 					g_ShopServerClient.DataRecv();

  00082	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ShopServerClient@@3VwsShopServerCli@@A ; g_ShopServerClient
  00087	e8 00 00 00 00	 call	 ?DataRecv@wsShopServerCli@@QAEHXZ ; wsShopServerCli::DataRecv
$LN12@ParentWndP:

; 169  : 					return 0;

  0008c	33 c0		 xor	 eax, eax

; 187  : 	}
; 188  : }

  0008e	5d		 pop	 ebp
  0008f	c3		 ret	 0
?ParentWndProc@CCashShop@@SAJPAUHWND__@@IIJ@Z ENDP	; CCashShop::ParentWndProc
_TEXT	ENDS
PUBLIC	?CGCashShopOpen@CCashShop@@QAEHPAUOBJECTSTRUCT@@PAUPMSG_REQ_CASHSHOPOPEN@@@Z ; CCashShop::CGCashShopOpen
EXTRN	?DataSend@@YAHHPAEK@Z:PROC			; DataSend
EXTRN	?PHeadSubSetB@@YAXPAEEEH@Z:PROC			; PHeadSubSetB
EXTRN	?Get@Message@@QAEPADH@Z:PROC			; Message::Get
EXTRN	?lMsg@@3VMessage@@A:BYTE			; lMsg
EXTRN	?gObjIsAccontConnect@@YAHHPAD@Z:PROC		; gObjIsAccontConnect
; Function compile flags: /Ogtp
;	COMDAT ?CGCashShopOpen@CCashShop@@QAEHPAUOBJECTSTRUCT@@PAUPMSG_REQ_CASHSHOPOPEN@@@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 5
_lpObj$ = 8						; size = 4
_lpMsg$ = 12						; size = 4
?CGCashShopOpen@CCashShop@@QAEHPAUOBJECTSTRUCT@@PAUPMSG_REQ_CASHSHOPOPEN@@@Z PROC ; CCashShop::CGCashShopOpen, COMDAT
; _this$ = ecx

; 262  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx

; 263  : 	BYTE btResult = TRUE;
; 264  : 
; 265  : 	if ( bCashItemListReload == TRUE )

  00007	b8 01 00 00 00	 mov	 eax, 1
  0000c	56		 push	 esi
  0000d	57		 push	 edi
  0000e	b3 01		 mov	 bl, 1
  00010	39 41 04	 cmp	 DWORD PTR [ecx+4], eax
  00013	75 02		 jne	 SHORT $LN10@CGCashShop

; 266  : 	{
; 267  : 		btResult = FALSE;

  00015	32 db		 xor	 bl, bl
$LN10@CGCashShop:

; 268  : 	}
; 269  : 
; 270  : 	if ( g_bConnectShopServer == TRUE && g_bShopServerConnectState == FALSE )

  00017	39 05 00 00 00
	00		 cmp	 DWORD PTR ?g_bConnectShopServer@@3HA, eax ; g_bConnectShopServer
  0001d	75 0b		 jne	 SHORT $LN9@CGCashShop
  0001f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_bShopServerConnectState@@3HA, 0 ; g_bShopServerConnectState
  00026	75 02		 jne	 SHORT $LN9@CGCashShop

; 271  : 	{
; 272  : 		btResult = FALSE;

  00028	32 db		 xor	 bl, bl
$LN9@CGCashShop:

; 273  : 	}
; 274  : 
; 275  : 	if ( !gObjIsAccontConnect(lpObj->m_Index, lpObj->AccountID))

  0002a	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]
  0002d	8b 06		 mov	 eax, DWORD PTR [esi]
  0002f	8d 7e 52	 lea	 edi, DWORD PTR [esi+82]
  00032	57		 push	 edi
  00033	50		 push	 eax
  00034	e8 00 00 00 00	 call	 ?gObjIsAccontConnect@@YAHHPAD@Z ; gObjIsAccontConnect
  00039	83 c4 08	 add	 esp, 8
  0003c	85 c0		 test	 eax, eax
  0003e	75 2a		 jne	 SHORT $LN8@CGCashShop

; 276  : 	{
; 277  : 		LogAddC(2, lMsg.Get(MSGGET(1, 175)), lpObj->AccountID, lpObj->m_Index);

  00040	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00042	51		 push	 ecx
  00043	57		 push	 edi
  00044	68 af 01 00 00	 push	 431			; 000001afH
  00049	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  0004e	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  00053	50		 push	 eax
  00054	6a 02		 push	 2
  00056	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  0005c	83 c4 10	 add	 esp, 16			; 00000010H
$LN6@CGCashShop:

; 282  : 		return FALSE;

  0005f	5f		 pop	 edi
  00060	5e		 pop	 esi
  00061	33 c0		 xor	 eax, eax
  00063	5b		 pop	 ebx

; 315  : }

  00064	8b e5		 mov	 esp, ebp
  00066	5d		 pop	 ebp
  00067	c2 08 00	 ret	 8
$LN8@CGCashShop:

; 278  : 		return FALSE;
; 279  : 	}
; 280  : 
; 281  : 	if ( lpObj->Connected <= PLAYER_LOGGED || lpObj->CloseCount != -1 )

  0006a	83 7e 04 02	 cmp	 DWORD PTR [esi+4], 2
  0006e	7e ef		 jle	 SHORT $LN6@CGCashShop
  00070	80 7e 0c ff	 cmp	 BYTE PTR [esi+12], -1
  00074	75 e9		 jne	 SHORT $LN6@CGCashShop

; 283  : 
; 284  : 	if ( lpMsg->btShopOpenType == 0 )

  00076	8b 55 0c	 mov	 edx, DWORD PTR _lpMsg$[ebp]
  00079	8a 42 04	 mov	 al, BYTE PTR [edx+4]
  0007c	84 c0		 test	 al, al
  0007e	75 21		 jne	 SHORT $LN5@CGCashShop

; 285  : 	{
; 286  : 		if ( lpObj->m_IfState.use > 0 )

  00080	8b 86 b8 11 00
	00		 mov	 eax, DWORD PTR [esi+4536]
  00086	a8 03		 test	 al, 3

; 287  : 		{
; 288  : 			btResult = FALSE;
; 289  : 		}
; 290  : 
; 291  : 		if ( btResult == TRUE )

  00088	77 25		 ja	 SHORT $LN13@CGCashShop
  0008a	80 fb 01	 cmp	 bl, 1
  0008d	75 22		 jne	 SHORT $LN1@CGCashShop

; 292  : 		{
; 293  : 			lpObj->m_IfState.use = 1;
; 294  : 			lpObj->m_IfState.type = 18;
; 295  : 			lpObj->m_IfState.state = 1;

  0008f	25 85 04 ff ff	 and	 eax, -64379		; ffff0485H
  00094	0d 85 04 00 00	 or	 eax, 1157		; 00000485H
  00099	89 86 b8 11 00
	00		 mov	 DWORD PTR [esi+4536], eax

; 296  : 		}
; 297  : 	}

  0009f	eb 10		 jmp	 SHORT $LN1@CGCashShop
$LN5@CGCashShop:

; 298  : 	else if ( lpMsg->btShopOpenType == TRUE )

  000a1	3c 01		 cmp	 al, 1
  000a3	75 0c		 jne	 SHORT $LN1@CGCashShop

; 299  : 	{
; 300  : 		lpObj->m_IfState.use = 0;
; 301  : 		lpObj->m_IfState.type = 0;
; 302  : 		lpObj->m_IfState.state = 0;

  000a5	81 a6 b8 11 00
	00 00 00 ff ff	 and	 DWORD PTR [esi+4536], -65536 ; ffff0000H
$LN13@CGCashShop:

; 303  : 
; 304  : 		btResult = FALSE;

  000af	32 db		 xor	 bl, bl
$LN1@CGCashShop:

; 305  : 	}
; 306  : 
; 307  : 	PMSG_ANS_CASHSHOPOPEN pMsg;
; 308  : 
; 309  : 	pMsg.btResult = btResult;
; 310  : 
; 311  : 	PHeadSubSetB((LPBYTE)&pMsg, 0xD2, 0x02, sizeof(PMSG_ANS_CASHSHOPOPEN));

  000b1	6a 05		 push	 5
  000b3	6a 02		 push	 2
  000b5	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  000b8	68 d2 00 00 00	 push	 210			; 000000d2H
  000bd	50		 push	 eax
  000be	88 5d fc	 mov	 BYTE PTR _pMsg$[ebp+4], bl
  000c1	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 312  : 
; 313  : 	DataSend(lpObj->m_Index, (LPBYTE)&pMsg, pMsg.h.size);

  000c6	0f b6 4d f9	 movzx	 ecx, BYTE PTR _pMsg$[ebp+1]
  000ca	8b 06		 mov	 eax, DWORD PTR [esi]
  000cc	51		 push	 ecx
  000cd	8d 55 f8	 lea	 edx, DWORD PTR _pMsg$[ebp]
  000d0	52		 push	 edx
  000d1	50		 push	 eax
  000d2	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  000d7	83 c4 1c	 add	 esp, 28			; 0000001cH
  000da	5f		 pop	 edi
  000db	5e		 pop	 esi

; 314  : return TRUE;

  000dc	b8 01 00 00 00	 mov	 eax, 1
  000e1	5b		 pop	 ebx

; 315  : }

  000e2	8b e5		 mov	 esp, ebp
  000e4	5d		 pop	 ebp
  000e5	c2 08 00	 ret	 8
?CGCashShopOpen@CCashShop@@QAEHPAUOBJECTSTRUCT@@PAUPMSG_REQ_CASHSHOPOPEN@@@Z ENDP ; CCashShop::CGCashShopOpen
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GCCashPoint@CCashShop@@QAEXPAUOBJECTSTRUCT@@@Z	; CCashShop::GCCashPoint
EXTRN	__fltused:DWORD
; Function compile flags: /Ogtp
;	COMDAT ?GCCashPoint@CCashShop@@QAEXPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_pMsg$ = -52						; size = 45
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
?GCCashPoint@CCashShop@@QAEXPAUOBJECTSTRUCT@@@Z PROC	; CCashShop::GCCashPoint, COMDAT
; _this$ = ecx

; 385  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]

; 386  : 	if ( !gObjIsAccontConnect(lpObj->m_Index, lpObj->AccountID))

  00014	8b 06		 mov	 eax, DWORD PTR [esi]
  00016	57		 push	 edi
  00017	8d 7e 52	 lea	 edi, DWORD PTR [esi+82]
  0001a	57		 push	 edi
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 ?gObjIsAccontConnect@@YAHHPAD@Z ; gObjIsAccontConnect
  00021	83 c4 08	 add	 esp, 8
  00024	85 c0		 test	 eax, eax
  00026	75 31		 jne	 SHORT $LN1@GCCashPoin

; 387  : 	{
; 388  : 		LogAddC(2, lMsg.Get(MSGGET(1, 175)), lpObj->AccountID, lpObj->m_Index);

  00028	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0002a	51		 push	 ecx
  0002b	57		 push	 edi
  0002c	68 af 01 00 00	 push	 431			; 000001afH
  00031	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  00036	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  0003b	50		 push	 eax
  0003c	6a 02		 push	 2
  0003e	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  00044	83 c4 10	 add	 esp, 16			; 00000010H
  00047	5f		 pop	 edi
  00048	5e		 pop	 esi

; 401  : }

  00049	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0004c	33 cd		 xor	 ecx, ebp
  0004e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c2 04 00	 ret	 4
$LN1@GCCashPoin:

; 389  : 		return;
; 390  : 	}
; 391  : 
; 392  : 	PMSG_ANS_CASHPOINT pMsg;
; 393  : 
; 394  : 	PHeadSubSetB((LPBYTE)&pMsg, 0xD2, 0x01, sizeof(PMSG_ANS_CASHPOINT));

  00059	6a 2d		 push	 45			; 0000002dH
  0005b	6a 01		 push	 1
  0005d	8d 55 cc	 lea	 edx, DWORD PTR _pMsg$[ebp]
  00060	68 d2 00 00 00	 push	 210			; 000000d2H
  00065	52		 push	 edx
  00066	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 395  : 
; 396  : 	pMsg.wCoin = lpObj->m_wcCashPoint;

  0006b	db 86 68 24 00
	00		 fild	 DWORD PTR [esi+9320]

; 397  : 	pMsg.pCoin = lpObj->m_wpCashPoint;
; 398  : 	pMsg.gCoin = lpObj->m_wgCashPoint;
; 399  : 
; 400  : 	DataSend(lpObj->m_Index, (LPBYTE)&pMsg, pMsg.h.size);

  00071	0f b6 45 cd	 movzx	 eax, BYTE PTR _pMsg$[ebp+1]
  00075	8b 16		 mov	 edx, DWORD PTR [esi]
  00077	dd 5d d9	 fstp	 QWORD PTR _pMsg$[ebp+13]
  0007a	50		 push	 eax
  0007b	db 86 6c 24 00
	00		 fild	 DWORD PTR [esi+9324]
  00081	8d 4d cc	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00084	51		 push	 ecx
  00085	52		 push	 edx
  00086	dd 5d e1	 fstp	 QWORD PTR _pMsg$[ebp+21]
  00089	db 86 70 24 00
	00		 fild	 DWORD PTR [esi+9328]
  0008f	dd 5d f1	 fstp	 QWORD PTR _pMsg$[ebp+37]
  00092	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 401  : }

  00097	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0009a	83 c4 1c	 add	 esp, 28			; 0000001cH
  0009d	5f		 pop	 edi
  0009e	33 cd		 xor	 ecx, ebp
  000a0	5e		 pop	 esi
  000a1	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000a6	8b e5		 mov	 esp, ebp
  000a8	5d		 pop	 ebp
  000a9	c2 04 00	 ret	 4
?GCCashPoint@CCashShop@@QAEXPAUOBJECTSTRUCT@@@Z ENDP	; CCashShop::GCCashPoint
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GCScriptVersionSend@CCashShop@@QAEXH@Z		; CCashShop::GCScriptVersionSend
; Function compile flags: /Ogtp
;	COMDAT ?GCScriptVersionSend@CCashShop@@QAEXH@Z
_TEXT	SEGMENT
_pMsg$ = -16						; size = 10
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
?GCScriptVersionSend@CCashShop@@QAEXH@Z PROC		; CCashShop::GCScriptVersionSend, COMDAT
; _this$ = ecx

; 453  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi

; 454  : 	PMSG_CASHSHOP_VERSION pMsg;
; 455  : 	PHeadSubSetB((LPBYTE)&pMsg,0xD2,0x0C,sizeof(pMsg));

  00011	6a 0a		 push	 10			; 0000000aH
  00013	6a 0c		 push	 12			; 0000000cH
  00015	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00018	68 d2 00 00 00	 push	 210			; 000000d2H
  0001d	50		 push	 eax
  0001e	8b f1		 mov	 esi, ecx
  00020	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 456  : 
; 457  : 	pMsg.ver.Ver1 = m_ScriptVer.Ver1;

  00025	66 8b 4e 08	 mov	 cx, WORD PTR [esi+8]

; 458  : 	pMsg.ver.Ver2 = m_ScriptVer.Ver2;

  00029	66 8b 56 0a	 mov	 dx, WORD PTR [esi+10]

; 459  : 	pMsg.ver.Ver3 = m_ScriptVer.Ver3;

  0002d	66 8b 46 0c	 mov	 ax, WORD PTR [esi+12]
  00031	66 89 4d f4	 mov	 WORD PTR _pMsg$[ebp+4], cx

; 460  : 
; 461  : 	DataSend(aIndex,(LPBYTE)&pMsg,pMsg.h.size);

  00035	0f b6 4d f1	 movzx	 ecx, BYTE PTR _pMsg$[ebp+1]
  00039	66 89 55 f6	 mov	 WORD PTR _pMsg$[ebp+6], dx
  0003d	51		 push	 ecx
  0003e	8d 55 f0	 lea	 edx, DWORD PTR _pMsg$[ebp]
  00041	66 89 45 f8	 mov	 WORD PTR _pMsg$[ebp+8], ax
  00045	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00048	52		 push	 edx
  00049	50		 push	 eax
  0004a	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 462  : }

  0004f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00052	83 c4 1c	 add	 esp, 28			; 0000001cH
  00055	33 cd		 xor	 ecx, ebp
  00057	5e		 pop	 esi
  00058	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0005d	8b e5		 mov	 esp, ebp
  0005f	5d		 pop	 ebp
  00060	c2 04 00	 ret	 4
?GCScriptVersionSend@CCashShop@@QAEXH@Z ENDP		; CCashShop::GCScriptVersionSend
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GCBannerVersionSend@CCashShop@@QAEXH@Z		; CCashShop::GCBannerVersionSend
; Function compile flags: /Ogtp
;	COMDAT ?GCBannerVersionSend@CCashShop@@QAEXH@Z
_TEXT	SEGMENT
_pMsg$ = -16						; size = 10
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
?GCBannerVersionSend@CCashShop@@QAEXH@Z PROC		; CCashShop::GCBannerVersionSend, COMDAT
; _this$ = ecx

; 466  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi

; 467  : 	PMSG_CASHSHOP_VERSION pMsg;
; 468  : 	PHeadSubSetB((LPBYTE)&pMsg,0xD2,0x15,sizeof(pMsg));

  00011	6a 0a		 push	 10			; 0000000aH
  00013	6a 15		 push	 21			; 00000015H
  00015	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00018	68 d2 00 00 00	 push	 210			; 000000d2H
  0001d	50		 push	 eax
  0001e	8b f1		 mov	 esi, ecx
  00020	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 469  : 
; 470  : 	pMsg.ver.Ver1 = m_BannerVer.Ver1;

  00025	66 8b 4e 0e	 mov	 cx, WORD PTR [esi+14]

; 471  : 	pMsg.ver.Ver2 = m_BannerVer.Ver2;

  00029	66 8b 56 10	 mov	 dx, WORD PTR [esi+16]

; 472  : 	pMsg.ver.Ver3 = m_BannerVer.Ver3;

  0002d	66 8b 46 12	 mov	 ax, WORD PTR [esi+18]
  00031	66 89 4d f4	 mov	 WORD PTR _pMsg$[ebp+4], cx

; 473  : 
; 474  : 	DataSend(aIndex,(LPBYTE)&pMsg,pMsg.h.size);

  00035	0f b6 4d f1	 movzx	 ecx, BYTE PTR _pMsg$[ebp+1]
  00039	66 89 55 f6	 mov	 WORD PTR _pMsg$[ebp+6], dx
  0003d	51		 push	 ecx
  0003e	8d 55 f0	 lea	 edx, DWORD PTR _pMsg$[ebp]
  00041	66 89 45 f8	 mov	 WORD PTR _pMsg$[ebp+8], ax
  00045	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00048	52		 push	 edx
  00049	50		 push	 eax
  0004a	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 475  : }

  0004f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00052	83 c4 1c	 add	 esp, 28			; 0000001cH
  00055	33 cd		 xor	 ecx, ebp
  00057	5e		 pop	 esi
  00058	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0005d	8b e5		 mov	 esp, ebp
  0005f	5d		 pop	 ebp
  00060	c2 04 00	 ret	 4
?GCBannerVersionSend@CCashShop@@QAEXH@Z ENDP		; CCashShop::GCBannerVersionSend
_TEXT	ENDS
PUBLIC	_lpObj$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?GCAnsStorageInfo@CCashShop@@QAEXPAUOBJECTSTRUCT@@PAVMSG_STOG_ITEM_LIST_ANS_EX@protocol@@@Z ; CCashShop::GCAnsStorageInfo
EXTRN	?gObjIsConnected@@YAHH@Z:PROC			; gObjIsConnected
; Function compile flags: /Ogtp
;	COMDAT ?GCAnsStorageInfo@CCashShop@@QAEXPAUOBJECTSTRUCT@@PAVMSG_STOG_ITEM_LIST_ANS_EX@protocol@@@Z
_TEXT	SEGMENT
_lpObj$GSCopy$ = -56					; size = 4
_pItem$ = -52						; size = 33
_pMsg$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
_lpMsg$ = 12						; size = 4
?GCAnsStorageInfo@CCashShop@@QAEXPAUOBJECTSTRUCT@@PAVMSG_STOG_ITEM_LIST_ANS_EX@protocol@@@Z PROC ; CCashShop::GCAnsStorageInfo, COMDAT
; _this$ = ecx

; 478  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 38	 sub	 esp, 56			; 00000038H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	8b 5d 0c	 mov	 ebx, DWORD PTR _lpMsg$[ebp]
  00014	56		 push	 esi
  00015	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]

; 479  : 	if( !gObjIsConnected(lpObj->m_Index) )

  00018	8b 06		 mov	 eax, DWORD PTR [esi]
  0001a	50		 push	 eax

; 499  : 	{
; 500  : 		pItem.itemGuid = lpMsg->itemList[i].dwGuid;

  0001b	89 75 c8	 mov	 DWORD PTR _lpObj$GSCopy$[ebp], esi
  0001e	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00023	83 c4 04	 add	 esp, 4
  00026	85 c0		 test	 eax, eax
  00028	0f 84 ac 00 00
	00		 je	 $LN1@GCAnsStora

; 480  : 		return;
; 481  : 
; 482  : 	if( lpObj->Type != OBJ_USER )

  0002e	80 7e 50 01	 cmp	 BYTE PTR [esi+80], 1
  00032	0f 85 a2 00 00
	00		 jne	 $LN1@GCAnsStora

; 483  : 		return;
; 484  : 
; 485  : 	PMSG_CASHSHOP_ANSINFO pMsg;
; 486  : 	PHeadSubSetB((LPBYTE)&pMsg,0xD2,0x06,sizeof(pMsg));

  00038	57		 push	 edi
  00039	6a 0c		 push	 12			; 0000000cH
  0003b	6a 06		 push	 6
  0003d	8d 4d f0	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00040	68 d2 00 00 00	 push	 210			; 000000d2H
  00045	51		 push	 ecx
  00046	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 487  : 
; 488  : 	pMsg.Info1 = 1;
; 489  : 	pMsg.Info2 = 1;
; 490  : 	pMsg.Info3 = (WORD)lpMsg->dwPageId;

  0004b	0f b7 43 0c	 movzx	 eax, WORD PTR [ebx+12]

; 491  : 	pMsg.Info4 = (WORD)lpMsg->dwPageId;
; 492  : 
; 493  : 	DataSend(lpObj->m_Index,(LPBYTE)&pMsg,pMsg.h.size);

  0004f	0f b6 4d f1	 movzx	 ecx, BYTE PTR _pMsg$[ebp+1]
  00053	51		 push	 ecx
  00054	8d 55 f0	 lea	 edx, DWORD PTR _pMsg$[ebp]
  00057	66 89 45 f8	 mov	 WORD PTR _pMsg$[ebp+8], ax
  0005b	66 89 45 fa	 mov	 WORD PTR _pMsg$[ebp+10], ax
  0005f	8b 06		 mov	 eax, DWORD PTR [esi]
  00061	52		 push	 edx
  00062	50		 push	 eax
  00063	c7 45 f4 01 00
	01 00		 mov	 DWORD PTR _pMsg$[ebp+4], 65537 ; 00010001H
  0006a	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 494  : 
; 495  : 	PMSG_ANS_STORAGEINFO pItem;
; 496  : 	PHeadSubSetB((LPBYTE)&pItem,0xD2,0x0D,sizeof(pItem));

  0006f	6a 21		 push	 33			; 00000021H
  00071	6a 0d		 push	 13			; 0000000dH
  00073	8d 4d cc	 lea	 ecx, DWORD PTR _pItem$[ebp]
  00076	68 d2 00 00 00	 push	 210			; 000000d2H
  0007b	51		 push	 ecx
  0007c	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 497  : 
; 498  : 	for(DWORD i = 0; i < lpMsg->dwItemCount; i++)

  00081	33 ff		 xor	 edi, edi
  00083	83 c4 2c	 add	 esp, 44			; 0000002cH
  00086	39 7b 14	 cmp	 DWORD PTR [ebx+20], edi
  00089	76 4e		 jbe	 SHORT $LN10@GCAnsStora

; 483  : 		return;
; 484  : 
; 485  : 	PMSG_CASHSHOP_ANSINFO pMsg;
; 486  : 	PHeadSubSetB((LPBYTE)&pMsg,0xD2,0x06,sizeof(pMsg));

  0008b	8d 73 1c	 lea	 esi, DWORD PTR [ebx+28]
  0008e	8b ff		 npad	 2
$LL3@GCAnsStora:

; 499  : 	{
; 500  : 		pItem.itemGuid = lpMsg->itemList[i].dwGuid;

  00090	8b 56 fc	 mov	 edx, DWORD PTR [esi-4]

; 501  : 		pItem.unk1 = lpMsg->itemList[i].dwUnk1;
; 502  : 		pItem.unk2_type = lpMsg->itemList[i].dwUnk2;
; 503  : 		pItem.groupId = lpMsg->itemList[i].dwGroupIndex;
; 504  : 		pItem.itemId = lpMsg->itemList[i].dwProductIndex;
; 505  : 		pItem.value = lpMsg->itemList[i].Durability;

  00093	dd 46 14	 fld	 QWORD PTR [esi+20]
  00096	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00099	dd 5d e4	 fstp	 QWORD PTR _pItem$[ebp+24]
  0009c	8b 06		 mov	 eax, DWORD PTR [esi]
  0009e	89 55 d0	 mov	 DWORD PTR _pItem$[ebp+4], edx
  000a1	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  000a4	89 55 dc	 mov	 DWORD PTR _pItem$[ebp+16], edx

; 506  : 		pItem.type = (BYTE)lpMsg->itemList[i].dwType;
; 507  : 
; 508  : 		DataSend(lpObj->m_Index,(LPBYTE)&pItem,pItem.h.size);

  000a7	0f b6 55 cd	 movzx	 edx, BYTE PTR _pItem$[ebp+1]
  000ab	89 45 d4	 mov	 DWORD PTR _pItem$[ebp+8], eax
  000ae	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  000b1	89 4d d8	 mov	 DWORD PTR _pItem$[ebp+12], ecx
  000b4	8a 4e 1c	 mov	 cl, BYTE PTR [esi+28]
  000b7	52		 push	 edx
  000b8	89 45 e0	 mov	 DWORD PTR _pItem$[ebp+20], eax
  000bb	88 4d ec	 mov	 BYTE PTR _pItem$[ebp+32], cl
  000be	8b 4d c8	 mov	 ecx, DWORD PTR _lpObj$GSCopy$[ebp]
  000c1	8b 11		 mov	 edx, DWORD PTR [ecx]
  000c3	8d 45 cc	 lea	 eax, DWORD PTR _pItem$[ebp]
  000c6	50		 push	 eax
  000c7	52		 push	 edx
  000c8	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  000cd	47		 inc	 edi
  000ce	83 c4 0c	 add	 esp, 12			; 0000000cH
  000d1	83 c6 28	 add	 esi, 40			; 00000028H
  000d4	3b 7b 14	 cmp	 edi, DWORD PTR [ebx+20]
  000d7	72 b7		 jb	 SHORT $LL3@GCAnsStora
$LN10@GCAnsStora:
  000d9	5f		 pop	 edi
$LN1@GCAnsStora:

; 509  : 	}
; 510  : }

  000da	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000dd	5e		 pop	 esi
  000de	33 cd		 xor	 ecx, ebp
  000e0	5b		 pop	 ebx
  000e1	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e6	8b e5		 mov	 esp, ebp
  000e8	5d		 pop	 ebp
  000e9	c2 08 00	 ret	 8
?GCAnsStorageInfo@CCashShop@@QAEXPAUOBJECTSTRUCT@@PAVMSG_STOG_ITEM_LIST_ANS_EX@protocol@@@Z ENDP ; CCashShop::GCAnsStorageInfo
_TEXT	ENDS
PUBLIC	_lpObj$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?GCAnsGiftInfo@CCashShop@@QAEXPAUOBJECTSTRUCT@@PAVMSG_STOG_GIFT_LIST_ANS_EX@protocol@@@Z ; CCashShop::GCAnsGiftInfo
; Function compile flags: /Ogtp
;	COMDAT ?GCAnsGiftInfo@CCashShop@@QAEXPAUOBJECTSTRUCT@@PAVMSG_STOG_GIFT_LIST_ANS_EX@protocol@@@Z
_TEXT	SEGMENT
_lpObj$GSCopy$ = -268					; size = 4
_i$185790 = -264					; size = 4
_pItem$ = -260						; size = 244
_pMsg$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
_lpMsg$ = 12						; size = 4
?GCAnsGiftInfo@CCashShop@@QAEXPAUOBJECTSTRUCT@@PAVMSG_STOG_GIFT_LIST_ANS_EX@protocol@@@Z PROC ; CCashShop::GCAnsGiftInfo, COMDAT
; _this$ = ecx

; 513  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 0c 01 00
	00		 sub	 esp, 268		; 0000010cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	8b 5d 0c	 mov	 ebx, DWORD PTR _lpMsg$[ebp]
  00017	56		 push	 esi
  00018	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]

; 514  : 	if( !gObjIsConnected(lpObj->m_Index) )

  0001b	8b 06		 mov	 eax, DWORD PTR [esi]
  0001d	50		 push	 eax

; 545  : 
; 546  : 		DataSend(lpObj->m_Index,(LPBYTE)&pItem,pItem.h.size);

  0001e	89 b5 f4 fe ff
	ff		 mov	 DWORD PTR _lpObj$GSCopy$[ebp], esi
  00024	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00029	83 c4 04	 add	 esp, 4
  0002c	85 c0		 test	 eax, eax
  0002e	0f 84 1e 01 00
	00		 je	 $LN1@GCAnsGiftI

; 515  : 		return;
; 516  : 
; 517  : 	if( lpObj->Type != OBJ_USER )

  00034	80 7e 50 01	 cmp	 BYTE PTR [esi+80], 1
  00038	0f 85 14 01 00
	00		 jne	 $LN1@GCAnsGiftI

; 518  : 		return;
; 519  : 
; 520  : 	PMSG_CASHSHOP_ANSINFO pMsg;
; 521  : 	PHeadSubSetB((LPBYTE)&pMsg,0xD2,0x06,sizeof(pMsg));

  0003e	6a 0c		 push	 12			; 0000000cH
  00040	6a 06		 push	 6
  00042	8d 4d f0	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00045	68 d2 00 00 00	 push	 210			; 000000d2H
  0004a	51		 push	 ecx
  0004b	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 522  : 
; 523  : 	pMsg.Info1 = (WORD)lpMsg->dwItemCount;

  00050	0f b7 43 14	 movzx	 eax, WORD PTR [ebx+20]

; 524  : 	pMsg.Info2 = (WORD)lpMsg->dwItemCount;
; 525  : 	pMsg.Info3 = (WORD)lpMsg->dwPageId;
; 526  : 	pMsg.Info4 = (WORD)lpMsg->dwPageId;
; 527  : 
; 528  : 	DataSend(lpObj->m_Index,(LPBYTE)&pMsg,pMsg.h.size);

  00054	0f b6 55 f1	 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  00058	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0005a	66 89 45 f4	 mov	 WORD PTR _pMsg$[ebp+4], ax
  0005e	66 89 45 f6	 mov	 WORD PTR _pMsg$[ebp+6], ax
  00062	0f b7 43 0c	 movzx	 eax, WORD PTR [ebx+12]
  00066	66 89 45 f8	 mov	 WORD PTR _pMsg$[ebp+8], ax
  0006a	66 89 45 fa	 mov	 WORD PTR _pMsg$[ebp+10], ax
  0006e	52		 push	 edx
  0006f	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00072	50		 push	 eax
  00073	51		 push	 ecx
  00074	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 529  : 
; 530  : 	PMSG_ANS_GIFTINFO pItem;
; 531  : 	PHeadSubSetB((LPBYTE)&pItem,0xD2,0x0E,sizeof(pItem));

  00079	68 f4 00 00 00	 push	 244			; 000000f4H
  0007e	6a 0e		 push	 14			; 0000000eH
  00080	8d 95 fc fe ff
	ff		 lea	 edx, DWORD PTR _pItem$[ebp]
  00086	68 d2 00 00 00	 push	 210			; 000000d2H
  0008b	52		 push	 edx
  0008c	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB
  00091	83 c4 2c	 add	 esp, 44			; 0000002cH

; 532  : 
; 533  : 	for(DWORD i = 0; i < lpMsg->dwItemCount; i++)

  00094	83 7b 14 00	 cmp	 DWORD PTR [ebx+20], 0
  00098	c7 85 f8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$185790[ebp], 0
  000a2	0f 86 aa 00 00
	00		 jbe	 $LN1@GCAnsGiftI

; 518  : 		return;
; 519  : 
; 520  : 	PMSG_CASHSHOP_ANSINFO pMsg;
; 521  : 	PHeadSubSetB((LPBYTE)&pMsg,0xD2,0x06,sizeof(pMsg));

  000a8	8d b5 28 ff ff
	ff		 lea	 esi, DWORD PTR _pItem$[ebp+44]
  000ae	2b f3		 sub	 esi, ebx
  000b0	57		 push	 edi
  000b1	8d 7b 1c	 lea	 edi, DWORD PTR [ebx+28]
  000b4	83 ee 4b	 sub	 esi, 75			; 0000004bH
$LL3@GCAnsGiftI:

; 534  : 	{
; 535  : 		pItem.itemGuid = lpMsg->itemList[i].dwGuid;

  000b7	8b 47 fc	 mov	 eax, DWORD PTR [edi-4]

; 536  : 		pItem.unk1 = lpMsg->itemList[i].dwUnk1;
; 537  : 		pItem.unk2_type = lpMsg->itemList[i].dwUnk2;
; 538  : 		pItem.groupId = lpMsg->itemList[i].dwGroupIndex;
; 539  : 		pItem.itemId = lpMsg->itemList[i].dwProductIndex;
; 540  : 		pItem.value = lpMsg->itemList[i].Durability;

  000ba	dd 47 14	 fld	 QWORD PTR [edi+20]
  000bd	8b 0f		 mov	 ecx, DWORD PTR [edi]
  000bf	dd 9d 14 ff ff
	ff		 fstp	 QWORD PTR _pItem$[ebp+24]
  000c5	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  000c8	89 85 00 ff ff
	ff		 mov	 DWORD PTR _pItem$[ebp+4], eax
  000ce	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  000d1	89 8d 04 ff ff
	ff		 mov	 DWORD PTR _pItem$[ebp+8], ecx
  000d7	8b 4f 0c	 mov	 ecx, DWORD PTR [edi+12]
  000da	89 95 08 ff ff
	ff		 mov	 DWORD PTR _pItem$[ebp+12], edx

; 541  : 		pItem.type = (BYTE)lpMsg->itemList[i].dwType;

  000e0	8a 57 1c	 mov	 dl, BYTE PTR [edi+28]
  000e3	89 85 0c ff ff
	ff		 mov	 DWORD PTR _pItem$[ebp+16], eax
  000e9	89 8d 10 ff ff
	ff		 mov	 DWORD PTR _pItem$[ebp+20], ecx
  000ef	88 95 1c ff ff
	ff		 mov	 BYTE PTR _pItem$[ebp+32], dl

; 542  : 
; 543  : 		strcpy(pItem.szUser,lpMsg->itemList[i].szFrom);

  000f5	8d 47 24	 lea	 eax, DWORD PTR [edi+36]
$LL8@GCAnsGiftI:
  000f8	8a 08		 mov	 cl, BYTE PTR [eax]
  000fa	88 0c 06	 mov	 BYTE PTR [esi+eax], cl
  000fd	40		 inc	 eax
  000fe	84 c9		 test	 cl, cl
  00100	75 f6		 jne	 SHORT $LL8@GCAnsGiftI

; 544  : 		strcpy(pItem.szText,lpMsg->itemList[i].szText);

  00102	8d 47 2f	 lea	 eax, DWORD PTR [edi+47]
$LL9@GCAnsGiftI:
  00105	8a 08		 mov	 cl, BYTE PTR [eax]
  00107	88 0c 06	 mov	 BYTE PTR [esi+eax], cl
  0010a	40		 inc	 eax
  0010b	84 c9		 test	 cl, cl
  0010d	75 f6		 jne	 SHORT $LL9@GCAnsGiftI

; 545  : 
; 546  : 		DataSend(lpObj->m_Index,(LPBYTE)&pItem,pItem.h.size);

  0010f	0f b6 85 fd fe
	ff ff		 movzx	 eax, BYTE PTR _pItem$[ebp+1]
  00116	8b 95 f4 fe ff
	ff		 mov	 edx, DWORD PTR _lpObj$GSCopy$[ebp]
  0011c	50		 push	 eax
  0011d	8b 02		 mov	 eax, DWORD PTR [edx]
  0011f	8d 8d fc fe ff
	ff		 lea	 ecx, DWORD PTR _pItem$[ebp]
  00125	51		 push	 ecx
  00126	50		 push	 eax
  00127	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  0012c	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR _i$185790[ebp]
  00132	40		 inc	 eax
  00133	83 c4 0c	 add	 esp, 12			; 0000000cH
  00136	81 ee 00 01 00
	00		 sub	 esi, 256		; 00000100H
  0013c	81 c7 00 01 00
	00		 add	 edi, 256		; 00000100H
  00142	89 85 f8 fe ff
	ff		 mov	 DWORD PTR _i$185790[ebp], eax
  00148	3b 43 14	 cmp	 eax, DWORD PTR [ebx+20]
  0014b	0f 82 66 ff ff
	ff		 jb	 $LL3@GCAnsGiftI
  00151	5f		 pop	 edi
$LN1@GCAnsGiftI:

; 547  : 	}
; 548  : }

  00152	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00155	5e		 pop	 esi
  00156	33 cd		 xor	 ecx, ebp
  00158	5b		 pop	 ebx
  00159	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0015e	8b e5		 mov	 esp, ebp
  00160	5d		 pop	 ebp
  00161	c2 08 00	 ret	 8
?GCAnsGiftInfo@CCashShop@@QAEXPAUOBJECTSTRUCT@@PAVMSG_STOG_GIFT_LIST_ANS_EX@protocol@@@Z ENDP ; CCashShop::GCAnsGiftInfo
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GCSendItemInfo@CCashShop@@QAEXHHHK@Z		; CCashShop::GCSendItemInfo
; Function compile flags: /Ogtp
;	COMDAT ?GCSendItemInfo@CCashShop@@QAEXHHHK@Z
_TEXT	SEGMENT
_pMsg$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_aIndex$ = 8						; size = 4
_ItemID$ = 12						; size = 4
_ItemPos$ = 16						; size = 4
_ItemTime$ = 20						; size = 4
?GCSendItemInfo@CCashShop@@QAEXHHHK@Z PROC		; CCashShop::GCSendItemInfo, COMDAT
; _this$ = ecx

; 567  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 568  : 	PMSG_CASHITEM_STATUS pMsg;
; 569  : 
; 570  : 	PHeadSubSetB((LPBYTE)&pMsg,0xD2,0x12,sizeof(pMsg));

  00010	6a 0c		 push	 12			; 0000000cH
  00012	6a 12		 push	 18			; 00000012H
  00014	8d 45 f0	 lea	 eax, DWORD PTR _pMsg$[ebp]
  00017	68 d2 00 00 00	 push	 210			; 000000d2H
  0001c	50		 push	 eax
  0001d	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 571  : 
; 572  : 	pMsg.ItemID = ItemID;

  00022	66 8b 4d 0c	 mov	 cx, WORD PTR _ItemID$[ebp]

; 573  : 	pMsg.ItemPos = ItemPos;

  00026	66 8b 55 10	 mov	 dx, WORD PTR _ItemPos$[ebp]

; 574  : 	pMsg.ItemTime = ItemTime;

  0002a	8b 45 14	 mov	 eax, DWORD PTR _ItemTime$[ebp]
  0002d	66 89 4d f4	 mov	 WORD PTR _pMsg$[ebp+4], cx

; 575  : 
; 576  : 	DataSend(aIndex,(LPBYTE)&pMsg,pMsg.h.size);

  00031	0f b6 4d f1	 movzx	 ecx, BYTE PTR _pMsg$[ebp+1]
  00035	66 89 55 f6	 mov	 WORD PTR _pMsg$[ebp+6], dx
  00039	51		 push	 ecx
  0003a	8d 55 f0	 lea	 edx, DWORD PTR _pMsg$[ebp]
  0003d	89 45 f8	 mov	 DWORD PTR _pMsg$[ebp+8], eax
  00040	8b 45 08	 mov	 eax, DWORD PTR _aIndex$[ebp]
  00043	52		 push	 edx
  00044	50		 push	 eax
  00045	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend

; 577  : }

  0004a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0004d	33 cd		 xor	 ecx, ebp
  0004f	83 c4 1c	 add	 esp, 28			; 0000001cH
  00052	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c2 10 00	 ret	 16			; 00000010H
?GCSendItemInfo@CCashShop@@QAEXHHHK@Z ENDP		; CCashShop::GCSendItemInfo
_TEXT	ENDS
PUBLIC	?GCCashItemBuyResult@CCashShop@@QAEXPAUOBJECTSTRUCT@@E@Z ; CCashShop::GCCashItemBuyResult
; Function compile flags: /Ogtp
;	COMDAT ?GCCashItemBuyResult@CCashShop@@QAEXPAUOBJECTSTRUCT@@E@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 5
_lpObj$ = 8						; size = 4
_btResult$ = 12						; size = 1
?GCCashItemBuyResult@CCashShop@@QAEXPAUOBJECTSTRUCT@@E@Z PROC ; CCashShop::GCCashItemBuyResult, COMDAT
; _this$ = ecx

; 622  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 623  : 	PMSG_ANS_CASHITEM_BUY pMsg;
; 624  : 
; 625  : 	pMsg.btResult = btResult;

  00006	8a 45 0c	 mov	 al, BYTE PTR _btResult$[ebp]

; 626  : 	PHeadSubSetB((LPBYTE)&pMsg, 0xD2, 0x03, sizeof(PMSG_ANS_CASHITEM_BUY));

  00009	6a 05		 push	 5
  0000b	6a 03		 push	 3
  0000d	8d 4d f8	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00010	68 d2 00 00 00	 push	 210			; 000000d2H
  00015	51		 push	 ecx
  00016	88 45 fc	 mov	 BYTE PTR _pMsg$[ebp+4], al
  00019	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 627  : 
; 628  : 	DataSend(lpObj->m_Index, (LPBYTE)&pMsg, pMsg.h.size);

  0001e	0f b6 55 f9	 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  00022	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00025	52		 push	 edx
  00026	8b 11		 mov	 edx, DWORD PTR [ecx]
  00028	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0002b	50		 push	 eax
  0002c	52		 push	 edx
  0002d	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00032	83 c4 1c	 add	 esp, 28			; 0000001cH

; 629  : }

  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c2 08 00	 ret	 8
?GCCashItemBuyResult@CCashShop@@QAEXPAUOBJECTSTRUCT@@E@Z ENDP ; CCashShop::GCCashItemBuyResult
_TEXT	ENDS
PUBLIC	?GCCashGiftSendResult@CCashShop@@QAEXPAUOBJECTSTRUCT@@E@Z ; CCashShop::GCCashGiftSendResult
; Function compile flags: /Ogtp
;	COMDAT ?GCCashGiftSendResult@CCashShop@@QAEXPAUOBJECTSTRUCT@@E@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 5
_lpObj$ = 8						; size = 4
_btResult$ = 12						; size = 1
?GCCashGiftSendResult@CCashShop@@QAEXPAUOBJECTSTRUCT@@E@Z PROC ; CCashShop::GCCashGiftSendResult, COMDAT
; _this$ = ecx

; 666  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 667  : 	PMSG_ANS_CASHITEM_GIFT pMsg;
; 668  : 	PHeadSubSetB((LPBYTE)&pMsg,0xD2,0x04,sizeof(pMsg));

  00006	6a 05		 push	 5
  00008	6a 04		 push	 4
  0000a	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0000d	68 d2 00 00 00	 push	 210			; 000000d2H
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 669  : 
; 670  : 	pMsg.btResult = btResult;
; 671  : 
; 672  : 	DataSend(lpObj->m_Index,(LPBYTE)&pMsg,pMsg.h.size);

  00018	0f b6 55 f9	 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  0001c	8a 4d 0c	 mov	 cl, BYTE PTR _btResult$[ebp]
  0001f	52		 push	 edx
  00020	88 4d fc	 mov	 BYTE PTR _pMsg$[ebp+4], cl
  00023	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00026	8b 11		 mov	 edx, DWORD PTR [ecx]
  00028	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0002b	50		 push	 eax
  0002c	52		 push	 edx
  0002d	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00032	83 c4 1c	 add	 esp, 28			; 0000001cH

; 673  : }

  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c2 08 00	 ret	 8
?GCCashGiftSendResult@CCashShop@@QAEXPAUOBJECTSTRUCT@@E@Z ENDP ; CCashShop::GCCashGiftSendResult
_TEXT	ENDS
PUBLIC	?GCCashItemUseResult@CCashShop@@QAEXPAUOBJECTSTRUCT@@E@Z ; CCashShop::GCCashItemUseResult
; Function compile flags: /Ogtp
;	COMDAT ?GCCashItemUseResult@CCashShop@@QAEXPAUOBJECTSTRUCT@@E@Z
_TEXT	SEGMENT
_pMsg$ = -8						; size = 5
_lpObj$ = 8						; size = 4
_btResult$ = 12						; size = 1
?GCCashItemUseResult@CCashShop@@QAEXPAUOBJECTSTRUCT@@E@Z PROC ; CCashShop::GCCashItemUseResult, COMDAT
; _this$ = ecx

; 716  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 717  : 	PMSG_ANS_CASHITEM_USE pMsg;
; 718  : 	PHeadSubSetB((LPBYTE)&pMsg,0xD2,0x0B,sizeof(pMsg));

  00006	6a 05		 push	 5
  00008	6a 0b		 push	 11			; 0000000bH
  0000a	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0000d	68 d2 00 00 00	 push	 210			; 000000d2H
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 ?PHeadSubSetB@@YAXPAEEEH@Z ; PHeadSubSetB

; 719  : 
; 720  : 	pMsg.btResult = btResult;
; 721  : 
; 722  : 	DataSend(lpObj->m_Index,(LPBYTE)&pMsg,pMsg.h.size);

  00018	0f b6 55 f9	 movzx	 edx, BYTE PTR _pMsg$[ebp+1]
  0001c	8a 4d 0c	 mov	 cl, BYTE PTR _btResult$[ebp]
  0001f	52		 push	 edx
  00020	88 4d fc	 mov	 BYTE PTR _pMsg$[ebp+4], cl
  00023	8b 4d 08	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00026	8b 11		 mov	 edx, DWORD PTR [ecx]
  00028	8d 45 f8	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0002b	50		 push	 eax
  0002c	52		 push	 edx
  0002d	e8 00 00 00 00	 call	 ?DataSend@@YAHHPAEK@Z	; DataSend
  00032	83 c4 1c	 add	 esp, 28			; 0000001cH

; 723  : }

  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c2 08 00	 ret	 8
?GCCashItemUseResult@CCashShop@@QAEXPAUOBJECTSTRUCT@@E@Z ENDP ; CCashShop::GCCashItemUseResult
_TEXT	ENDS
PUBLIC	??_C@_0HP@KEHPDILO@?$FLCashShop?$FN?$FLBuy?5Item?5Create?5in?5In@ ; `string'
PUBLIC	__real@4f800000
PUBLIC	_lpObj$GSCopy$
PUBLIC	__$ArrayPad$
PUBLIC	?GiveBuyItemToInventory@CCashShop@@QAEHPAUOBJECTSTRUCT@@HPAUuseInfoEx@protocol@@@Z ; CCashShop::GiveBuyItemToInventory
EXTRN	?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A:BYTE	; ItemAttribute
EXTRN	?GCInventoryItemOneSend@@YAXHH@Z:PROC		; GCInventoryItemOneSend
EXTRN	?ItemIsBufExOption@@YAXPAEPAVCItem@@@Z:PROC	; ItemIsBufExOption
EXTRN	?gObjOnlyInventoryInsertItem@@YAEHVCItem@@@Z:PROC ; gObjOnlyInventoryInsertItem
EXTRN	?ItemGetDurability@@YAHHHHH@Z:PROC		; ItemGetDurability
EXTRN	?IsExtItem@CItem@@QAEHXZ:PROC			; CItem::IsExtItem
EXTRN	?IsSetItem@CItem@@QAEHXZ:PROC			; CItem::IsSetItem
EXTRN	?Convert@CItem@@QAEXHEEEEEEPAEEE@Z:PROC		; CItem::Convert
EXTRN	??0CItem@@QAE@XZ:PROC				; CItem::CItem
;	COMDAT ??_C@_0HP@KEHPDILO@?$FLCashShop?$FN?$FLBuy?5Item?5Create?5in?5In@
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\time.inl
CONST	SEGMENT
??_C@_0HP@KEHPDILO@?$FLCashShop?$FN?$FLBuy?5Item?5Create?5in?5In@ DB '[Ca'
	DB	'shShop][Buy Item Create in Inven] - User(ID:%s,Name:%s) Item('
	DB	'Name:%s,Code:%d,Skill:%d,Luck:%d,Add:%d,Ex(%d:%d:%d:%d:%d:%d)'
	DB	')', 00H					; `string'
CONST	ENDS
;	COMDAT __real@4f800000
CONST	SEGMENT
__real@4f800000 DD 04f800000r			; 4.29497e+009
; Function compile flags: /Ogtp
; File c:\muserver_dev\development\mu-s8ep2-repack\gameserver\source\cashshop.cpp
CONST	ENDS
;	COMDAT ?GiveBuyItemToInventory@CCashShop@@QAEHPAUOBJECTSTRUCT@@HPAUuseInfoEx@protocol@@@Z
_TEXT	SEGMENT
_this$ = -244						; size = 4
_pTime$185900 = -240					; size = 8
tv292 = -236						; size = 4
tv287 = -236						; size = 4
_lpObj$GSCopy$ = -232					; size = 4
_btItemPos$ = -225					; size = 1
_pItem$ = -224						; size = 212
_ExOption$ = -12					; size = 8
__$ArrayPad$ = -4					; size = 4
_lpObj$ = 8						; size = 4
_iItemCode$ = 12					; size = 4
_pItemInfo$ = 16					; size = 4
?GiveBuyItemToInventory@CCashShop@@QAEHPAUOBJECTSTRUCT@@HPAUuseInfoEx@protocol@@@Z PROC ; CCashShop::GiveBuyItemToInventory, COMDAT
; _this$ = ecx

; 726  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f4 00 00
	00		 sub	 esp, 244		; 000000f4H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00016	53		 push	 ebx
  00017	8b 5d 0c	 mov	 ebx, DWORD PTR _iItemCode$[ebp]
  0001a	56		 push	 esi
  0001b	8b 75 10	 mov	 esi, DWORD PTR _pItemInfo$[ebp]
  0001e	89 8d 0c ff ff
	ff		 mov	 DWORD PTR _this$[ebp], ecx
  00024	57		 push	 edi

; 727  : 	BOOL bEmptySpace = FALSE;
; 728  : 	CItem pItem;

  00025	8d 8d 20 ff ff
	ff		 lea	 ecx, DWORD PTR _pItem$[ebp]

; 768  : 	}
; 769  : 
; 770  : 	LogAddTD("[CashShop][Buy Item Create in Inven] - User(ID:%s,Name:%s) Item(Name:%s,Code:%d,Skill:%d,Luck:%d,Add:%d,Ex(%d:%d:%d:%d:%d:%d))",
; 771  : 		lpObj->AccountID, lpObj->Name, ItemAttribute[iItemCode].Name, iItemCode, 
; 772  : 		pItem.m_Option1, pItem.m_Option2, pItem.m_Option3, ExOption[0], ExOption[1], ExOption[2],
; 773  : 		ExOption[3], ExOption[4], ExOption[5]);

  0002b	89 85 18 ff ff
	ff		 mov	 DWORD PTR _lpObj$GSCopy$[ebp], eax
  00031	e8 00 00 00 00	 call	 ??0CItem@@QAE@XZ	; CItem::CItem
  00036	0f b6 4e 15	 movzx	 ecx, BYTE PTR [esi+21]
  0003a	0f b6 56 14	 movzx	 edx, BYTE PTR [esi+20]
  0003e	0f b6 46 13	 movzx	 eax, BYTE PTR [esi+19]
  00042	6a 03		 push	 3
  00044	68 ff 00 00 00	 push	 255			; 000000ffH
  00049	6a 00		 push	 0
  0004b	6a 00		 push	 0
  0004d	51		 push	 ecx
  0004e	0f b6 4e 12	 movzx	 ecx, BYTE PTR [esi+18]
  00052	52		 push	 edx
  00053	0f b6 56 11	 movzx	 edx, BYTE PTR [esi+17]
  00057	50		 push	 eax
  00058	51		 push	 ecx
  00059	52		 push	 edx
  0005a	53		 push	 ebx
  0005b	8d 8d 20 ff ff
	ff		 lea	 ecx, DWORD PTR _pItem$[ebp]
  00061	e8 00 00 00 00	 call	 ?Convert@CItem@@QAEXHEEEEEEPAEEE@Z ; CItem::Convert
  00066	0f b6 46 10	 movzx	 eax, BYTE PTR [esi+16]
  0006a	66 89 85 28 ff
	ff ff		 mov	 WORD PTR _pItem$[ebp+8], ax
  00071	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00074	85 c0		 test	 eax, eax
  00076	74 16		 je	 SHORT $LN5@GiveBuyIte

; 729  : 	BYTE ExOption[MAX_EXOPTION_SIZE];
; 730  : 
; 731  : 	pItem.Convert(iItemCode, pItemInfo->btOption1, pItemInfo->btOption2, pItemInfo->btOption3,
; 732  : 		pItemInfo->btExcOp, pItemInfo->btAncOp, 0, 0, -1, CURRENT_DB_VERSION);
; 733  : 
; 734  : 	pItem.m_Level = pItemInfo->btLevel;
; 735  : 
; 736  : 	if( pItemInfo->dwDurability != 0 )
; 737  : 	{
; 738  : 		pItem.m_Durability = (float)pItemInfo->dwDurability;

  00078	89 85 14 ff ff
	ff		 mov	 DWORD PTR tv292[ebp], eax
  0007e	db 85 14 ff ff
	ff		 fild	 DWORD PTR tv292[ebp]
  00084	79 3d		 jns	 SHORT $LN10@GiveBuyIte
  00086	d8 05 00 00 00
	00		 fadd	 DWORD PTR __real@4f800000

; 739  : 	}
; 740  : 	else

  0008c	eb 35		 jmp	 SHORT $LN10@GiveBuyIte
$LN5@GiveBuyIte:

; 741  : 	{
; 742  : 		pItem.m_Durability = (float)ItemGetDurability(iItemCode,pItem.m_Level,pItem.IsExtItem(),pItem.IsSetItem());

  0008e	8d 8d 20 ff ff
	ff		 lea	 ecx, DWORD PTR _pItem$[ebp]
  00094	e8 00 00 00 00	 call	 ?IsSetItem@CItem@@QAEHXZ ; CItem::IsSetItem
  00099	50		 push	 eax
  0009a	8d 8d 20 ff ff
	ff		 lea	 ecx, DWORD PTR _pItem$[ebp]
  000a0	e8 00 00 00 00	 call	 ?IsExtItem@CItem@@QAEHXZ ; CItem::IsExtItem
  000a5	0f bf 8d 28 ff
	ff ff		 movsx	 ecx, WORD PTR _pItem$[ebp+8]
  000ac	50		 push	 eax
  000ad	51		 push	 ecx
  000ae	53		 push	 ebx
  000af	e8 00 00 00 00	 call	 ?ItemGetDurability@@YAHHHHH@Z ; ItemGetDurability
  000b4	89 85 14 ff ff
	ff		 mov	 DWORD PTR tv287[ebp], eax
  000ba	83 c4 10	 add	 esp, 16			; 00000010H
  000bd	db 85 14 ff ff
	ff		 fild	 DWORD PTR tv287[ebp]
$LN10@GiveBuyIte:

; 743  : 	}
; 744  : 
; 745  : 	if( pItemInfo->dwUseTime != 0 )

  000c3	83 7e 0c 00	 cmp	 DWORD PTR [esi+12], 0
  000c7	d9 9d 44 ff ff
	ff		 fstp	 DWORD PTR _pItem$[ebp+36]
  000cd	74 29		 je	 SHORT $LN3@GiveBuyIte

; 746  : 	{
; 747  : 		time_t pTime;
; 748  : 		pTime = time(NULL);

  000cf	6a 00		 push	 0
  000d1	e8 00 00 00 00	 call	 __time64

; 749  : 		pItem.m_Number = (DWORD)pTime + pItemInfo->dwUseTime*60;

  000d6	8b 76 0c	 mov	 esi, DWORD PTR [esi+12]
  000d9	89 95 14 ff ff
	ff		 mov	 DWORD PTR _pTime$185900[ebp+4], edx
  000df	8b d6		 mov	 edx, esi
  000e1	c1 e2 04	 shl	 edx, 4
  000e4	83 c4 04	 add	 esp, 4
  000e7	2b d6		 sub	 edx, esi
  000e9	8d 04 90	 lea	 eax, DWORD PTR [eax+edx*4]
  000ec	89 85 20 ff ff
	ff		 mov	 DWORD PTR _pItem$[ebp], eax

; 750  : 		pItem.m_bPeriodItem = TRUE;

  000f2	66 c7 45 ef 01
	00		 mov	 WORD PTR _pItem$[ebp+207], 1
$LN3@GiveBuyIte:

; 751  : 		pItem.m_bExpired = FALSE;
; 752  : 	}
; 753  : 
; 754  : 	BYTE btItemPos = gObjOnlyInventoryInsertItem(lpObj->m_Index, pItem);

  000f8	81 ec d4 00 00
	00		 sub	 esp, 212		; 000000d4H
  000fe	8b fc		 mov	 edi, esp
  00100	b9 35 00 00 00	 mov	 ecx, 53			; 00000035H
  00105	8d b5 20 ff ff
	ff		 lea	 esi, DWORD PTR _pItem$[ebp]
  0010b	f3 a5		 rep movsd
  0010d	8b bd 18 ff ff
	ff		 mov	 edi, DWORD PTR _lpObj$GSCopy$[ebp]
  00113	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00115	51		 push	 ecx
  00116	e8 00 00 00 00	 call	 ?gObjOnlyInventoryInsertItem@@YAEHVCItem@@@Z ; gObjOnlyInventoryInsertItem

; 755  : 
; 756  : 	ItemIsBufExOption(ExOption, &pItem);

  0011b	8d 95 20 ff ff
	ff		 lea	 edx, DWORD PTR _pItem$[ebp]
  00121	88 85 1f ff ff
	ff		 mov	 BYTE PTR _btItemPos$[ebp], al
  00127	52		 push	 edx
  00128	8d 45 f4	 lea	 eax, DWORD PTR _ExOption$[ebp]
  0012b	50		 push	 eax
  0012c	e8 00 00 00 00	 call	 ?ItemIsBufExOption@@YAXPAEPAVCItem@@@Z ; ItemIsBufExOption

; 757  : 
; 758  : 	if( btItemPos == (BYTE)-1 )

  00131	8a 85 1f ff ff
	ff		 mov	 al, BYTE PTR _btItemPos$[ebp]
  00137	81 c4 e0 00 00
	00		 add	 esp, 224		; 000000e0H
  0013d	3c ff		 cmp	 al, 255			; 000000ffH
  0013f	75 15		 jne	 SHORT $LN2@GiveBuyIte

; 759  : 	{
; 760  : 		return FALSE;

  00141	33 c0		 xor	 eax, eax

; 774  : 
; 775  : 	return TRUE;
; 776  : }

  00143	5f		 pop	 edi
  00144	5e		 pop	 esi
  00145	5b		 pop	 ebx
  00146	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00149	33 cd		 xor	 ecx, ebp
  0014b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00150	8b e5		 mov	 esp, ebp
  00152	5d		 pop	 ebp
  00153	c2 0c 00	 ret	 12			; 0000000cH
$LN2@GiveBuyIte:

; 761  : 	}
; 762  : 
; 763  : 	GCInventoryItemOneSend(lpObj->m_Index, btItemPos);

  00156	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00158	0f b6 f0	 movzx	 esi, al
  0015b	56		 push	 esi
  0015c	51		 push	 ecx
  0015d	e8 00 00 00 00	 call	 ?GCInventoryItemOneSend@@YAXHH@Z ; GCInventoryItemOneSend
  00162	83 c4 08	 add	 esp, 8

; 764  : 
; 765  : 	if( pItem.m_bPeriodItem )

  00165	80 7d ef 00	 cmp	 BYTE PTR _pItem$[ebp+207], 0
  00169	74 1e		 je	 SHORT $LN1@GiveBuyIte

; 766  : 	{
; 767  : 		GCSendItemInfo(lpObj->m_Index,pItem.m_Type,btItemPos,pItem.m_Number);

  0016b	8b 95 20 ff ff
	ff		 mov	 edx, DWORD PTR _pItem$[ebp]
  00171	0f bf 85 26 ff
	ff ff		 movsx	 eax, WORD PTR _pItem$[ebp+6]
  00178	8b 0f		 mov	 ecx, DWORD PTR [edi]
  0017a	52		 push	 edx
  0017b	56		 push	 esi
  0017c	50		 push	 eax
  0017d	51		 push	 ecx
  0017e	8b 8d 0c ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00184	e8 00 00 00 00	 call	 ?GCSendItemInfo@CCashShop@@QAEXHHHK@Z ; CCashShop::GCSendItemInfo
$LN1@GiveBuyIte:

; 768  : 	}
; 769  : 
; 770  : 	LogAddTD("[CashShop][Buy Item Create in Inven] - User(ID:%s,Name:%s) Item(Name:%s,Code:%d,Skill:%d,Luck:%d,Add:%d,Ex(%d:%d:%d:%d:%d:%d))",
; 771  : 		lpObj->AccountID, lpObj->Name, ItemAttribute[iItemCode].Name, iItemCode, 
; 772  : 		pItem.m_Option1, pItem.m_Option2, pItem.m_Option3, ExOption[0], ExOption[1], ExOption[2],
; 773  : 		ExOption[3], ExOption[4], ExOption[5]);

  00189	0f b6 55 f9	 movzx	 edx, BYTE PTR _ExOption$[ebp+5]
  0018d	0f b6 45 f8	 movzx	 eax, BYTE PTR _ExOption$[ebp+4]
  00191	0f b6 4d f7	 movzx	 ecx, BYTE PTR _ExOption$[ebp+3]
  00195	52		 push	 edx
  00196	0f b6 55 f6	 movzx	 edx, BYTE PTR _ExOption$[ebp+2]
  0019a	50		 push	 eax
  0019b	0f b6 45 f5	 movzx	 eax, BYTE PTR _ExOption$[ebp+1]
  0019f	51		 push	 ecx
  001a0	0f b6 4d f4	 movzx	 ecx, BYTE PTR _ExOption$[ebp]
  001a4	52		 push	 edx
  001a5	0f b6 55 b2	 movzx	 edx, BYTE PTR _pItem$[ebp+146]
  001a9	50		 push	 eax
  001aa	0f b6 45 b1	 movzx	 eax, BYTE PTR _pItem$[ebp+145]
  001ae	51		 push	 ecx
  001af	0f b6 4d b0	 movzx	 ecx, BYTE PTR _pItem$[ebp+144]
  001b3	52		 push	 edx
  001b4	50		 push	 eax
  001b5	51		 push	 ecx
  001b6	53		 push	 ebx
  001b7	6b db 70	 imul	 ebx, 112		; 00000070H
  001ba	81 c3 00 00 00
	00		 add	 ebx, OFFSET ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A ; ItemAttribute
  001c0	53		 push	 ebx
  001c1	8d 57 5d	 lea	 edx, DWORD PTR [edi+93]
  001c4	52		 push	 edx
  001c5	83 c7 52	 add	 edi, 82			; 00000052H
  001c8	57		 push	 edi
  001c9	68 00 00 00 00	 push	 OFFSET ??_C@_0HP@KEHPDILO@?$FLCashShop?$FN?$FLBuy?5Item?5Create?5in?5In@
  001ce	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 774  : 
; 775  : 	return TRUE;
; 776  : }

  001d4	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001d7	83 c4 38	 add	 esp, 56			; 00000038H
  001da	5f		 pop	 edi
  001db	5e		 pop	 esi
  001dc	33 cd		 xor	 ecx, ebp
  001de	b8 01 00 00 00	 mov	 eax, 1
  001e3	5b		 pop	 ebx
  001e4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001e9	8b e5		 mov	 esp, ebp
  001eb	5d		 pop	 ebp
  001ec	c2 0c 00	 ret	 12			; 0000000cH
?GiveBuyItemToInventory@CCashShop@@QAEHPAUOBJECTSTRUCT@@HPAUuseInfoEx@protocol@@@Z ENDP ; CCashShop::GiveBuyItemToInventory
_TEXT	ENDS
PUBLIC	?CheckInventoryEmptySpace@CCashShop@@QAEHPAUOBJECTSTRUCT@@H@Z ; CCashShop::CheckInventoryEmptySpace
EXTRN	?gObjOnlyInventoryRectCheck@@YAEHHHHH@Z:PROC	; gObjOnlyInventoryRectCheck
EXTRN	?ItemGetSize@@YAXHAAH0@Z:PROC			; ItemGetSize
; Function compile flags: /Ogtp
;	COMDAT ?CheckInventoryEmptySpace@CCashShop@@QAEHPAUOBJECTSTRUCT@@H@Z
_TEXT	SEGMENT
_iItemWidth$ = -8					; size = 4
_iItemHeight$ = -4					; size = 4
_lpObj$ = 8						; size = 4
_iItemCode$ = 12					; size = 4
?CheckInventoryEmptySpace@CCashShop@@QAEHPAUOBJECTSTRUCT@@H@Z PROC ; CCashShop::CheckInventoryEmptySpace, COMDAT
; _this$ = ecx

; 780  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 781  : 	int h = 0;
; 782  : 	int w = 0;
; 783  : 	unsigned char blank = 0;
; 784  : 	int iItemHeight = 0;
; 785  : 	int iItemWidth = 0;
; 786  : 
; 787  : 	ItemGetSize(iItemCode,iItemWidth,iItemHeight);

  00006	8b 55 0c	 mov	 edx, DWORD PTR _iItemCode$[ebp]
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d 45 fc	 lea	 eax, DWORD PTR _iItemHeight$[ebp]
  0000f	50		 push	 eax
  00010	8d 4d f8	 lea	 ecx, DWORD PTR _iItemWidth$[ebp]
  00013	51		 push	 ecx
  00014	33 ff		 xor	 edi, edi
  00016	52		 push	 edx
  00017	89 7d fc	 mov	 DWORD PTR _iItemHeight$[ebp], edi
  0001a	89 7d f8	 mov	 DWORD PTR _iItemWidth$[ebp], edi
  0001d	e8 00 00 00 00	 call	 ?ItemGetSize@@YAXHAAH0@Z ; ItemGetSize

; 788  : 
; 789  : 	for ( h = 0; h < 8 + (lpObj->pInventoryExtend * 4); h++ )

  00022	8b 5d 08	 mov	 ebx, DWORD PTR _lpObj$[ebp]
  00025	0f b6 83 cd 11
	00 00		 movzx	 eax, BYTE PTR [ebx+4557]
  0002c	8d 0c 85 08 00
	00 00		 lea	 ecx, DWORD PTR [eax*4+8]
  00033	83 c4 0c	 add	 esp, 12			; 0000000cH
  00036	85 c9		 test	 ecx, ecx
  00038	7e 4d		 jle	 SHORT $LN7@CheckInven
  0003a	8d 9b 00 00 00
	00		 npad	 6
$LL18@CheckInven:

; 790  : 	{
; 791  : 		for ( w=0;w<8;w++)

  00040	33 f6		 xor	 esi, esi
$LL6@CheckInven:

; 792  : 		{
; 793  : 			if ( *(BYTE *)(lpObj->pInventoryMap + h*8 + w ) == 0xFF )

  00042	8b 83 c8 11 00
	00		 mov	 eax, DWORD PTR [ebx+4552]
  00048	8d 14 fe	 lea	 edx, DWORD PTR [esi+edi*8]
  0004b	80 3c 02 ff	 cmp	 BYTE PTR [edx+eax], 255	; 000000ffH
  0004f	75 1d		 jne	 SHORT $LN5@CheckInven

; 794  : 			{
; 795  : 				blank = gObjOnlyInventoryRectCheck(lpObj->m_Index, w, h, iItemWidth, iItemHeight);

  00051	8b 4d fc	 mov	 ecx, DWORD PTR _iItemHeight$[ebp]
  00054	8b 55 f8	 mov	 edx, DWORD PTR _iItemWidth$[ebp]
  00057	8b 03		 mov	 eax, DWORD PTR [ebx]
  00059	51		 push	 ecx
  0005a	52		 push	 edx
  0005b	57		 push	 edi
  0005c	56		 push	 esi
  0005d	50		 push	 eax
  0005e	e8 00 00 00 00	 call	 ?gObjOnlyInventoryRectCheck@@YAEHHHHH@Z ; gObjOnlyInventoryRectCheck
  00063	83 c4 14	 add	 esp, 20			; 00000014H

; 796  : 
; 797  : 				if ( blank == 0xFE )

  00066	3c fe		 cmp	 al, 254			; 000000feH
  00068	74 1d		 je	 SHORT $LN7@CheckInven

; 798  : 					return FALSE;
; 799  : 
; 800  : 				if ( blank != 0xFF )

  0006a	3c ff		 cmp	 al, 255			; 000000ffH
  0006c	75 24		 jne	 SHORT $LN15@CheckInven
$LN5@CheckInven:

; 790  : 	{
; 791  : 		for ( w=0;w<8;w++)

  0006e	46		 inc	 esi
  0006f	83 fe 08	 cmp	 esi, 8
  00072	7c ce		 jl	 SHORT $LL6@CheckInven

; 788  : 
; 789  : 	for ( h = 0; h < 8 + (lpObj->pInventoryExtend * 4); h++ )

  00074	0f b6 8b cd 11
	00 00		 movzx	 ecx, BYTE PTR [ebx+4557]
  0007b	47		 inc	 edi
  0007c	8d 14 8d 08 00
	00 00		 lea	 edx, DWORD PTR [ecx*4+8]
  00083	3b fa		 cmp	 edi, edx
  00085	7c b9		 jl	 SHORT $LL18@CheckInven
$LN7@CheckInven:
  00087	5f		 pop	 edi
  00088	5e		 pop	 esi

; 802  : 			}
; 803  : 		}
; 804  : 	}
; 805  : 
; 806  : 	return FALSE;

  00089	33 c0		 xor	 eax, eax
  0008b	5b		 pop	 ebx

; 807  : }

  0008c	8b e5		 mov	 esp, ebp
  0008e	5d		 pop	 ebp
  0008f	c2 08 00	 ret	 8
$LN15@CheckInven:
  00092	5f		 pop	 edi
  00093	5e		 pop	 esi

; 801  : 					return TRUE;

  00094	b8 01 00 00 00	 mov	 eax, 1
  00099	5b		 pop	 ebx

; 807  : }

  0009a	8b e5		 mov	 esp, ebp
  0009c	5d		 pop	 ebp
  0009d	c2 08 00	 ret	 8
?CheckInventoryEmptySpace@CCashShop@@QAEHPAUOBJECTSTRUCT@@H@Z ENDP ; CCashShop::CheckInventoryEmptySpace
_TEXT	ENDS
PUBLIC	?ItemCheckWorker@CCashShop@@QAEXXZ		; CCashShop::ItemCheckWorker
EXTRN	?gObjCalCharacter@@YAXH@Z:PROC			; gObjCalCharacter
EXTRN	?GCInventoryItemDeleteSend@@YAXHEE@Z:PROC	; GCInventoryItemDeleteSend
EXTRN	?Clear@CItem@@QAEXXZ:PROC			; CItem::Clear
EXTRN	?GetName@CItem@@QAEPADXZ:PROC			; CItem::GetName
EXTRN	?SkillChangeUse@CObjUseSkill@@QAEHH@Z:PROC	; CObjUseSkill::SkillChangeUse
EXTRN	?gObjUseSkill@@3VCObjUseSkill@@A:DWORD		; gObjUseSkill
EXTRN	?IsTransformRing@@YA_NG@Z:PROC			; IsTransformRing
EXTRN	?IsItem@CItem@@QAEHXZ:PROC			; CItem::IsItem
EXTRN	?gObj@@3PAUOBJECTSTRUCT@@A:DWORD		; gObj
; Function compile flags: /Ogtp
;	COMDAT ?ItemCheckWorker@CCashShop@@QAEXXZ
_TEXT	SEGMENT
_curTime$ = -20						; size = 8
tv332 = -12						; size = 4
_bCalCharacter$ = -8					; size = 4
_n$185932 = -4						; size = 4
?ItemCheckWorker@CCashShop@@QAEXXZ PROC			; CCashShop::ItemCheckWorker, COMDAT
; _this$ = ecx

; 810  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 811  : 	time_t curTime;
; 812  : 	curTime = time(NULL);

  00009	6a 00		 push	 0
  0000b	e8 00 00 00 00	 call	 __time64
  00010	be 00 dd 49 06	 mov	 esi, 105504000		; 0649dd00H
  00015	83 c4 04	 add	 esp, 4
  00018	89 45 ec	 mov	 DWORD PTR _curTime$[ebp], eax
  0001b	89 55 f0	 mov	 DWORD PTR _curTime$[ebp+4], edx

; 813  : 
; 814  : 	int bCalCharacter;
; 815  : 
; 816  : 	for(int n = OBJ_STARTUSERINDEX; n < OBJMAX; n++)

  0001e	c7 45 fc 04 29
	00 00		 mov	 DWORD PTR _n$185932[ebp], 10500 ; 00002904H
  00025	89 75 f4	 mov	 DWORD PTR tv332[ebp], esi
  00028	eb 06 8d 9b 00
	00 00 00	 npad	 8
$LL28@ItemCheckW:

; 817  : 	{
; 818  : 		if( !gObjIsConnected(n) )

  00030	8b 45 fc	 mov	 eax, DWORD PTR _n$185932[ebp]
  00033	50		 push	 eax
  00034	e8 00 00 00 00	 call	 ?gObjIsConnected@@YAHH@Z ; gObjIsConnected
  00039	83 c4 04	 add	 esp, 4
  0003c	85 c0		 test	 eax, eax
  0003e	0f 84 12 01 00
	00		 je	 $LN14@ItemCheckW

; 819  : 			continue;
; 820  : 
; 821  : 		LPOBJ lpObj = &gObj[n];

  00044	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 822  : 
; 823  : 		bCalCharacter = FALSE;

  0004a	33 ff		 xor	 edi, edi
  0004c	89 7d f8	 mov	 DWORD PTR _bCalCharacter$[ebp], edi

; 824  : 
; 825  : 		for(int i = 0; i < INVENTORY_SIZE; i++)

  0004f	33 db		 xor	 ebx, ebx
$LL11@ItemCheckW:

; 826  : 		{
; 827  : 			if( !lpObj->pInventory[i].IsItem() || !lpObj->pInventory[i].m_bPeriodItem )

  00051	8b 8e c0 11 00
	00		 mov	 ecx, DWORD PTR [esi+4544]
  00057	03 cf		 add	 ecx, edi
  00059	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0005e	85 c0		 test	 eax, eax
  00060	0f 84 cc 00 00
	00		 je	 $LN10@ItemCheckW
  00066	8b 96 c0 11 00
	00		 mov	 edx, DWORD PTR [esi+4544]
  0006c	80 bc 17 cf 00
	00 00 00	 cmp	 BYTE PTR [edi+edx+207], 0
  00074	8d 04 17	 lea	 eax, DWORD PTR [edi+edx]
  00077	0f 84 b5 00 00
	00		 je	 $LN10@ItemCheckW

; 828  : 				continue;
; 829  : 
; 830  : 			if( lpObj->pInventory[i].m_bExpired )

  0007d	80 b8 d0 00 00
	00 00		 cmp	 BYTE PTR [eax+208], 0
  00084	0f 85 a8 00 00
	00		 jne	 $LN10@ItemCheckW

; 831  : 				continue;
; 832  : 
; 833  : 			if( lpObj->pInventory[i].m_Number < curTime )

  0008a	33 c9		 xor	 ecx, ecx
  0008c	3b 4d f0	 cmp	 ecx, DWORD PTR _curTime$[ebp+4]
  0008f	0f 8f 9d 00 00
	00		 jg	 $LN10@ItemCheckW
  00095	7c 0b		 jl	 SHORT $LN24@ItemCheckW
  00097	8b 08		 mov	 ecx, DWORD PTR [eax]
  00099	3b 4d ec	 cmp	 ecx, DWORD PTR _curTime$[ebp]
  0009c	0f 83 90 00 00
	00		 jae	 $LN10@ItemCheckW
$LN24@ItemCheckW:

; 834  : 			{
; 835  : 				lpObj->pInventory[i].m_bExpired = TRUE;

  000a2	c6 80 d0 00 00
	00 01		 mov	 BYTE PTR [eax+208], 1

; 836  : 
; 837  : 				if( i == 10 || i == 11 )

  000a9	83 fb 0a	 cmp	 ebx, 10			; 0000000aH
  000ac	74 05		 je	 SHORT $LN3@ItemCheckW
  000ae	83 fb 0b	 cmp	 ebx, 11			; 0000000bH
  000b1	75 5d		 jne	 SHORT $LN2@ItemCheckW
$LN3@ItemCheckW:

; 838  : 				{
; 839  : 					if( IsTransformRing(lpObj->pInventory[i].m_Type) )

  000b3	8b 86 c0 11 00
	00		 mov	 eax, DWORD PTR [esi+4544]
  000b9	0f b7 4c 07 06	 movzx	 ecx, WORD PTR [edi+eax+6]
  000be	51		 push	 ecx
  000bf	e8 00 00 00 00	 call	 ?IsTransformRing@@YA_NG@Z ; IsTransformRing
  000c4	83 c4 04	 add	 esp, 4
  000c7	84 c0		 test	 al, al
  000c9	74 45		 je	 SHORT $LN2@ItemCheckW

; 840  : 					{
; 841  : 						gObjUseSkill.SkillChangeUse(lpObj->m_Index);

  000cb	8b 16		 mov	 edx, DWORD PTR [esi]
  000cd	52		 push	 edx
  000ce	b9 00 00 00 00	 mov	 ecx, OFFSET ?gObjUseSkill@@3VCObjUseSkill@@A ; gObjUseSkill
  000d3	e8 00 00 00 00	 call	 ?SkillChangeUse@CObjUseSkill@@QAEHH@Z ; CObjUseSkill::SkillChangeUse

; 842  : 						LogAddTD(lMsg.Get(544),lpObj->AccountID,lpObj->Name,lpObj->pInventory[i].GetName(),lpObj->pInventory[i].m_Level,0);

  000d8	8b 86 c0 11 00
	00		 mov	 eax, DWORD PTR [esi+4544]
  000de	0f bf 54 07 08	 movsx	 edx, WORD PTR [edi+eax+8]
  000e3	8d 0c 07	 lea	 ecx, DWORD PTR [edi+eax]
  000e6	6a 00		 push	 0
  000e8	52		 push	 edx
  000e9	e8 00 00 00 00	 call	 ?GetName@CItem@@QAEPADXZ ; CItem::GetName
  000ee	50		 push	 eax
  000ef	8d 46 5d	 lea	 eax, DWORD PTR [esi+93]
  000f2	50		 push	 eax
  000f3	8d 4e 52	 lea	 ecx, DWORD PTR [esi+82]
  000f6	51		 push	 ecx
  000f7	68 20 02 00 00	 push	 544			; 00000220H
  000fc	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  00101	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  00106	50		 push	 eax
  00107	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  0010d	83 c4 18	 add	 esp, 24			; 00000018H
$LN2@ItemCheckW:

; 843  : 					}
; 844  : 				}
; 845  : 
; 846  : 				lpObj->pInventory[i].Clear();

  00110	8b 8e c0 11 00
	00		 mov	 ecx, DWORD PTR [esi+4544]
  00116	03 cf		 add	 ecx, edi
  00118	e8 00 00 00 00	 call	 ?Clear@CItem@@QAEXXZ	; CItem::Clear

; 847  : 				GCInventoryItemDeleteSend(lpObj->m_Index,i,0);

  0011d	8b 16		 mov	 edx, DWORD PTR [esi]
  0011f	6a 00		 push	 0
  00121	53		 push	 ebx
  00122	52		 push	 edx
  00123	e8 00 00 00 00	 call	 ?GCInventoryItemDeleteSend@@YAXHEE@Z ; GCInventoryItemDeleteSend
  00128	83 c4 0c	 add	 esp, 12			; 0000000cH

; 848  : 				bCalCharacter = TRUE;

  0012b	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _bCalCharacter$[ebp], 1
$LN10@ItemCheckW:

; 824  : 
; 825  : 		for(int i = 0; i < INVENTORY_SIZE; i++)

  00132	81 c7 d4 00 00
	00		 add	 edi, 212		; 000000d4H
  00138	43		 inc	 ebx
  00139	81 ff 44 c4 00
	00		 cmp	 edi, 50244		; 0000c444H
  0013f	0f 8c 0c ff ff
	ff		 jl	 $LL11@ItemCheckW

; 849  : 			}
; 850  : 		}
; 851  : 
; 852  : 		if( bCalCharacter == TRUE )

  00145	83 7d f8 01	 cmp	 DWORD PTR _bCalCharacter$[ebp], 1
  00149	75 0b		 jne	 SHORT $LN14@ItemCheckW

; 853  : 		{
; 854  : 			gObjCalCharacter(lpObj->m_Index);

  0014b	8b 06		 mov	 eax, DWORD PTR [esi]
  0014d	50		 push	 eax
  0014e	e8 00 00 00 00	 call	 ?gObjCalCharacter@@YAXH@Z ; gObjCalCharacter
  00153	83 c4 04	 add	 esp, 4
$LN14@ItemCheckW:

; 813  : 
; 814  : 	int bCalCharacter;
; 815  : 
; 816  : 	for(int n = OBJ_STARTUSERINDEX; n < OBJMAX; n++)

  00156	8b 75 f4	 mov	 esi, DWORD PTR tv332[ebp]
  00159	ff 45 fc	 inc	 DWORD PTR _n$185932[ebp]
  0015c	81 c6 40 27 00
	00		 add	 esi, 10048		; 00002740H
  00162	89 75 f4	 mov	 DWORD PTR tv332[ebp], esi
  00165	81 fe 00 2f e3
	06		 cmp	 esi, 115552000		; 06e32f00H
  0016b	0f 8c bf fe ff
	ff		 jl	 $LL28@ItemCheckW
  00171	5f		 pop	 edi
  00172	5e		 pop	 esi
  00173	5b		 pop	 ebx

; 855  : 		}
; 856  : 	}
; 857  : }

  00174	8b e5		 mov	 esp, ebp
  00176	5d		 pop	 ebp
  00177	c3		 ret	 0
?ItemCheckWorker@CCashShop@@QAEXXZ ENDP			; CCashShop::ItemCheckWorker
_TEXT	ENDS
PUBLIC	?IsGetAmountFromShopItem@CCashShop@@QAEHH@Z	; CCashShop::IsGetAmountFromShopItem
; Function compile flags: /Ogtp
;	COMDAT ?IsGetAmountFromShopItem@CCashShop@@QAEHH@Z
_TEXT	SEGMENT
_iItemCode$ = 8						; size = 4
?IsGetAmountFromShopItem@CCashShop@@QAEHH@Z PROC	; CCashShop::IsGetAmountFromShopItem, COMDAT
; _this$ = ecx

; 860  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 861  : 	switch ( iItemCode )

  00003	8b 45 08	 mov	 eax, DWORD PTR _iItemCode$[ebp]
  00006	3d 47 1c 00 00	 cmp	 eax, 7239		; 00001c47H
  0000b	7f 36		 jg	 SHORT $LN6@IsGetAmoun
  0000d	3d 46 1c 00 00	 cmp	 eax, 7238		; 00001c46H
  00012	7d 44		 jge	 SHORT $LN1@IsGetAmoun
  00014	3d 3a 1a 00 00	 cmp	 eax, 6714		; 00001a3aH
  00019	7f 1b		 jg	 SHORT $LN7@IsGetAmoun
  0001b	3d 35 1a 00 00	 cmp	 eax, 6709		; 00001a35H
  00020	7d 36		 jge	 SHORT $LN1@IsGetAmoun
  00022	3d 2e 1a 00 00	 cmp	 eax, 6702		; 00001a2eH
  00027	7c 07		 jl	 SHORT $LN2@IsGetAmoun
  00029	3d 30 1a 00 00	 cmp	 eax, 6704		; 00001a30H
  0002e	7e 28		 jle	 SHORT $LN1@IsGetAmoun
$LN2@IsGetAmoun:

; 886  : 	}
; 887  : return FALSE;

  00030	33 c0		 xor	 eax, eax

; 888  : }

  00032	5d		 pop	 ebp
  00033	c2 04 00	 ret	 4
$LN7@IsGetAmoun:

; 861  : 	switch ( iItemCode )

  00036	3d 35 1c 00 00	 cmp	 eax, 7221		; 00001c35H
  0003b	74 1b		 je	 SHORT $LN1@IsGetAmoun

; 886  : 	}
; 887  : return FALSE;

  0003d	33 c0		 xor	 eax, eax

; 888  : }

  0003f	5d		 pop	 ebp
  00040	c2 04 00	 ret	 4
$LN6@IsGetAmoun:

; 861  : 	switch ( iItemCode )

  00043	3d 4e 1c 00 00	 cmp	 eax, 7246		; 00001c4eH
  00048	7c e6		 jl	 SHORT $LN2@IsGetAmoun
  0004a	3d 52 1c 00 00	 cmp	 eax, 7250		; 00001c52H
  0004f	7e 07		 jle	 SHORT $LN1@IsGetAmoun
  00051	3d 5e 1c 00 00	 cmp	 eax, 7262		; 00001c5eH
  00056	75 d8		 jne	 SHORT $LN2@IsGetAmoun
$LN1@IsGetAmoun:

; 862  : 	{
; 863  : 	case ITEMGET(14,71):
; 864  : 	case ITEMGET(14,70):
; 865  : 
; 866  : 	case ITEMGET(13,58):
; 867  : 	case ITEMGET(13,57):
; 868  : 	case ITEMGET(13,56):
; 869  : 	case ITEMGET(13,55):
; 870  : 	case ITEMGET(13,54):
; 871  : 	case ITEMGET(13,53):
; 872  : 
; 873  : 	case ITEMGET(13,46):
; 874  : 	case ITEMGET(13,47):
; 875  : 	case ITEMGET(13,48):
; 876  : 		
; 877  : 	case ITEMGET(14,53):
; 878  : 
; 879  : 	case ITEMGET(14,78):
; 880  : 	case ITEMGET(14,79):
; 881  : 	case ITEMGET(14,80):
; 882  : 	case ITEMGET(14,81):
; 883  : 	case ITEMGET(14,82):
; 884  : 	case ITEMGET(14,94):
; 885  : 		return TRUE;

  00058	b8 01 00 00 00	 mov	 eax, 1

; 888  : }

  0005d	5d		 pop	 ebp
  0005e	c2 04 00	 ret	 4
?IsGetAmountFromShopItem@CCashShop@@QAEHH@Z ENDP	; CCashShop::IsGetAmountFromShopItem
_TEXT	ENDS
PUBLIC	?CheckPeriodItem@CCashShop@@QAEHH@Z		; CCashShop::CheckPeriodItem
; Function compile flags: /Ogtp
;	COMDAT ?CheckPeriodItem@CCashShop@@QAEHH@Z
_TEXT	SEGMENT
_iItemCode$ = 8						; size = 4
?CheckPeriodItem@CCashShop@@QAEHH@Z PROC		; CCashShop::CheckPeriodItem, COMDAT
; _this$ = ecx

; 891  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 892  : 
; 893  : 	switch( iItemCode )

  00003	8b 45 08	 mov	 eax, DWORD PTR _iItemCode$[ebp]
  00006	3d 5e 1a 00 00	 cmp	 eax, 6750		; 00001a5eH
  0000b	7f 1f		 jg	 SHORT $LN6@CheckPerio
  0000d	3d 5d 1a 00 00	 cmp	 eax, 6749		; 00001a5dH
  00012	7d 48		 jge	 SHORT $LN1@CheckPerio
  00014	05 d5 e5 ff ff	 add	 eax, -6699		; ffffe5d5H
  00019	83 f8 14	 cmp	 eax, 20			; 00000014H
  0001c	77 2a		 ja	 SHORT $LN2@CheckPerio
  0001e	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR $LN8@CheckPerio[eax]
  00025	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN9@CheckPerio[eax*4]
$LN6@CheckPerio:
  0002c	3d 4d 1c 00 00	 cmp	 eax, 7245		; 00001c4dH
  00031	7f 1b		 jg	 SHORT $LN7@CheckPerio
  00033	3d 48 1c 00 00	 cmp	 eax, 7240		; 00001c48H
  00038	7d 22		 jge	 SHORT $LN1@CheckPerio
  0003a	3d 68 1a 00 00	 cmp	 eax, 6760		; 00001a68H
  0003f	7c 07		 jl	 SHORT $LN2@CheckPerio
  00041	3d 69 1a 00 00	 cmp	 eax, 6761		; 00001a69H
  00046	7e 14		 jle	 SHORT $LN1@CheckPerio
$LN2@CheckPerio:

; 914  : 	}
; 915  : 	return FALSE;

  00048	33 c0		 xor	 eax, eax

; 916  : }

  0004a	5d		 pop	 ebp
  0004b	c2 04 00	 ret	 4
$LN7@CheckPerio:

; 892  : 
; 893  : 	switch( iItemCode )

  0004e	3d 61 1c 00 00	 cmp	 eax, 7265		; 00001c61H
  00053	7c f3		 jl	 SHORT $LN2@CheckPerio
  00055	3d 62 1c 00 00	 cmp	 eax, 7266		; 00001c62H
  0005a	7f ec		 jg	 SHORT $LN2@CheckPerio
$LN1@CheckPerio:

; 894  : 	{
; 895  : 	case ITEMGET(13,43):
; 896  : 	case ITEMGET(13,44):
; 897  : 	case ITEMGET(13,45):
; 898  : 	case ITEMGET(13,59):
; 899  : 	case ITEMGET(13,62):
; 900  : 	case ITEMGET(13,63):
; 901  : 	case ITEMGET(13,93):
; 902  : 	case ITEMGET(13,94):
; 903  : 	case ITEMGET(13,104):
; 904  : 	case ITEMGET(13,105):
; 905  : 	case ITEMGET(14,72):
; 906  : 	case ITEMGET(14,73):
; 907  : 	case ITEMGET(14,74):
; 908  : 	case ITEMGET(14,75):
; 909  : 	case ITEMGET(14,76):
; 910  : 	case ITEMGET(14,77):
; 911  : 	case ITEMGET(14,97):
; 912  : 	case ITEMGET(14,98):
; 913  : 		return TRUE;

  0005c	b8 01 00 00 00	 mov	 eax, 1

; 916  : }

  00061	5d		 pop	 ebp
  00062	c2 04 00	 ret	 4
  00065	8d 49 00	 npad	 3
$LN9@CheckPerio:
  00068	00 00 00 00	 DD	 $LN1@CheckPerio
  0006c	00 00 00 00	 DD	 $LN2@CheckPerio
$LN8@CheckPerio:
  00070	00		 DB	 0
  00071	00		 DB	 0
  00072	00		 DB	 0
  00073	01		 DB	 1
  00074	01		 DB	 1
  00075	01		 DB	 1
  00076	01		 DB	 1
  00077	01		 DB	 1
  00078	01		 DB	 1
  00079	01		 DB	 1
  0007a	01		 DB	 1
  0007b	01		 DB	 1
  0007c	01		 DB	 1
  0007d	01		 DB	 1
  0007e	01		 DB	 1
  0007f	01		 DB	 1
  00080	00		 DB	 0
  00081	01		 DB	 1
  00082	01		 DB	 1
  00083	00		 DB	 0
  00084	00		 DB	 0
?CheckPeriodItem@CCashShop@@QAEHH@Z ENDP		; CCashShop::CheckPeriodItem
_TEXT	ENDS
PUBLIC	?GSReqCashPoint@CCashShop@@QAEXK@Z		; CCashShop::GSReqCashPoint
EXTRN	?DataSend@wsShopServerCli@@QAEHPADH@Z:PROC	; wsShopServerCli::DataSend
; Function compile flags: /Ogtp
;	COMDAT ?GSReqCashPoint@CCashShop@@QAEXK@Z
_TEXT	SEGMENT
_pMsg$ = -12						; size = 12
_dwUserGuid$ = 8					; size = 4
?GSReqCashPoint@CCashShop@@QAEXK@Z PROC			; CCashShop::GSReqCashPoint, COMDAT
; _this$ = ecx

; 921  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 922  : 	protocol::MSG_GTOS_USER_CASH_REQ_EX pMsg;
; 923  : 
; 924  : 	pMsg.dwUserGuid = dwUserGuid;

  00006	8b 55 08	 mov	 edx, DWORD PTR _dwUserGuid$[ebp]

; 925  : 	g_ShopServerClient.DataSend((PCHAR)&pMsg, sizeof(protocol::MSG_GTOS_USER_CASH_REQ_EX));

  00009	6a 0c		 push	 12			; 0000000cH
  0000b	8d 45 f4	 lea	 eax, DWORD PTR _pMsg$[ebp]
  0000e	50		 push	 eax
  0000f	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ShopServerClient@@3VwsShopServerCli@@A ; g_ShopServerClient
  00014	c7 45 f4 0c 00
	00 00		 mov	 DWORD PTR _pMsg$[ebp], 12 ; 0000000cH
  0001b	c7 45 f8 00 01
	01 00		 mov	 DWORD PTR _pMsg$[ebp+4], 65792 ; 00010100H
  00022	89 55 fc	 mov	 DWORD PTR _pMsg$[ebp+8], edx
  00025	e8 00 00 00 00	 call	 ?DataSend@wsShopServerCli@@QAEHPADH@Z ; wsShopServerCli::DataSend

; 926  : }

  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
?GSReqCashPoint@CCashShop@@QAEXK@Z ENDP			; CCashShop::GSReqCashPoint
_TEXT	ENDS
PUBLIC	?GSReqCashItemList@CCashShop@@QAEXKK@Z		; CCashShop::GSReqCashItemList
; Function compile flags: /Ogtp
;	COMDAT ?GSReqCashItemList@CCashShop@@QAEXKK@Z
_TEXT	SEGMENT
_pMsg$ = -16						; size = 16
_dwUserGuid$ = 8					; size = 4
_dwPageId$ = 12						; size = 4
?GSReqCashItemList@CCashShop@@QAEXKK@Z PROC		; CCashShop::GSReqCashItemList, COMDAT
; _this$ = ecx

; 929  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 930  : 	protocol::MSG_GTOS_ITEM_LIST_REQ_EX pMsg;
; 931  : 
; 932  : 	pMsg.dwUserGuid = dwUserGuid;

  00006	8b 55 08	 mov	 edx, DWORD PTR _dwUserGuid$[ebp]

; 933  : 	pMsg.dwPageId = dwPageId;

  00009	8b 45 0c	 mov	 eax, DWORD PTR _dwPageId$[ebp]

; 934  : 
; 935  : 	g_ShopServerClient.DataSend((PCHAR)&pMsg, sizeof(protocol::MSG_GTOS_ITEM_LIST_REQ_EX));

  0000c	6a 10		 push	 16			; 00000010H
  0000e	8d 4d f0	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00011	51		 push	 ecx
  00012	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ShopServerClient@@3VwsShopServerCli@@A ; g_ShopServerClient
  00017	c7 45 f0 10 00
	00 00		 mov	 DWORD PTR _pMsg$[ebp], 16 ; 00000010H
  0001e	c7 45 f4 00 03
	01 00		 mov	 DWORD PTR _pMsg$[ebp+4], 66304 ; 00010300H
  00025	89 55 f8	 mov	 DWORD PTR _pMsg$[ebp+8], edx
  00028	89 45 fc	 mov	 DWORD PTR _pMsg$[ebp+12], eax
  0002b	e8 00 00 00 00	 call	 ?DataSend@wsShopServerCli@@QAEHPADH@Z ; wsShopServerCli::DataSend

; 936  : }

  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c2 08 00	 ret	 8
?GSReqCashItemList@CCashShop@@QAEXKK@Z ENDP		; CCashShop::GSReqCashItemList
_TEXT	ENDS
PUBLIC	?GSReqCashGiftList@CCashShop@@QAEXKK@Z		; CCashShop::GSReqCashGiftList
; Function compile flags: /Ogtp
;	COMDAT ?GSReqCashGiftList@CCashShop@@QAEXKK@Z
_TEXT	SEGMENT
_pMsg$ = -16						; size = 16
_dwUserGuid$ = 8					; size = 4
_dwPageId$ = 12						; size = 4
?GSReqCashGiftList@CCashShop@@QAEXKK@Z PROC		; CCashShop::GSReqCashGiftList, COMDAT
; _this$ = ecx

; 939  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 940  : 	protocol::MSG_GTOS_GIFT_LIST_REQ_EX pMsg;
; 941  : 
; 942  : 	pMsg.dwUserGuid = dwUserGuid;

  00006	8b 55 08	 mov	 edx, DWORD PTR _dwUserGuid$[ebp]

; 943  : 	pMsg.dwPageId = dwPageId;

  00009	8b 45 0c	 mov	 eax, DWORD PTR _dwPageId$[ebp]

; 944  : 
; 945  : 	g_ShopServerClient.DataSend((PCHAR)&pMsg, sizeof(protocol::MSG_GTOS_GIFT_LIST_REQ_EX));

  0000c	6a 10		 push	 16			; 00000010H
  0000e	8d 4d f0	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00011	51		 push	 ecx
  00012	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ShopServerClient@@3VwsShopServerCli@@A ; g_ShopServerClient
  00017	c7 45 f0 10 00
	00 00		 mov	 DWORD PTR _pMsg$[ebp], 16 ; 00000010H
  0001e	c7 45 f4 00 07
	01 00		 mov	 DWORD PTR _pMsg$[ebp+4], 67328 ; 00010700H
  00025	89 55 f8	 mov	 DWORD PTR _pMsg$[ebp+8], edx
  00028	89 45 fc	 mov	 DWORD PTR _pMsg$[ebp+12], eax
  0002b	e8 00 00 00 00	 call	 ?DataSend@wsShopServerCli@@QAEHPADH@Z ; wsShopServerCli::DataSend

; 946  : }

  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c2 08 00	 ret	 8
?GSReqCashGiftList@CCashShop@@QAEXKK@Z ENDP		; CCashShop::GSReqCashGiftList
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GSReqBuyCashItem@CCashShop@@QAEXKPAUOBJECTSTRUCT@@PAUPMSG_REQ_CASHITEM_BUY@@@Z ; CCashShop::GSReqBuyCashItem
; Function compile flags: /Ogtp
;	COMDAT ?GSReqBuyCashItem@CCashShop@@QAEXKPAUOBJECTSTRUCT@@PAUPMSG_REQ_CASHITEM_BUY@@@Z
_TEXT	SEGMENT
_pMsg$ = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
_dwServerGuid$ = 8					; size = 4
_lpObj$ = 12						; size = 4
_lpMsg$ = 16						; size = 4
?GSReqBuyCashItem@CCashShop@@QAEXKPAUOBJECTSTRUCT@@PAUPMSG_REQ_CASHITEM_BUY@@@Z PROC ; CCashShop::GSReqBuyCashItem, COMDAT
; _this$ = ecx

; 949  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 4d 0c	 mov	 ecx, DWORD PTR _lpObj$[ebp]
  00013	8b 45 10	 mov	 eax, DWORD PTR _lpMsg$[ebp]

; 950  : 	protocol::MSG_GTOS_BUY_ITEM_REQ_EX pMsg;

  00016	ba 00 09 00 00	 mov	 edx, 2304		; 00000900H
  0001b	66 89 55 d0	 mov	 WORD PTR _pMsg$[ebp+4], dx
  0001f	ba 01 00 00 00	 mov	 edx, 1
  00024	66 89 55 d2	 mov	 WORD PTR _pMsg$[ebp+6], dx

; 951  : 
; 952  : 	pMsg.dwServerGuid = dwServerGuid;

  00028	8b 55 08	 mov	 edx, DWORD PTR _dwServerGuid$[ebp]
  0002b	89 55 d4	 mov	 DWORD PTR _pMsg$[ebp+8], edx

; 953  : 	pMsg.dwUserGuid = lpObj->DBNumber;

  0002e	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  00031	89 55 d8	 mov	 DWORD PTR _pMsg$[ebp+12], edx

; 954  : 	pMsg.dwCharGuid = lpObj->m_Index;

  00034	8b 11		 mov	 edx, DWORD PTR [ecx]
  00036	89 55 dc	 mov	 DWORD PTR _pMsg$[ebp+16], edx

; 955  : 	pMsg.dwPackageCategory = lpMsg->itemCategory;

  00039	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0003c	89 55 ec	 mov	 DWORD PTR _pMsg$[ebp+32], edx

; 956  : 	pMsg.dwPackageId = lpMsg->itemGuid;

  0003f	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00042	89 55 f0	 mov	 DWORD PTR _pMsg$[ebp+36], edx

; 957  : 	pMsg.dwProductId = lpMsg->productId;

  00045	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]

; 958  : 	pMsg.ItemID = lpMsg->itemId;

  00048	66 8b 40 10	 mov	 ax, WORD PTR [eax+16]
  0004c	66 89 45 f8	 mov	 WORD PTR _pMsg$[ebp+44], ax

; 959  : 
; 960  : 	memset(pMsg.szCharName,0,sizeof(pMsg.szCharName));

  00050	33 c0		 xor	 eax, eax
  00052	89 55 f4	 mov	 DWORD PTR _pMsg$[ebp+40], edx
  00055	89 45 e0	 mov	 DWORD PTR _pMsg$[ebp+20], eax
  00058	89 45 e4	 mov	 DWORD PTR _pMsg$[ebp+24], eax
  0005b	66 89 45 e8	 mov	 WORD PTR _pMsg$[ebp+28], ax
  0005f	88 45 ea	 mov	 BYTE PTR _pMsg$[ebp+30], al

; 961  : 	strcpy(pMsg.szCharName,lpObj->Name);

  00062	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  00065	8d 55 e0	 lea	 edx, DWORD PTR _pMsg$[ebp+20]
  00068	c7 45 cc 30 00
	00 00		 mov	 DWORD PTR _pMsg$[ebp], 48 ; 00000030H
  0006f	2b d0		 sub	 edx, eax
$LL3@GSReqBuyCa:
  00071	8a 08		 mov	 cl, BYTE PTR [eax]
  00073	88 0c 02	 mov	 BYTE PTR [edx+eax], cl
  00076	40		 inc	 eax
  00077	84 c9		 test	 cl, cl
  00079	75 f6		 jne	 SHORT $LL3@GSReqBuyCa

; 962  : 
; 963  : 	g_ShopServerClient.DataSend((PCHAR)&pMsg, sizeof(protocol::MSG_GTOS_BUY_ITEM_REQ_EX));

  0007b	6a 30		 push	 48			; 00000030H
  0007d	8d 4d cc	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00080	51		 push	 ecx
  00081	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ShopServerClient@@3VwsShopServerCli@@A ; g_ShopServerClient
  00086	e8 00 00 00 00	 call	 ?DataSend@wsShopServerCli@@QAEHPADH@Z ; wsShopServerCli::DataSend

; 964  : }

  0008b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0008e	33 cd		 xor	 ecx, ebp
  00090	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00095	8b e5		 mov	 esp, ebp
  00097	5d		 pop	 ebp
  00098	c2 0c 00	 ret	 12			; 0000000cH
?GSReqBuyCashItem@CCashShop@@QAEXKPAUOBJECTSTRUCT@@PAUPMSG_REQ_CASHITEM_BUY@@@Z ENDP ; CCashShop::GSReqBuyCashItem
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GSReqGiftCashItem@CCashShop@@QAEXKPAUOBJECTSTRUCT@@PAUPMSG_REQ_CASHITEM_GIFT@@@Z ; CCashShop::GSReqGiftCashItem
EXTRN	_memset:PROC
; Function compile flags: /Ogtp
;	COMDAT ?GSReqGiftCashItem@CCashShop@@QAEXKPAUOBJECTSTRUCT@@PAUPMSG_REQ_CASHITEM_GIFT@@@Z
_TEXT	SEGMENT
_pMsg$ = -264						; size = 260
__$ArrayPad$ = -4					; size = 4
_dwServerGuid$ = 8					; size = 4
_lpObj$ = 12						; size = 4
_lpMsg$ = 16						; size = 4
?GSReqGiftCashItem@CCashShop@@QAEXKPAUOBJECTSTRUCT@@PAUPMSG_REQ_CASHITEM_GIFT@@@Z PROC ; CCashShop::GSReqGiftCashItem, COMDAT
; _this$ = ecx

; 967  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 08 01 00
	00		 sub	 esp, 264		; 00000108H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 4d 0c	 mov	 ecx, DWORD PTR _lpObj$[ebp]

; 968  : 	protocol::MSG_GTOS_GIFT_ITEM_REQ_EX pMsg;
; 969  : 
; 970  : 	pMsg.dwServerGuid = dwServerGuid;

  00016	8b 45 08	 mov	 eax, DWORD PTR _dwServerGuid$[ebp]

; 971  : 	pMsg.dwUserGuid = lpObj->DBNumber;

  00019	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  0001c	89 85 00 ff ff
	ff		 mov	 DWORD PTR _pMsg$[ebp+8], eax

; 972  : 	pMsg.dwCharGuid = lpObj->m_Index;

  00022	8b 01		 mov	 eax, DWORD PTR [ecx]
  00024	89 85 08 ff ff
	ff		 mov	 DWORD PTR _pMsg$[ebp+16], eax
  0002a	56		 push	 esi
  0002b	8b 75 10	 mov	 esi, DWORD PTR _lpMsg$[ebp]

; 973  : 	pMsg.dwPackageCategory = lpMsg->itemCategory;
; 974  : 	pMsg.dwPackageId = lpMsg->itemGuid;

  0002e	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00031	89 95 04 ff ff
	ff		 mov	 DWORD PTR _pMsg$[ebp+12], edx
  00037	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0003a	89 85 1c ff ff
	ff		 mov	 DWORD PTR _pMsg$[ebp+36], eax

; 975  : 	pMsg.dwProductId = lpMsg->productId;
; 976  : 	pMsg.ItemID = lpMsg->itemId;

  00040	66 8b 46 10	 mov	 ax, WORD PTR [esi+16]
  00044	89 95 18 ff ff
	ff		 mov	 DWORD PTR _pMsg$[ebp+32], edx
  0004a	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  0004d	66 89 85 24 ff
	ff ff		 mov	 WORD PTR _pMsg$[ebp+44], ax

; 977  : 
; 978  : 	memset(pMsg.szCharName,0,sizeof(pMsg.szCharName));

  00054	33 c0		 xor	 eax, eax
  00056	89 95 20 ff ff
	ff		 mov	 DWORD PTR _pMsg$[ebp+40], edx
  0005c	89 85 0c ff ff
	ff		 mov	 DWORD PTR _pMsg$[ebp+20], eax
  00062	89 85 10 ff ff
	ff		 mov	 DWORD PTR _pMsg$[ebp+24], eax
  00068	66 89 85 14 ff
	ff ff		 mov	 WORD PTR _pMsg$[ebp+28], ax
  0006f	88 85 16 ff ff
	ff		 mov	 BYTE PTR _pMsg$[ebp+30], al

; 979  : 	strcpy(pMsg.szCharName,lpObj->Name);

  00075	8d 41 5d	 lea	 eax, DWORD PTR [ecx+93]
  00078	8d 95 0c ff ff
	ff		 lea	 edx, DWORD PTR _pMsg$[ebp+20]
  0007e	c7 85 f8 fe ff
	ff 04 01 00 00	 mov	 DWORD PTR _pMsg$[ebp], 260 ; 00000104H
  00088	c7 85 fc fe ff
	ff 00 0d 01 00	 mov	 DWORD PTR _pMsg$[ebp+4], 68864 ; 00010d00H
  00092	2b d0		 sub	 edx, eax
$LL3@GSReqGiftC:
  00094	8a 08		 mov	 cl, BYTE PTR [eax]
  00096	88 0c 02	 mov	 BYTE PTR [edx+eax], cl
  00099	40		 inc	 eax
  0009a	84 c9		 test	 cl, cl
  0009c	75 f6		 jne	 SHORT $LL3@GSReqGiftC

; 980  : 
; 981  : 	memset(pMsg.szToName,0,sizeof(pMsg.szToName));

  0009e	33 c0		 xor	 eax, eax

; 982  : 	memset(pMsg.szText,0,sizeof(pMsg.szText));

  000a0	68 c8 00 00 00	 push	 200			; 000000c8H
  000a5	50		 push	 eax
  000a6	8d 8d 31 ff ff
	ff		 lea	 ecx, DWORD PTR _pMsg$[ebp+57]
  000ac	51		 push	 ecx
  000ad	89 85 26 ff ff
	ff		 mov	 DWORD PTR _pMsg$[ebp+46], eax
  000b3	89 85 2a ff ff
	ff		 mov	 DWORD PTR _pMsg$[ebp+50], eax
  000b9	66 89 85 2e ff
	ff ff		 mov	 WORD PTR _pMsg$[ebp+54], ax
  000c0	88 85 30 ff ff
	ff		 mov	 BYTE PTR _pMsg$[ebp+56], al
  000c6	e8 00 00 00 00	 call	 _memset

; 983  : 
; 984  : 	strcpy(pMsg.szToName,lpMsg->szName);

  000cb	8d 46 16	 lea	 eax, DWORD PTR [esi+22]
  000ce	8d 95 26 ff ff
	ff		 lea	 edx, DWORD PTR _pMsg$[ebp+46]
  000d4	83 c4 0c	 add	 esp, 12			; 0000000cH
  000d7	2b d0		 sub	 edx, eax
  000d9	8d a4 24 00 00
	00 00		 npad	 7
$LL4@GSReqGiftC:
  000e0	8a 08		 mov	 cl, BYTE PTR [eax]
  000e2	88 0c 02	 mov	 BYTE PTR [edx+eax], cl
  000e5	40		 inc	 eax
  000e6	84 c9		 test	 cl, cl
  000e8	75 f6		 jne	 SHORT $LL4@GSReqGiftC

; 985  : 	strcpy(pMsg.szText,lpMsg->szText);

  000ea	8d 46 21	 lea	 eax, DWORD PTR [esi+33]
  000ed	8d 95 31 ff ff
	ff		 lea	 edx, DWORD PTR _pMsg$[ebp+57]
  000f3	2b d0		 sub	 edx, eax
  000f5	5e		 pop	 esi
$LL5@GSReqGiftC:
  000f6	8a 08		 mov	 cl, BYTE PTR [eax]
  000f8	88 0c 02	 mov	 BYTE PTR [edx+eax], cl
  000fb	40		 inc	 eax
  000fc	84 c9		 test	 cl, cl
  000fe	75 f6		 jne	 SHORT $LL5@GSReqGiftC

; 986  : 
; 987  : 	g_ShopServerClient.DataSend((PCHAR)&pMsg, sizeof(protocol::MSG_GTOS_GIFT_ITEM_REQ_EX));

  00100	68 04 01 00 00	 push	 260			; 00000104H
  00105	8d 95 f8 fe ff
	ff		 lea	 edx, DWORD PTR _pMsg$[ebp]
  0010b	52		 push	 edx
  0010c	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ShopServerClient@@3VwsShopServerCli@@A ; g_ShopServerClient
  00111	e8 00 00 00 00	 call	 ?DataSend@wsShopServerCli@@QAEHPADH@Z ; wsShopServerCli::DataSend

; 988  : }

  00116	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00119	33 cd		 xor	 ecx, ebp
  0011b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00120	8b e5		 mov	 esp, ebp
  00122	5d		 pop	 ebp
  00123	c2 0c 00	 ret	 12			; 0000000cH
?GSReqGiftCashItem@CCashShop@@QAEXKPAUOBJECTSTRUCT@@PAUPMSG_REQ_CASHITEM_GIFT@@@Z ENDP ; CCashShop::GSReqGiftCashItem
_TEXT	ENDS
PUBLIC	?GSReqUseCashItem@CCashShop@@QAEXKKKKK@Z	; CCashShop::GSReqUseCashItem
; Function compile flags: /Ogtp
;	COMDAT ?GSReqUseCashItem@CCashShop@@QAEXKKKKK@Z
_TEXT	SEGMENT
_pMsg$ = -28						; size = 28
_dwUserGuid$ = 8					; size = 4
_itemGuid$ = 12						; size = 4
_dwUnkInfo$ = 16					; size = 4
_itemID$ = 20						; size = 4
_itemType$ = 24						; size = 4
?GSReqUseCashItem@CCashShop@@QAEXKKKKK@Z PROC		; CCashShop::GSReqUseCashItem, COMDAT
; _this$ = ecx

; 991  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH

; 992  : 	protocol::MSG_GTOS_ITEM_USE_REQ_EX pMsg;
; 993  : 
; 994  : 	pMsg.dwUserGuid = dwUserGuid;
; 995  : 	pMsg.dwItemGuid = itemGuid;
; 996  : 	pMsg.dwUnkInfo = dwUnkInfo;

  00006	8b 4d 10	 mov	 ecx, DWORD PTR _dwUnkInfo$[ebp]
  00009	8b 55 08	 mov	 edx, DWORD PTR _dwUserGuid$[ebp]
  0000c	8b 45 0c	 mov	 eax, DWORD PTR _itemGuid$[ebp]
  0000f	89 4d f4	 mov	 DWORD PTR _pMsg$[ebp+16], ecx

; 997  : 	pMsg.dwItemId = itemID;
; 998  : 	pMsg.dwItemType = itemType;
; 999  : 
; 1000 : 	g_ShopServerClient.DataSend((PCHAR)&pMsg, sizeof(protocol::MSG_GTOS_ITEM_USE_REQ_EX));

  00012	6a 1c		 push	 28			; 0000001cH
  00014	8d 4d e4	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00017	89 55 ec	 mov	 DWORD PTR _pMsg$[ebp+8], edx
  0001a	8b 55 14	 mov	 edx, DWORD PTR _itemID$[ebp]
  0001d	89 45 f0	 mov	 DWORD PTR _pMsg$[ebp+12], eax
  00020	8b 45 18	 mov	 eax, DWORD PTR _itemType$[ebp]
  00023	51		 push	 ecx
  00024	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ShopServerClient@@3VwsShopServerCli@@A ; g_ShopServerClient
  00029	c7 45 e4 1c 00
	00 00		 mov	 DWORD PTR _pMsg$[ebp], 28 ; 0000001cH
  00030	c7 45 e8 00 05
	01 00		 mov	 DWORD PTR _pMsg$[ebp+4], 66816 ; 00010500H
  00037	89 55 f8	 mov	 DWORD PTR _pMsg$[ebp+20], edx
  0003a	89 45 fc	 mov	 DWORD PTR _pMsg$[ebp+24], eax
  0003d	e8 00 00 00 00	 call	 ?DataSend@wsShopServerCli@@QAEHPADH@Z ; wsShopServerCli::DataSend

; 1001 : }

  00042	8b e5		 mov	 esp, ebp
  00044	5d		 pop	 ebp
  00045	c2 14 00	 ret	 20			; 00000014H
?GSReqUseCashItem@CCashShop@@QAEXKKKKK@Z ENDP		; CCashShop::GSReqUseCashItem
_TEXT	ENDS
PUBLIC	?GSNtfUseItem@CCashShop@@QAEXKK@Z		; CCashShop::GSNtfUseItem
; Function compile flags: /Ogtp
;	COMDAT ?GSNtfUseItem@CCashShop@@QAEXKK@Z
_TEXT	SEGMENT
_pMsg$ = -16						; size = 16
_dwUserGuid$ = 8					; size = 4
_dwItemGuid$ = 12					; size = 4
?GSNtfUseItem@CCashShop@@QAEXKK@Z PROC			; CCashShop::GSNtfUseItem, COMDAT
; _this$ = ecx

; 1004 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 1005 : 	protocol::MSG_GTOS_USE_ITEM_NTF_EX pMsg;
; 1006 : 
; 1007 : 	pMsg.dwUserGuid = dwUserGuid;

  00006	8b 55 08	 mov	 edx, DWORD PTR _dwUserGuid$[ebp]

; 1008 : 	pMsg.dwItemGuid = dwItemGuid;

  00009	8b 45 0c	 mov	 eax, DWORD PTR _dwItemGuid$[ebp]

; 1009 : 
; 1010 : 	g_ShopServerClient.DataSend((PCHAR)&pMsg,sizeof(protocol::MSG_GTOS_USE_ITEM_NTF_EX));

  0000c	6a 10		 push	 16			; 00000010H
  0000e	8d 4d f0	 lea	 ecx, DWORD PTR _pMsg$[ebp]
  00011	51		 push	 ecx
  00012	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ShopServerClient@@3VwsShopServerCli@@A ; g_ShopServerClient
  00017	c7 45 f0 10 00
	00 00		 mov	 DWORD PTR _pMsg$[ebp], 16 ; 00000010H
  0001e	c7 45 f4 00 0b
	01 00		 mov	 DWORD PTR _pMsg$[ebp+4], 68352 ; 00010b00H
  00025	89 55 f8	 mov	 DWORD PTR _pMsg$[ebp+8], edx
  00028	89 45 fc	 mov	 DWORD PTR _pMsg$[ebp+12], eax
  0002b	e8 00 00 00 00	 call	 ?DataSend@wsShopServerCli@@QAEHPADH@Z ; wsShopServerCli::DataSend

; 1011 : }

  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c2 08 00	 ret	 8
?GSNtfUseItem@CCashShop@@QAEXKK@Z ENDP			; CCashShop::GSNtfUseItem
_TEXT	ENDS
PUBLIC	?IsCashItem@@YAHH@Z				; IsCashItem
; Function compile flags: /Ogtp
;	COMDAT ?IsCashItem@@YAHH@Z
_TEXT	SEGMENT
_iItemCode$ = 8						; size = 4
?IsCashItem@@YAHH@Z PROC				; IsCashItem, COMDAT

; 1169 : BOOL IsCashItem(int iItemCode) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1170 : 	switch (iItemCode) {

  00003	8b 45 08	 mov	 eax, DWORD PTR _iItemCode$[ebp]
  00006	3d a6 1a 00 00	 cmp	 eax, 6822		; 00001aa6H
  0000b	7f 1f		 jg	 SHORT $LN6@IsCashItem
  0000d	3d a3 1a 00 00	 cmp	 eax, 6819		; 00001aa3H
  00012	7d 30		 jge	 SHORT $LN1@IsCashItem
  00014	05 d5 e5 ff ff	 add	 eax, -6699		; ffffe5d5H
  00019	83 f8 50	 cmp	 eax, 80			; 00000050H
  0001c	77 2d		 ja	 SHORT $LN2@IsCashItem
  0001e	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR $LN7@IsCashItem[eax]
  00025	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN9@IsCashItem[eax*4]
$LN6@IsCashItem:
  0002c	05 cb e3 ff ff	 add	 eax, -7221		; ffffe3cbH
  00031	83 f8 6e	 cmp	 eax, 110		; 0000006eH
  00034	77 15		 ja	 SHORT $LN2@IsCashItem
  00036	0f b6 88 00 00
	00 00		 movzx	 ecx, BYTE PTR $LN8@IsCashItem[eax]
  0003d	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN10@IsCashItem[ecx*4]
$LN1@IsCashItem:

; 1171 : 		case ITEMGET(13, 54):
; 1172 : 		case ITEMGET(13, 55):
; 1173 : 		case ITEMGET(13, 56):
; 1174 : 		case ITEMGET(13, 57):
; 1175 : 		case ITEMGET(13, 58):
; 1176 : 		case ITEMGET(13, 59):
; 1177 : 		case ITEMGET(13, 60):
; 1178 : 		case ITEMGET(13, 61):
; 1179 : 		case ITEMGET(13, 43):
; 1180 : 		case ITEMGET(13, 44):
; 1181 : 		case ITEMGET(13, 45):
; 1182 : 		case ITEMGET(13, 46):
; 1183 : 		case ITEMGET(13, 47):
; 1184 : 		case ITEMGET(13, 48):
; 1185 : 		case ITEMGET(13, 93):
; 1186 : 		case ITEMGET(13, 94):
; 1187 : 		case ITEMGET(13, 69):
; 1188 : 		case ITEMGET(13, 70):
; 1189 : 		case ITEMGET(13, 76):
; 1190 : 		case ITEMGET(13, 77):
; 1191 : 		case ITEMGET(13, 78):
; 1192 : 		case ITEMGET(13, 163):
; 1193 : 		case ITEMGET(13, 164):
; 1194 : 		case ITEMGET(13, 165):
; 1195 : 		case ITEMGET(13, 166):
; 1196 : 		case ITEMGET(14, 60):
; 1197 : 		case ITEMGET(14, 54):
; 1198 : 		case ITEMGET(14, 53):
; 1199 : 		case ITEMGET(13, 62):
; 1200 : 		case ITEMGET(13, 63):
; 1201 : 		case ITEMGET(13, 64):
; 1202 : 		case ITEMGET(13, 65):
; 1203 : 		case ITEMGET(13, 106):
; 1204 : 		case ITEMGET(13, 122):
; 1205 : 		case ITEMGET(13, 123):
; 1206 : 		case ITEMGET(14, 58):
; 1207 : 		case ITEMGET(14, 59):
; 1208 : 		case ITEMGET(14, 61): 
; 1209 : 		case ITEMGET(14, 62): 
; 1210 : 		case ITEMGET(14, 70):
; 1211 : 		case ITEMGET(14, 71):
; 1212 : 		case ITEMGET(14, 72):
; 1213 : 		case ITEMGET(14, 73):
; 1214 : 		case ITEMGET(14, 74):
; 1215 : 		case ITEMGET(14, 75):
; 1216 : 		case ITEMGET(14, 76):
; 1217 : 		case ITEMGET(14, 77):
; 1218 : 		case ITEMGET(14, 78):
; 1219 : 		case ITEMGET(14, 79):
; 1220 : 		case ITEMGET(14, 80):
; 1221 : 		case ITEMGET(14, 81):
; 1222 : 		case ITEMGET(14, 82): 
; 1223 : 		case ITEMGET(14, 83):
; 1224 : 		case ITEMGET(14, 94):
; 1225 : 		case ITEMGET(14, 96):
; 1226 : 		case ITEMGET(14, 97):
; 1227 : 		case ITEMGET(14, 98):
; 1228 : 		case ITEMGET(14, 162):
; 1229 : 		case ITEMGET(14, 163):
; 1230 : 			return TRUE;

  00044	b8 01 00 00 00	 mov	 eax, 1

; 1233 : }

  00049	5d		 pop	 ebp
  0004a	c3		 ret	 0
$LN2@IsCashItem:

; 1231 : 	}
; 1232 : 	return FALSE;

  0004b	33 c0		 xor	 eax, eax

; 1233 : }

  0004d	5d		 pop	 ebp
  0004e	c3		 ret	 0
  0004f	90		 npad	 1
$LN9@IsCashItem:
  00050	00 00 00 00	 DD	 $LN1@IsCashItem
  00054	00 00 00 00	 DD	 $LN2@IsCashItem
$LN7@IsCashItem:
  00058	00		 DB	 0
  00059	00		 DB	 0
  0005a	00		 DB	 0
  0005b	00		 DB	 0
  0005c	00		 DB	 0
  0005d	00		 DB	 0
  0005e	01		 DB	 1
  0005f	01		 DB	 1
  00060	01		 DB	 1
  00061	01		 DB	 1
  00062	01		 DB	 1
  00063	00		 DB	 0
  00064	00		 DB	 0
  00065	00		 DB	 0
  00066	00		 DB	 0
  00067	00		 DB	 0
  00068	00		 DB	 0
  00069	00		 DB	 0
  0006a	00		 DB	 0
  0006b	00		 DB	 0
  0006c	00		 DB	 0
  0006d	00		 DB	 0
  0006e	00		 DB	 0
  0006f	01		 DB	 1
  00070	01		 DB	 1
  00071	01		 DB	 1
  00072	00		 DB	 0
  00073	00		 DB	 0
  00074	01		 DB	 1
  00075	01		 DB	 1
  00076	01		 DB	 1
  00077	01		 DB	 1
  00078	01		 DB	 1
  00079	00		 DB	 0
  0007a	00		 DB	 0
  0007b	00		 DB	 0
  0007c	01		 DB	 1
  0007d	01		 DB	 1
  0007e	01		 DB	 1
  0007f	01		 DB	 1
  00080	01		 DB	 1
  00081	01		 DB	 1
  00082	01		 DB	 1
  00083	01		 DB	 1
  00084	01		 DB	 1
  00085	01		 DB	 1
  00086	01		 DB	 1
  00087	01		 DB	 1
  00088	01		 DB	 1
  00089	01		 DB	 1
  0008a	00		 DB	 0
  0008b	00		 DB	 0
  0008c	01		 DB	 1
  0008d	01		 DB	 1
  0008e	01		 DB	 1
  0008f	01		 DB	 1
  00090	01		 DB	 1
  00091	01		 DB	 1
  00092	01		 DB	 1
  00093	01		 DB	 1
  00094	01		 DB	 1
  00095	01		 DB	 1
  00096	01		 DB	 1
  00097	00		 DB	 0
  00098	01		 DB	 1
  00099	01		 DB	 1
  0009a	01		 DB	 1
  0009b	01		 DB	 1
  0009c	01		 DB	 1
  0009d	01		 DB	 1
  0009e	01		 DB	 1
  0009f	01		 DB	 1
  000a0	01		 DB	 1
  000a1	01		 DB	 1
  000a2	01		 DB	 1
  000a3	01		 DB	 1
  000a4	01		 DB	 1
  000a5	01		 DB	 1
  000a6	01		 DB	 1
  000a7	00		 DB	 0
  000a8	00		 DB	 0
  000a9	8d 49 00	 npad	 3
$LN10@IsCashItem:
  000ac	00 00 00 00	 DD	 $LN1@IsCashItem
  000b0	00 00 00 00	 DD	 $LN2@IsCashItem
$LN8@IsCashItem:
  000b4	00		 DB	 0
  000b5	00		 DB	 0
  000b6	01		 DB	 1
  000b7	01		 DB	 1
  000b8	01		 DB	 1
  000b9	00		 DB	 0
  000ba	00		 DB	 0
  000bb	00		 DB	 0
  000bc	00		 DB	 0
  000bd	00		 DB	 0
  000be	01		 DB	 1
  000bf	01		 DB	 1
  000c0	01		 DB	 1
  000c1	01		 DB	 1
  000c2	01		 DB	 1
  000c3	01		 DB	 1
  000c4	01		 DB	 1
  000c5	00		 DB	 0
  000c6	00		 DB	 0
  000c7	00		 DB	 0
  000c8	00		 DB	 0
  000c9	00		 DB	 0
  000ca	00		 DB	 0
  000cb	00		 DB	 0
  000cc	00		 DB	 0
  000cd	00		 DB	 0
  000ce	00		 DB	 0
  000cf	00		 DB	 0
  000d0	00		 DB	 0
  000d1	00		 DB	 0
  000d2	00		 DB	 0
  000d3	01		 DB	 1
  000d4	01		 DB	 1
  000d5	01		 DB	 1
  000d6	01		 DB	 1
  000d7	01		 DB	 1
  000d8	01		 DB	 1
  000d9	01		 DB	 1
  000da	01		 DB	 1
  000db	01		 DB	 1
  000dc	01		 DB	 1
  000dd	00		 DB	 0
  000de	01		 DB	 1
  000df	00		 DB	 0
  000e0	00		 DB	 0
  000e1	00		 DB	 0
  000e2	01		 DB	 1
  000e3	01		 DB	 1
  000e4	01		 DB	 1
  000e5	01		 DB	 1
  000e6	01		 DB	 1
  000e7	01		 DB	 1
  000e8	01		 DB	 1
  000e9	01		 DB	 1
  000ea	01		 DB	 1
  000eb	01		 DB	 1
  000ec	01		 DB	 1
  000ed	01		 DB	 1
  000ee	01		 DB	 1
  000ef	01		 DB	 1
  000f0	01		 DB	 1
  000f1	01		 DB	 1
  000f2	01		 DB	 1
  000f3	01		 DB	 1
  000f4	01		 DB	 1
  000f5	01		 DB	 1
  000f6	01		 DB	 1
  000f7	01		 DB	 1
  000f8	01		 DB	 1
  000f9	01		 DB	 1
  000fa	01		 DB	 1
  000fb	01		 DB	 1
  000fc	01		 DB	 1
  000fd	01		 DB	 1
  000fe	01		 DB	 1
  000ff	01		 DB	 1
  00100	01		 DB	 1
  00101	01		 DB	 1
  00102	01		 DB	 1
  00103	01		 DB	 1
  00104	01		 DB	 1
  00105	01		 DB	 1
  00106	01		 DB	 1
  00107	01		 DB	 1
  00108	01		 DB	 1
  00109	01		 DB	 1
  0010a	01		 DB	 1
  0010b	01		 DB	 1
  0010c	01		 DB	 1
  0010d	01		 DB	 1
  0010e	01		 DB	 1
  0010f	01		 DB	 1
  00110	01		 DB	 1
  00111	01		 DB	 1
  00112	01		 DB	 1
  00113	01		 DB	 1
  00114	01		 DB	 1
  00115	01		 DB	 1
  00116	01		 DB	 1
  00117	01		 DB	 1
  00118	01		 DB	 1
  00119	01		 DB	 1
  0011a	01		 DB	 1
  0011b	01		 DB	 1
  0011c	01		 DB	 1
  0011d	01		 DB	 1
  0011e	01		 DB	 1
  0011f	01		 DB	 1
  00120	01		 DB	 1
  00121	00		 DB	 0
  00122	00		 DB	 0
?IsCashItem@@YAHH@Z ENDP				; IsCashItem
_TEXT	ENDS
PUBLIC	?IsCashSpecialItem@@YAHH@Z			; IsCashSpecialItem
; Function compile flags: /Ogtp
;	COMDAT ?IsCashSpecialItem@@YAHH@Z
_TEXT	SEGMENT
_ItemType$ = 8						; size = 4
?IsCashSpecialItem@@YAHH@Z PROC				; IsCashSpecialItem, COMDAT

; 1236 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1237 : 	switch( ItemType )

  00003	8b 45 08	 mov	 eax, DWORD PTR _ItemType$[ebp]
  00006	3d 36 1c 00 00	 cmp	 eax, 7222		; 00001c36H
  0000b	7f 17		 jg	 SHORT $LN7@IsCashSpec
  0000d	74 20		 je	 SHORT $LN2@IsCashSpec
  0000f	3d 40 1a 00 00	 cmp	 eax, 6720		; 00001a40H
  00014	7c 15		 jl	 SHORT $LN1@IsCashSpec
  00016	3d 41 1a 00 00	 cmp	 eax, 6721		; 00001a41H
  0001b	7e 12		 jle	 SHORT $LN2@IsCashSpec
  0001d	3d 7b 1a 00 00	 cmp	 eax, 6779		; 00001a7bH
  00022	eb 05		 jmp	 SHORT $LN8@IsCashSpec
$LN7@IsCashSpec:
  00024	3d 60 1c 00 00	 cmp	 eax, 7264		; 00001c60H
$LN8@IsCashSpec:
  00029	74 04		 je	 SHORT $LN2@IsCashSpec
$LN1@IsCashSpec:

; 1245 : 	default:
; 1246 : 		return false;

  0002b	33 c0		 xor	 eax, eax

; 1247 : 	}
; 1248 : }

  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
$LN2@IsCashSpec:

; 1238 : 	{
; 1239 : 	case ITEMGET(13,64):
; 1240 : 	case ITEMGET(13,65):
; 1241 : 	case ITEMGET(14,54):
; 1242 : 	case ITEMGET(14,96):
; 1243 : 	case ITEMGET(13,123):
; 1244 : 		return true;

  0002f	b8 01 00 00 00	 mov	 eax, 1

; 1247 : 	}
; 1248 : }

  00034	5d		 pop	 ebp
  00035	c3		 ret	 0
?IsCashSpecialItem@@YAHH@Z ENDP				; IsCashSpecialItem
_TEXT	ENDS
PUBLIC	??8?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> > >::operator==
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??8?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> > >::operator==, COMDAT
; _this$ = ecx

; 316  : 		{	// test for iterator equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 317  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 318  : 		if (this->_Getcont() == 0
; 319  : 			|| this->_Getcont() != _Right._Getcont())
; 320  : 			{	// report error
; 321  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 322  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 323  : 			}
; 324  : 
; 325  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 326  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 327  : 			&& this->_Getcont() == _Right._Getcont());
; 328  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 329  : 
; 330  : 		return (this->_Ptr == _Right._Ptr);

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00008	33 c9		 xor	 ecx, ecx
  0000a	3b 02		 cmp	 eax, DWORD PTR [edx]
  0000c	0f 94 c0	 sete	 al

; 331  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??8?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> > >::operator==
_TEXT	ENDS
PUBLIC	??R?$less@H@std@@QBE_NABH0@Z			; std::less<int>::operator()
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xfunctional
;	COMDAT ??R?$less@H@std@@QBE_NABH0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??R?$less@H@std@@QBE_NABH0@Z PROC			; std::less<int>::operator(), COMDAT
; _this$ = ecx

; 124  : 		{	// apply operator< to operands

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 125  : 		return (_Left < _Right);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  00006	8b 08		 mov	 ecx, DWORD PTR [eax]
  00008	8b 55 0c	 mov	 edx, DWORD PTR __Right$[ebp]
  0000b	33 c0		 xor	 eax, eax
  0000d	3b 0a		 cmp	 ecx, DWORD PTR [edx]
  0000f	0f 9c c0	 setl	 al

; 126  : 		}

  00012	5d		 pop	 ebp
  00013	c2 08 00	 ret	 8
??R?$less@H@std@@QBE_NABH0@Z ENDP			; std::less<int>::operator()
_TEXT	ENDS
PUBLIC	?_Color@?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::_Color
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ?_Color@?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Color@?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::_Color, COMDAT

; 606  : 		{	// return reference to color in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 607  : 		return ((char&)(*_Pnode)._Color);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 14	 add	 eax, 20			; 00000014H

; 608  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Color@?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::_Color
_TEXT	ENDS
PUBLIC	?_Isnil@?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::_Isnil
; Function compile flags: /Ogtp
;	COMDAT ?_Isnil@?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Isnil@?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::_Isnil, COMDAT

; 611  : 		{	// return reference to nil flag in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 612  : 		return ((char&)(*_Pnode)._Isnil);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 15	 add	 eax, 21			; 00000015H

; 613  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Isnil@?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@SAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::_Isnil
_TEXT	ENDS
PUBLIC	?_Left@?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::_Left
; Function compile flags: /Ogtp
;	COMDAT ?_Left@?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Left@?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::_Left, COMDAT

; 621  : 		{	// return reference to left pointer in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 622  : 		return ((_Nodepref)(*_Pnode)._Left);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]

; 623  : 		}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
?_Left@?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::_Left
_TEXT	ENDS
PUBLIC	?_Parent@?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::_Parent
; Function compile flags: /Ogtp
;	COMDAT ?_Parent@?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Parent@?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::_Parent, COMDAT

; 626  : 		{	// return reference to parent pointer in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 627  : 		return ((_Nodepref)(*_Pnode)._Parent);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 04	 add	 eax, 4

; 628  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Parent@?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::_Parent
_TEXT	ENDS
PUBLIC	?_Right@?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::_Right
; Function compile flags: /Ogtp
;	COMDAT ?_Right@?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Right@?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::_Right, COMDAT

; 631  : 		{	// return reference to right pointer in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 632  : 		return ((_Nodepref)(*_Pnode)._Right);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 08	 add	 eax, 8

; 633  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Right@?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@SAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::_Right
_TEXT	ENDS
PUBLIC	?_Myval@?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@SAAAU?$pair@$$CBHPAUOBJECTSTRUCT@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::_Myval
; Function compile flags: /Ogtp
;	COMDAT ?_Myval@?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@SAAAU?$pair@$$CBHPAUOBJECTSTRUCT@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Myval@?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@SAAAU?$pair@$$CBHPAUOBJECTSTRUCT@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::_Myval, COMDAT

; 636  : 		{	// return reference to value in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 637  : 		return ((reference)(*_Pnode)._Myval);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 0c	 add	 eax, 12			; 0000000cH

; 638  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Myval@?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@SAAAU?$pair@$$CBHPAUOBJECTSTRUCT@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::_Myval
_TEXT	ENDS
PUBLIC	?_Max@?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::_Max
; Function compile flags: /Ogtp
;	COMDAT ?_Max@?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Max@?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::_Max, COMDAT

; 641  : 		{	// return rightmost node in subtree at _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 642  : 		while (!_Isnil(_Right(_Pnode)))

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00009	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  0000d	75 0c		 jne	 SHORT $LN1@Max
  0000f	90		 npad	 1
$LL2@Max:

; 643  : 			_Pnode = _Right(_Pnode);

  00010	8b c1		 mov	 eax, ecx
  00012	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00015	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  00019	74 f5		 je	 SHORT $LL2@Max
$LN1@Max:

; 644  : 		return (_Pnode);
; 645  : 		}

  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
?_Max@?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::_Max
_TEXT	ENDS
PUBLIC	?_Min@?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::_Min
; Function compile flags: /Ogtp
;	COMDAT ?_Min@?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Min@?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::_Min, COMDAT

; 648  : 		{	// return leftmost node in subtree at _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 649  : 		while (!_Isnil(_Left(_Pnode)))

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	8b 08		 mov	 ecx, DWORD PTR [eax]
  00008	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  0000c	75 0c		 jne	 SHORT $LN1@Min
  0000e	8b ff		 npad	 2
$LL2@Min:

; 650  : 			_Pnode = _Left(_Pnode);

  00010	8b c1		 mov	 eax, ecx
  00012	8b 08		 mov	 ecx, DWORD PTR [eax]
  00014	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  00018	74 f6		 je	 SHORT $LL2@Min
$LN1@Min:

; 651  : 		return (_Pnode);
; 652  : 		}

  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
?_Min@?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::_Min
_TEXT	ENDS
PUBLIC	??0?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@std@@QAE@XZ ; std::allocator<std::pair<int const ,OBJECTSTRUCT *> >::allocator<std::pair<int const ,OBJECTSTRUCT *> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??0?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@std@@QAE@XZ PROC ; std::allocator<std::pair<int const ,OBJECTSTRUCT *> >::allocator<std::pair<int const ,OBJECTSTRUCT *> >, COMDAT
; _this$ = ecx

; 161  : 	_ALLOCATOR() _THROW0()

  00000	8b c1		 mov	 eax, ecx

; 162  : 		{	// construct default allocator (do nothing)
; 163  : 		}

  00002	c3		 ret	 0
??0?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@std@@QAE@XZ ENDP ; std::allocator<std::pair<int const ,OBJECTSTRUCT *> >::allocator<std::pair<int const ,OBJECTSTRUCT *> >
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::_Node>::deallocate
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Ogtp
;	COMDAT ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@2@I@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::_Node>::deallocate, COMDAT
; _this$ = ecx

; 181  : 		{	// deallocate object at _Ptr, ignore size

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 182  : 		::operator delete(_Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000c	83 c4 04	 add	 esp, 4

; 183  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 08 00	 ret	 8
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::_Node>::deallocate
_TEXT	ENDS
PUBLIC	?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >,std::_Iterator_base0>::_Mynode
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@2@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >,std::_Iterator_base0>::_Mynode, COMDAT
; _this$ = ecx

; 122  : 		return (_Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 123  : 		}

  00002	c3		 ret	 0
?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >,std::_Iterator_base0>::_Mynode
_TEXT	ENDS
PUBLIC	??0?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<int const ,OBJECTSTRUCT *> >::allocator<std::pair<int const ,OBJECTSTRUCT *> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??0?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@std@@QAE@ABV01@@Z PROC ; std::allocator<std::pair<int const ,OBJECTSTRUCT *> >::allocator<std::pair<int const ,OBJECTSTRUCT *> >, COMDAT
; _this$ = ecx

; 165  : 	_ALLOCATOR(const _ALLOCATOR<_Ty>&) _THROW0()

  00000	8b c1		 mov	 eax, ecx

; 166  : 		{	// construct by copying (do nothing)
; 167  : 		}

  00002	c2 04 00	 ret	 4
??0?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<std::pair<int const ,OBJECTSTRUCT *> >::allocator<std::pair<int const ,OBJECTSTRUCT *> >
_TEXT	ENDS
PUBLIC	??D?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@std@@QBEABU?$pair@$$CBHPAUOBJECTSTRUCT@@@1@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> > >::operator*
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??D?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@std@@QBEABU?$pair@$$CBHPAUOBJECTSTRUCT@@@1@XZ
_TEXT	SEGMENT
??D?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@std@@QBEABU?$pair@$$CBHPAUOBJECTSTRUCT@@@1@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> > >::operator*, COMDAT
; _this$ = ecx

; 231  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 232  : 		if (this->_Getcont() == 0
; 233  : 			|| this->_Ptr == 0
; 234  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 235  : 			{	// report error
; 236  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 237  : 			_SCL_SECURE_OUT_OF_RANGE;
; 238  : 			}
; 239  : 
; 240  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 241  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 242  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 243  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 244  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 245  : 
; 246  : 		return (_Mytree::_Myval(this->_Ptr));

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 0c	 add	 eax, 12			; 0000000cH

; 247  : 		}

  00005	c3		 ret	 0
??D?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@std@@QBEABU?$pair@$$CBHPAUOBJECTSTRUCT@@@1@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> > >::operator*
_TEXT	ENDS
PUBLIC	??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >,std::_Iterator_base0>
; Function compile flags: /Ogtp
;	COMDAT ??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >,std::_Iterator_base0>, COMDAT
; _this$ = ecx

; 38   : 		{	// construct with null node pointer

  00000	8b c1		 mov	 eax, ecx
  00002	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 39   : 		}

  00008	c3		 ret	 0
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >,std::_Iterator_base0>
_TEXT	ENDS
PUBLIC	??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >,std::_Iterator_base0>::operator++
; Function compile flags: /Ogtp
;	COMDAT ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >,std::_Iterator_base0>::operator++, COMDAT
; _this$ = ecx

; 58   : 		{	// preincrement

  00000	8b c1		 mov	 eax, ecx

; 59   : 		if (_Mytree::_Isnil(_Ptr))

  00002	8b 10		 mov	 edx, DWORD PTR [eax]
  00004	80 7a 15 00	 cmp	 BYTE PTR [edx+21], 0
  00008	75 40		 jne	 SHORT $LN3@operator

; 60   : 			;	// end() shouldn't be incremented, don't move
; 61   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))

  0000a	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  0000d	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  00011	75 1a		 jne	 SHORT $LN34@operator

; 62   : 			_Ptr = _Mytree::_Min(
; 63   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree

  00013	8b 11		 mov	 edx, DWORD PTR [ecx]
  00015	80 7a 15 00	 cmp	 BYTE PTR [edx+21], 0
  00019	75 0f		 jne	 SHORT $LN17@operator
  0001b	eb 03 8d 49 00	 npad	 5
$LL18@operator:
  00020	8b ca		 mov	 ecx, edx
  00022	8b 11		 mov	 edx, DWORD PTR [ecx]
  00024	80 7a 15 00	 cmp	 BYTE PTR [edx+21], 0
  00028	74 f6		 je	 SHORT $LL18@operator
$LN17@operator:
  0002a	89 08		 mov	 DWORD PTR [eax], ecx

; 71   : 			}
; 72   : 		return (*this);
; 73   : 		}

  0002c	c3		 ret	 0
$LN34@operator:

; 64   : 		else
; 65   : 			{	// climb looking for right subtree
; 66   : 			_Nodeptr _Pnode;
; 67   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 68   : 				&& _Ptr == _Mytree::_Right(_Pnode))

  0002d	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  00030	80 7a 15 00	 cmp	 BYTE PTR [edx+21], 0
  00034	75 12		 jne	 SHORT $LN1@operator
$LL2@operator:
  00036	8b 08		 mov	 ecx, DWORD PTR [eax]
  00038	3b 4a 08	 cmp	 ecx, DWORD PTR [edx+8]
  0003b	75 0b		 jne	 SHORT $LN1@operator

; 69   : 				_Ptr = _Pnode;	// ==> parent while right subtree

  0003d	89 10		 mov	 DWORD PTR [eax], edx
  0003f	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  00042	80 7a 15 00	 cmp	 BYTE PTR [edx+21], 0
  00046	74 ee		 je	 SHORT $LL2@operator
$LN1@operator:

; 70   : 			_Ptr = _Pnode;	// ==> parent (head if end())

  00048	89 10		 mov	 DWORD PTR [eax], edx
$LN3@operator:

; 71   : 			}
; 72   : 		return (*this);
; 73   : 		}

  0004a	c3		 ret	 0
??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >,std::_Iterator_base0>::operator++
_TEXT	ENDS
PUBLIC	??9?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> > >::operator!=
; Function compile flags: /Ogtp
;	COMDAT ??9?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> > >::operator!=, COMDAT
; _this$ = ecx

; 334  : 		{	// test for iterator inequality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 335  : 		return (!(*this == _Right));

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00008	33 c9		 xor	 ecx, ecx
  0000a	3b 02		 cmp	 eax, DWORD PTR [edx]
  0000c	0f 95 c0	 setne	 al

; 336  : 		}

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
??9?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> > >::operator!=
_TEXT	ENDS
PUBLIC	??0?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@QAE@U?$less@H@1@@Z ; std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0>::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\map
;	COMDAT ??0?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@QAE@U?$less@H@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 1
??0?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@QAE@U?$less@H@1@@Z PROC ; std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0>::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0>, COMDAT
; _this$ = ecx

; 40   : 		{	// construct with specified comparator

  00000	8b c1		 mov	 eax, ecx

; 41   : 		}

  00002	c2 04 00	 ret	 4
??0?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@QAE@U?$less@H@1@@Z ENDP ; std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0>::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0>
_TEXT	ENDS
PUBLIC	??$addressof@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@std@@YAPAU?$pair@$$CBHPAUOBJECTSTRUCT@@@0@AAU10@@Z ; std::addressof<std::pair<int const ,OBJECTSTRUCT *> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$addressof@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@std@@YAPAU?$pair@$$CBHPAUOBJECTSTRUCT@@@0@AAU10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@std@@YAPAU?$pair@$$CBHPAUOBJECTSTRUCT@@@0@AAU10@@Z PROC ; std::addressof<std::pair<int const ,OBJECTSTRUCT *> >, COMDAT

; 110  : 	{	// return address of _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 111  : 	return ((_Ty *) &(char&)_Val);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 112  : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@std@@YAPAU?$pair@$$CBHPAUOBJECTSTRUCT@@@0@AAU10@@Z ENDP ; std::addressof<std::pair<int const ,OBJECTSTRUCT *> >
_TEXT	ENDS
PUBLIC	??$_Kfn@$$CBHPAUOBJECTSTRUCT@@@?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@SAABHABU?$pair@$$CBHPAUOBJECTSTRUCT@@@1@@Z ; std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0>::_Kfn<int const ,OBJECTSTRUCT *>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\map
;	COMDAT ??$_Kfn@$$CBHPAUOBJECTSTRUCT@@@?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@SAABHABU?$pair@$$CBHPAUOBJECTSTRUCT@@@1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$_Kfn@$$CBHPAUOBJECTSTRUCT@@@?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@SAABHABU?$pair@$$CBHPAUOBJECTSTRUCT@@@1@@Z PROC ; std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0>::_Kfn<int const ,OBJECTSTRUCT *>, COMDAT

; 66   : 		static const _Kty& _Kfn(const _STD pair<_Ty1, _Ty2>& _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 67   : 		{	// extract key from element value
; 68   : 		return (_Val.first);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 69   : 		}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Kfn@$$CBHPAUOBJECTSTRUCT@@@?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@SAABHABU?$pair@$$CBHPAUOBJECTSTRUCT@@@1@@Z ENDP ; std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0>::_Kfn<int const ,OBJECTSTRUCT *>
_TEXT	ENDS
PUBLIC	??$?0U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::_Node><std::pair<int const ,OBJECTSTRUCT *> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$?0U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??$?0U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@1@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::_Node><std::pair<int const ,OBJECTSTRUCT *> >, COMDAT
; _this$ = ecx

; 170  : 		_ALLOCATOR(const _ALLOCATOR<_Other>&) _THROW0()

  00000	8b c1		 mov	 eax, ecx

; 171  : 		{	// construct from a related allocator (do nothing)
; 172  : 		}

  00002	c2 04 00	 ret	 4
??$?0U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@1@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::_Node><std::pair<int const ,OBJECTSTRUCT *> >
_TEXT	ENDS
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??0bad_alloc@std@@QAE@PBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
EXTRN	??0exception@std@@QAE@ABQBD@Z:PROC		; std::exception::exception
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R2exception@std@@8
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\exception
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@PBD@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0bad_alloc@std@@QAE@PBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 345  : 		{	// construct from message string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8d 45 08	 lea	 eax, DWORD PTR __Message$[ebp]
  00007	50		 push	 eax
  00008	8b f1		 mov	 esi, ecx
  0000a	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  0000f	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@

; 346  : 		}

  00015	8b c6		 mov	 eax, esi
  00017	5e		 pop	 esi
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@PBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
EXTRN	??1exception@std@@UAE@XZ:PROC			; std::exception::~exception
; Function compile flags: /Ogtp
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 354  : 		{	// destroy the object

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@

; 355  : 		}

  00006	e9 00 00 00 00	 jmp	 ??1exception@std@@UAE@XZ ; std::exception::~exception
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
  0000c	e8 00 00 00 00	 call	 ??1exception@std@@UAE@XZ ; std::exception::~exception
  00011	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  00015	74 09		 je	 SHORT $LN6@scalar
  00017	56		 push	 esi
  00018	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0001d	83 c4 04	 add	 esp, 4
$LN6@scalar:
  00020	8b c6		 mov	 eax, esi
  00022	5e		 pop	 esi
  00023	5d		 pop	 ebp
  00024	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@std@@QBEIXZ ; std::allocator<std::pair<int const ,OBJECTSTRUCT *> >::max_size
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?max_size@?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@std@@QBEIXZ PROC ; std::allocator<std::pair<int const ,OBJECTSTRUCT *> >::max_size, COMDAT
; _this$ = ecx

; 218  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 219  : 		return (0 < _Count ? _Count : 1);

  00000	b8 ff ff ff 1f	 mov	 eax, 536870911		; 1fffffffH

; 220  : 		}

  00005	c3		 ret	 0
?max_size@?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@std@@QBEIXZ ENDP ; std::allocator<std::pair<int const ,OBJECTSTRUCT *> >::max_size
_TEXT	ENDS
PUBLIC	??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >,std::_Iterator_base0>::operator--
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >,std::_Iterator_base0>::operator--, COMDAT
; _this$ = ecx

; 83   : 		{	// predecrement

  00000	8b c1		 mov	 eax, ecx

; 84   : 		if (_Mytree::_Isnil(_Ptr))

  00002	8b 08		 mov	 ecx, DWORD PTR [eax]
  00004	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  00008	74 06		 je	 SHORT $LN8@operator@2

; 85   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost

  0000a	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx

; 99   : 			}
; 100  : 		return (*this);
; 101  : 		}

  0000f	c3		 ret	 0
$LN8@operator@2:

; 86   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))

  00010	8b 11		 mov	 edx, DWORD PTR [ecx]
  00012	80 7a 15 00	 cmp	 BYTE PTR [edx+21], 0
  00016	75 17		 jne	 SHORT $LN40@operator@2

; 87   : 			_Ptr = _Mytree::_Max(
; 88   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree

  00018	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  0001b	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  0001f	75 30		 jne	 SHORT $LN21@operator@2
$LL22@operator@2:
  00021	8b d1		 mov	 edx, ecx
  00023	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  00026	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  0002a	74 f5		 je	 SHORT $LL22@operator@2

; 96   : 				;	// begin() shouldn't be decremented, don't move
; 97   : 			else
; 98   : 				_Ptr = _Pnode;	// ==> parent if not head

  0002c	89 10		 mov	 DWORD PTR [eax], edx

; 99   : 			}
; 100  : 		return (*this);
; 101  : 		}

  0002e	c3		 ret	 0
$LN40@operator@2:

; 89   : 		else
; 90   : 			{	// climb looking for left subtree
; 91   : 			_Nodeptr _Pnode;
; 92   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 93   : 				&& _Ptr == _Mytree::_Left(_Pnode))

  0002f	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00032	80 7a 15 00	 cmp	 BYTE PTR [edx+21], 0
  00036	75 11		 jne	 SHORT $LN3@operator@2
$LL4@operator@2:
  00038	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003a	3b 0a		 cmp	 ecx, DWORD PTR [edx]
  0003c	75 0b		 jne	 SHORT $LN3@operator@2

; 94   : 				_Ptr = _Pnode;	// ==> parent while left subtree

  0003e	89 10		 mov	 DWORD PTR [eax], edx
  00040	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  00043	80 7a 15 00	 cmp	 BYTE PTR [edx+21], 0
  00047	74 ef		 je	 SHORT $LL4@operator@2
$LN3@operator@2:

; 95   : 			if (_Mytree::_Isnil(_Ptr))

  00049	8b 08		 mov	 ecx, DWORD PTR [eax]
  0004b	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  0004f	75 02		 jne	 SHORT $LN1@operator@2

; 87   : 			_Ptr = _Mytree::_Max(
; 88   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree

$LN21@operator@2:

; 96   : 				;	// begin() shouldn't be decremented, don't move
; 97   : 			else
; 98   : 				_Ptr = _Pnode;	// ==> parent if not head

  00051	89 10		 mov	 DWORD PTR [eax], edx
$LN1@operator@2:

; 99   : 			}
; 100  : 		return (*this);
; 101  : 		}

  00053	c3		 ret	 0
??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >,std::_Iterator_base0>::operator--
_TEXT	ENDS
PUBLIC	??$forward@AAH@std@@YAAAHAAH@Z			; std::forward<int &>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$forward@AAH@std@@YAAAHAAH@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAH@std@@YAAAHAAH@Z PROC			; std::forward<int &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAH@std@@YAAAHAAH@Z ENDP			; std::forward<int &>
_TEXT	ENDS
PUBLIC	??$forward@AAPAUOBJECTSTRUCT@@@std@@YAAAPAUOBJECTSTRUCT@@AAPAU1@@Z ; std::forward<OBJECTSTRUCT * &>
; Function compile flags: /Ogtp
;	COMDAT ??$forward@AAPAUOBJECTSTRUCT@@@std@@YAAAPAUOBJECTSTRUCT@@AAPAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAUOBJECTSTRUCT@@@std@@YAAAPAUOBJECTSTRUCT@@AAPAU1@@Z PROC ; std::forward<OBJECTSTRUCT * &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAPAUOBJECTSTRUCT@@@std@@YAAAPAUOBJECTSTRUCT@@AAPAU1@@Z ENDP ; std::forward<OBJECTSTRUCT * &>
_TEXT	ENDS
PUBLIC	??$?0AAHAAPAUOBJECTSTRUCT@@@?$_Pair_base@HPAUOBJECTSTRUCT@@@std@@QAE@AAHAAPAUOBJECTSTRUCT@@@Z ; std::_Pair_base<int,OBJECTSTRUCT *>::_Pair_base<int,OBJECTSTRUCT *><int &,OBJECTSTRUCT * &>
; Function compile flags: /Ogtp
;	COMDAT ??$?0AAHAAPAUOBJECTSTRUCT@@@?$_Pair_base@HPAUOBJECTSTRUCT@@@std@@QAE@AAHAAPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAHAAPAUOBJECTSTRUCT@@@?$_Pair_base@HPAUOBJECTSTRUCT@@@std@@QAE@AAHAAPAUOBJECTSTRUCT@@@Z PROC ; std::_Pair_base<int,OBJECTSTRUCT *>::_Pair_base<int,OBJECTSTRUCT *><int &,OBJECTSTRUCT * &>, COMDAT
; _this$ = ecx

; 163  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Val1$[ebp]
  00008	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Val2$[ebp]
  0000d	89 10		 mov	 DWORD PTR [eax], edx
  0000f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00011	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 164  : 		}

  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
??$?0AAHAAPAUOBJECTSTRUCT@@@?$_Pair_base@HPAUOBJECTSTRUCT@@@std@@QAE@AAHAAPAUOBJECTSTRUCT@@@Z ENDP ; std::_Pair_base<int,OBJECTSTRUCT *>::_Pair_base<int,OBJECTSTRUCT *><int &,OBJECTSTRUCT * &>
_TEXT	ENDS
PUBLIC	??$forward@U?$pair@HPAUOBJECTSTRUCT@@@std@@@std@@YA$$QAU?$pair@HPAUOBJECTSTRUCT@@@0@AAU10@@Z ; std::forward<std::pair<int,OBJECTSTRUCT *> >
; Function compile flags: /Ogtp
;	COMDAT ??$forward@U?$pair@HPAUOBJECTSTRUCT@@@std@@@std@@YA$$QAU?$pair@HPAUOBJECTSTRUCT@@@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@U?$pair@HPAUOBJECTSTRUCT@@@std@@@std@@YA$$QAU?$pair@HPAUOBJECTSTRUCT@@@0@AAU10@@Z PROC ; std::forward<std::pair<int,OBJECTSTRUCT *> >, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@U?$pair@HPAUOBJECTSTRUCT@@@std@@@std@@YA$$QAU?$pair@HPAUOBJECTSTRUCT@@@0@AAU10@@Z ENDP ; std::forward<std::pair<int,OBJECTSTRUCT *> >
_TEXT	ENDS
PUBLIC	??$_Move@AAD@std@@YA$$QADAAD@Z			; std::_Move<char &>
; Function compile flags: /Ogtp
;	COMDAT ??$_Move@AAD@std@@YA$$QADAAD@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$_Move@AAD@std@@YA$$QADAAD@Z PROC			; std::_Move<char &>, COMDAT

; 94   : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 95   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 96   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Move@AAD@std@@YA$$QADAAD@Z ENDP			; std::_Move<char &>
_TEXT	ENDS
PUBLIC	??$_Destroy@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@std@@YAXPAU?$pair@$$CBHPAUOBJECTSTRUCT@@@0@@Z ; std::_Destroy<std::pair<int const ,OBJECTSTRUCT *> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Destroy@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@std@@YAXPAU?$pair@$$CBHPAUOBJECTSTRUCT@@@0@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@std@@YAXPAU?$pair@$$CBHPAUOBJECTSTRUCT@@@0@@Z PROC ; std::_Destroy<std::pair<int const ,OBJECTSTRUCT *> >, COMDAT

; 63   : 	_Ptr->~_Ty();
; 64   : 	}

  00000	c3		 ret	 0
??$_Destroy@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@std@@YAXPAU?$pair@$$CBHPAUOBJECTSTRUCT@@@0@@Z ENDP ; std::_Destroy<std::pair<int const ,OBJECTSTRUCT *> >
_TEXT	ENDS
PUBLIC	??$move@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@0@AAV10@@Z ; std::move<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> > > &>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$move@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@0@AAV10@@Z PROC ; std::move<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> > > &>, COMDAT

; 86   : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 87   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 88   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@std@@@std@@YA$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@0@AAV10@@Z ENDP ; std::move<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> > > &>
_TEXT	ENDS
PUBLIC	??$move@AA_N@std@@YA$$QA_NAA_N@Z		; std::move<bool &>
; Function compile flags: /Ogtp
;	COMDAT ??$move@AA_N@std@@YA$$QA_NAA_N@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AA_N@std@@YA$$QA_NAA_N@Z PROC			; std::move<bool &>, COMDAT

; 86   : 	{	// forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 87   : 	return ((typename tr1::_Remove_reference<_Ty>::_Type&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 88   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AA_N@std@@YA$$QA_NAA_N@Z ENDP			; std::move<bool &>
_TEXT	ENDS
PUBLIC	??$forward@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@0@AAV10@@Z ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> > > &>
; Function compile flags: /Ogtp
;	COMDAT ??$forward@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@0@AAV10@@Z PROC ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> > > &>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@std@@@std@@YAAAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@0@AAV10@@Z ENDP ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> > > &>
_TEXT	ENDS
PUBLIC	??$forward@_N@std@@YA$$QA_NAA_N@Z		; std::forward<bool>
; Function compile flags: /Ogtp
;	COMDAT ??$forward@_N@std@@YA$$QA_NAA_N@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@_N@std@@YA$$QA_NAA_N@Z PROC			; std::forward<bool>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@_N@std@@YA$$QA_NAA_N@Z ENDP			; std::forward<bool>
_TEXT	ENDS
PUBLIC	??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@std@@_N@?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> > > &,bool>
; Function compile flags: /Ogtp
;	COMDAT ??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@std@@_N@?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@std@@_N@?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z PROC ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> > > &,bool>, COMDAT
; _this$ = ecx

; 163  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Val1$[ebp]
  00008	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Val2$[ebp]
  0000d	89 10		 mov	 DWORD PTR [eax], edx
  0000f	8a 11		 mov	 dl, BYTE PTR [ecx]
  00011	88 50 04	 mov	 BYTE PTR [eax+4], dl

; 164  : 		}

  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@std@@_N@?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z ENDP ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> > > &,bool>
_TEXT	ENDS
PUBLIC	??$forward@H@std@@YA$$QAHAAH@Z			; std::forward<int>
; Function compile flags: /Ogtp
;	COMDAT ??$forward@H@std@@YA$$QAHAAH@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@H@std@@YA$$QAHAAH@Z PROC			; std::forward<int>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@H@std@@YA$$QAHAAH@Z ENDP			; std::forward<int>
_TEXT	ENDS
PUBLIC	??$forward@PAUOBJECTSTRUCT@@@std@@YA$$QAPAUOBJECTSTRUCT@@AAPAU1@@Z ; std::forward<OBJECTSTRUCT *>
; Function compile flags: /Ogtp
;	COMDAT ??$forward@PAUOBJECTSTRUCT@@@std@@YA$$QAPAUOBJECTSTRUCT@@AAPAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@PAUOBJECTSTRUCT@@@std@@YA$$QAPAUOBJECTSTRUCT@@AAPAU1@@Z PROC ; std::forward<OBJECTSTRUCT *>, COMDAT

; 78   : 	{	// forward _Arg, given explicitly specified type parameter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 79   : 	return ((_Ty&&)_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 80   : 	}

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@PAUOBJECTSTRUCT@@@std@@YA$$QAPAUOBJECTSTRUCT@@AAPAU1@@Z ENDP ; std::forward<OBJECTSTRUCT *>
_TEXT	ENDS
PUBLIC	??$?0HPAUOBJECTSTRUCT@@@?$_Pair_base@$$CBHPAUOBJECTSTRUCT@@@std@@QAE@$$QAH$$QAPAUOBJECTSTRUCT@@@Z ; std::_Pair_base<int const ,OBJECTSTRUCT *>::_Pair_base<int const ,OBJECTSTRUCT *><int,OBJECTSTRUCT *>
; Function compile flags: /Ogtp
;	COMDAT ??$?0HPAUOBJECTSTRUCT@@@?$_Pair_base@$$CBHPAUOBJECTSTRUCT@@@std@@QAE@$$QAH$$QAPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0HPAUOBJECTSTRUCT@@@?$_Pair_base@$$CBHPAUOBJECTSTRUCT@@@std@@QAE@$$QAH$$QAPAUOBJECTSTRUCT@@@Z PROC ; std::_Pair_base<int const ,OBJECTSTRUCT *>::_Pair_base<int const ,OBJECTSTRUCT *><int,OBJECTSTRUCT *>, COMDAT
; _this$ = ecx

; 163  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Val1$[ebp]
  00008	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Val2$[ebp]
  0000d	89 10		 mov	 DWORD PTR [eax], edx
  0000f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00011	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 164  : 		}

  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
??$?0HPAUOBJECTSTRUCT@@@?$_Pair_base@$$CBHPAUOBJECTSTRUCT@@@std@@QAE@$$QAH$$QAPAUOBJECTSTRUCT@@@Z ENDP ; std::_Pair_base<int const ,OBJECTSTRUCT *>::_Pair_base<int const ,OBJECTSTRUCT *><int,OBJECTSTRUCT *>
_TEXT	ENDS
PUBLIC	?_Adopt@_Iterator_base0@std@@QAEXPBX@Z		; std::_Iterator_base0::_Adopt
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
;	COMDAT ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z PROC		; std::_Iterator_base0::_Adopt, COMDAT
; _this$ = ecx

; 49   : 		}

  00000	c2 04 00	 ret	 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ENDP		; std::_Iterator_base0::_Adopt
_TEXT	ENDS
PUBLIC	??_EOBJECTSTRUCT@@QAEPAXI@Z			; OBJECTSTRUCT::`vector deleting destructor'
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	??_M@YGXPAXIHP6EX0@Z@Z:PROC			; `eh vector destructor iterator'
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??_EOBJECTSTRUCT@@QAEPAXI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??_EOBJECTSTRUCT@@QAEPAXI@Z$0
__ehfuncinfo$??_EOBJECTSTRUCT@@QAEPAXI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??_EOBJECTSTRUCT@@QAEPAXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
xdata$x	ENDS
;	COMDAT ??_EOBJECTSTRUCT@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_EOBJECTSTRUCT@@QAEPAXI@Z PROC			; OBJECTSTRUCT::`vector deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??_EOBJECTSTRUCT@@QAEPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	53		 push	 ebx
  00013	56		 push	 esi
  00014	57		 push	 edi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00026	8b f1		 mov	 esi, ecx
  00028	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  0002b	8a 5d 08	 mov	 bl, BYTE PTR ___flags$[ebp]
  0002e	f6 c3 02	 test	 bl, 2
  00031	74 3b		 je	 SHORT $LN3@vector
  00033	8b 46 fc	 mov	 eax, DWORD PTR [esi-4]
  00036	68 00 00 00 00	 push	 OFFSET ??1OBJECTSTRUCT@@QAE@XZ
  0003b	8d 7e fc	 lea	 edi, DWORD PTR [esi-4]
  0003e	50		 push	 eax
  0003f	68 40 27 00 00	 push	 10048			; 00002740H
  00044	56		 push	 esi
  00045	e8 00 00 00 00	 call	 ??_M@YGXPAXIHP6EX0@Z@Z
  0004a	f6 c3 01	 test	 bl, 1
  0004d	74 09		 je	 SHORT $LN2@vector
  0004f	57		 push	 edi
  00050	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00055	83 c4 04	 add	 esp, 4
$LN2@vector:
  00058	8b c7		 mov	 eax, edi
  0005a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0005d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00064	59		 pop	 ecx
  00065	5f		 pop	 edi
  00066	5e		 pop	 esi
  00067	5b		 pop	 ebx
  00068	8b e5		 mov	 esp, ebp
  0006a	5d		 pop	 ebp
  0006b	c2 04 00	 ret	 4
$LN3@vector:
  0006e	8d 8e ec 20 00
	00		 lea	 ecx, DWORD PTR [esi+8428]
  00074	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0007b	e8 00 00 00 00	 call	 ??1TMonsterAIAgro@@UAE@XZ ; TMonsterAIAgro::~TMonsterAIAgro
  00080	8d 8e 0c 16 00
	00		 lea	 ecx, DWORD PTR [esi+5644]
  00086	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0008d	e8 00 00 00 00	 call	 ??1CSkillDelay@@UAE@XZ	; CSkillDelay::~CSkillDelay
  00092	f6 c3 01	 test	 bl, 1
  00095	74 09		 je	 SHORT $LN1@vector
  00097	56		 push	 esi
  00098	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0009d	83 c4 04	 add	 esp, 4
$LN1@vector:
  000a0	8b c6		 mov	 eax, esi
  000a2	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000a5	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000ac	59		 pop	 ecx
  000ad	5f		 pop	 edi
  000ae	5e		 pop	 esi
  000af	5b		 pop	 ebx
  000b0	8b e5		 mov	 esp, ebp
  000b2	5d		 pop	 ebp
  000b3	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??_EOBJECTSTRUCT@@QAEPAXI@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	81 c1 0c 16 00
	00		 add	 ecx, 5644		; 0000160cH
  00009	e9 00 00 00 00	 jmp	 ??1CSkillDelay@@UAE@XZ	; CSkillDelay::~CSkillDelay
__ehhandler$??_EOBJECTSTRUCT@@QAEPAXI@Z:
  0000e	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00012	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00015	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00018	33 c8		 xor	 ecx, eax
  0001a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001f	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??_EOBJECTSTRUCT@@QAEPAXI@Z
  00024	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??_EOBJECTSTRUCT@@QAEPAXI@Z ENDP			; OBJECTSTRUCT::`vector deleting destructor'
PUBLIC	?CGCashPoint@CCashShop@@QAEHPAUOBJECTSTRUCT@@@Z	; CCashShop::CGCashPoint
; Function compile flags: /Ogtp
; File c:\muserver_dev\development\mu-s8ep2-repack\gameserver\source\cashshop.cpp
;	COMDAT ?CGCashPoint@CCashShop@@QAEHPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_lpObj$ = 8						; size = 4
?CGCashPoint@CCashShop@@QAEHPAUOBJECTSTRUCT@@@Z PROC	; CCashShop::CGCashPoint, COMDAT
; _this$ = ecx

; 318  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 319  : 	DWORD dwUserGuid = 0;
; 320  : 	
; 321  : 	if ( g_bConnectShopServer == TRUE && g_bShopServerConnectState == FALSE )

  00003	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?g_bConnectShopServer@@3HA, 1 ; g_bConnectShopServer
  0000a	53		 push	 ebx
  0000b	8b d9		 mov	 ebx, ecx
  0000d	75 10		 jne	 SHORT $LN3@CGCashPoin
  0000f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_bShopServerConnectState@@3HA, 0 ; g_bShopServerConnectState
  00016	75 07		 jne	 SHORT $LN3@CGCashPoin

; 322  : 	{
; 323  : 		return FALSE;

  00018	33 c0		 xor	 eax, eax
  0001a	5b		 pop	 ebx

; 339  : }

  0001b	5d		 pop	 ebp
  0001c	c2 04 00	 ret	 4
$LN3@CGCashPoin:
  0001f	56		 push	 esi

; 324  : 	}
; 325  : 
; 326  : 	if ( !gObjIsAccontConnect(lpObj->m_Index, lpObj->AccountID))

  00020	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]
  00023	8b 06		 mov	 eax, DWORD PTR [esi]
  00025	57		 push	 edi
  00026	8d 7e 52	 lea	 edi, DWORD PTR [esi+82]
  00029	57		 push	 edi
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 ?gObjIsAccontConnect@@YAHHPAD@Z ; gObjIsAccontConnect
  00030	83 c4 08	 add	 esp, 8
  00033	85 c0		 test	 eax, eax
  00035	75 28		 jne	 SHORT $LN2@CGCashPoin

; 327  : 	{
; 328  : 		LogAddC(2, lMsg.Get(MSGGET(1, 175)), lpObj->AccountID, lpObj->m_Index);

  00037	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00039	51		 push	 ecx
  0003a	57		 push	 edi
  0003b	68 af 01 00 00	 push	 431			; 000001afH
  00040	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  00045	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  0004a	50		 push	 eax
  0004b	6a 02		 push	 2
  0004d	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  00053	83 c4 10	 add	 esp, 16			; 00000010H
$LN8@CGCashPoin:

; 329  : 		return FALSE;

  00056	5f		 pop	 edi
  00057	5e		 pop	 esi
  00058	33 c0		 xor	 eax, eax
  0005a	5b		 pop	 ebx

; 339  : }

  0005b	5d		 pop	 ebp
  0005c	c2 04 00	 ret	 4
$LN2@CGCashPoin:

; 330  : 	}
; 331  : 
; 332  : 	if ( lpObj->Connected !=PLAYER_PLAYING && lpObj->Type != OBJ_USER )

  0005f	83 7e 04 03	 cmp	 DWORD PTR [esi+4], 3
  00063	74 06		 je	 SHORT $LN1@CGCashPoin
  00065	80 7e 50 01	 cmp	 BYTE PTR [esi+80], 1

; 333  : 		return FALSE;

  00069	75 eb		 jne	 SHORT $LN8@CGCashPoin
$LN1@CGCashPoin:

; 334  : 
; 335  : 	dwUserGuid = lpObj->DBNumber;
; 336  : 	GSReqCashPoint(dwUserGuid);

  0006b	8b 56 30	 mov	 edx, DWORD PTR [esi+48]
  0006e	52		 push	 edx
  0006f	8b cb		 mov	 ecx, ebx
  00071	e8 00 00 00 00	 call	 ?GSReqCashPoint@CCashShop@@QAEXK@Z ; CCashShop::GSReqCashPoint
  00076	5f		 pop	 edi
  00077	5e		 pop	 esi

; 337  : 
; 338  : 	return TRUE;

  00078	b8 01 00 00 00	 mov	 eax, 1
  0007d	5b		 pop	 ebx

; 339  : }

  0007e	5d		 pop	 ebp
  0007f	c2 04 00	 ret	 4
?CGCashPoint@CCashShop@@QAEHPAUOBJECTSTRUCT@@@Z ENDP	; CCashShop::CGCashPoint
_TEXT	ENDS
PUBLIC	?CGReqInfo@CCashShop@@QAEHPAEH@Z		; CCashShop::CGReqInfo
; Function compile flags: /Ogtp
;	COMDAT ?CGReqInfo@CCashShop@@QAEHPAEH@Z
_TEXT	SEGMENT
_dwReqType$ = 8						; size = 4
_aRecv$ = 8						; size = 4
tv171 = 12						; size = 4
_aIndex$ = 12						; size = 4
?CGReqInfo@CCashShop@@QAEHPAEH@Z PROC			; CCashShop::CGReqInfo, COMDAT
; _this$ = ecx

; 404  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 405  : 	PMSG_CASHSHOP_REQINFO* lpMsg = (PMSG_CASHSHOP_REQINFO*)aRecv;
; 406  : 
; 407  : 	LPOBJ lpObj = &gObj[aIndex];
; 408  : 	DWORD dwUserGuid = 0;
; 409  : 	DWORD dwReqPage = lpMsg->Id;

  00003	8b 45 08	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00006	53		 push	 ebx
  00007	8b 58 04	 mov	 ebx, DWORD PTR [eax+4]

; 410  : 	DWORD dwReqType = lpMsg->Type;

  0000a	0f b6 40 08	 movzx	 eax, BYTE PTR [eax+8]
  0000e	56		 push	 esi
  0000f	8b 75 0c	 mov	 esi, DWORD PTR _aIndex$[ebp]
  00012	69 f6 40 27 00
	00		 imul	 esi, 10048		; 00002740H
  00018	03 35 00 00 00
	00		 add	 esi, DWORD PTR ?gObj@@3PAUOBJECTSTRUCT@@A ; gObj

; 411  : 	
; 412  : 	if ( g_bConnectShopServer == TRUE && g_bShopServerConnectState == FALSE )

  0001e	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?g_bConnectShopServer@@3HA, 1 ; g_bConnectShopServer
  00025	57		 push	 edi
  00026	8b f9		 mov	 edi, ecx
  00028	89 45 08	 mov	 DWORD PTR _dwReqType$[ebp], eax
  0002b	75 09		 jne	 SHORT $LN6@CGReqInfo
  0002d	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_bShopServerConnectState@@3HA, 0 ; g_bShopServerConnectState

; 413  : 	{
; 414  : 		return FALSE;

  00034	74 38		 je	 SHORT $LN9@CGReqInfo
$LN6@CGReqInfo:

; 415  : 	}
; 416  : 
; 417  : 	if ( !gObjIsAccontConnect(lpObj->m_Index, lpObj->AccountID))

  00036	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00038	8d 46 52	 lea	 eax, DWORD PTR [esi+82]
  0003b	50		 push	 eax
  0003c	51		 push	 ecx
  0003d	89 45 0c	 mov	 DWORD PTR tv171[ebp], eax
  00040	e8 00 00 00 00	 call	 ?gObjIsAccontConnect@@YAHHPAD@Z ; gObjIsAccontConnect
  00045	83 c4 08	 add	 esp, 8
  00048	85 c0		 test	 eax, eax
  0004a	75 2b		 jne	 SHORT $LN5@CGReqInfo

; 418  : 	{
; 419  : 		LogAddC(2, lMsg.Get(MSGGET(1, 175)), lpObj->AccountID, lpObj->m_Index);

  0004c	8b 16		 mov	 edx, DWORD PTR [esi]
  0004e	8b 45 0c	 mov	 eax, DWORD PTR tv171[ebp]
  00051	52		 push	 edx
  00052	50		 push	 eax
  00053	68 af 01 00 00	 push	 431			; 000001afH
  00058	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  0005d	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  00062	50		 push	 eax
  00063	6a 02		 push	 2
  00065	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  0006b	83 c4 10	 add	 esp, 16			; 00000010H
$LN9@CGReqInfo:

; 420  : 		return FALSE;

  0006e	5f		 pop	 edi
  0006f	5e		 pop	 esi
  00070	33 c0		 xor	 eax, eax
  00072	5b		 pop	 ebx

; 437  : 
; 438  : 	/*PMSG_CASHSHOP_REQINFO* lpMsg = (PMSG_CASHSHOP_REQINFO*)aRecv;
; 439  : 
; 440  : 	PMSG_CASHSHOP_ANSINFO pMsg;
; 441  : 	PHeadSubSetB((LPBYTE)&pMsg,0xD2,0x06,sizeof(pMsg));
; 442  : 
; 443  : 	pMsg.Info1 = 0;
; 444  : 	pMsg.Info2 = 0;
; 445  : 	pMsg.Info3 = 0;
; 446  : 	pMsg.Info4 = 0;
; 447  : 
; 448  : 	DataSend(aIndex,(LPBYTE)&pMsg,pMsg.h.size);*/
; 449  : 
; 450  : }

  00073	5d		 pop	 ebp
  00074	c2 08 00	 ret	 8
$LN5@CGReqInfo:

; 421  : 	}
; 422  : 
; 423  : 	if ( lpObj->Connected !=PLAYER_PLAYING && lpObj->Type != OBJ_USER )

  00077	83 7e 04 03	 cmp	 DWORD PTR [esi+4], 3
  0007b	74 06		 je	 SHORT $LN4@CGReqInfo
  0007d	80 7e 50 01	 cmp	 BYTE PTR [esi+80], 1

; 424  : 		return FALSE;

  00081	75 eb		 jne	 SHORT $LN9@CGReqInfo
$LN4@CGReqInfo:

; 425  : 
; 426  : 	dwUserGuid = lpObj->DBNumber;
; 427  : 
; 428  : 	if( dwReqType == 0x53 )

  00083	8b 45 08	 mov	 eax, DWORD PTR _dwReqType$[ebp]
  00086	8b 76 30	 mov	 esi, DWORD PTR [esi+48]
  00089	83 f8 53	 cmp	 eax, 83			; 00000053H
  0008c	75 15		 jne	 SHORT $LN3@CGReqInfo

; 429  : 	{
; 430  : 		GSReqCashItemList(dwUserGuid,dwReqPage);

  0008e	53		 push	 ebx
  0008f	56		 push	 esi
  00090	8b cf		 mov	 ecx, edi
  00092	e8 00 00 00 00	 call	 ?GSReqCashItemList@CCashShop@@QAEXKK@Z ; CCashShop::GSReqCashItemList
  00097	5f		 pop	 edi
  00098	5e		 pop	 esi

; 435  : 	}
; 436  : 	return TRUE;

  00099	b8 01 00 00 00	 mov	 eax, 1
  0009e	5b		 pop	 ebx

; 437  : 
; 438  : 	/*PMSG_CASHSHOP_REQINFO* lpMsg = (PMSG_CASHSHOP_REQINFO*)aRecv;
; 439  : 
; 440  : 	PMSG_CASHSHOP_ANSINFO pMsg;
; 441  : 	PHeadSubSetB((LPBYTE)&pMsg,0xD2,0x06,sizeof(pMsg));
; 442  : 
; 443  : 	pMsg.Info1 = 0;
; 444  : 	pMsg.Info2 = 0;
; 445  : 	pMsg.Info3 = 0;
; 446  : 	pMsg.Info4 = 0;
; 447  : 
; 448  : 	DataSend(aIndex,(LPBYTE)&pMsg,pMsg.h.size);*/
; 449  : 
; 450  : }

  0009f	5d		 pop	 ebp
  000a0	c2 08 00	 ret	 8
$LN3@CGReqInfo:

; 431  : 	}
; 432  : 	else if( dwReqType == 0x47 )

  000a3	83 f8 47	 cmp	 eax, 71			; 00000047H
  000a6	75 09		 jne	 SHORT $LN1@CGReqInfo

; 433  : 	{
; 434  : 		GSReqCashGiftList(dwUserGuid,dwReqPage);

  000a8	53		 push	 ebx
  000a9	56		 push	 esi
  000aa	8b cf		 mov	 ecx, edi
  000ac	e8 00 00 00 00	 call	 ?GSReqCashGiftList@CCashShop@@QAEXKK@Z ; CCashShop::GSReqCashGiftList
$LN1@CGReqInfo:

; 435  : 	}
; 436  : 	return TRUE;

  000b1	5f		 pop	 edi
  000b2	5e		 pop	 esi
  000b3	b8 01 00 00 00	 mov	 eax, 1
  000b8	5b		 pop	 ebx

; 437  : 
; 438  : 	/*PMSG_CASHSHOP_REQINFO* lpMsg = (PMSG_CASHSHOP_REQINFO*)aRecv;
; 439  : 
; 440  : 	PMSG_CASHSHOP_ANSINFO pMsg;
; 441  : 	PHeadSubSetB((LPBYTE)&pMsg,0xD2,0x06,sizeof(pMsg));
; 442  : 
; 443  : 	pMsg.Info1 = 0;
; 444  : 	pMsg.Info2 = 0;
; 445  : 	pMsg.Info3 = 0;
; 446  : 	pMsg.Info4 = 0;
; 447  : 
; 448  : 	DataSend(aIndex,(LPBYTE)&pMsg,pMsg.h.size);*/
; 449  : 
; 450  : }

  000b9	5d		 pop	 ebp
  000ba	c2 08 00	 ret	 8
?CGReqInfo@CCashShop@@QAEHPAEH@Z ENDP			; CCashShop::CGReqInfo
_TEXT	ENDS
PUBLIC	?GCSendAllItemInfo@CCashShop@@QAEXPAUOBJECTSTRUCT@@@Z ; CCashShop::GCSendAllItemInfo
; Function compile flags: /Ogtp
;	COMDAT ?GCSendAllItemInfo@CCashShop@@QAEXPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_lpObj$ = 8						; size = 4
?GCSendAllItemInfo@CCashShop@@QAEXPAUOBJECTSTRUCT@@@Z PROC ; CCashShop::GCSendAllItemInfo, COMDAT
; _this$ = ecx

; 551  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx

; 552  : 	for(int n = 0; n < INVENTORY_SIZE; n++)

  00005	8b 5d 08	 mov	 ebx, DWORD PTR _lpObj$[ebp]
  00008	56		 push	 esi
  00009	57		 push	 edi
  0000a	33 ff		 xor	 edi, edi
  0000c	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000f	33 f6		 xor	 esi, esi
$LL5@GCSendAllI:

; 553  : 	{
; 554  : 		if( !lpObj->pInventory[n].IsItem() )

  00011	8b 8b c0 11 00
	00		 mov	 ecx, DWORD PTR [ebx+4544]
  00017	03 ce		 add	 ecx, esi
  00019	e8 00 00 00 00	 call	 ?IsItem@CItem@@QAEHXZ	; CItem::IsItem
  0001e	85 c0		 test	 eax, eax
  00020	74 2e		 je	 SHORT $LN4@GCSendAllI

; 555  : 			continue;
; 556  : 
; 557  : 		CItem* lpItem = &lpObj->pInventory[n];

  00022	8b 83 c0 11 00
	00		 mov	 eax, DWORD PTR [ebx+4544]
  00028	03 c6		 add	 eax, esi

; 558  : 
; 559  : 		if( lpItem->m_bPeriodItem && !lpItem->m_bExpired )

  0002a	80 b8 cf 00 00
	00 00		 cmp	 BYTE PTR [eax+207], 0
  00031	74 1d		 je	 SHORT $LN4@GCSendAllI
  00033	80 b8 d0 00 00
	00 00		 cmp	 BYTE PTR [eax+208], 0
  0003a	75 14		 jne	 SHORT $LN4@GCSendAllI

; 560  : 		{
; 561  : 			GCSendItemInfo(lpObj->m_Index,lpItem->m_Type,n,lpItem->m_Number);

  0003c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003e	0f bf 50 06	 movsx	 edx, WORD PTR [eax+6]
  00042	8b 03		 mov	 eax, DWORD PTR [ebx]
  00044	51		 push	 ecx
  00045	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00048	57		 push	 edi
  00049	52		 push	 edx
  0004a	50		 push	 eax
  0004b	e8 00 00 00 00	 call	 ?GCSendItemInfo@CCashShop@@QAEXHHHK@Z ; CCashShop::GCSendItemInfo
$LN4@GCSendAllI:

; 552  : 	for(int n = 0; n < INVENTORY_SIZE; n++)

  00050	81 c6 d4 00 00
	00		 add	 esi, 212		; 000000d4H
  00056	47		 inc	 edi
  00057	81 fe 44 c4 00
	00		 cmp	 esi, 50244		; 0000c444H
  0005d	7c b2		 jl	 SHORT $LL5@GCSendAllI
  0005f	5f		 pop	 edi
  00060	5e		 pop	 esi
  00061	5b		 pop	 ebx

; 562  : 		}
; 563  : 	}
; 564  : }

  00062	8b e5		 mov	 esp, ebp
  00064	5d		 pop	 ebp
  00065	c2 04 00	 ret	 4
?GCSendAllItemInfo@CCashShop@@QAEXPAUOBJECTSTRUCT@@@Z ENDP ; CCashShop::GCSendAllItemInfo
_TEXT	ENDS
PUBLIC	??_C@_0FJ@GFEOBLHC@?$FLCashShop?$FN?$FLBuy?5Request?$FN?5User?$CIID?3@ ; `string'
PUBLIC	?CGCashItemBuy@CCashShop@@QAEXPAUOBJECTSTRUCT@@PAUPMSG_REQ_CASHITEM_BUY@@@Z ; CCashShop::CGCashItemBuy
EXTRN	?gGameServerCode@@3FA:WORD			; gGameServerCode
;	COMDAT ??_C@_0FJ@GFEOBLHC@?$FLCashShop?$FN?$FLBuy?5Request?$FN?5User?$CIID?3@
CONST	SEGMENT
??_C@_0FJ@GFEOBLHC@?$FLCashShop?$FN?$FLBuy?5Request?$FN?5User?$CIID?3@ DB '['
	DB	'CashShop][Buy Request] User(ID:%s, Name:%s) Item(Name:%s,Guid'
	DB	':%d,Category:%d) Result:%d', 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?CGCashItemBuy@CCashShop@@QAEXPAUOBJECTSTRUCT@@PAUPMSG_REQ_CASHITEM_BUY@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_btResult$ = -4						; size = 1
_lpObj$ = 8						; size = 4
_lpMsg$ = 12						; size = 4
?CGCashItemBuy@CCashShop@@QAEXPAUOBJECTSTRUCT@@PAUPMSG_REQ_CASHITEM_BUY@@@Z PROC ; CCashShop::CGCashItemBuy, COMDAT
; _this$ = ecx

; 580  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 581  : 	BYTE btResult = 0;
; 582  : 	int iItemCode = (WORD)lpMsg->itemId;

  00006	8b 45 0c	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	0f b7 70 10	 movzx	 esi, WORD PTR [eax+16]
  0000f	32 db		 xor	 bl, bl

; 583  : 
; 584  : 	if ( g_bConnectShopServer == TRUE && g_bShopServerConnectState == FALSE )

  00011	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?g_bConnectShopServer@@3HA, 1 ; g_bConnectShopServer
  00018	57		 push	 edi
  00019	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  0001c	88 5d fc	 mov	 BYTE PTR _btResult$[ebp], bl
  0001f	75 0e		 jne	 SHORT $LN8@CGCashItem
  00021	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_bShopServerConnectState@@3HA, 0 ; g_bShopServerConnectState
  00028	75 05		 jne	 SHORT $LN8@CGCashItem

; 585  : 	{
; 586  : 		btResult = -2;

  0002a	b3 fe		 mov	 bl, 254			; 000000feH
  0002c	88 5d fc	 mov	 BYTE PTR _btResult$[ebp], bl
$LN8@CGCashItem:

; 587  : 	}
; 588  : 
; 589  : 	if ( !gObjIsAccontConnect(lpObj->m_Index, lpObj->AccountID))

  0002f	8b 7d 08	 mov	 edi, DWORD PTR _lpObj$[ebp]
  00032	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00034	8d 47 52	 lea	 eax, DWORD PTR [edi+82]
  00037	50		 push	 eax
  00038	51		 push	 ecx
  00039	e8 00 00 00 00	 call	 ?gObjIsAccontConnect@@YAHHPAD@Z ; gObjIsAccontConnect
  0003e	83 c4 08	 add	 esp, 8
  00041	85 c0		 test	 eax, eax
  00043	75 27		 jne	 SHORT $LN7@CGCashItem

; 590  : 	{
; 591  : 		LogAddC(2, lMsg.Get(MSGGET(1, 175)), lpObj->AccountID, lpObj->m_Index);

  00045	8b 17		 mov	 edx, DWORD PTR [edi]
  00047	52		 push	 edx
  00048	8d 47 52	 lea	 eax, DWORD PTR [edi+82]
  0004b	50		 push	 eax
  0004c	68 af 01 00 00	 push	 431			; 000001afH
  00051	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  00056	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  0005b	50		 push	 eax
  0005c	6a 02		 push	 2
  0005e	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC

; 592  : 		btResult = -2;

  00064	b3 fe		 mov	 bl, 254			; 000000feH
  00066	83 c4 10	 add	 esp, 16			; 00000010H
  00069	88 5d fc	 mov	 BYTE PTR _btResult$[ebp], bl
$LN7@CGCashItem:

; 593  : 	}
; 594  : 
; 595  : 	if ( lpObj->Connected !=PLAYER_PLAYING && lpObj->Type != OBJ_USER )

  0006c	83 7f 04 03	 cmp	 DWORD PTR [edi+4], 3
  00070	74 0b		 je	 SHORT $LN6@CGCashItem
  00072	80 7f 50 01	 cmp	 BYTE PTR [edi+80], 1
  00076	74 05		 je	 SHORT $LN6@CGCashItem

; 596  : 	{
; 597  : 		btResult = -2;

  00078	b3 fe		 mov	 bl, 254			; 000000feH
  0007a	88 5d fc	 mov	 BYTE PTR _btResult$[ebp], bl
$LN6@CGCashItem:

; 598  : 	}
; 599  : 
; 600  : 	if ( iItemCode < 0 || iItemCode >= ITEMGET(16,0) )

  0007d	81 fe ff 1f 00
	00		 cmp	 esi, 8191		; 00001fffH
  00083	77 51		 ja	 SHORT $LN4@CGCashItem

; 603  : 	}
; 604  : 	else
; 605  : 	{
; 606  : 		LogAddTD("[CashShop][Buy Request] User(ID:%s, Name:%s) Item(Name:%s,Guid:%d,Category:%d) Result:%d",
; 607  : 			lpObj->AccountID, lpObj->Name, ItemAttribute[iItemCode].Name, lpMsg->itemGuid, lpMsg->itemCategory, btResult);

  00085	0f b6 c3	 movzx	 eax, bl
  00088	6b f6 70	 imul	 esi, 112		; 00000070H
  0008b	50		 push	 eax
  0008c	8b 45 0c	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  0008f	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00092	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00095	51		 push	 ecx
  00096	52		 push	 edx
  00097	81 c6 00 00 00
	00		 add	 esi, OFFSET ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A ; ItemAttribute
  0009d	56		 push	 esi
  0009e	8d 47 5d	 lea	 eax, DWORD PTR [edi+93]
  000a1	50		 push	 eax
  000a2	8d 47 52	 lea	 eax, DWORD PTR [edi+82]
  000a5	50		 push	 eax
  000a6	68 00 00 00 00	 push	 OFFSET ??_C@_0FJ@GFEOBLHC@?$FLCashShop?$FN?$FLBuy?5Request?$FN?5User?$CIID?3@
  000ab	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  000b1	83 c4 1c	 add	 esp, 28			; 0000001cH

; 608  : 	}
; 609  : 
; 610  : 
; 611  : 	if ( btResult == 0 )

  000b4	84 db		 test	 bl, bl
  000b6	75 22		 jne	 SHORT $LN2@CGCashItem

; 612  : 	{
; 613  : 		GSReqBuyCashItem(gGameServerCode, lpObj, lpMsg );

  000b8	8b 4d 0c	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  000bb	0f bf 15 00 00
	00 00		 movsx	 edx, WORD PTR ?gGameServerCode@@3FA ; gGameServerCode
  000c2	51		 push	 ecx
  000c3	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000c6	57		 push	 edi
  000c7	52		 push	 edx
  000c8	e8 00 00 00 00	 call	 ?GSReqBuyCashItem@CCashShop@@QAEXKPAUOBJECTSTRUCT@@PAUPMSG_REQ_CASHITEM_BUY@@@Z ; CCashShop::GSReqBuyCashItem
  000cd	5f		 pop	 edi
  000ce	5e		 pop	 esi
  000cf	5b		 pop	 ebx

; 618  : 	}
; 619  : }

  000d0	8b e5		 mov	 esp, ebp
  000d2	5d		 pop	 ebp
  000d3	c2 08 00	 ret	 8
$LN4@CGCashItem:

; 601  : 	{
; 602  : 		btResult = -2;

  000d6	c6 45 fc fe	 mov	 BYTE PTR _btResult$[ebp], 254 ; 000000feH
$LN2@CGCashItem:

; 614  : 	}
; 615  : 	else
; 616  : 	{
; 617  : 		GCCashItemBuyResult(lpObj, btResult);

  000da	8b 45 fc	 mov	 eax, DWORD PTR _btResult$[ebp]
  000dd	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000e0	50		 push	 eax
  000e1	57		 push	 edi
  000e2	e8 00 00 00 00	 call	 ?GCCashItemBuyResult@CCashShop@@QAEXPAUOBJECTSTRUCT@@E@Z ; CCashShop::GCCashItemBuyResult
  000e7	5f		 pop	 edi
  000e8	5e		 pop	 esi
  000e9	5b		 pop	 ebx

; 618  : 	}
; 619  : }

  000ea	8b e5		 mov	 esp, ebp
  000ec	5d		 pop	 ebp
  000ed	c2 08 00	 ret	 8
?CGCashItemBuy@CCashShop@@QAEXPAUOBJECTSTRUCT@@PAUPMSG_REQ_CASHITEM_BUY@@@Z ENDP ; CCashShop::CGCashItemBuy
_TEXT	ENDS
PUBLIC	??_C@_0FK@NLJCPGNE@?$FLCashShop?$FN?$FLGift?5Request?$FN?5User?$CIID@ ; `string'
PUBLIC	?CGCashGiftSend@CCashShop@@QAEXPAUOBJECTSTRUCT@@PAUPMSG_REQ_CASHITEM_GIFT@@@Z ; CCashShop::CGCashGiftSend
;	COMDAT ??_C@_0FK@NLJCPGNE@?$FLCashShop?$FN?$FLGift?5Request?$FN?5User?$CIID@
CONST	SEGMENT
??_C@_0FK@NLJCPGNE@?$FLCashShop?$FN?$FLGift?5Request?$FN?5User?$CIID@ DB '['
	DB	'CashShop][Gift Request] User(ID:%s, Name:%s) Item(Name:%s,Gui'
	DB	'd:%d,Category:%d) Result:%d', 00H		; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?CGCashGiftSend@CCashShop@@QAEXPAUOBJECTSTRUCT@@PAUPMSG_REQ_CASHITEM_GIFT@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_btResult$ = -4						; size = 1
_lpObj$ = 8						; size = 4
_lpMsg$ = 12						; size = 4
?CGCashGiftSend@CCashShop@@QAEXPAUOBJECTSTRUCT@@PAUPMSG_REQ_CASHITEM_GIFT@@@Z PROC ; CCashShop::CGCashGiftSend, COMDAT
; _this$ = ecx

; 632  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 633  : 	BYTE btResult = 0;
; 634  : 	int iItemCode = lpMsg->wUnk1;

  00006	8b 45 0c	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	0f b7 70 14	 movzx	 esi, WORD PTR [eax+20]
  0000f	32 db		 xor	 bl, bl

; 635  : 
; 636  : 	if ( g_bConnectShopServer == TRUE && g_bShopServerConnectState == FALSE )

  00011	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?g_bConnectShopServer@@3HA, 1 ; g_bConnectShopServer
  00018	57		 push	 edi
  00019	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  0001c	88 5d fc	 mov	 BYTE PTR _btResult$[ebp], bl
  0001f	75 0e		 jne	 SHORT $LN5@CGCashGift
  00021	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_bShopServerConnectState@@3HA, 0 ; g_bShopServerConnectState
  00028	75 05		 jne	 SHORT $LN5@CGCashGift

; 637  : 	{
; 638  : 		btResult = -2;

  0002a	b3 fe		 mov	 bl, 254			; 000000feH
  0002c	88 5d fc	 mov	 BYTE PTR _btResult$[ebp], bl
$LN5@CGCashGift:

; 639  : 	}
; 640  : 
; 641  : 	if ( !gObjIsAccontConnect(lpObj->m_Index, lpObj->AccountID))

  0002f	8b 7d 08	 mov	 edi, DWORD PTR _lpObj$[ebp]
  00032	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00034	8d 47 52	 lea	 eax, DWORD PTR [edi+82]
  00037	50		 push	 eax
  00038	51		 push	 ecx
  00039	e8 00 00 00 00	 call	 ?gObjIsAccontConnect@@YAHHPAD@Z ; gObjIsAccontConnect
  0003e	83 c4 08	 add	 esp, 8
  00041	85 c0		 test	 eax, eax
  00043	75 27		 jne	 SHORT $LN4@CGCashGift

; 642  : 	{
; 643  : 		LogAddC(2, lMsg.Get(MSGGET(1, 175)), lpObj->AccountID, lpObj->m_Index);

  00045	8b 17		 mov	 edx, DWORD PTR [edi]
  00047	52		 push	 edx
  00048	8d 47 52	 lea	 eax, DWORD PTR [edi+82]
  0004b	50		 push	 eax
  0004c	68 af 01 00 00	 push	 431			; 000001afH
  00051	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  00056	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  0005b	50		 push	 eax
  0005c	6a 02		 push	 2
  0005e	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC

; 644  : 		btResult = -2;

  00064	b3 fe		 mov	 bl, 254			; 000000feH
  00066	83 c4 10	 add	 esp, 16			; 00000010H
  00069	88 5d fc	 mov	 BYTE PTR _btResult$[ebp], bl
$LN4@CGCashGift:

; 645  : 	}
; 646  : 
; 647  : 	if ( lpObj->Connected !=PLAYER_PLAYING && lpObj->Type != OBJ_USER )

  0006c	83 7f 04 03	 cmp	 DWORD PTR [edi+4], 3
  00070	74 0b		 je	 SHORT $LN3@CGCashGift
  00072	80 7f 50 01	 cmp	 BYTE PTR [edi+80], 1
  00076	74 05		 je	 SHORT $LN3@CGCashGift

; 648  : 	{
; 649  : 		btResult = -2;

  00078	b3 fe		 mov	 bl, 254			; 000000feH
  0007a	88 5d fc	 mov	 BYTE PTR _btResult$[ebp], bl
$LN3@CGCashGift:

; 650  : 	}
; 651  : 
; 652  : 	LogAddTD("[CashShop][Gift Request] User(ID:%s, Name:%s) Item(Name:%s,Guid:%d,Category:%d) Result:%d",
; 653  : 		lpObj->AccountID, lpObj->Name, ItemAttribute[iItemCode].Name, lpMsg->itemGuid, lpMsg->itemCategory, btResult);

  0007d	0f b6 c3	 movzx	 eax, bl
  00080	6b f6 70	 imul	 esi, 112		; 00000070H
  00083	50		 push	 eax
  00084	8b 45 0c	 mov	 eax, DWORD PTR _lpMsg$[ebp]
  00087	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0008a	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0008d	51		 push	 ecx
  0008e	52		 push	 edx
  0008f	81 c6 00 00 00
	00		 add	 esi, OFFSET ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A ; ItemAttribute
  00095	56		 push	 esi
  00096	8d 47 5d	 lea	 eax, DWORD PTR [edi+93]
  00099	50		 push	 eax
  0009a	8d 47 52	 lea	 eax, DWORD PTR [edi+82]
  0009d	50		 push	 eax
  0009e	68 00 00 00 00	 push	 OFFSET ??_C@_0FK@NLJCPGNE@?$FLCashShop?$FN?$FLGift?5Request?$FN?5User?$CIID@
  000a3	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  000a9	83 c4 1c	 add	 esp, 28			; 0000001cH

; 654  : 
; 655  : 	if ( btResult == 0 )

  000ac	84 db		 test	 bl, bl
  000ae	75 1e		 jne	 SHORT $LN2@CGCashGift

; 656  : 	{
; 657  : 		GSReqGiftCashItem(gGameServerCode, lpObj, lpMsg );

  000b0	8b 4d 0c	 mov	 ecx, DWORD PTR _lpMsg$[ebp]
  000b3	0f bf 15 00 00
	00 00		 movsx	 edx, WORD PTR ?gGameServerCode@@3FA ; gGameServerCode
  000ba	51		 push	 ecx
  000bb	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000be	57		 push	 edi
  000bf	52		 push	 edx
  000c0	e8 00 00 00 00	 call	 ?GSReqGiftCashItem@CCashShop@@QAEXKPAUOBJECTSTRUCT@@PAUPMSG_REQ_CASHITEM_GIFT@@@Z ; CCashShop::GSReqGiftCashItem
  000c5	5f		 pop	 edi
  000c6	5e		 pop	 esi
  000c7	5b		 pop	 ebx

; 662  : 	}
; 663  : }

  000c8	8b e5		 mov	 esp, ebp
  000ca	5d		 pop	 ebp
  000cb	c2 08 00	 ret	 8
$LN2@CGCashGift:

; 658  : 	}
; 659  : 	else
; 660  : 	{
; 661  : 		GCCashGiftSendResult(lpObj, btResult);

  000ce	8b 45 fc	 mov	 eax, DWORD PTR _btResult$[ebp]
  000d1	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000d4	50		 push	 eax
  000d5	57		 push	 edi
  000d6	e8 00 00 00 00	 call	 ?GCCashGiftSendResult@CCashShop@@QAEXPAUOBJECTSTRUCT@@E@Z ; CCashShop::GCCashGiftSendResult
  000db	5f		 pop	 edi
  000dc	5e		 pop	 esi
  000dd	5b		 pop	 ebx

; 662  : 	}
; 663  : }

  000de	8b e5		 mov	 esp, ebp
  000e0	5d		 pop	 ebp
  000e1	c2 08 00	 ret	 8
?CGCashGiftSend@CCashShop@@QAEXPAUOBJECTSTRUCT@@PAUPMSG_REQ_CASHITEM_GIFT@@@Z ENDP ; CCashShop::CGCashGiftSend
_TEXT	ENDS
PUBLIC	??_C@_0EN@GDABACKC@?$FLCashShop?$FN?$FLUse?5Request?$FN?5User?$CIID?3@ ; `string'
PUBLIC	?CGReqUseItem@CCashShop@@QAEXPAUOBJECTSTRUCT@@PAUPSMG_REQ_CASHITEM_USE@@@Z ; CCashShop::CGReqUseItem
EXTRN	?ClearPeriodItem@CCashItemPeriodSystem@@QAEEPAUOBJECTSTRUCT@@H@Z:PROC ; CCashItemPeriodSystem::ClearPeriodItem
EXTRN	?g_CashItemPeriodSystem@@3VCCashItemPeriodSystem@@A:BYTE ; g_CashItemPeriodSystem
;	COMDAT ??_C@_0EN@GDABACKC@?$FLCashShop?$FN?$FLUse?5Request?$FN?5User?$CIID?3@
CONST	SEGMENT
??_C@_0EN@GDABACKC@?$FLCashShop?$FN?$FLUse?5Request?$FN?5User?$CIID?3@ DB '['
	DB	'CashShop][Use Request] User(ID:%s, Name:%s) Item(Name:%s,Guid'
	DB	':%d) Result:%d', 00H			; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?CGReqUseItem@CCashShop@@QAEXPAUOBJECTSTRUCT@@PAUPSMG_REQ_CASHITEM_USE@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_btResult$ = -4						; size = 1
_lpObj$ = 8						; size = 4
_iItemCode$ = 12					; size = 4
_lpMsg$ = 12						; size = 4
?CGReqUseItem@CCashShop@@QAEXPAUOBJECTSTRUCT@@PAUPSMG_REQ_CASHITEM_USE@@@Z PROC ; CCashShop::CGReqUseItem, COMDAT
; _this$ = ecx

; 676  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 677  : 	BYTE btResult = 0;
; 678  : 	int iItemCode = lpMsg->ItemID;

  00009	8b 7d 0c	 mov	 edi, DWORD PTR _lpMsg$[ebp]
  0000c	0f bf 47 0c	 movsx	 eax, WORD PTR [edi+12]
  00010	32 db		 xor	 bl, bl

; 679  : 
; 680  : 	if ( g_bConnectShopServer == TRUE && g_bShopServerConnectState == FALSE )

  00012	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?g_bConnectShopServer@@3HA, 1 ; g_bConnectShopServer
  00019	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  0001c	88 5d fc	 mov	 BYTE PTR _btResult$[ebp], bl
  0001f	89 45 0c	 mov	 DWORD PTR _iItemCode$[ebp], eax
  00022	75 0e		 jne	 SHORT $LN6@CGReqUseIt
  00024	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_bShopServerConnectState@@3HA, 0 ; g_bShopServerConnectState
  0002b	75 05		 jne	 SHORT $LN6@CGReqUseIt

; 681  : 	{
; 682  : 		btResult = -2;

  0002d	b3 fe		 mov	 bl, 254			; 000000feH
  0002f	88 5d fc	 mov	 BYTE PTR _btResult$[ebp], bl
$LN6@CGReqUseIt:

; 683  : 	}
; 684  : 
; 685  : 	if ( !gObjIsAccontConnect(lpObj->m_Index, lpObj->AccountID))

  00032	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]
  00035	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00037	8d 46 52	 lea	 eax, DWORD PTR [esi+82]
  0003a	50		 push	 eax
  0003b	51		 push	 ecx
  0003c	e8 00 00 00 00	 call	 ?gObjIsAccontConnect@@YAHHPAD@Z ; gObjIsAccontConnect
  00041	83 c4 08	 add	 esp, 8
  00044	85 c0		 test	 eax, eax
  00046	75 27		 jne	 SHORT $LN5@CGReqUseIt

; 686  : 	{
; 687  : 		LogAddC(2, lMsg.Get(MSGGET(1, 175)), lpObj->AccountID, lpObj->m_Index);

  00048	8b 16		 mov	 edx, DWORD PTR [esi]
  0004a	52		 push	 edx
  0004b	8d 46 52	 lea	 eax, DWORD PTR [esi+82]
  0004e	50		 push	 eax
  0004f	68 af 01 00 00	 push	 431			; 000001afH
  00054	b9 00 00 00 00	 mov	 ecx, OFFSET ?lMsg@@3VMessage@@A ; lMsg
  00059	e8 00 00 00 00	 call	 ?Get@Message@@QAEPADH@Z	; Message::Get
  0005e	50		 push	 eax
  0005f	6a 02		 push	 2
  00061	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC

; 688  : 		btResult = -2;

  00067	b3 fe		 mov	 bl, 254			; 000000feH
  00069	83 c4 10	 add	 esp, 16			; 00000010H
  0006c	88 5d fc	 mov	 BYTE PTR _btResult$[ebp], bl
$LN5@CGReqUseIt:

; 689  : 	}
; 690  : 
; 691  : 	if ( lpObj->Connected !=PLAYER_PLAYING && lpObj->Type != OBJ_USER )

  0006f	83 7e 04 03	 cmp	 DWORD PTR [esi+4], 3
  00073	74 0b		 je	 SHORT $LN4@CGReqUseIt
  00075	80 7e 50 01	 cmp	 BYTE PTR [esi+80], 1
  00079	74 05		 je	 SHORT $LN4@CGReqUseIt

; 692  : 	{
; 693  : 		btResult = -2;

  0007b	b3 fe		 mov	 bl, 254			; 000000feH
  0007d	88 5d fc	 mov	 BYTE PTR _btResult$[ebp], bl
$LN4@CGReqUseIt:

; 694  : 	}
; 695  : 
; 696  : 	if ( CheckPeriodItem(iItemCode) == TRUE )

  00080	8b 55 0c	 mov	 edx, DWORD PTR _iItemCode$[ebp]
  00083	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00086	52		 push	 edx
  00087	e8 00 00 00 00	 call	 ?CheckPeriodItem@CCashShop@@QAEHH@Z ; CCashShop::CheckPeriodItem
  0008c	83 f8 01	 cmp	 eax, 1
  0008f	75 0f		 jne	 SHORT $LN3@CGReqUseIt

; 697  : 	{
; 698  : 		g_CashItemPeriodSystem.ClearPeriodItem(lpObj,iItemCode);

  00091	52		 push	 edx
  00092	56		 push	 esi
  00093	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CashItemPeriodSystem@@3VCCashItemPeriodSystem@@A ; g_CashItemPeriodSystem
  00098	e8 00 00 00 00	 call	 ?ClearPeriodItem@CCashItemPeriodSystem@@QAEEPAUOBJECTSTRUCT@@H@Z ; CCashItemPeriodSystem::ClearPeriodItem
  0009d	8b 55 0c	 mov	 edx, DWORD PTR _iItemCode$[ebp]
$LN3@CGReqUseIt:

; 699  : 	}
; 700  : 
; 701  : 	LogAddTD("[CashShop][Use Request] User(ID:%s, Name:%s) Item(Name:%s,Guid:%d) Result:%d",
; 702  : 		lpObj->AccountID, lpObj->Name, ItemAttribute[iItemCode].Name, lpMsg->itemGuid,  btResult);

  000a0	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  000a3	6b d2 70	 imul	 edx, 112		; 00000070H
  000a6	0f b6 c3	 movzx	 eax, bl
  000a9	50		 push	 eax
  000aa	51		 push	 ecx
  000ab	81 c2 00 00 00
	00		 add	 edx, OFFSET ?ItemAttribute@@3PAUITEM_ATTRIBUTE@@A ; ItemAttribute
  000b1	52		 push	 edx
  000b2	8d 56 5d	 lea	 edx, DWORD PTR [esi+93]
  000b5	52		 push	 edx
  000b6	8d 46 52	 lea	 eax, DWORD PTR [esi+82]
  000b9	50		 push	 eax
  000ba	68 00 00 00 00	 push	 OFFSET ??_C@_0EN@GDABACKC@?$FLCashShop?$FN?$FLUse?5Request?$FN?5User?$CIID?3@
  000bf	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  000c5	83 c4 18	 add	 esp, 24			; 00000018H

; 703  : 
; 704  : 
; 705  : 	if ( btResult == 0 )

  000c8	84 db		 test	 bl, bl
  000ca	75 26		 jne	 SHORT $LN2@CGReqUseIt

; 706  : 	{
; 707  : 		GSReqUseCashItem(lpObj->DBNumber,lpMsg->itemGuid,lpMsg->itemUnk,iItemCode,lpMsg->btType);

  000cc	0f b6 47 0e	 movzx	 eax, BYTE PTR [edi+14]
  000d0	8b 4d 0c	 mov	 ecx, DWORD PTR _iItemCode$[ebp]
  000d3	8b 57 08	 mov	 edx, DWORD PTR [edi+8]
  000d6	50		 push	 eax
  000d7	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  000da	51		 push	 ecx
  000db	8b 4e 30	 mov	 ecx, DWORD PTR [esi+48]
  000de	52		 push	 edx
  000df	50		 push	 eax
  000e0	51		 push	 ecx
  000e1	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000e4	e8 00 00 00 00	 call	 ?GSReqUseCashItem@CCashShop@@QAEXKKKKK@Z ; CCashShop::GSReqUseCashItem
  000e9	5f		 pop	 edi
  000ea	5e		 pop	 esi
  000eb	5b		 pop	 ebx

; 712  : 	}
; 713  : }

  000ec	8b e5		 mov	 esp, ebp
  000ee	5d		 pop	 ebp
  000ef	c2 08 00	 ret	 8
$LN2@CGReqUseIt:

; 708  : 	}
; 709  : 	else
; 710  : 	{
; 711  : 		GCCashItemUseResult(lpObj, btResult);

  000f2	8b 55 fc	 mov	 edx, DWORD PTR _btResult$[ebp]
  000f5	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000f8	52		 push	 edx
  000f9	56		 push	 esi
  000fa	e8 00 00 00 00	 call	 ?GCCashItemUseResult@CCashShop@@QAEXPAUOBJECTSTRUCT@@E@Z ; CCashShop::GCCashItemUseResult
  000ff	5f		 pop	 edi
  00100	5e		 pop	 esi
  00101	5b		 pop	 ebx

; 712  : 	}
; 713  : }

  00102	8b e5		 mov	 esp, ebp
  00104	5d		 pop	 ebp
  00105	c2 08 00	 ret	 8
?CGReqUseItem@CCashShop@@QAEXPAUOBJECTSTRUCT@@PAUPSMG_REQ_CASHITEM_USE@@@Z ENDP ; CCashShop::CGReqUseItem
_TEXT	ENDS
PUBLIC	?_Lmost@?$_Tree@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::_Lmost
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Lmost@?$_Tree@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::_Lmost, COMDAT
; _this$ = ecx

; 1759 : 		return (this->_Left(this->_Myhead));

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 1760 : 		}

  00003	c3		 ret	 0
?_Lmost@?$_Tree@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::_Lmost
_TEXT	ENDS
PUBLIC	?_Rmost@?$_Tree@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::_Rmost
; Function compile flags: /Ogtp
;	COMDAT ?_Rmost@?$_Tree@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Rmost@?$_Tree@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::_Rmost, COMDAT
; _this$ = ecx

; 1784 : 		return (this->_Right(this->_Myhead));

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	83 c0 08	 add	 eax, 8

; 1785 : 		}

  00006	c3		 ret	 0
?_Rmost@?$_Tree@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::_Rmost
_TEXT	ENDS
PUBLIC	?_Root@?$_Tree@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::_Root
; Function compile flags: /Ogtp
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Root@?$_Tree@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::_Root, COMDAT
; _this$ = ecx

; 1789 : 		return (this->_Parent(this->_Myhead));

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	83 c0 04	 add	 eax, 4

; 1790 : 		}

  00006	c3		 ret	 0
?_Root@?$_Tree@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::_Root
_TEXT	ENDS
PUBLIC	?_Rrotate@?$_Tree@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::_Rrotate
; Function compile flags: /Ogtp
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Wherenode$ = 8					; size = 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::_Rrotate, COMDAT
; _this$ = ecx

; 1793 : 		{	// promote left node to root of subtree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1794 : 		_Nodeptr _Pnode = this->_Left(_Wherenode);

  00003	8b 55 08	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  00006	8b 02		 mov	 eax, DWORD PTR [edx]
  00008	56		 push	 esi

; 1795 : 		this->_Left(_Wherenode) = this->_Right(_Pnode);

  00009	8b 70 08	 mov	 esi, DWORD PTR [eax+8]
  0000c	89 32		 mov	 DWORD PTR [edx], esi

; 1796 : 
; 1797 : 		if (!this->_Isnil(this->_Right(_Pnode)))

  0000e	8b 70 08	 mov	 esi, DWORD PTR [eax+8]
  00011	80 7e 15 00	 cmp	 BYTE PTR [esi+21], 0
  00015	75 03		 jne	 SHORT $LN5@Rrotate

; 1798 : 			this->_Parent(this->_Right(_Pnode)) = _Wherenode;

  00017	89 56 04	 mov	 DWORD PTR [esi+4], edx
$LN5@Rrotate:

; 1799 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

  0001a	8b 72 04	 mov	 esi, DWORD PTR [edx+4]
  0001d	89 70 04	 mov	 DWORD PTR [eax+4], esi

; 1800 : 
; 1801 : 		if (_Wherenode == _Root())

  00020	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00023	5e		 pop	 esi
  00024	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00027	75 0d		 jne	 SHORT $LN4@Rrotate

; 1802 : 			_Root() = _Pnode;

  00029	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1807 : 
; 1808 : 		this->_Right(_Pnode) = _Wherenode;

  0002c	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 1809 : 		this->_Parent(_Wherenode) = _Pnode;

  0002f	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 1810 : 		}

  00032	5d		 pop	 ebp
  00033	c2 04 00	 ret	 4
$LN4@Rrotate:

; 1803 : 		else if (_Wherenode == this->_Right(this->_Parent(_Wherenode)))

  00036	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00039	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  0003c	75 0d		 jne	 SHORT $LN2@Rrotate

; 1804 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;

  0003e	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 1807 : 
; 1808 : 		this->_Right(_Pnode) = _Wherenode;

  00041	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 1809 : 		this->_Parent(_Wherenode) = _Pnode;

  00044	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 1810 : 		}

  00047	5d		 pop	 ebp
  00048	c2 04 00	 ret	 4
$LN2@Rrotate:

; 1805 : 		else
; 1806 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;

  0004b	89 01		 mov	 DWORD PTR [ecx], eax

; 1807 : 
; 1808 : 		this->_Right(_Pnode) = _Wherenode;

  0004d	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 1809 : 		this->_Parent(_Wherenode) = _Pnode;

  00050	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 1810 : 		}

  00053	5d		 pop	 ebp
  00054	c2 04 00	 ret	 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::_Rrotate
_TEXT	ENDS
PUBLIC	??1?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::~_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >
; Function compile flags: /Ogtp
;	COMDAT ??1?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::~_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >, COMDAT
; _this$ = ecx

; 555  : 		this->_Alnod.deallocate(this->_Myhead, 1);

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	50		 push	 eax
  00004	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00009	59		 pop	 ecx

; 556  : 		}

  0000a	c3		 ret	 0
??1?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::~_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >
_TEXT	ENDS
PUBLIC	?_Key@?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@SAAAHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::_Key
; Function compile flags: /Ogtp
;	COMDAT ?_Key@?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@SAAAHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Key@?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@SAAAHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::_Key, COMDAT

; 616  : 		{	// return reference to key in node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 617  : 		return ((key_type&)_Traits::_Kfn(_Myval(_Pnode)));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00006	83 c0 0c	 add	 eax, 12			; 0000000cH

; 618  : 		}

  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Key@?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@SAAAHPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::_Key
_TEXT	ENDS
PUBLIC	??D?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@std@@QBEAAU?$pair@$$CBHPAUOBJECTSTRUCT@@@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> > >::operator*
; Function compile flags: /Ogtp
;	COMDAT ??D?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@std@@QBEAAU?$pair@$$CBHPAUOBJECTSTRUCT@@@1@XZ
_TEXT	SEGMENT
??D?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@std@@QBEAAU?$pair@$$CBHPAUOBJECTSTRUCT@@@1@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> > >::operator*, COMDAT
; _this$ = ecx

; 396  : 		return ((reference)**(_Mybase *)this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 0c	 add	 eax, 12			; 0000000cH

; 397  : 		}

  00005	c3		 ret	 0
??D?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@std@@QBEAAU?$pair@$$CBHPAUOBJECTSTRUCT@@@1@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> > >::operator*
_TEXT	ENDS
PUBLIC	??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@std@@QAE@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> > >::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> > >
; Function compile flags: /Ogtp
;	COMDAT ??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@std@@QAE@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> > >::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> > >, COMDAT
; _this$ = ecx

; 208  : 		{	// construct with null node pointer

  00000	8b c1		 mov	 eax, ecx
  00002	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 209  : 		}

  00008	c3		 ret	 0
??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> > >::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> > >
_TEXT	ENDS
PUBLIC	??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> > >::operator++
; Function compile flags: /Ogtp
;	COMDAT ??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> > >::operator++, COMDAT
; _this$ = ecx

; 250  : 		{	// preincrement

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 251  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 252  : 		if (this->_Getcont() == 0
; 253  : 			|| this->_Ptr == 0
; 254  : 			|| _Mytree::_Isnil(this->_Ptr))
; 255  : 			{	// report error
; 256  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 257  : 			_SCL_SECURE_OUT_OF_RANGE;
; 258  : 			}
; 259  : 
; 260  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 261  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 262  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 263  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 264  : 
; 265  : 		++(*(_Mybase *)this);

  00003	e8 00 00 00 00	 call	 ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >,std::_Iterator_base0>::operator++

; 266  : 		return (*this);

  00008	8b c6		 mov	 eax, esi
  0000a	5e		 pop	 esi

; 267  : 		}

  0000b	c3		 ret	 0
??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> > >::operator++
_TEXT	ENDS
PUBLIC	?_Lbound@?$_Tree@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::_Lbound
; Function compile flags: /Ogtp
;	COMDAT ?_Lbound@?$_Tree@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@2@ABH@Z
_TEXT	SEGMENT
__Keyval$ = 8						; size = 4
?_Lbound@?$_Tree@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@2@ABH@Z PROC ; std::_Tree<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::_Lbound, COMDAT
; _this$ = ecx

; 1741 : 		{	// find leftmost node not less than _Keyval

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1742 : 		_Nodeptr _Pnode = _Root();

  00003	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00006	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]

; 1743 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 1744 : 
; 1745 : 		while (!this->_Isnil(_Pnode))

  00009	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  0000d	75 19		 jne	 SHORT $LN3@Lbound
  0000f	8b 55 08	 mov	 edx, DWORD PTR __Keyval$[ebp]
  00012	8b 12		 mov	 edx, DWORD PTR [edx]
$LL4@Lbound:

; 1746 : 			if (_DEBUG_LT_PRED(this->comp, this->_Key(_Pnode), _Keyval))

  00014	39 51 0c	 cmp	 DWORD PTR [ecx+12], edx
  00017	7d 05		 jge	 SHORT $LN2@Lbound

; 1747 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree

  00019	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]

; 1748 : 			else

  0001c	eb 04		 jmp	 SHORT $LN1@Lbound
$LN2@Lbound:

; 1749 : 				{	// _Pnode not less than _Keyval, remember it
; 1750 : 				_Wherenode = _Pnode;

  0001e	8b c1		 mov	 eax, ecx

; 1751 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree

  00020	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN1@Lbound:

; 1743 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 1744 : 
; 1745 : 		while (!this->_Isnil(_Pnode))

  00022	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  00026	74 ec		 je	 SHORT $LL4@Lbound
$LN3@Lbound:

; 1752 : 				}
; 1753 : 
; 1754 : 		return (_Wherenode);	// return best remembered candidate
; 1755 : 		}

  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
?_Lbound@?$_Tree@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@2@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::_Lbound
_TEXT	ENDS
PUBLIC	??0?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@1@@Z ; std::_Tree_nod<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::_Tree_nod<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >
; Function compile flags: /Ogtp
;	COMDAT ??0?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@1@@Z PROC ; std::_Tree_nod<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::_Tree_nod<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >, COMDAT
; _this$ = ecx

; 482  : 		{	// construct traits from _Parg and allocators from _Al

  00000	8b c1		 mov	 eax, ecx

; 483  : 		}

  00002	c2 08 00	 ret	 8
??0?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@1@@Z ENDP ; std::_Tree_nod<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::_Tree_nod<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >
_TEXT	ENDS
PUBLIC	??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@std@@QAE?AV01@H@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> > >::operator++
; Function compile flags: /Ogtp
;	COMDAT ??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@std@@QAE?AV01@H@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> > >::operator++, COMDAT
; _this$ = ecx

; 270  : 		{	// postincrement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 271  : 		_Myiter _Tmp = *this;

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	56		 push	 esi
  00006	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  00009	89 06		 mov	 DWORD PTR [esi], eax

; 272  : 		++*this;

  0000b	e8 00 00 00 00	 call	 ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >,std::_Iterator_base0>::operator++

; 273  : 		return (_Tmp);

  00010	8b c6		 mov	 eax, esi
  00012	5e		 pop	 esi

; 274  : 		}

  00013	5d		 pop	 ebp
  00014	c2 08 00	 ret	 8
??E?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@std@@QAE?AV01@H@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> > >::operator++
_TEXT	ENDS
PUBLIC	??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@1@@Z ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >,std::_Iterator_base0>
; Function compile flags: /Ogtp
;	COMDAT ??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@1@@Z PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >,std::_Iterator_base0>, COMDAT
; _this$ = ecx

; 43   : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 44   : 		this->_Adopt(_Plist);
; 45   : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@1@@Z ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >,std::_Iterator_base0>
_TEXT	ENDS
PUBLIC	??$?0AAHAAPAUOBJECTSTRUCT@@@?$pair@HPAUOBJECTSTRUCT@@@std@@QAE@AAHAAPAUOBJECTSTRUCT@@@Z ; std::pair<int,OBJECTSTRUCT *>::pair<int,OBJECTSTRUCT *><int &,OBJECTSTRUCT * &>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$?0AAHAAPAUOBJECTSTRUCT@@@?$pair@HPAUOBJECTSTRUCT@@@std@@QAE@AAHAAPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAHAAPAUOBJECTSTRUCT@@@?$pair@HPAUOBJECTSTRUCT@@@std@@QAE@AAHAAPAUOBJECTSTRUCT@@@Z PROC ; std::pair<int,OBJECTSTRUCT *>::pair<int,OBJECTSTRUCT *><int &,OBJECTSTRUCT * &>, COMDAT
; _this$ = ecx

; 247  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Val1$[ebp]
  00008	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Val2$[ebp]
  0000d	89 10		 mov	 DWORD PTR [eax], edx
  0000f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00011	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 248  : 		}

  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
??$?0AAHAAPAUOBJECTSTRUCT@@@?$pair@HPAUOBJECTSTRUCT@@@std@@QAE@AAHAAPAUOBJECTSTRUCT@@@Z ENDP ; std::pair<int,OBJECTSTRUCT *>::pair<int,OBJECTSTRUCT *><int &,OBJECTSTRUCT * &>
_TEXT	ENDS
PUBLIC	??$swap@D@std@@YAXAAD0@Z			; std::swap<char>
; Function compile flags: /Ogtp
;	COMDAT ??$swap@D@std@@YAXAAD0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@D@std@@YAXAAD0@Z PROC				; std::swap<char>, COMDAT

; 101  : 	{	// exchange values stored at _Left and _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 102  : 	_Ty _Tmp = _Move(_Left);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  00006	8a 08		 mov	 cl, BYTE PTR [eax]
  00008	56		 push	 esi

; 103  : 	_Left = _Move(_Right);

  00009	8b 75 0c	 mov	 esi, DWORD PTR __Right$[ebp]
  0000c	8a 16		 mov	 dl, BYTE PTR [esi]
  0000e	88 10		 mov	 BYTE PTR [eax], dl

; 104  : 	_Right = _Move(_Tmp);

  00010	88 0e		 mov	 BYTE PTR [esi], cl
  00012	5e		 pop	 esi

; 105  : 	}

  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
??$swap@D@std@@YAXAAD0@Z ENDP				; std::swap<char>
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::_Node>
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	__CxxThrowException@8:PROC
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\exception
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	ENDS
;	COMDAT ??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@0@IPAU120@@Z
_TEXT	SEGMENT
$T192279 = -12						; size = 12
$T192284 = 8						; size = 4
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@0@IPAU120@@Z PROC ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::_Node>, COMDAT

; 30   : 	{	// allocate storage for _Count elements of type _Ty

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 31   : 	void *_Ptr = 0;
; 32   : 
; 33   : 	if (_Count <= 0)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00009	33 c0		 xor	 eax, eax
  0000b	85 c9		 test	 ecx, ecx

; 34   : 		_Count = 0;
; 35   : 	else if (((_SIZT)(-1) / sizeof (_Ty) < _Count)

  0000d	74 46		 je	 SHORT $LN5@Allocate

; 36   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000f	81 f9 aa aa aa
	0a		 cmp	 ecx, 178956970		; 0aaaaaaaH
  00015	77 16		 ja	 SHORT $LN1@Allocate
  00017	8d 04 49	 lea	 eax, DWORD PTR [ecx+ecx*2]
  0001a	03 c0		 add	 eax, eax
  0001c	03 c0		 add	 eax, eax
  0001e	03 c0		 add	 eax, eax
  00020	50		 push	 eax
  00021	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00026	83 c4 04	 add	 esp, 4
  00029	85 c0		 test	 eax, eax

; 38   : 
; 39   : 	return ((_Ty _FARQ *)_Ptr);

  0002b	75 28		 jne	 SHORT $LN5@Allocate
$LN1@Allocate:

; 37   : 		_THROW_NCEE(bad_alloc, 0);

  0002d	8d 4d 08	 lea	 ecx, DWORD PTR $T192284[ebp]
  00030	51		 push	 ecx
  00031	8d 4d f4	 lea	 ecx, DWORD PTR $T192279[ebp]
  00034	c7 45 08 00 00
	00 00		 mov	 DWORD PTR $T192284[ebp], 0
  0003b	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00040	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00045	8d 55 f4	 lea	 edx, DWORD PTR $T192279[ebp]
  00048	52		 push	 edx
  00049	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T192279[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00050	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN10@Allocate:
$LN5@Allocate:

; 40   : 	}

  00055	8b e5		 mov	 esp, ebp
  00057	5d		 pop	 ebp
  00058	c3		 ret	 0
$LN9@Allocate:
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@0@IPAU120@@Z ENDP ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::_Node>
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  00006	56		 push	 esi
  00007	50		 push	 eax
  00008	8b f1		 mov	 esi, ecx
  0000a	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  0000f	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
  00015	8b c6		 mov	 eax, esi
  00017	5e		 pop	 esi
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@std@@QAEXPAU?$pair@$$CBHPAUOBJECTSTRUCT@@@2@@Z ; std::allocator<std::pair<int const ,OBJECTSTRUCT *> >::destroy
; Function compile flags: /Ogtp
;	COMDAT ?destroy@?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@std@@QAEXPAU?$pair@$$CBHPAUOBJECTSTRUCT@@@2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?destroy@?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@std@@QAEXPAU?$pair@$$CBHPAUOBJECTSTRUCT@@@2@@Z PROC ; std::allocator<std::pair<int const ,OBJECTSTRUCT *> >::destroy, COMDAT
; _this$ = ecx

; 213  : 		_Destroy(_Ptr);
; 214  : 		}

  00000	c2 04 00	 ret	 4
?destroy@?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@std@@QAEXPAU?$pair@$$CBHPAUOBJECTSTRUCT@@@2@@Z ENDP ; std::allocator<std::pair<int const ,OBJECTSTRUCT *> >::destroy
_TEXT	ENDS
PUBLIC	?max_size@?$_Tree@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::max_size
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ?max_size@?$_Tree@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$_Tree@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@QBEIXZ PROC ; std::_Tree<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::max_size, COMDAT
; _this$ = ecx

; 874  : 		return (this->_Alval.max_size());

  00000	b8 ff ff ff 1f	 mov	 eax, 536870911		; 1fffffffH

; 875  : 		}

  00005	c3		 ret	 0
?max_size@?$_Tree@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::max_size
_TEXT	ENDS
PUBLIC	??0?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> > >,bool>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??0?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z PROC ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> > >,bool>, COMDAT
; _this$ = ecx

; 145  : 		{	// construct from specified values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Val1$[ebp]
  00008	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Val2$[ebp]
  0000d	89 10		 mov	 DWORD PTR [eax], edx
  0000f	8a 11		 mov	 dl, BYTE PTR [ecx]
  00011	88 50 04	 mov	 BYTE PTR [eax+4], dl

; 146  : 		}

  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
??0?$_Pair_base@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z ENDP ; std::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> > >,bool>::_Pair_base<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> > >,bool>
_TEXT	ENDS
PUBLIC	??F?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> > >::operator--
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??F?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> > >::operator--, COMDAT
; _this$ = ecx

; 277  : 		{	// predecrement

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 278  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 279  : 		if (this->_Getcont() == 0
; 280  : 			|| this->_Ptr == 0)
; 281  : 			{	// report error
; 282  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 283  : 			_SCL_SECURE_OUT_OF_RANGE;
; 284  : 			}
; 285  : 
; 286  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 287  : 		--(*(_Mybase *)this);
; 288  : 		if (_Ptrsav == this->_Ptr)
; 289  : 			{	// report error
; 290  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 291  : 			_SCL_SECURE_OUT_OF_RANGE;
; 292  : 			}
; 293  : 
; 294  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 295  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 296  : 
; 297  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 298  : 		--(*(_Mybase *)this);
; 299  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 300  : 
; 301  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 302  : 		--(*(_Mybase *)this);

  00003	e8 00 00 00 00	 call	 ??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >,std::_Iterator_base0>::operator--

; 303  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 304  : 
; 305  : 		return (*this);

  00008	8b c6		 mov	 eax, esi
  0000a	5e		 pop	 esi

; 306  : 		}

  0000b	c3		 ret	 0
??F?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> > >::operator--
_TEXT	ENDS
PUBLIC	??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@std@@_N@?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> > > &,bool>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@std@@_N@?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@std@@_N@?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z PROC ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> > > &,bool>, COMDAT
; _this$ = ecx

; 247  : 		{	// construct from moved values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Val1$[ebp]
  00008	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Val2$[ebp]
  0000d	89 10		 mov	 DWORD PTR [eax], edx
  0000f	8a 11		 mov	 dl, BYTE PTR [ecx]
  00011	88 50 04	 mov	 BYTE PTR [eax+4], dl

; 248  : 		}

  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
??$?0AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@std@@_N@?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z ENDP ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> > > &,bool>
_TEXT	ENDS
PUBLIC	??$?0HPAUOBJECTSTRUCT@@@?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@QAE@$$QAU?$pair@HPAUOBJECTSTRUCT@@@1@@Z ; std::pair<int const ,OBJECTSTRUCT *>::pair<int const ,OBJECTSTRUCT *><int,OBJECTSTRUCT *>
; Function compile flags: /Ogtp
;	COMDAT ??$?0HPAUOBJECTSTRUCT@@@?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@QAE@$$QAU?$pair@HPAUOBJECTSTRUCT@@@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??$?0HPAUOBJECTSTRUCT@@@?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@QAE@$$QAU?$pair@HPAUOBJECTSTRUCT@@@1@@Z PROC ; std::pair<int const ,OBJECTSTRUCT *>::pair<int const ,OBJECTSTRUCT *><int,OBJECTSTRUCT *>, COMDAT
; _this$ = ecx

; 255  : 		{	// construct from moved compatible pair

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00008	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000a	89 10		 mov	 DWORD PTR [eax], edx
  0000c	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0000f	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 256  : 		}

  00012	5d		 pop	 ebp
  00013	c2 04 00	 ret	 4
??$?0HPAUOBJECTSTRUCT@@@?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@QAE@$$QAU?$pair@HPAUOBJECTSTRUCT@@@1@@Z ENDP ; std::pair<int const ,OBJECTSTRUCT *>::pair<int const ,OBJECTSTRUCT *><int,OBJECTSTRUCT *>
_TEXT	ENDS
PUBLIC	??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@std@@QAE@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> > >::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@std@@QAE@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> > >::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> > >, COMDAT
; _this$ = ecx

; 372  : 	_Tree_iterator()

  00000	8b c1		 mov	 eax, ecx
  00002	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 373  : 		{	// construct with null node
; 374  : 		}

  00008	c3		 ret	 0
??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> > >::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> > >
_TEXT	ENDS
PUBLIC	??C?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@std@@QBEPAU?$pair@$$CBHPAUOBJECTSTRUCT@@@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> > >::operator->
; Function compile flags: /Ogtp
;	COMDAT ??C?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@std@@QBEPAU?$pair@$$CBHPAUOBJECTSTRUCT@@@1@XZ
_TEXT	SEGMENT
??C?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@std@@QBEPAU?$pair@$$CBHPAUOBJECTSTRUCT@@@1@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> > >::operator->, COMDAT
; _this$ = ecx

; 401  : 		return (&**this);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 0c	 add	 eax, 12			; 0000000cH

; 402  : 		}

  00005	c3		 ret	 0
??C?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@std@@QBEPAU?$pair@$$CBHPAUOBJECTSTRUCT@@@1@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> > >::operator->
_TEXT	ENDS
PUBLIC	?_Lrotate@?$_Tree@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::_Lrotate
; Function compile flags: /Ogtp
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Wherenode$ = 8					; size = 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::_Lrotate, COMDAT
; _this$ = ecx

; 1763 : 		{	// promote right node to root of subtree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1764 : 		_Nodeptr _Pnode = this->_Right(_Wherenode);

  00003	8b 55 08	 mov	 edx, DWORD PTR __Wherenode$[ebp]
  00006	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00009	56		 push	 esi

; 1765 : 		this->_Right(_Wherenode) = this->_Left(_Pnode);

  0000a	8b 30		 mov	 esi, DWORD PTR [eax]
  0000c	89 72 08	 mov	 DWORD PTR [edx+8], esi

; 1766 : 
; 1767 : 		if (!this->_Isnil(this->_Left(_Pnode)))

  0000f	8b 30		 mov	 esi, DWORD PTR [eax]
  00011	80 7e 15 00	 cmp	 BYTE PTR [esi+21], 0
  00015	75 03		 jne	 SHORT $LN5@Lrotate

; 1768 : 			this->_Parent(this->_Left(_Pnode)) = _Wherenode;

  00017	89 56 04	 mov	 DWORD PTR [esi+4], edx
$LN5@Lrotate:

; 1769 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

  0001a	8b 72 04	 mov	 esi, DWORD PTR [edx+4]
  0001d	89 70 04	 mov	 DWORD PTR [eax+4], esi

; 1770 : 
; 1771 : 		if (_Wherenode == _Root())

  00020	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00023	5e		 pop	 esi
  00024	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  00027	75 0c		 jne	 SHORT $LN4@Lrotate

; 1772 : 			_Root() = _Pnode;

  00029	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1777 : 
; 1778 : 		this->_Left(_Pnode) = _Wherenode;

  0002c	89 10		 mov	 DWORD PTR [eax], edx

; 1779 : 		this->_Parent(_Wherenode) = _Pnode;

  0002e	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 1780 : 		}

  00031	5d		 pop	 ebp
  00032	c2 04 00	 ret	 4
$LN4@Lrotate:

; 1773 : 		else if (_Wherenode == this->_Left(this->_Parent(_Wherenode)))

  00035	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00038	3b 11		 cmp	 edx, DWORD PTR [ecx]
  0003a	75 0b		 jne	 SHORT $LN2@Lrotate

; 1774 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;

  0003c	89 01		 mov	 DWORD PTR [ecx], eax

; 1777 : 
; 1778 : 		this->_Left(_Pnode) = _Wherenode;

  0003e	89 10		 mov	 DWORD PTR [eax], edx

; 1779 : 		this->_Parent(_Wherenode) = _Pnode;

  00040	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 1780 : 		}

  00043	5d		 pop	 ebp
  00044	c2 04 00	 ret	 4
$LN2@Lrotate:

; 1775 : 		else
; 1776 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;

  00047	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 1777 : 
; 1778 : 		this->_Left(_Pnode) = _Wherenode;

  0004a	89 10		 mov	 DWORD PTR [eax], edx

; 1779 : 		this->_Parent(_Wherenode) = _Pnode;

  0004c	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 1780 : 		}

  0004f	5d		 pop	 ebp
  00050	c2 04 00	 ret	 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::_Lrotate
_TEXT	ENDS
PUBLIC	??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@1@@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> > >::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> > >
; Function compile flags: /Ogtp
;	COMDAT ??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@1@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> > >::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> > >, COMDAT
; _this$ = ecx

; 213  : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 214  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@1@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> > >::_Tree_const_iterator<std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> > >
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::_Node>::allocate
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
$T192486 = -12						; size = 12
$T192478 = 8						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@2@I@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::_Node>::allocate, COMDAT
; _this$ = ecx

; 186  : 		{	// allocate array of _Count elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 187  : 		return (_Allocate(_Count, (pointer)0));

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00006	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00009	33 c0		 xor	 eax, eax
  0000b	85 c9		 test	 ecx, ecx
  0000d	74 46		 je	 SHORT $LN1@allocate
  0000f	81 f9 aa aa aa
	0a		 cmp	 ecx, 178956970		; 0aaaaaaaH
  00015	77 16		 ja	 SHORT $LN3@allocate
  00017	8d 04 49	 lea	 eax, DWORD PTR [ecx+ecx*2]
  0001a	03 c0		 add	 eax, eax
  0001c	03 c0		 add	 eax, eax
  0001e	03 c0		 add	 eax, eax
  00020	50		 push	 eax
  00021	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00026	83 c4 04	 add	 esp, 4
  00029	85 c0		 test	 eax, eax
  0002b	75 28		 jne	 SHORT $LN1@allocate
$LN3@allocate:
  0002d	8d 4d 08	 lea	 ecx, DWORD PTR $T192478[ebp]
  00030	51		 push	 ecx
  00031	8d 4d f4	 lea	 ecx, DWORD PTR $T192486[ebp]
  00034	c7 45 08 00 00
	00 00		 mov	 DWORD PTR $T192478[ebp], 0
  0003b	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00040	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00045	8d 55 f4	 lea	 edx, DWORD PTR $T192486[ebp]
  00048	52		 push	 edx
  00049	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T192486[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00050	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN13@allocate:
$LN1@allocate:

; 188  : 		}

  00055	8b e5		 mov	 esp, ebp
  00057	5d		 pop	 ebp
  00058	c2 04 00	 ret	 4
$LN12@allocate:
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::_Node>::allocate
_TEXT	ENDS
PUBLIC	??$_Dest_val@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@std@@U?$pair@$$CBHPAUOBJECTSTRUCT@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@0@PAU?$pair@$$CBHPAUOBJECTSTRUCT@@@0@@Z ; std::_Dest_val<std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,std::pair<int const ,OBJECTSTRUCT *> >
; Function compile flags: /Ogtp
;	COMDAT ??$_Dest_val@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@std@@U?$pair@$$CBHPAUOBJECTSTRUCT@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@0@PAU?$pair@$$CBHPAUOBJECTSTRUCT@@@0@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
??$_Dest_val@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@std@@U?$pair@$$CBHPAUOBJECTSTRUCT@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@0@PAU?$pair@$$CBHPAUOBJECTSTRUCT@@@0@@Z PROC ; std::_Dest_val<std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,std::pair<int const ,OBJECTSTRUCT *> >, COMDAT

; 287  : 	_Alval.destroy(_Pdest);
; 288  : 	}

  00000	c3		 ret	 0
??$_Dest_val@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@std@@U?$pair@$$CBHPAUOBJECTSTRUCT@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@0@PAU?$pair@$$CBHPAUOBJECTSTRUCT@@@0@@Z ENDP ; std::_Dest_val<std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,std::pair<int const ,OBJECTSTRUCT *> >
_TEXT	ENDS
PUBLIC	??0?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> > >,bool>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\utility
;	COMDAT ??0?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z PROC ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> > >,bool>, COMDAT
; _this$ = ecx

; 227  : 		{	// construct from specified values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Val1$[ebp]
  00008	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Val2$[ebp]
  0000d	89 10		 mov	 DWORD PTR [eax], edx
  0000f	8a 11		 mov	 dl, BYTE PTR [ecx]
  00011	88 50 04	 mov	 BYTE PTR [eax+4], dl

; 228  : 		}

  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
??0?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@1@$$QA_N@Z ENDP ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> > >,bool>
_TEXT	ENDS
PUBLIC	??F?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> > >::operator--
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??F?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> > >::operator--, COMDAT
; _this$ = ecx

; 418  : 		{	// predecrement

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 419  : 		--(*(_Mybase *)this);

  00003	e8 00 00 00 00	 call	 ??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >,std::_Iterator_base0>::operator--

; 420  : 		return (*this);

  00008	8b c6		 mov	 eax, esi
  0000a	5e		 pop	 esi

; 421  : 		}

  0000b	c3		 ret	 0
??F?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> > >::operator--
_TEXT	ENDS
PUBLIC	?_Buynode@?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@2@XZ ; std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::_Buynode
; Function compile flags: /Ogtp
;	COMDAT ?_Buynode@?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@2@XZ
_TEXT	SEGMENT
$T192548 = -16						; size = 12
$T192532 = -4						; size = 4
?_Buynode@?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@2@XZ PROC ; std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::_Buynode, COMDAT
; _this$ = ecx

; 559  : 		{	// allocate a node

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi

; 560  : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

  00007	6a 18		 push	 24			; 00000018H
  00009	8b f1		 mov	 esi, ecx
  0000b	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00010	33 c9		 xor	 ecx, ecx
  00012	83 c4 04	 add	 esp, 4
  00015	3b c1		 cmp	 eax, ecx
  00017	74 1a		 je	 SHORT $LN5@Buynode

; 561  : 
; 562  : 		this->_Left(_Wherenode) = this->_Myhead;

  00019	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0001c	89 10		 mov	 DWORD PTR [eax], edx

; 563  : 		this->_Parent(_Wherenode) = this->_Myhead;

  0001e	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00021	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 564  : 		this->_Right(_Wherenode) = this->_Myhead;

  00024	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00027	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 565  : 		this->_Color(_Wherenode) = this->_Red;

  0002a	66 89 48 14	 mov	 WORD PTR [eax+20], cx
  0002e	5e		 pop	 esi

; 566  : 		this->_Isnil(_Wherenode) = false;
; 567  : 		return (_Wherenode);
; 568  : 		}

  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0

; 560  : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

$LN5@Buynode:
  00033	8d 45 fc	 lea	 eax, DWORD PTR $T192532[ebp]
  00036	89 4d fc	 mov	 DWORD PTR $T192532[ebp], ecx
  00039	50		 push	 eax
  0003a	8d 4d f0	 lea	 ecx, DWORD PTR $T192548[ebp]
  0003d	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00042	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00047	8d 4d f0	 lea	 ecx, DWORD PTR $T192548[ebp]
  0004a	51		 push	 ecx
  0004b	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T192548[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00052	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN27@Buynode:
$LN26@Buynode:
  00057	cc		 int	 3
?_Buynode@?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@2@XZ ENDP ; std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::_Buynode
_TEXT	ENDS
PUBLIC	??$construct@U?$pair@HPAUOBJECTSTRUCT@@@std@@@?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@std@@QAEXPAU?$pair@$$CBHPAUOBJECTSTRUCT@@@1@$$QAU?$pair@HPAUOBJECTSTRUCT@@@1@@Z ; std::allocator<std::pair<int const ,OBJECTSTRUCT *> >::construct<std::pair<int,OBJECTSTRUCT *> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$construct@U?$pair@HPAUOBJECTSTRUCT@@@std@@@?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@std@@QAEXPAU?$pair@$$CBHPAUOBJECTSTRUCT@@@1@$$QAU?$pair@HPAUOBJECTSTRUCT@@@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$construct@U?$pair@HPAUOBJECTSTRUCT@@@std@@@?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@std@@QAEXPAU?$pair@$$CBHPAUOBJECTSTRUCT@@@1@$$QAU?$pair@HPAUOBJECTSTRUCT@@@1@@Z PROC ; std::allocator<std::pair<int const ,OBJECTSTRUCT *> >::construct<std::pair<int,OBJECTSTRUCT *> >, COMDAT
; _this$ = ecx

; 206  : 		void construct(pointer _Ptr, _Other&& _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 207  : 		{	// construct object at _Ptr with value _Val
; 208  : 		::new ((void _FARQ *)_Ptr) _Ty(_STD forward<_Other>(_Val));

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 0d		 je	 SHORT $LN3@construct
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0000d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000f	89 10		 mov	 DWORD PTR [eax], edx
  00011	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00014	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN3@construct:

; 209  : 		}

  00017	5d		 pop	 ebp
  00018	c2 08 00	 ret	 8
??$construct@U?$pair@HPAUOBJECTSTRUCT@@@std@@@?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@std@@QAEXPAU?$pair@$$CBHPAUOBJECTSTRUCT@@@1@$$QAU?$pair@HPAUOBJECTSTRUCT@@@1@@Z ENDP ; std::allocator<std::pair<int const ,OBJECTSTRUCT *> >::construct<std::pair<int,OBJECTSTRUCT *> >
_TEXT	ENDS
PUBLIC	??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@1@@Z ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> > >::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@1@@Z PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> > >::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> > >, COMDAT
; _this$ = ecx

; 378  : 		{	// construct with node pointer _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b c1		 mov	 eax, ecx
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 379  : 		}

  0000a	5d		 pop	 ebp
  0000b	c2 08 00	 ret	 8
??0?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@1@PBV?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@1@@Z ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> > >::_Tree_iterator<std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> > >
_TEXT	ENDS
PUBLIC	?begin@?$_Tree@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::begin
; Function compile flags: /Ogtp
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$_Tree@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::begin, COMDAT
; _this$ = ecx

; 806  : 		{	// return iterator for beginning of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 807  : 		return (iterator(_Lmost(), this));

  00003	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00006	8b 08		 mov	 ecx, DWORD PTR [eax]
  00008	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0000b	89 08		 mov	 DWORD PTR [eax], ecx

; 808  : 		}

  0000d	5d		 pop	 ebp
  0000e	c2 04 00	 ret	 4
?begin@?$_Tree@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::begin
_TEXT	ENDS
PUBLIC	??0?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >
; Function compile flags: /Ogtp
;	COMDAT ??0?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@1@@Z
_TEXT	SEGMENT
$T192723 = -16						; size = 12
$T192707 = -4						; size = 4
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@1@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >, COMDAT
; _this$ = ecx

; 542  : 		{	// construct base, and allocator from _Al

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx

; 543  : 		this->_Mysize = 0;
; 544  : 		this->_Myhead = this->_Alnod.allocate(1);

  00009	6a 18		 push	 24			; 00000018H
  0000b	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00012	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00017	83 c4 04	 add	 esp, 4
  0001a	85 c0		 test	 eax, eax
  0001c	74 28		 je	 SHORT $LN15@Tree_val
  0001e	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 545  : 
; 546  : 		this->_Left(this->_Myhead) = this->_Myhead;

  00021	89 00		 mov	 DWORD PTR [eax], eax

; 547  : 		this->_Parent(this->_Myhead) = this->_Myhead;

  00023	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00026	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 548  : 		this->_Right(this->_Myhead) = this->_Myhead;

  00029	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0002c	89 40 08	 mov	 DWORD PTR [eax+8], eax

; 549  : 		this->_Color(this->_Myhead) = this->_Black;

  0002f	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00032	b0 01		 mov	 al, 1
  00034	88 41 14	 mov	 BYTE PTR [ecx+20], al

; 550  : 		this->_Isnil(this->_Myhead) = true;

  00037	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0003a	88 42 15	 mov	 BYTE PTR [edx+21], al

; 551  : 		}

  0003d	8b c6		 mov	 eax, esi
  0003f	5e		 pop	 esi
  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c2 08 00	 ret	 8

; 543  : 		this->_Mysize = 0;
; 544  : 		this->_Myhead = this->_Alnod.allocate(1);

$LN15@Tree_val:
  00046	8d 45 fc	 lea	 eax, DWORD PTR $T192707[ebp]
  00049	50		 push	 eax
  0004a	8d 4d f0	 lea	 ecx, DWORD PTR $T192723[ebp]
  0004d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T192707[ebp], 0
  00054	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00059	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0005e	8d 4d f0	 lea	 ecx, DWORD PTR $T192723[ebp]
  00061	51		 push	 ecx
  00062	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T192723[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00069	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN37@Tree_val:
$LN36@Tree_val:
  0006e	cc		 int	 3
??0?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@1@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >
_TEXT	ENDS
PUBLIC	?_Erase@?$_Tree@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::_Erase
; Function compile flags: /Ogtp
;	COMDAT ?_Erase@?$_Tree@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Rootnode$ = 8						; size = 4
?_Erase@?$_Tree@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::_Erase, COMDAT
; _this$ = ecx

; 1610 : 		{	// free entire subtree, recursively

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	57		 push	 edi

; 1611 : 		for (_Nodeptr _Pnode = _Rootnode;

  00006	8b 7d 08	 mov	 edi, DWORD PTR __Rootnode$[ebp]

; 1612 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)

  00009	80 7f 15 00	 cmp	 BYTE PTR [edi+21], 0
  0000d	8b d9		 mov	 ebx, ecx
  0000f	8b f7		 mov	 esi, edi
  00011	75 1e		 jne	 SHORT $LN1@Erase
$LL3@Erase:

; 1613 : 			{	// free subtrees, then node
; 1614 : 			_Erase(this->_Right(_Pnode));

  00013	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00016	50		 push	 eax
  00017	8b cb		 mov	 ecx, ebx
  00019	e8 00 00 00 00	 call	 ?_Erase@?$_Tree@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::_Erase

; 1615 : 			_Pnode = this->_Left(_Pnode);

  0001e	8b 36		 mov	 esi, DWORD PTR [esi]

; 1616 : 			_Dest_val(this->_Alval,
; 1617 : 				_STD addressof(this->_Myval(_Rootnode)));
; 1618 : 
; 1619 : 			this->_Alnod.deallocate(_Rootnode, 1);

  00020	57		 push	 edi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00026	83 c4 04	 add	 esp, 4
  00029	80 7e 15 00	 cmp	 BYTE PTR [esi+21], 0
  0002d	8b fe		 mov	 edi, esi
  0002f	74 e2		 je	 SHORT $LL3@Erase
$LN1@Erase:
  00031	5f		 pop	 edi
  00032	5e		 pop	 esi
  00033	5b		 pop	 ebx

; 1620 : 			}
; 1621 : 		}

  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4
?_Erase@?$_Tree@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::_Erase
_TEXT	ENDS
PUBLIC	??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?_Insert@?$_Tree@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::_Insert
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
;	COMDAT ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
CONST	SEGMENT
??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@ DB 'map/set<T> too l'
	DB	'ong', 00H					; `string'
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
CONST	ENDS
;	COMDAT ?_Insert@?$_Tree@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@2@1@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Addleft$ = 12						; size = 1
__Wherenode$ = 16					; size = 4
__Newnode$ = 20						; size = 4
?_Insert@?$_Tree@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@2@1@Z PROC ; std::_Tree<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::_Insert, COMDAT
; _this$ = ecx

; 1631 : 		{	// add node with value next to _Wherenode, to left if _Addleft

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1632 : 		if (max_size() - 1 <= this->_Mysize)

  00003	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00006	3d fe ff ff 1f	 cmp	 eax, 536870910		; 1ffffffeH
  0000b	72 16		 jb	 SHORT $LN17@Insert

; 1633 : 			{	// tree would get too big, fail
; 1634 : 			_Dest_val(this->_Alval,
; 1635 : 				_STD addressof(this->_Myval(_Newnode)));
; 1636 : 
; 1637 : 			this->_Alnod.deallocate(_Newnode, 1);

  0000d	8b 45 14	 mov	 eax, DWORD PTR __Newnode$[ebp]
  00010	50		 push	 eax
  00011	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00016	83 c4 04	 add	 esp, 4

; 1638 : 
; 1639 : 			_Xlength_error("map/set<T> too long");

  00019	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
  0001e	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN377@Insert:
$LN17@Insert:

; 1640 : 			}
; 1641 : 		++this->_Mysize;

  00023	40		 inc	 eax
  00024	53		 push	 ebx
  00025	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 1642 : 		_Newnode->_Parent = _Wherenode;

  00028	8b 45 10	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0002b	57		 push	 edi
  0002c	8b 7d 14	 mov	 edi, DWORD PTR __Newnode$[ebp]
  0002f	89 47 04	 mov	 DWORD PTR [edi+4], eax

; 1643 : 
; 1644 : 		if (_Wherenode == this->_Myhead)

  00032	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00035	32 db		 xor	 bl, bl
  00037	3b c2		 cmp	 eax, edx
  00039	75 10		 jne	 SHORT $LN16@Insert

; 1645 : 			{	// first node in tree, just set head values
; 1646 : 			_Root() = _Newnode;

  0003b	89 7a 04	 mov	 DWORD PTR [edx+4], edi

; 1647 : 			_Lmost() = _Newnode;

  0003e	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00041	89 3a		 mov	 DWORD PTR [edx], edi

; 1648 : 			_Rmost() = _Newnode;

  00043	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00046	89 78 08	 mov	 DWORD PTR [eax+8], edi
  00049	eb 20		 jmp	 SHORT $LN11@Insert
$LN16@Insert:

; 1649 : 			}
; 1650 : 		else if (_Addleft)

  0004b	38 5d 0c	 cmp	 BYTE PTR __Addleft$[ebp], bl
  0004e	74 0d		 je	 SHORT $LN14@Insert

; 1651 : 			{	// add to left of _Wherenode
; 1652 : 			this->_Left(_Wherenode) = _Newnode;

  00050	89 38		 mov	 DWORD PTR [eax], edi

; 1653 : 			if (_Wherenode == _Lmost())

  00052	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00055	3b 02		 cmp	 eax, DWORD PTR [edx]
  00057	75 12		 jne	 SHORT $LN11@Insert

; 1654 : 				_Lmost() = _Newnode;

  00059	89 3a		 mov	 DWORD PTR [edx], edi

; 1655 : 			}
; 1656 : 		else

  0005b	eb 0e		 jmp	 SHORT $LN11@Insert
$LN14@Insert:

; 1657 : 			{	// add to right of _Wherenode
; 1658 : 			this->_Right(_Wherenode) = _Newnode;

  0005d	89 78 08	 mov	 DWORD PTR [eax+8], edi

; 1659 : 			if (_Wherenode == _Rmost())

  00060	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00063	3b 42 08	 cmp	 eax, DWORD PTR [edx+8]
  00066	75 03		 jne	 SHORT $LN11@Insert

; 1660 : 				_Rmost() = _Newnode;

  00068	89 7a 08	 mov	 DWORD PTR [edx+8], edi
$LN11@Insert:

; 1661 : 			}
; 1662 : 
; 1663 : 		for (_Nodeptr _Pnode = _Newnode;
; 1664 : 			this->_Color(this->_Parent(_Pnode)) == this->_Red; )

  0006b	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  0006e	8b c7		 mov	 eax, edi
  00070	38 5a 14	 cmp	 BYTE PTR [edx+20], bl
  00073	0f 85 97 01 00
	00		 jne	 $LN9@Insert
  00079	56		 push	 esi
  0007a	8d 9b 00 00 00
	00		 npad	 6
$LL10@Insert:

; 1665 : 			if (this->_Parent(_Pnode)
; 1666 : 				== this->_Left(this->_Parent(this->_Parent(_Pnode))))

  00080	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00083	8b 72 04	 mov	 esi, DWORD PTR [edx+4]
  00086	3b 16		 cmp	 edx, DWORD PTR [esi]
  00088	0f 85 c1 00 00
	00		 jne	 $LN8@Insert

; 1667 : 				{	// fixup red-red in left subtree
; 1668 : 				_Wherenode =
; 1669 : 					this->_Right(this->_Parent(this->_Parent(_Pnode)));

  0008e	8b 76 08	 mov	 esi, DWORD PTR [esi+8]

; 1670 : 				if (this->_Color(_Wherenode) == this->_Red)

  00091	38 5e 14	 cmp	 BYTE PTR [esi+20], bl
  00094	75 1c		 jne	 SHORT $LN7@Insert

; 1671 : 					{	// parent has two red children, blacken both
; 1672 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;

  00096	c6 42 14 01	 mov	 BYTE PTR [edx+20], 1

; 1673 : 					this->_Color(_Wherenode) = this->_Black;

  0009a	c6 46 14 01	 mov	 BYTE PTR [esi+20], 1

; 1674 : 					this->_Color(this->_Parent(this->_Parent(_Pnode)))
; 1675 : 						= this->_Red;

  0009e	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000a1	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  000a4	88 5a 14	 mov	 BYTE PTR [edx+20], bl

; 1676 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));

  000a7	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000aa	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 1677 : 					}
; 1678 : 				else

  000ad	e9 51 01 00 00	 jmp	 $LN316@Insert
$LN7@Insert:

; 1679 : 					{	// parent has red and black children
; 1680 : 					if (_Pnode == this->_Right(this->_Parent(_Pnode)))

  000b2	3b 42 08	 cmp	 eax, DWORD PTR [edx+8]
  000b5	75 3a		 jne	 SHORT $LN111@Insert

; 1681 : 						{	// rotate right child to left
; 1682 : 						_Pnode = this->_Parent(_Pnode);

  000b7	8b c2		 mov	 eax, edx

; 1683 : 						_Lrotate(_Pnode);

  000b9	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  000bc	8b 32		 mov	 esi, DWORD PTR [edx]
  000be	89 70 08	 mov	 DWORD PTR [eax+8], esi
  000c1	8b 32		 mov	 esi, DWORD PTR [edx]
  000c3	38 5e 15	 cmp	 BYTE PTR [esi+21], bl
  000c6	75 03		 jne	 SHORT $LN110@Insert
  000c8	89 46 04	 mov	 DWORD PTR [esi+4], eax
$LN110@Insert:
  000cb	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  000ce	89 72 04	 mov	 DWORD PTR [edx+4], esi
  000d1	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  000d4	3b 46 04	 cmp	 eax, DWORD PTR [esi+4]
  000d7	75 05		 jne	 SHORT $LN109@Insert
  000d9	89 56 04	 mov	 DWORD PTR [esi+4], edx
  000dc	eb 0e		 jmp	 SHORT $LN106@Insert
$LN109@Insert:
  000de	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  000e1	3b 06		 cmp	 eax, DWORD PTR [esi]
  000e3	75 04		 jne	 SHORT $LN107@Insert
  000e5	89 16		 mov	 DWORD PTR [esi], edx
  000e7	eb 03		 jmp	 SHORT $LN106@Insert
$LN107@Insert:
  000e9	89 56 08	 mov	 DWORD PTR [esi+8], edx
$LN106@Insert:
  000ec	89 02		 mov	 DWORD PTR [edx], eax
  000ee	89 50 04	 mov	 DWORD PTR [eax+4], edx
$LN111@Insert:

; 1684 : 						}
; 1685 : 					this->_Color(this->_Parent(_Pnode)) =
; 1686 : 						this->_Black;	// propagate red up

  000f1	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000f4	c6 42 14 01	 mov	 BYTE PTR [edx+20], 1

; 1687 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1688 : 						this->_Red;

  000f8	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000fb	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  000fe	88 5a 14	 mov	 BYTE PTR [edx+20], bl

; 1689 : 					_Rrotate(this->_Parent(this->_Parent(_Pnode)));

  00101	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00104	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  00107	8b 32		 mov	 esi, DWORD PTR [edx]
  00109	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  0010c	89 3a		 mov	 DWORD PTR [edx], edi
  0010e	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]
  00111	38 5f 15	 cmp	 BYTE PTR [edi+21], bl
  00114	75 03		 jne	 SHORT $LN173@Insert
  00116	89 57 04	 mov	 DWORD PTR [edi+4], edx
$LN173@Insert:
  00119	8b 7a 04	 mov	 edi, DWORD PTR [edx+4]
  0011c	89 7e 04	 mov	 DWORD PTR [esi+4], edi
  0011f	8b 79 04	 mov	 edi, DWORD PTR [ecx+4]
  00122	3b 57 04	 cmp	 edx, DWORD PTR [edi+4]
  00125	75 0b		 jne	 SHORT $LN172@Insert
  00127	89 77 04	 mov	 DWORD PTR [edi+4], esi
  0012a	89 56 08	 mov	 DWORD PTR [esi+8], edx

; 1690 : 					}
; 1691 : 				}
; 1692 : 			else

  0012d	e9 cb 00 00 00	 jmp	 $LN376@Insert

; 1689 : 					_Rrotate(this->_Parent(this->_Parent(_Pnode)));

$LN172@Insert:
  00132	8b 7a 04	 mov	 edi, DWORD PTR [edx+4]
  00135	3b 57 08	 cmp	 edx, DWORD PTR [edi+8]
  00138	75 0b		 jne	 SHORT $LN170@Insert
  0013a	89 77 08	 mov	 DWORD PTR [edi+8], esi
  0013d	89 56 08	 mov	 DWORD PTR [esi+8], edx

; 1690 : 					}
; 1691 : 				}
; 1692 : 			else

  00140	e9 b8 00 00 00	 jmp	 $LN376@Insert

; 1689 : 					_Rrotate(this->_Parent(this->_Parent(_Pnode)));

$LN170@Insert:
  00145	89 37		 mov	 DWORD PTR [edi], esi
  00147	89 56 08	 mov	 DWORD PTR [esi+8], edx

; 1690 : 					}
; 1691 : 				}
; 1692 : 			else

  0014a	e9 ae 00 00 00	 jmp	 $LN376@Insert
$LN8@Insert:

; 1693 : 				{	// fixup red-red in right subtree
; 1694 : 				_Wherenode =
; 1695 : 					this->_Left(this->_Parent(this->_Parent(_Pnode)));

  0014f	8b 36		 mov	 esi, DWORD PTR [esi]

; 1696 : 				if (this->_Color(_Wherenode) == this->_Red)

  00151	38 5e 14	 cmp	 BYTE PTR [esi+20], bl
  00154	75 1c		 jne	 SHORT $LN3@Insert

; 1697 : 					{	// parent has two red children, blacken both
; 1698 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;

  00156	c6 42 14 01	 mov	 BYTE PTR [edx+20], 1

; 1699 : 					this->_Color(_Wherenode) = this->_Black;

  0015a	c6 46 14 01	 mov	 BYTE PTR [esi+20], 1

; 1700 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1701 : 						this->_Red;

  0015e	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00161	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  00164	88 5a 14	 mov	 BYTE PTR [edx+20], bl

; 1702 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));

  00167	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0016a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 1703 : 					}
; 1704 : 				else

  0016d	e9 91 00 00 00	 jmp	 $LN316@Insert
$LN3@Insert:

; 1705 : 					{	// parent has red and black children
; 1706 : 					if (_Pnode == this->_Left(this->_Parent(_Pnode)))

  00172	3b 02		 cmp	 eax, DWORD PTR [edx]
  00174	75 3c		 jne	 SHORT $LN253@Insert

; 1707 : 						{	// rotate left child to right
; 1708 : 						_Pnode = this->_Parent(_Pnode);

  00176	8b c2		 mov	 eax, edx

; 1709 : 						_Rrotate(_Pnode);

  00178	8b 10		 mov	 edx, DWORD PTR [eax]
  0017a	8b 72 08	 mov	 esi, DWORD PTR [edx+8]
  0017d	89 30		 mov	 DWORD PTR [eax], esi
  0017f	8b 72 08	 mov	 esi, DWORD PTR [edx+8]
  00182	38 5e 15	 cmp	 BYTE PTR [esi+21], bl
  00185	75 03		 jne	 SHORT $LN252@Insert
  00187	89 46 04	 mov	 DWORD PTR [esi+4], eax
$LN252@Insert:
  0018a	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  0018d	89 72 04	 mov	 DWORD PTR [edx+4], esi
  00190	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  00193	3b 46 04	 cmp	 eax, DWORD PTR [esi+4]
  00196	75 05		 jne	 SHORT $LN251@Insert
  00198	89 56 04	 mov	 DWORD PTR [esi+4], edx
  0019b	eb 0f		 jmp	 SHORT $LN248@Insert
$LN251@Insert:
  0019d	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  001a0	3b 46 08	 cmp	 eax, DWORD PTR [esi+8]
  001a3	75 05		 jne	 SHORT $LN249@Insert
  001a5	89 56 08	 mov	 DWORD PTR [esi+8], edx
  001a8	eb 02		 jmp	 SHORT $LN248@Insert
$LN249@Insert:
  001aa	89 16		 mov	 DWORD PTR [esi], edx
$LN248@Insert:
  001ac	89 42 08	 mov	 DWORD PTR [edx+8], eax
  001af	89 50 04	 mov	 DWORD PTR [eax+4], edx
$LN253@Insert:

; 1710 : 						}
; 1711 : 					this->_Color(this->_Parent(_Pnode)) =
; 1712 : 						this->_Black;	// propagate red up

  001b2	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  001b5	c6 42 14 01	 mov	 BYTE PTR [edx+20], 1

; 1713 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1714 : 						this->_Red;

  001b9	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  001bc	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  001bf	88 5a 14	 mov	 BYTE PTR [edx+20], bl

; 1715 : 					_Lrotate(this->_Parent(this->_Parent(_Pnode)));

  001c2	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  001c5	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  001c8	8b 72 08	 mov	 esi, DWORD PTR [edx+8]
  001cb	8b 3e		 mov	 edi, DWORD PTR [esi]
  001cd	89 7a 08	 mov	 DWORD PTR [edx+8], edi
  001d0	8b 3e		 mov	 edi, DWORD PTR [esi]
  001d2	38 5f 15	 cmp	 BYTE PTR [edi+21], bl
  001d5	75 03		 jne	 SHORT $LN315@Insert
  001d7	89 57 04	 mov	 DWORD PTR [edi+4], edx
$LN315@Insert:
  001da	8b 7a 04	 mov	 edi, DWORD PTR [edx+4]
  001dd	89 7e 04	 mov	 DWORD PTR [esi+4], edi
  001e0	8b 79 04	 mov	 edi, DWORD PTR [ecx+4]
  001e3	3b 57 04	 cmp	 edx, DWORD PTR [edi+4]
  001e6	75 05		 jne	 SHORT $LN314@Insert
  001e8	89 77 04	 mov	 DWORD PTR [edi+4], esi
  001eb	eb 0e		 jmp	 SHORT $LN311@Insert
$LN314@Insert:
  001ed	8b 7a 04	 mov	 edi, DWORD PTR [edx+4]
  001f0	3b 17		 cmp	 edx, DWORD PTR [edi]
  001f2	75 04		 jne	 SHORT $LN312@Insert
  001f4	89 37		 mov	 DWORD PTR [edi], esi
  001f6	eb 03		 jmp	 SHORT $LN311@Insert
$LN312@Insert:
  001f8	89 77 08	 mov	 DWORD PTR [edi+8], esi
$LN311@Insert:
  001fb	89 16		 mov	 DWORD PTR [esi], edx
$LN376@Insert:
  001fd	8b 7d 14	 mov	 edi, DWORD PTR __Newnode$[ebp]
  00200	89 72 04	 mov	 DWORD PTR [edx+4], esi
$LN316@Insert:

; 1661 : 			}
; 1662 : 
; 1663 : 		for (_Nodeptr _Pnode = _Newnode;
; 1664 : 			this->_Color(this->_Parent(_Pnode)) == this->_Red; )

  00203	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00206	38 5a 14	 cmp	 BYTE PTR [edx+20], bl
  00209	0f 84 71 fe ff
	ff		 je	 $LL10@Insert
  0020f	5e		 pop	 esi
$LN9@Insert:

; 1716 : 					}
; 1717 : 				}
; 1718 : 
; 1719 : 		this->_Color(_Root()) = this->_Black;	// root is always black

  00210	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00213	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]

; 1720 : 		return (iterator(_Newnode, this));

  00216	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00219	89 38		 mov	 DWORD PTR [eax], edi
  0021b	5f		 pop	 edi
  0021c	c6 41 14 01	 mov	 BYTE PTR [ecx+20], 1
  00220	5b		 pop	 ebx

; 1721 : 		}

  00221	5d		 pop	 ebp
  00222	c2 10 00	 ret	 16			; 00000010H
$LN375@Insert:
?_Insert@?$_Tree@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@2@1@Z ENDP ; std::_Tree<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::_Insert
_TEXT	ENDS
PUBLIC	??$_Cons_val@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@std@@U?$pair@$$CBHPAUOBJECTSTRUCT@@@2@U?$pair@HPAUOBJECTSTRUCT@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@0@PAU?$pair@$$CBHPAUOBJECTSTRUCT@@@0@$$QAU?$pair@HPAUOBJECTSTRUCT@@@0@@Z ; std::_Cons_val<std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,std::pair<int const ,OBJECTSTRUCT *>,std::pair<int,OBJECTSTRUCT *> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
;	COMDAT ??$_Cons_val@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@std@@U?$pair@$$CBHPAUOBJECTSTRUCT@@@2@U?$pair@HPAUOBJECTSTRUCT@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@0@PAU?$pair@$$CBHPAUOBJECTSTRUCT@@@0@$$QAU?$pair@HPAUOBJECTSTRUCT@@@0@@Z
_TEXT	SEGMENT
__Alval$ = 8						; size = 4
__Pdest$ = 12						; size = 4
__Src$ = 16						; size = 4
??$_Cons_val@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@std@@U?$pair@$$CBHPAUOBJECTSTRUCT@@@2@U?$pair@HPAUOBJECTSTRUCT@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@0@PAU?$pair@$$CBHPAUOBJECTSTRUCT@@@0@$$QAU?$pair@HPAUOBJECTSTRUCT@@@0@@Z PROC ; std::_Cons_val<std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,std::pair<int const ,OBJECTSTRUCT *>,std::pair<int,OBJECTSTRUCT *> >, COMDAT

; 279  : 	{	// construct using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 280  : 	_Alval.construct(_Pdest, _STD forward<_Ty2>(_Src));

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Pdest$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	74 0d		 je	 SHORT $LN7@Cons_val
  0000a	8b 4d 10	 mov	 ecx, DWORD PTR __Src$[ebp]
  0000d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000f	89 10		 mov	 DWORD PTR [eax], edx
  00011	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00014	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN7@Cons_val:

; 281  : 	}

  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
??$_Cons_val@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@std@@U?$pair@$$CBHPAUOBJECTSTRUCT@@@2@U?$pair@HPAUOBJECTSTRUCT@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@0@PAU?$pair@$$CBHPAUOBJECTSTRUCT@@@0@$$QAU?$pair@HPAUOBJECTSTRUCT@@@0@@Z ENDP ; std::_Cons_val<std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,std::pair<int const ,OBJECTSTRUCT *>,std::pair<int,OBJECTSTRUCT *> >
_TEXT	ENDS
PUBLIC	?end@?$_Tree@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::end
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$_Tree@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::end, COMDAT
; _this$ = ecx

; 816  : 		{	// return iterator for end of mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 817  : 		return (iterator(this->_Myhead, this));

  00003	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00006	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00009	89 08		 mov	 DWORD PTR [eax], ecx

; 818  : 		}

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
?end@?$_Tree@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::end
_TEXT	ENDS
PUBLIC	??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@ ; `string'
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::erase
EXTRN	?_Xout_of_range@std@@YAXPBD@Z:PROC		; std::_Xout_of_range
;	COMDAT ??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xutility
CONST	SEGMENT
??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@ DB 'invalid '
	DB	'map/set<T> iterator', 00H			; `string'
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
CONST	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@2@@Z
_TEXT	SEGMENT
tv795 = -12						; size = 4
__Erasednode$ = -8					; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::erase, COMDAT
; _this$ = ecx

; 1195 : 		{	// erase element at _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx

; 1196 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1197 : 		if (_Where._Getcont() != this || this->_Isnil(_Where._Mynode()))
; 1198 : 			_DEBUG_ERROR("map/set erase iterator outside range");
; 1199 : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 1200 : 		++_Where;	// save successor iterator for return
; 1201 : 		_Orphan_ptr(*this, _Erasednode);
; 1202 : 
; 1203 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1204 : 		if (this->_Isnil(_Where._Mynode()))

  00007	8b 5d 0c	 mov	 ebx, DWORD PTR __Where$[ebp]
  0000a	80 7b 15 00	 cmp	 BYTE PTR [ebx+21], 0
  0000e	56		 push	 esi
  0000f	57		 push	 edi
  00010	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00013	74 0a		 je	 SHORT $LN40@erase

; 1205 : 			_Xout_of_range("invalid map/set<T> iterator");

  00015	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@
  0001a	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN295@erase:
$LN40@erase:

; 1206 : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 1207 : 		++_Where;	// save successor iterator for return

  0001f	8d 4d 0c	 lea	 ecx, DWORD PTR __Where$[ebp]
  00022	89 5d f8	 mov	 DWORD PTR __Erasednode$[ebp], ebx
  00025	e8 00 00 00 00	 call	 ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >,std::_Iterator_base0>::operator++

; 1208 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1209 : 
; 1210 : 		_Nodeptr _Fixnode;	// the node to recolor as needed
; 1211 : 		_Nodeptr _Fixnodeparent;	// parent of _Fixnode (which may be nil)
; 1212 : 		_Nodeptr _Pnode = _Erasednode;
; 1213 : 
; 1214 : 		if (this->_Isnil(this->_Left(_Pnode)))

  0002a	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  0002c	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  00030	74 05		 je	 SHORT $LN39@erase

; 1215 : 			_Fixnode = this->_Right(_Pnode);	// stitch up right subtree

  00032	8b 7b 08	 mov	 edi, DWORD PTR [ebx+8]

; 1216 : 		else if (this->_Isnil(this->_Right(_Pnode)))

  00035	eb 17		 jmp	 SHORT $LN291@erase
$LN39@erase:
  00037	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  0003a	80 78 15 00	 cmp	 BYTE PTR [eax+21], 0
  0003e	74 04		 je	 SHORT $LN37@erase

; 1217 : 			_Fixnode = this->_Left(_Pnode);	// stitch up left subtree

  00040	8b f9		 mov	 edi, ecx

; 1218 : 		else

  00042	eb 0a		 jmp	 SHORT $LN291@erase
$LN37@erase:

; 1219 : 			{	// two subtrees, must lift successor node to replace erased
; 1220 : 			_Pnode = _Where._Mynode();	// _Pnode is successor node

  00044	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]

; 1221 : 			_Fixnode = this->_Right(_Pnode);	// _Fixnode is only subtree

  00047	8b 78 08	 mov	 edi, DWORD PTR [eax+8]

; 1222 : 			}
; 1223 : 
; 1224 : 		if (_Pnode == _Erasednode)

  0004a	3b c3		 cmp	 eax, ebx
  0004c	75 72		 jne	 SHORT $LN35@erase
$LN291@erase:

; 1225 : 			{	// at most one subtree, relink it
; 1226 : 			_Fixnodeparent = this->_Parent(_Erasednode);
; 1227 : 			if (!this->_Isnil(_Fixnode))

  0004e	80 7f 15 00	 cmp	 BYTE PTR [edi+21], 0
  00052	8b 73 04	 mov	 esi, DWORD PTR [ebx+4]
  00055	75 03		 jne	 SHORT $LN34@erase

; 1228 : 				this->_Parent(_Fixnode) = _Fixnodeparent;	// link up

  00057	89 77 04	 mov	 DWORD PTR [edi+4], esi
$LN34@erase:

; 1229 : 
; 1230 : 			if (_Root() == _Erasednode)

  0005a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0005d	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00060	39 58 04	 cmp	 DWORD PTR [eax+4], ebx
  00063	75 05		 jne	 SHORT $LN33@erase

; 1231 : 				_Root() = _Fixnode;	// link down from root

  00065	89 78 04	 mov	 DWORD PTR [eax+4], edi

; 1232 : 			else if (this->_Left(_Fixnodeparent) == _Erasednode)

  00068	eb 0b		 jmp	 SHORT $LN30@erase
$LN33@erase:
  0006a	39 1e		 cmp	 DWORD PTR [esi], ebx
  0006c	75 04		 jne	 SHORT $LN31@erase

; 1233 : 				this->_Left(_Fixnodeparent) = _Fixnode;	// link down to left

  0006e	89 3e		 mov	 DWORD PTR [esi], edi

; 1234 : 			else

  00070	eb 03		 jmp	 SHORT $LN30@erase
$LN31@erase:

; 1235 : 				this->_Right(_Fixnodeparent) =
; 1236 : 					_Fixnode;	// link down to right

  00072	89 7e 08	 mov	 DWORD PTR [esi+8], edi
$LN30@erase:

; 1237 : 
; 1238 : 			if (_Lmost() == _Erasednode)

  00075	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00078	39 18		 cmp	 DWORD PTR [eax], ebx
  0007a	75 1b		 jne	 SHORT $LN29@erase

; 1239 : 				_Lmost() = this->_Isnil(_Fixnode)
; 1240 : 					? _Fixnodeparent	// smallest is parent of erased node
; 1241 : 					: this->_Min(_Fixnode);	// smallest in relinked subtree

  0007c	80 7f 15 00	 cmp	 BYTE PTR [edi+21], 0
  00080	74 04		 je	 SHORT $LN43@erase
  00082	8b c6		 mov	 eax, esi
  00084	eb 0c		 jmp	 SHORT $LN44@erase
$LN43@erase:
  00086	57		 push	 edi
  00087	e8 00 00 00 00	 call	 ?_Min@?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::_Min
  0008c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0008f	83 c4 04	 add	 esp, 4
$LN44@erase:
  00092	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00095	89 02		 mov	 DWORD PTR [edx], eax
$LN29@erase:

; 1242 : 
; 1243 : 			if (_Rmost() == _Erasednode)

  00097	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0009a	89 4d f4	 mov	 DWORD PTR tv795[ebp], ecx
  0009d	39 59 08	 cmp	 DWORD PTR [ecx+8], ebx
  000a0	75 78		 jne	 SHORT $LN165@erase

; 1244 : 				_Rmost() = this->_Isnil(_Fixnode)
; 1245 : 					? _Fixnodeparent	// largest is parent of erased node
; 1246 : 					: this->_Max(_Fixnode);	// largest in relinked subtree

  000a2	80 7f 15 00	 cmp	 BYTE PTR [edi+21], 0
  000a6	74 07		 je	 SHORT $LN45@erase
  000a8	8b c6		 mov	 eax, esi
  000aa	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 1247 : 			}
; 1248 : 		else

  000ad	eb 6b		 jmp	 SHORT $LN165@erase
$LN45@erase:

; 1244 : 				_Rmost() = this->_Isnil(_Fixnode)
; 1245 : 					? _Fixnodeparent	// largest is parent of erased node
; 1246 : 					: this->_Max(_Fixnode);	// largest in relinked subtree

  000af	57		 push	 edi
  000b0	e8 00 00 00 00	 call	 ?_Max@?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@SAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@2@PAU342@@Z ; std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::_Max
  000b5	8b 4d f4	 mov	 ecx, DWORD PTR tv795[ebp]
  000b8	83 c4 04	 add	 esp, 4
  000bb	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 1247 : 			}
; 1248 : 		else

  000be	eb 5a		 jmp	 SHORT $LN165@erase
$LN35@erase:

; 1249 : 			{	// erased has two subtrees, _Pnode is successor to erased
; 1250 : 			this->_Parent(this->_Left(_Erasednode)) =
; 1251 : 				_Pnode;	// link left up

  000c0	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1252 : 			this->_Left(_Pnode) =
; 1253 : 				this->_Left(_Erasednode);	// link successor down

  000c3	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  000c5	89 08		 mov	 DWORD PTR [eax], ecx

; 1254 : 
; 1255 : 			if (_Pnode == this->_Right(_Erasednode))

  000c7	3b 43 08	 cmp	 eax, DWORD PTR [ebx+8]
  000ca	75 04		 jne	 SHORT $LN26@erase

; 1256 : 				_Fixnodeparent = _Pnode;	// successor is next to erased

  000cc	8b f0		 mov	 esi, eax

; 1257 : 			else

  000ce	eb 1a		 jmp	 SHORT $LN25@erase
$LN26@erase:

; 1258 : 				{	// successor further down, link in place of erased
; 1259 : 				_Fixnodeparent =
; 1260 : 					this->_Parent(_Pnode);	// parent is successor's
; 1261 : 				if (!this->_Isnil(_Fixnode))

  000d0	80 7f 15 00	 cmp	 BYTE PTR [edi+21], 0
  000d4	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  000d7	75 03		 jne	 SHORT $LN24@erase

; 1262 : 					this->_Parent(_Fixnode) = _Fixnodeparent;	// link fix up

  000d9	89 77 04	 mov	 DWORD PTR [edi+4], esi
$LN24@erase:

; 1263 : 				this->_Left(_Fixnodeparent) = _Fixnode;	// link fix down

  000dc	89 3e		 mov	 DWORD PTR [esi], edi

; 1264 : 				this->_Right(_Pnode) =
; 1265 : 					this->_Right(_Erasednode);	// link next down

  000de	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  000e1	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 1266 : 				this->_Parent(this->_Right(_Erasednode)) =
; 1267 : 					_Pnode;	// right up

  000e4	8b 53 08	 mov	 edx, DWORD PTR [ebx+8]
  000e7	89 42 04	 mov	 DWORD PTR [edx+4], eax
$LN25@erase:

; 1268 : 				}
; 1269 : 
; 1270 : 			if (_Root() == _Erasednode)

  000ea	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000ed	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  000f0	39 59 04	 cmp	 DWORD PTR [ecx+4], ebx
  000f3	75 05		 jne	 SHORT $LN23@erase

; 1271 : 				_Root() = _Pnode;	// link down from root

  000f5	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1272 : 			else if (this->_Left(this->_Parent(_Erasednode)) == _Erasednode)

  000f8	eb 0e		 jmp	 SHORT $LN20@erase
$LN23@erase:
  000fa	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  000fd	39 19		 cmp	 DWORD PTR [ecx], ebx
  000ff	75 04		 jne	 SHORT $LN21@erase

; 1273 : 				this->_Left(this->_Parent(_Erasednode)) =
; 1274 : 					_Pnode;	// link down to left

  00101	89 01		 mov	 DWORD PTR [ecx], eax

; 1275 : 			else

  00103	eb 03		 jmp	 SHORT $LN20@erase
$LN21@erase:

; 1276 : 				this->_Right(this->_Parent(_Erasednode)) =
; 1277 : 					_Pnode;	// link down to right

  00105	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$LN20@erase:

; 1278 : 
; 1279 : 			this->_Parent(_Pnode) =
; 1280 : 				this->_Parent(_Erasednode);	// link successor up

  00108	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  0010b	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 1281 : 			_STD swap(this->_Color(_Pnode),
; 1282 : 				this->_Color(_Erasednode));	// recolor it

  0010e	8a 53 14	 mov	 dl, BYTE PTR [ebx+20]
  00111	8a 48 14	 mov	 cl, BYTE PTR [eax+20]
  00114	88 50 14	 mov	 BYTE PTR [eax+20], dl
  00117	88 4b 14	 mov	 BYTE PTR [ebx+20], cl
$LN165@erase:

; 1283 : 			}
; 1284 : 
; 1285 : 		if (this->_Color(_Erasednode) == this->_Black)

  0011a	8b 45 f8	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  0011d	b3 01		 mov	 bl, 1
  0011f	38 58 14	 cmp	 BYTE PTR [eax+20], bl
  00122	0f 85 fa 00 00
	00		 jne	 $LN19@erase

; 1286 : 			{	// erasing black link, must recolor/rebalance tree
; 1287 : 			for (; _Fixnode != _Root()
; 1288 : 				&& this->_Color(_Fixnode) == this->_Black;
; 1289 : 				_Fixnodeparent = this->_Parent(_Fixnode))

  00128	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0012b	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0012e	3b 7a 04	 cmp	 edi, DWORD PTR [edx+4]
  00131	0f 84 e8 00 00
	00		 je	 $LN16@erase
$LL18@erase:
  00137	38 5f 14	 cmp	 BYTE PTR [edi+20], bl
  0013a	0f 85 df 00 00
	00		 jne	 $LN16@erase

; 1290 : 				if (_Fixnode == this->_Left(_Fixnodeparent))

  00140	8b 06		 mov	 eax, DWORD PTR [esi]
  00142	3b f8		 cmp	 edi, eax
  00144	75 65		 jne	 SHORT $LN15@erase

; 1291 : 					{	// fixup left subtree
; 1292 : 					_Pnode = this->_Right(_Fixnodeparent);

  00146	8b 46 08	 mov	 eax, DWORD PTR [esi+8]

; 1293 : 					if (this->_Color(_Pnode) == this->_Red)

  00149	80 78 14 00	 cmp	 BYTE PTR [eax+20], 0
  0014d	75 13		 jne	 SHORT $LN14@erase

; 1294 : 						{	// rotate red up from right subtree
; 1295 : 						this->_Color(_Pnode) = this->_Black;

  0014f	88 58 14	 mov	 BYTE PTR [eax+20], bl

; 1296 : 						this->_Color(_Fixnodeparent) = this->_Red;
; 1297 : 						_Lrotate(_Fixnodeparent);

  00152	56		 push	 esi
  00153	c6 46 14 00	 mov	 BYTE PTR [esi+20], 0
  00157	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::_Lrotate

; 1298 : 						_Pnode = this->_Right(_Fixnodeparent);

  0015c	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0015f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
$LN14@erase:

; 1299 : 						}
; 1300 : 
; 1301 : 					if (this->_Isnil(_Pnode))

  00162	80 78 15 00	 cmp	 BYTE PTR [eax+21], 0

; 1302 : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 1303 : 					else if (this->_Color(this->_Left(_Pnode)) == this->_Black

  00166	75 74		 jne	 SHORT $LN293@erase

; 1304 : 						&& this->_Color(this->_Right(_Pnode)) == this->_Black)

  00168	8b 10		 mov	 edx, DWORD PTR [eax]
  0016a	38 5a 14	 cmp	 BYTE PTR [edx+20], bl
  0016d	75 08		 jne	 SHORT $LN11@erase
  0016f	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00172	38 5a 14	 cmp	 BYTE PTR [edx+20], bl
  00175	74 61		 je	 SHORT $LN294@erase
$LN11@erase:

; 1305 : 						{	// redden right subtree with black children
; 1306 : 						this->_Color(_Pnode) = this->_Red;
; 1307 : 						_Fixnode = _Fixnodeparent;
; 1308 : 						}
; 1309 : 					else
; 1310 : 						{	// must rearrange right subtree
; 1311 : 						if (this->_Color(this->_Right(_Pnode))
; 1312 : 							== this->_Black)

  00177	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0017a	38 5a 14	 cmp	 BYTE PTR [edx+20], bl
  0017d	75 15		 jne	 SHORT $LN9@erase

; 1313 : 							{	// rotate red up from left sub-subtree
; 1314 : 							this->_Color(this->_Left(_Pnode)) = this->_Black;

  0017f	8b 10		 mov	 edx, DWORD PTR [eax]
  00181	88 5a 14	 mov	 BYTE PTR [edx+20], bl

; 1315 : 							this->_Color(_Pnode) = this->_Red;
; 1316 : 							_Rrotate(_Pnode);

  00184	50		 push	 eax
  00185	c6 40 14 00	 mov	 BYTE PTR [eax+20], 0
  00189	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::_Rrotate

; 1317 : 							_Pnode = this->_Right(_Fixnodeparent);

  0018e	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00191	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
$LN9@erase:

; 1318 : 							}
; 1319 : 
; 1320 : 						this->_Color(_Pnode) = this->_Color(_Fixnodeparent);

  00194	8a 56 14	 mov	 dl, BYTE PTR [esi+20]
  00197	88 50 14	 mov	 BYTE PTR [eax+20], dl

; 1321 : 						this->_Color(_Fixnodeparent) = this->_Black;

  0019a	88 5e 14	 mov	 BYTE PTR [esi+20], bl

; 1322 : 						this->_Color(this->_Right(_Pnode)) = this->_Black;

  0019d	8b 40 08	 mov	 eax, DWORD PTR [eax+8]

; 1323 : 						_Lrotate(_Fixnodeparent);

  001a0	56		 push	 esi
  001a1	88 58 14	 mov	 BYTE PTR [eax+20], bl
  001a4	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::_Lrotate

; 1324 : 						break;	// tree now recolored/rebalanced

  001a9	eb 74		 jmp	 SHORT $LN16@erase
$LN15@erase:

; 1325 : 						}
; 1326 : 					}
; 1327 : 				else
; 1328 : 					{	// fixup right subtree
; 1329 : 					_Pnode = this->_Left(_Fixnodeparent);
; 1330 : 					if (this->_Color(_Pnode) == this->_Red)

  001ab	80 78 14 00	 cmp	 BYTE PTR [eax+20], 0
  001af	75 12		 jne	 SHORT $LN7@erase

; 1331 : 						{	// rotate red up from left subtree
; 1332 : 						this->_Color(_Pnode) = this->_Black;

  001b1	88 58 14	 mov	 BYTE PTR [eax+20], bl

; 1333 : 						this->_Color(_Fixnodeparent) = this->_Red;
; 1334 : 						_Rrotate(_Fixnodeparent);

  001b4	56		 push	 esi
  001b5	c6 46 14 00	 mov	 BYTE PTR [esi+20], 0
  001b9	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::_Rrotate

; 1335 : 						_Pnode = this->_Left(_Fixnodeparent);

  001be	8b 06		 mov	 eax, DWORD PTR [esi]
  001c0	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
$LN7@erase:

; 1336 : 						}
; 1337 : 					if (this->_Isnil(_Pnode))

  001c3	80 78 15 00	 cmp	 BYTE PTR [eax+21], 0

; 1338 : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 1339 : 					else if (this->_Color(this->_Right(_Pnode)) ==

  001c7	75 13		 jne	 SHORT $LN293@erase

; 1340 : 						this->_Black
; 1341 : 						&& this->_Color(this->_Left(_Pnode)) == this->_Black)

  001c9	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  001cc	38 5a 14	 cmp	 BYTE PTR [edx+20], bl
  001cf	75 1e		 jne	 SHORT $LN4@erase
  001d1	8b 10		 mov	 edx, DWORD PTR [eax]
  001d3	38 5a 14	 cmp	 BYTE PTR [edx+20], bl
  001d6	75 17		 jne	 SHORT $LN4@erase
$LN294@erase:

; 1342 : 						{	// redden left subtree with black children
; 1343 : 						this->_Color(_Pnode) = this->_Red;

  001d8	c6 40 14 00	 mov	 BYTE PTR [eax+20], 0
$LN293@erase:

; 1286 : 			{	// erasing black link, must recolor/rebalance tree
; 1287 : 			for (; _Fixnode != _Root()
; 1288 : 				&& this->_Color(_Fixnode) == this->_Black;
; 1289 : 				_Fixnodeparent = this->_Parent(_Fixnode))

  001dc	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]

; 1344 : 						_Fixnode = _Fixnodeparent;

  001df	8b fe		 mov	 edi, esi
  001e1	8b 76 04	 mov	 esi, DWORD PTR [esi+4]
  001e4	3b 78 04	 cmp	 edi, DWORD PTR [eax+4]
  001e7	0f 85 4a ff ff
	ff		 jne	 $LL18@erase

; 1286 : 			{	// erasing black link, must recolor/rebalance tree
; 1287 : 			for (; _Fixnode != _Root()
; 1288 : 				&& this->_Color(_Fixnode) == this->_Black;
; 1289 : 				_Fixnodeparent = this->_Parent(_Fixnode))

  001ed	eb 30		 jmp	 SHORT $LN16@erase
$LN4@erase:

; 1345 : 						}
; 1346 : 					else
; 1347 : 						{	// must rearrange left subtree
; 1348 : 						if (this->_Color(this->_Left(_Pnode)) == this->_Black)

  001ef	8b 10		 mov	 edx, DWORD PTR [eax]
  001f1	38 5a 14	 cmp	 BYTE PTR [edx+20], bl
  001f4	75 15		 jne	 SHORT $LN2@erase

; 1349 : 							{	// rotate red up from right sub-subtree
; 1350 : 							this->_Color(this->_Right(_Pnode)) = this->_Black;

  001f6	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  001f9	88 5a 14	 mov	 BYTE PTR [edx+20], bl

; 1351 : 							this->_Color(_Pnode) = this->_Red;
; 1352 : 							_Lrotate(_Pnode);

  001fc	50		 push	 eax
  001fd	c6 40 14 00	 mov	 BYTE PTR [eax+20], 0
  00201	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::_Lrotate

; 1353 : 							_Pnode = this->_Left(_Fixnodeparent);

  00206	8b 06		 mov	 eax, DWORD PTR [esi]
  00208	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
$LN2@erase:

; 1354 : 							}
; 1355 : 
; 1356 : 						this->_Color(_Pnode) = this->_Color(_Fixnodeparent);

  0020b	8a 56 14	 mov	 dl, BYTE PTR [esi+20]
  0020e	88 50 14	 mov	 BYTE PTR [eax+20], dl

; 1357 : 						this->_Color(_Fixnodeparent) = this->_Black;

  00211	88 5e 14	 mov	 BYTE PTR [esi+20], bl

; 1358 : 						this->_Color(this->_Left(_Pnode)) = this->_Black;

  00214	8b 00		 mov	 eax, DWORD PTR [eax]

; 1359 : 						_Rrotate(_Fixnodeparent);

  00216	56		 push	 esi
  00217	88 58 14	 mov	 BYTE PTR [eax+20], bl
  0021a	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::_Rrotate
$LN16@erase:

; 1360 : 						break;	// tree now recolored/rebalanced
; 1361 : 						}
; 1362 : 					}
; 1363 : 
; 1364 : 			this->_Color(_Fixnode) = this->_Black;	// stopping node is black

  0021f	88 5f 14	 mov	 BYTE PTR [edi+20], bl
$LN19@erase:

; 1365 : 			}
; 1366 : 
; 1367 : 		_Dest_val(this->_Alval,
; 1368 : 			_STD addressof(this->_Myval(_Erasednode)));	// delete erased node
; 1369 : 
; 1370 : 		this->_Alnod.deallocate(_Erasednode, 1);

  00222	8b 4d f8	 mov	 ecx, DWORD PTR __Erasednode$[ebp]
  00225	51		 push	 ecx
  00226	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete

; 1371 : 
; 1372 : 		if (0 < this->_Mysize)

  0022b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0022e	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00231	83 c4 04	 add	 esp, 4
  00234	5f		 pop	 edi
  00235	5e		 pop	 esi
  00236	5b		 pop	 ebx
  00237	85 c0		 test	 eax, eax
  00239	74 04		 je	 SHORT $LN1@erase

; 1373 : 			--this->_Mysize;

  0023b	48		 dec	 eax
  0023c	89 41 08	 mov	 DWORD PTR [ecx+8], eax
$LN1@erase:

; 1374 : 
; 1375 : 		return (iterator(_Where._Ptr, this));	// return successor iterator

  0023f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00242	8b 55 0c	 mov	 edx, DWORD PTR __Where$[ebp]
  00245	89 10		 mov	 DWORD PTR [eax], edx

; 1376 : 		}

  00247	8b e5		 mov	 esp, ebp
  00249	5d		 pop	 ebp
  0024a	c2 08 00	 ret	 8
$LN292@erase:
?erase@?$_Tree@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::erase
_TEXT	ENDS
PUBLIC	??0?$_Tree@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::_Tree<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >
; Function compile flags: /Ogtp
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@1@@Z
_TEXT	SEGMENT
$T194156 = -16						; size = 12
$T194096 = -4						; size = 4
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 4
??0?$_Tree@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::_Tree<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >, COMDAT
; _this$ = ecx

; 698  : 		{	// construct empty tree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	6a 18		 push	 24			; 00000018H
  0000b	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00012	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00017	83 c4 04	 add	 esp, 4
  0001a	85 c0		 test	 eax, eax
  0001c	74 28		 je	 SHORT $LN20@Tree
  0001e	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00021	89 00		 mov	 DWORD PTR [eax], eax
  00023	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00026	89 40 04	 mov	 DWORD PTR [eax+4], eax
  00029	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0002c	89 40 08	 mov	 DWORD PTR [eax+8], eax
  0002f	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00032	b0 01		 mov	 al, 1
  00034	88 41 14	 mov	 BYTE PTR [ecx+20], al
  00037	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0003a	88 42 15	 mov	 BYTE PTR [edx+21], al

; 699  : 		}

  0003d	8b c6		 mov	 eax, esi
  0003f	5e		 pop	 esi
  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c2 08 00	 ret	 8

; 698  : 		{	// construct empty tree

$LN20@Tree:
  00046	8d 45 fc	 lea	 eax, DWORD PTR $T194096[ebp]
  00049	50		 push	 eax
  0004a	8d 4d f0	 lea	 ecx, DWORD PTR $T194156[ebp]
  0004d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T194096[ebp], 0
  00054	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00059	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0005e	8d 4d f0	 lea	 ecx, DWORD PTR $T194156[ebp]
  00061	51		 push	 ecx
  00062	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T194156[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00069	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN43@Tree:
$LN42@Tree:
  0006e	cc		 int	 3
??0?$_Tree@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@H@1@ABV?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::_Tree<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >
_TEXT	ENDS
PUBLIC	?lower_bound@?$_Tree@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::lower_bound
; Function compile flags: /Ogtp
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@2@ABH@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
?lower_bound@?$_Tree@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@2@ABH@Z PROC ; std::_Tree<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::lower_bound, COMDAT
; _this$ = ecx

; 1449 : 		{	// find leftmost node not less than _Keyval in mutable tree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1450 : 		return (iterator(_Lbound(_Keyval), this));

  00003	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00006	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00009	80 78 15 00	 cmp	 BYTE PTR [eax+21], 0
  0000d	75 19		 jne	 SHORT $LN36@lower_boun
  0000f	8b 55 0c	 mov	 edx, DWORD PTR __Keyval$[ebp]
  00012	8b 12		 mov	 edx, DWORD PTR [edx]
$LL6@lower_boun:
  00014	39 50 0c	 cmp	 DWORD PTR [eax+12], edx
  00017	7d 05		 jge	 SHORT $LN4@lower_boun
  00019	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0001c	eb 04		 jmp	 SHORT $LN3@lower_boun
$LN4@lower_boun:
  0001e	8b c8		 mov	 ecx, eax
  00020	8b 00		 mov	 eax, DWORD PTR [eax]
$LN3@lower_boun:
  00022	80 78 15 00	 cmp	 BYTE PTR [eax+21], 0
  00026	74 ec		 je	 SHORT $LL6@lower_boun
$LN36@lower_boun:
  00028	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0002b	89 08		 mov	 DWORD PTR [eax], ecx

; 1451 : 		}

  0002d	5d		 pop	 ebp
  0002e	c2 08 00	 ret	 8
?lower_bound@?$_Tree@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@2@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::lower_bound
_TEXT	ENDS
PUBLIC	?clear@?$_Tree@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::clear
; Function compile flags: /Ogtp
;	COMDAT ?clear@?$_Tree@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$_Tree@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::clear, COMDAT
; _this$ = ecx

; 1410 : 		{	// erase all

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	57		 push	 edi
  00003	8b f9		 mov	 edi, ecx

; 1411 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1412 : 		this->_Orphan_ptr(*this, 0);
; 1413 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1414 : 
; 1415 : 		_Erase(_Root());

  00005	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00008	8b 58 04	 mov	 ebx, DWORD PTR [eax+4]
  0000b	80 7b 15 00	 cmp	 BYTE PTR [ebx+21], 0
  0000f	8b f3		 mov	 esi, ebx
  00011	75 1e		 jne	 SHORT $LN7@clear
$LL9@clear:
  00013	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00016	51		 push	 ecx
  00017	8b cf		 mov	 ecx, edi
  00019	e8 00 00 00 00	 call	 ?_Erase@?$_Tree@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::_Erase
  0001e	8b 36		 mov	 esi, DWORD PTR [esi]
  00020	53		 push	 ebx
  00021	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00026	83 c4 04	 add	 esp, 4
  00029	80 7e 15 00	 cmp	 BYTE PTR [esi+21], 0
  0002d	8b de		 mov	 ebx, esi
  0002f	74 e2		 je	 SHORT $LL9@clear
$LN7@clear:

; 1416 : 		_Root() = this->_Myhead;

  00031	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00034	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 1417 : 		_Lmost() = this->_Myhead;

  00037	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0003a	89 00		 mov	 DWORD PTR [eax], eax

; 1418 : 		_Rmost() = this->_Myhead;

  0003c	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0003f	89 40 08	 mov	 DWORD PTR [eax+8], eax

; 1419 : 		this->_Mysize = 0;

  00042	c7 47 08 00 00
	00 00		 mov	 DWORD PTR [edi+8], 0
  00049	5f		 pop	 edi
  0004a	5e		 pop	 esi
  0004b	5b		 pop	 ebx

; 1420 : 		}

  0004c	c3		 ret	 0
?clear@?$_Tree@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::clear
_TEXT	ENDS
PUBLIC	?_Linsert@?$_Tree@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@std@@_N@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@2@_N@Z ; std::_Tree<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::_Linsert
; Function compile flags: /Ogtp
;	COMDAT ?_Linsert@?$_Tree@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@std@@_N@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@2@_N@Z
_TEXT	SEGMENT
__Addleft$ = -4						; size = 1
___$ReturnUdt$ = 8					; size = 4
__Node$ = 12						; size = 4
$T194354 = 16						; size = 4
$T194352 = 16						; size = 4
__Where$189111 = 16					; size = 4
__Leftish$ = 16						; size = 1
?_Linsert@?$_Tree@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@std@@_N@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@2@_N@Z PROC ; std::_Tree<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::_Linsert, COMDAT
; _this$ = ecx

; 944  : 		{	// try to insert node at _Node, on left if _Leftish

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 945  : 		const value_type& _Val = this->_Myval(_Node);
; 946  : 
; 947  : 		_Nodeptr _Trynode = _Root();
; 948  : 		_Nodeptr _Wherenode = this->_Myhead;
; 949  : 		bool _Addleft = true;	// add to left of head if tree empty
; 950  : 		while (!this->_Isnil(_Trynode))

  00004	8b 55 0c	 mov	 edx, DWORD PTR __Node$[ebp]
  00007	53		 push	 ebx
  00008	8b d9		 mov	 ebx, ecx
  0000a	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  0000d	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00010	80 78 15 00	 cmp	 BYTE PTR [eax+21], 0
  00014	56		 push	 esi
  00015	8b f1		 mov	 esi, ecx
  00017	b1 01		 mov	 cl, 1
  00019	57		 push	 edi
  0001a	88 4d fc	 mov	 BYTE PTR __Addleft$[ebp], cl
  0001d	75 2d		 jne	 SHORT $LN11@Linsert
  0001f	8b 7a 0c	 mov	 edi, DWORD PTR [edx+12]
$LL12@Linsert:

; 951  : 			{	// look for leaf to insert before (_Addleft) or after
; 952  : 			_Wherenode = _Trynode;
; 953  : 			if (_Leftish)

  00022	80 7d 10 00	 cmp	 BYTE PTR __Leftish$[ebp], 0
  00026	8b f0		 mov	 esi, eax
  00028	74 08		 je	 SHORT $LN10@Linsert

; 954  : 				_Addleft = !_DEBUG_LT_PRED(this->comp,

  0002a	39 78 0c	 cmp	 DWORD PTR [eax+12], edi
  0002d	0f 9d c1	 setge	 cl

; 955  : 					this->_Key(_Trynode),
; 956  : 					this->_Kfn(_Val));	// favor left end
; 957  : 			else

  00030	eb 06		 jmp	 SHORT $LN146@Linsert
$LN10@Linsert:

; 958  : 				_Addleft = _DEBUG_LT_PRED(this->comp,

  00032	3b 78 0c	 cmp	 edi, DWORD PTR [eax+12]
  00035	0f 9c c1	 setl	 cl
$LN146@Linsert:
  00038	88 4d fc	 mov	 BYTE PTR __Addleft$[ebp], cl

; 959  : 					this->_Kfn(_Val),
; 960  : 					this->_Key(_Trynode));	// favor right end
; 961  : 			_Trynode = _Addleft ? this->_Left(_Trynode)
; 962  : 				: this->_Right(_Trynode);

  0003b	84 c9		 test	 cl, cl
  0003d	74 04		 je	 SHORT $LN15@Linsert
  0003f	8b 00		 mov	 eax, DWORD PTR [eax]
  00041	eb 03		 jmp	 SHORT $LN16@Linsert
$LN15@Linsert:
  00043	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
$LN16@Linsert:

; 945  : 		const value_type& _Val = this->_Myval(_Node);
; 946  : 
; 947  : 		_Nodeptr _Trynode = _Root();
; 948  : 		_Nodeptr _Wherenode = this->_Myhead;
; 949  : 		bool _Addleft = true;	// add to left of head if tree empty
; 950  : 		while (!this->_Isnil(_Trynode))

  00046	80 78 15 00	 cmp	 BYTE PTR [eax+21], 0
  0004a	74 d6		 je	 SHORT $LL12@Linsert
$LN11@Linsert:

; 963  : 			}
; 964  : 
; 965  : 		if (this->_Multi)
; 966  : 			return (_Pairib(_Insert(_Addleft, _Wherenode, _Node), true));
; 967  : 		else
; 968  : 			{	// insert only if unique
; 969  : 			iterator _Where = iterator(_Wherenode, this);

  0004c	8b fe		 mov	 edi, esi
  0004e	89 7d 10	 mov	 DWORD PTR __Where$189111[ebp], edi

; 970  : 			if (!_Addleft)

  00051	84 c9		 test	 cl, cl
  00053	74 35		 je	 SHORT $LN99@Linsert

; 971  : 				;	// need to test if insert after is okay
; 972  : 			else if (_Where == begin())

  00055	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]

; 973  : 				return (_Pairib(_Insert(true, _Wherenode, _Node), true));

  00058	8d 4d 10	 lea	 ecx, DWORD PTR $T194352[ebp]
  0005b	3b 30		 cmp	 esi, DWORD PTR [eax]
  0005d	75 20		 jne	 SHORT $LN4@Linsert
  0005f	52		 push	 edx
  00060	56		 push	 esi
  00061	6a 01		 push	 1
  00063	51		 push	 ecx
  00064	8b cb		 mov	 ecx, ebx
  00066	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::_Insert
  0006b	8b 10		 mov	 edx, DWORD PTR [eax]
  0006d	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00070	5f		 pop	 edi
  00071	5e		 pop	 esi
  00072	89 10		 mov	 DWORD PTR [eax], edx
  00074	c6 40 04 01	 mov	 BYTE PTR [eax+4], 1
  00078	5b		 pop	 ebx

; 989  : 				}
; 990  : 			}
; 991  : 		}

  00079	8b e5		 mov	 esp, ebp
  0007b	5d		 pop	 ebp
  0007c	c2 0c 00	 ret	 12			; 0000000cH
$LN4@Linsert:

; 974  : 			else
; 975  : 				--_Where;	// need to test if insert before is okay

  0007f	e8 00 00 00 00	 call	 ??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >,std::_Iterator_base0>::operator--
  00084	8b 7d 10	 mov	 edi, DWORD PTR __Where$189111[ebp]
  00087	8b 55 0c	 mov	 edx, DWORD PTR __Node$[ebp]
$LN99@Linsert:

; 976  : 
; 977  : 			if (_DEBUG_LT_PRED(this->comp,

  0008a	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]

; 978  : 				this->_Key(_Where._Mynode()),
; 979  : 				this->_Kfn(_Val)))
; 980  : 				return (_Pairib(_Insert(_Addleft, _Wherenode, _Node), true));

  0008d	52		 push	 edx
  0008e	3b 42 0c	 cmp	 eax, DWORD PTR [edx+12]
  00091	7d 24		 jge	 SHORT $LN2@Linsert
  00093	8b 4d fc	 mov	 ecx, DWORD PTR __Addleft$[ebp]
  00096	56		 push	 esi
  00097	51		 push	 ecx
  00098	8d 55 10	 lea	 edx, DWORD PTR $T194354[ebp]
  0009b	52		 push	 edx
  0009c	8b cb		 mov	 ecx, ebx
  0009e	e8 00 00 00 00	 call	 ?_Insert@?$_Tree@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@2@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@2@1@Z ; std::_Tree<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::_Insert
  000a3	8b 08		 mov	 ecx, DWORD PTR [eax]
  000a5	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000a8	5f		 pop	 edi
  000a9	5e		 pop	 esi
  000aa	89 08		 mov	 DWORD PTR [eax], ecx
  000ac	c6 40 04 01	 mov	 BYTE PTR [eax+4], 1
  000b0	5b		 pop	 ebx

; 989  : 				}
; 990  : 			}
; 991  : 		}

  000b1	8b e5		 mov	 esp, ebp
  000b3	5d		 pop	 ebp
  000b4	c2 0c 00	 ret	 12			; 0000000cH
$LN2@Linsert:

; 981  : 			else
; 982  : 				{	// duplicate, don't insert
; 983  : 				_Dest_val(this->_Alval,
; 984  : 					_STD addressof(this->_Myval(_Node)));
; 985  : 
; 986  : 				this->_Alnod.deallocate(_Node, 1);

  000b7	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete

; 987  : 
; 988  : 				return (_Pairib(_Where, false));

  000bc	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000bf	83 c4 04	 add	 esp, 4
  000c2	89 38		 mov	 DWORD PTR [eax], edi
  000c4	5f		 pop	 edi
  000c5	5e		 pop	 esi
  000c6	c6 40 04 00	 mov	 BYTE PTR [eax+4], 0
  000ca	5b		 pop	 ebx

; 989  : 				}
; 990  : 			}
; 991  : 		}

  000cb	8b e5		 mov	 esp, ebp
  000cd	5d		 pop	 ebp
  000ce	c2 0c 00	 ret	 12			; 0000000cH
?_Linsert@?$_Tree@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@std@@_N@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@2@_N@Z ENDP ; std::_Tree<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::_Linsert
_TEXT	ENDS
PUBLIC	??$_Buynode@U?$pair@HPAUOBJECTSTRUCT@@@std@@@?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@HPAUOBJECTSTRUCT@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::_Buynode<std::pair<int,OBJECTSTRUCT *> >
; Function compile flags: /Ogtp
;	COMDAT ??$_Buynode@U?$pair@HPAUOBJECTSTRUCT@@@std@@@?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@HPAUOBJECTSTRUCT@@@1@@Z
_TEXT	SEGMENT
$T194722 = -12						; size = 12
$T194677 = 8						; size = 4
__Val$ = 8						; size = 4
??$_Buynode@U?$pair@HPAUOBJECTSTRUCT@@@std@@@?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@HPAUOBJECTSTRUCT@@@1@@Z PROC ; std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::_Buynode<std::pair<int,OBJECTSTRUCT *> >, COMDAT
; _this$ = ecx

; 586  : 		_Nodeptr _Buynode(_Valty&& _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi
  00007	57		 push	 edi

; 587  : 		{	// allocate a node with defaults
; 588  : 		_Nodeptr _Wherenode = _Buynode();

  00008	6a 18		 push	 24			; 00000018H
  0000a	8b f9		 mov	 edi, ecx
  0000c	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00011	8b f0		 mov	 esi, eax
  00013	33 c0		 xor	 eax, eax
  00015	83 c4 04	 add	 esp, 4
  00018	3b f0		 cmp	 esi, eax
  0001a	74 33		 je	 SHORT $LN12@Buynode@2
  0001c	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  0001f	89 0e		 mov	 DWORD PTR [esi], ecx
  00021	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  00024	89 56 04	 mov	 DWORD PTR [esi+4], edx
  00027	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]

; 589  : 
; 590  : 		_TRY_BEGIN
; 591  : 		_Cons_val(this->_Alval, _STD addressof(this->_Myval(_Wherenode)),
; 592  : 			_STD forward<_Valty>(_Val));

  0002a	8b 55 08	 mov	 edx, DWORD PTR __Val$[ebp]
  0002d	66 89 46 14	 mov	 WORD PTR [esi+20], ax
  00031	52		 push	 edx
  00032	8d 46 0c	 lea	 eax, DWORD PTR [esi+12]
  00035	50		 push	 eax
  00036	83 c7 0d	 add	 edi, 13			; 0000000dH
  00039	57		 push	 edi
  0003a	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  0003d	e8 00 00 00 00	 call	 ??$_Cons_val@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@std@@U?$pair@$$CBHPAUOBJECTSTRUCT@@@2@U?$pair@HPAUOBJECTSTRUCT@@@2@@std@@YAXAAV?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@0@PAU?$pair@$$CBHPAUOBJECTSTRUCT@@@0@$$QAU?$pair@HPAUOBJECTSTRUCT@@@0@@Z ; std::_Cons_val<std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,std::pair<int const ,OBJECTSTRUCT *>,std::pair<int,OBJECTSTRUCT *> >
  00042	83 c4 0c	 add	 esp, 12			; 0000000cH
  00045	5f		 pop	 edi

; 593  : 		_CATCH_ALL
; 594  : 		this->_Alnod.deallocate(_Wherenode, 1);
; 595  : 		_RERAISE;
; 596  : 		_CATCH_END
; 597  : 
; 598  : 		return (_Wherenode);

  00046	8b c6		 mov	 eax, esi
  00048	5e		 pop	 esi

; 599  : 		}

  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c2 04 00	 ret	 4

; 587  : 		{	// allocate a node with defaults
; 588  : 		_Nodeptr _Wherenode = _Buynode();

$LN12@Buynode@2:
  0004f	8d 4d 08	 lea	 ecx, DWORD PTR $T194677[ebp]
  00052	51		 push	 ecx
  00053	8d 4d f4	 lea	 ecx, DWORD PTR $T194722[ebp]
  00056	89 45 08	 mov	 DWORD PTR $T194677[ebp], eax
  00059	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  0005e	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00063	8d 55 f4	 lea	 edx, DWORD PTR $T194722[ebp]
  00066	52		 push	 edx
  00067	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T194722[ebp], OFFSET ??_7bad_alloc@std@@6B@
  0006e	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN44@Buynode@2:
$LN43@Buynode@2:
  00073	cc		 int	 3
??$_Buynode@U?$pair@HPAUOBJECTSTRUCT@@@std@@@?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@HPAUOBJECTSTRUCT@@@1@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::_Buynode<std::pair<int,OBJECTSTRUCT *> >
_TEXT	ENDS
PUBLIC	?find@?$_Tree@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::find
; Function compile flags: /Ogtp
;	COMDAT ?find@?$_Tree@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@2@ABH@Z
_TEXT	SEGMENT
$T194768 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Keyval$ = 12						; size = 4
?find@?$_Tree@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@2@ABH@Z PROC ; std::_Tree<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::find, COMDAT
; _this$ = ecx

; 1423 : 		{	// find an element in mutable sequence that matches _Keyval

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1424 : 		iterator _Where = lower_bound(_Keyval);

  00004	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00007	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0000a	80 78 15 00	 cmp	 BYTE PTR [eax+21], 0
  0000e	57		 push	 edi
  0000f	8b 7d 0c	 mov	 edi, DWORD PTR __Keyval$[ebp]
  00012	75 18		 jne	 SHORT $LN9@find
  00014	56		 push	 esi
  00015	8b 37		 mov	 esi, DWORD PTR [edi]
$LL10@find:
  00017	39 70 0c	 cmp	 DWORD PTR [eax+12], esi
  0001a	7d 05		 jge	 SHORT $LN8@find
  0001c	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0001f	eb 04		 jmp	 SHORT $LN7@find
$LN8@find:
  00021	8b d0		 mov	 edx, eax
  00023	8b 00		 mov	 eax, DWORD PTR [eax]
$LN7@find:
  00025	80 78 15 00	 cmp	 BYTE PTR [eax+21], 0
  00029	74 ec		 je	 SHORT $LL10@find
  0002b	5e		 pop	 esi
$LN9@find:

; 1425 : 		return (_Where == end()
; 1426 : 			|| _DEBUG_LT_PRED(this->comp,
; 1427 : 				_Keyval, this->_Key(_Where._Mynode()))
; 1428 : 					? end() : _Where);

  0002c	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0002f	89 55 0c	 mov	 DWORD PTR __Where$[ebp], edx
  00032	3b d0		 cmp	 edx, eax
  00034	74 18		 je	 SHORT $LN3@find
  00036	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00038	3b 4a 0c	 cmp	 ecx, DWORD PTR [edx+12]
  0003b	7c 11		 jl	 SHORT $LN3@find
  0003d	8d 45 0c	 lea	 eax, DWORD PTR __Where$[ebp]
  00040	8b 10		 mov	 edx, DWORD PTR [eax]
  00042	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00045	89 10		 mov	 DWORD PTR [eax], edx
  00047	5f		 pop	 edi

; 1429 : 		}

  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c2 08 00	 ret	 8
$LN3@find:

; 1425 : 		return (_Where == end()
; 1426 : 			|| _DEBUG_LT_PRED(this->comp,
; 1427 : 				_Keyval, this->_Key(_Where._Mynode()))
; 1428 : 					? end() : _Where);

  0004e	89 45 fc	 mov	 DWORD PTR $T194768[ebp], eax
  00051	8d 45 fc	 lea	 eax, DWORD PTR $T194768[ebp]
  00054	8b 10		 mov	 edx, DWORD PTR [eax]
  00056	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00059	89 10		 mov	 DWORD PTR [eax], edx
  0005b	5f		 pop	 edi

; 1429 : 		}

  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c2 08 00	 ret	 8
?find@?$_Tree@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@2@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::find
_TEXT	ENDS
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::erase
; Function compile flags: /Ogtp
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@2@0@Z
_TEXT	SEGMENT
$T194991 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@2@0@Z PROC ; std::_Tree<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::erase, COMDAT
; _this$ = ecx

; 1379 : 		{	// erase [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1380 : 		if (_First == begin() && _Last == end())

  00004	8b 55 10	 mov	 edx, DWORD PTR __Last$[ebp]
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0000d	8b 4d 0c	 mov	 ecx, DWORD PTR __First$[ebp]
  00010	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00012	75 1c		 jne	 SHORT $LN97@erase@2
  00014	3b d0		 cmp	 edx, eax
  00016	75 18		 jne	 SHORT $LN97@erase@2

; 1381 : 			{	// erase all
; 1382 : 			clear();

  00018	8b ce		 mov	 ecx, esi
  0001a	e8 00 00 00 00	 call	 ?clear@?$_Tree@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::clear

; 1383 : 			return (begin());

  0001f	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00022	8b 08		 mov	 ecx, DWORD PTR [eax]

; 1389 : 			return (iterator(_First._Ptr, this));

  00024	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00027	89 08		 mov	 DWORD PTR [eax], ecx
  00029	5e		 pop	 esi

; 1390 : 			}
; 1391 : 		}

  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 0c 00	 ret	 12			; 0000000cH
$LN97@erase@2:

; 1384 : 			}
; 1385 : 		else
; 1386 : 			{	// partial erase, one at a time
; 1387 : 			while (_First != _Last)

  00030	3b ca		 cmp	 ecx, edx
  00032	74 5e		 je	 SHORT $LN1@erase@2
$LL2@erase@2:

; 1388 : 				erase(_First++);

  00034	80 79 15 00	 cmp	 BYTE PTR [ecx+21], 0
  00038	8b d1		 mov	 edx, ecx
  0003a	75 42		 jne	 SHORT $LN59@erase@2
  0003c	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0003f	80 78 15 00	 cmp	 BYTE PTR [eax+21], 0
  00043	75 1a		 jne	 SHORT $LN99@erase@2
  00045	8b c8		 mov	 ecx, eax
  00047	8b 01		 mov	 eax, DWORD PTR [ecx]
  00049	80 78 15 00	 cmp	 BYTE PTR [eax+21], 0
  0004d	75 0b		 jne	 SHORT $LN73@erase@2
  0004f	90		 npad	 1
$LL74@erase@2:
  00050	8b c8		 mov	 ecx, eax
  00052	8b 01		 mov	 eax, DWORD PTR [ecx]
  00054	80 78 15 00	 cmp	 BYTE PTR [eax+21], 0
  00058	74 f6		 je	 SHORT $LL74@erase@2
$LN73@erase@2:
  0005a	89 4d 0c	 mov	 DWORD PTR __First$[ebp], ecx
  0005d	eb 1f		 jmp	 SHORT $LN59@erase@2
$LN99@erase@2:
  0005f	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00062	80 78 15 00	 cmp	 BYTE PTR [eax+21], 0
  00066	75 13		 jne	 SHORT $LN57@erase@2
$LL58@erase@2:
  00068	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  0006b	75 0e		 jne	 SHORT $LN57@erase@2
  0006d	8b c8		 mov	 ecx, eax
  0006f	89 4d 0c	 mov	 DWORD PTR __First$[ebp], ecx
  00072	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00075	80 78 15 00	 cmp	 BYTE PTR [eax+21], 0
  00079	74 ed		 je	 SHORT $LL58@erase@2
$LN57@erase@2:
  0007b	89 45 0c	 mov	 DWORD PTR __First$[ebp], eax
$LN59@erase@2:
  0007e	52		 push	 edx
  0007f	8d 55 fc	 lea	 edx, DWORD PTR $T194991[ebp]
  00082	52		 push	 edx
  00083	8b ce		 mov	 ecx, esi
  00085	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::erase
  0008a	8b 4d 0c	 mov	 ecx, DWORD PTR __First$[ebp]
  0008d	3b 4d 10	 cmp	 ecx, DWORD PTR __Last$[ebp]
  00090	75 a2		 jne	 SHORT $LL2@erase@2
$LN1@erase@2:

; 1389 : 			return (iterator(_First._Ptr, this));

  00092	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00095	89 08		 mov	 DWORD PTR [eax], ecx
  00097	5e		 pop	 esi

; 1390 : 			}
; 1391 : 		}

  00098	8b e5		 mov	 esp, ebp
  0009a	5d		 pop	 ebp
  0009b	c2 0c 00	 ret	 12			; 0000000cH
?erase@?$_Tree@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@2@0@Z ENDP ; std::_Tree<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::erase
_TEXT	ENDS
PUBLIC	??$insert@U?$pair@HPAUOBJECTSTRUCT@@@std@@@?$_Tree@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@HPAUOBJECTSTRUCT@@@1@@Z ; std::_Tree<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::insert<std::pair<int,OBJECTSTRUCT *> >
; Function compile flags: /Ogtp
;	COMDAT ??$insert@U?$pair@HPAUOBJECTSTRUCT@@@std@@@?$_Tree@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@HPAUOBJECTSTRUCT@@@1@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Val$ = 12						; size = 4
??$insert@U?$pair@HPAUOBJECTSTRUCT@@@std@@@?$_Tree@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@HPAUOBJECTSTRUCT@@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::insert<std::pair<int,OBJECTSTRUCT *> >, COMDAT
; _this$ = ecx

; 753  : 		_Pairib insert(_Valty&& _Val)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 754  : 		{	// try to insert node with value _Val, favoring right side
; 755  : 		return (_Linsert(this->_Buynode(_STD forward<_Valty>(_Val)),
; 756  : 			false));

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	6a 00		 push	 0
  0000a	50		 push	 eax
  0000b	8b f1		 mov	 esi, ecx
  0000d	e8 00 00 00 00	 call	 ??$_Buynode@U?$pair@HPAUOBJECTSTRUCT@@@std@@@?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@HPAUOBJECTSTRUCT@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::_Buynode<std::pair<int,OBJECTSTRUCT *> >
  00012	8b 7d 08	 mov	 edi, DWORD PTR ___$ReturnUdt$[ebp]
  00015	50		 push	 eax
  00016	57		 push	 edi
  00017	8b ce		 mov	 ecx, esi
  00019	e8 00 00 00 00	 call	 ?_Linsert@?$_Tree@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@std@@_N@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@2@_N@Z ; std::_Tree<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::_Linsert
  0001e	8b c7		 mov	 eax, edi
  00020	5f		 pop	 edi
  00021	5e		 pop	 esi

; 757  : 		}

  00022	5d		 pop	 ebp
  00023	c2 08 00	 ret	 8
??$insert@U?$pair@HPAUOBJECTSTRUCT@@@std@@@?$_Tree@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@std@@_N@1@$$QAU?$pair@HPAUOBJECTSTRUCT@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::insert<std::pair<int,OBJECTSTRUCT *> >
_TEXT	ENDS
PUBLIC	?DeleteUser@CCashShop@@QAEHPAUOBJECTSTRUCT@@@Z	; CCashShop::DeleteUser
; Function compile flags: /Ogtp
; File c:\muserver_dev\development\mu-s8ep2-repack\gameserver\source\cashshop.cpp
;	COMDAT ?DeleteUser@CCashShop@@QAEHPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
$T195331 = 8						; size = 4
_Iter$ = 8						; size = 4
_lpObj$ = 8						; size = 4
?DeleteUser@CCashShop@@QAEHPAUOBJECTSTRUCT@@@Z PROC	; CCashShop::DeleteUser, COMDAT
; _this$ = ecx

; 232  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 233  : 	std::map<int, LPOBJ>::iterator Iter = this->MapUserObject.find(lpObj->DBNumber);

  00003	8b 45 08	 mov	 eax, DWORD PTR _lpObj$[ebp]
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	8b f1		 mov	 esi, ecx
  0000a	83 c0 30	 add	 eax, 48			; 00000030H
  0000d	50		 push	 eax
  0000e	8d 4d 08	 lea	 ecx, DWORD PTR _Iter$[ebp]
  00011	51		 push	 ecx
  00012	8d 4e 14	 lea	 ecx, DWORD PTR [esi+20]
  00015	e8 00 00 00 00	 call	 ?find@?$_Tree@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::find

; 234  : 	
; 235  : 	if ( Iter == this->MapUserObject.end() )

  0001a	8b 45 08	 mov	 eax, DWORD PTR _Iter$[ebp]
  0001d	3b 46 18	 cmp	 eax, DWORD PTR [esi+24]
  00020	75 08		 jne	 SHORT $LN1@DeleteUser

; 236  : 	{
; 237  : 		return FALSE;

  00022	5f		 pop	 edi
  00023	33 c0		 xor	 eax, eax
  00025	5e		 pop	 esi

; 243  : }

  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
$LN1@DeleteUser:

; 238  : 	}
; 239  : 
; 240  : 
; 241  : 	this->MapUserObject.erase(Iter);

  0002a	50		 push	 eax
  0002b	8d 55 08	 lea	 edx, DWORD PTR $T195331[ebp]
  0002e	52		 push	 edx
  0002f	8d 4e 14	 lea	 ecx, DWORD PTR [esi+20]
  00032	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::erase
  00037	5f		 pop	 edi

; 242  : 	return TRUE;

  00038	b8 01 00 00 00	 mov	 eax, 1
  0003d	5e		 pop	 esi

; 243  : }

  0003e	5d		 pop	 ebp
  0003f	c2 04 00	 ret	 4
?DeleteUser@CCashShop@@QAEHPAUOBJECTSTRUCT@@@Z ENDP	; CCashShop::DeleteUser
_TEXT	ENDS
PUBLIC	?SearchUser@CCashShop@@QAEPAUOBJECTSTRUCT@@H@Z	; CCashShop::SearchUser
; Function compile flags: /Ogtp
;	COMDAT ?SearchUser@CCashShop@@QAEPAUOBJECTSTRUCT@@H@Z
_TEXT	SEGMENT
$T195373 = -4						; size = 4
_iUserGuid$ = 8						; size = 4
?SearchUser@CCashShop@@QAEPAUOBJECTSTRUCT@@H@Z PROC	; CCashShop::SearchUser, COMDAT
; _this$ = ecx

; 247  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx

; 248  : 	LPOBJ lpReturnObj = NULL;
; 249  : 
; 250  : 	std::map<int, LPOBJ>::iterator Iter;
; 251  : 	Iter = this->MapUserObject.find(iUserGuid);

  00007	8d 45 08	 lea	 eax, DWORD PTR _iUserGuid$[ebp]
  0000a	50		 push	 eax
  0000b	8d 4d fc	 lea	 ecx, DWORD PTR $T195373[ebp]
  0000e	51		 push	 ecx
  0000f	8d 4e 14	 lea	 ecx, DWORD PTR [esi+20]
  00012	e8 00 00 00 00	 call	 ?find@?$_Tree@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::find
  00017	8b 00		 mov	 eax, DWORD PTR [eax]

; 252  : 
; 253  : 	if ( Iter == this->MapUserObject.end() )

  00019	3b 46 18	 cmp	 eax, DWORD PTR [esi+24]
  0001c	5e		 pop	 esi
  0001d	75 08		 jne	 SHORT $LN1@SearchUser

; 254  : 		return FALSE;

  0001f	33 c0		 xor	 eax, eax

; 259  : }

  00021	8b e5		 mov	 esp, ebp
  00023	5d		 pop	 ebp
  00024	c2 04 00	 ret	 4
$LN1@SearchUser:

; 255  : 
; 256  : 	lpReturnObj = Iter->second;
; 257  : 
; 258  : 	return lpReturnObj;

  00027	8b 40 10	 mov	 eax, DWORD PTR [eax+16]

; 259  : }

  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
?SearchUser@CCashShop@@QAEPAUOBJECTSTRUCT@@H@Z ENDP	; CCashShop::SearchUser
_TEXT	ENDS
PUBLIC	?SGAnsCashPoint@@YAXPAVMSG_STOG_USER_CASH_ANS_EX@protocol@@@Z ; SGAnsCashPoint
; Function compile flags: /Ogtp
;	COMDAT ?SGAnsCashPoint@@YAXPAVMSG_STOG_USER_CASH_ANS_EX@protocol@@@Z
_TEXT	SEGMENT
_aRecv$ = 8						; size = 4
?SGAnsCashPoint@@YAXPAVMSG_STOG_USER_CASH_ANS_EX@protocol@@@Z PROC ; SGAnsCashPoint, COMDAT

; 1016 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1017 : 	LPOBJ lpObj = NULL;
; 1018 : 
; 1019 : 	lpObj = g_CashShop.SearchUser(aRecv->dwUserGuid);

  00004	8b 75 08	 mov	 esi, DWORD PTR _aRecv$[ebp]
  00007	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0000a	50		 push	 eax
  0000b	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CashShop@@3VCCashShop@@A ; g_CashShop
  00010	e8 00 00 00 00	 call	 ?SearchUser@CCashShop@@QAEPAUOBJECTSTRUCT@@H@Z ; CCashShop::SearchUser

; 1020 : 
; 1021 : 	if ( lpObj == NULL )

  00015	85 c0		 test	 eax, eax
  00017	74 26		 je	 SHORT $LN2@SGAnsCashP

; 1022 : 		return;
; 1023 : 
; 1024 : 	lpObj->m_wcCashPoint = aRecv->dwUserCash[0];

  00019	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  0001c	89 88 68 24 00
	00		 mov	 DWORD PTR [eax+9320], ecx

; 1025 : 	lpObj->m_wpCashPoint = aRecv->dwUserCash[1];

  00022	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  00025	89 90 6c 24 00
	00		 mov	 DWORD PTR [eax+9324], edx

; 1026 : 	lpObj->m_wgCashPoint = aRecv->dwUserCash[2];

  0002b	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  0002e	89 88 70 24 00
	00		 mov	 DWORD PTR [eax+9328], ecx

; 1027 : 
; 1028 : 	g_CashShop.GCCashPoint(lpObj);

  00034	50		 push	 eax
  00035	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CashShop@@3VCCashShop@@A ; g_CashShop
  0003a	e8 00 00 00 00	 call	 ?GCCashPoint@CCashShop@@QAEXPAUOBJECTSTRUCT@@@Z ; CCashShop::GCCashPoint
$LN2@SGAnsCashP:
  0003f	5e		 pop	 esi

; 1029 : }

  00040	5d		 pop	 ebp
  00041	c3		 ret	 0
?SGAnsCashPoint@@YAXPAVMSG_STOG_USER_CASH_ANS_EX@protocol@@@Z ENDP ; SGAnsCashPoint
_TEXT	ENDS
PUBLIC	?SGAnsCashItemList@@YAXPAVMSG_STOG_ITEM_LIST_ANS_EX@protocol@@@Z ; SGAnsCashItemList
; Function compile flags: /Ogtp
;	COMDAT ?SGAnsCashItemList@@YAXPAVMSG_STOG_ITEM_LIST_ANS_EX@protocol@@@Z
_TEXT	SEGMENT
_aRecv$ = 8						; size = 4
?SGAnsCashItemList@@YAXPAVMSG_STOG_ITEM_LIST_ANS_EX@protocol@@@Z PROC ; SGAnsCashItemList, COMDAT

; 1032 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1033 : 	LPOBJ lpObj = NULL;
; 1034 : 
; 1035 : 	lpObj = g_CashShop.SearchUser(aRecv->dwUserGuid);

  00004	8b 75 08	 mov	 esi, DWORD PTR _aRecv$[ebp]
  00007	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0000a	50		 push	 eax
  0000b	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CashShop@@3VCCashShop@@A ; g_CashShop
  00010	e8 00 00 00 00	 call	 ?SearchUser@CCashShop@@QAEPAUOBJECTSTRUCT@@H@Z ; CCashShop::SearchUser

; 1036 : 
; 1037 : 	if ( lpObj == NULL )

  00015	85 c0		 test	 eax, eax
  00017	74 0c		 je	 SHORT $LN2@SGAnsCashI

; 1038 : 		return;
; 1039 : 
; 1040 : 	g_CashShop.GCAnsStorageInfo(lpObj,aRecv);

  00019	56		 push	 esi
  0001a	50		 push	 eax
  0001b	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CashShop@@3VCCashShop@@A ; g_CashShop
  00020	e8 00 00 00 00	 call	 ?GCAnsStorageInfo@CCashShop@@QAEXPAUOBJECTSTRUCT@@PAVMSG_STOG_ITEM_LIST_ANS_EX@protocol@@@Z ; CCashShop::GCAnsStorageInfo
$LN2@SGAnsCashI:
  00025	5e		 pop	 esi

; 1041 : }

  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
?SGAnsCashItemList@@YAXPAVMSG_STOG_ITEM_LIST_ANS_EX@protocol@@@Z ENDP ; SGAnsCashItemList
_TEXT	ENDS
PUBLIC	??_C@_0DG@CEAMHAIN@?$FLCashShop?$FN?$FLUse?5Answer?$FN?5User?$CIID?3?$CF@ ; `string'
PUBLIC	?SGAnsUseCashItem@@YAXPAVMSG_STOG_ITEM_USE_ANS_EX@protocol@@@Z ; SGAnsUseCashItem
EXTRN	?gObjSearchItemPlus@@YAHPAUOBJECTSTRUCT@@HHHH@Z:PROC ; gObjSearchItemPlus
EXTRN	?DGSetSummonerCreate@@YAXPAUOBJECTSTRUCT@@H@Z:PROC ; DGSetSummonerCreate
EXTRN	?GDReqPeriodItemInsert@CCashItemPeriodSystem@@QAEXPAUOBJECTSTRUCT@@HH@Z:PROC ; CCashItemPeriodSystem::GDReqPeriodItemInsert
;	COMDAT ??_C@_0DG@CEAMHAIN@?$FLCashShop?$FN?$FLUse?5Answer?$FN?5User?$CIID?3?$CF@
CONST	SEGMENT
??_C@_0DG@CEAMHAIN@?$FLCashShop?$FN?$FLUse?5Answer?$FN?5User?$CIID?3?$CF@ DB '['
	DB	'CashShop][Use Answer] User(ID:%s, Name:%s) Result:%d', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?SGAnsUseCashItem@@YAXPAVMSG_STOG_ITEM_USE_ANS_EX@protocol@@@Z
_TEXT	SEGMENT
_iResult$ = 8						; size = 4
_aRecv$ = 8						; size = 4
?SGAnsUseCashItem@@YAXPAVMSG_STOG_ITEM_USE_ANS_EX@protocol@@@Z PROC ; SGAnsUseCashItem, COMDAT

; 1044 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 1045 : 	LPOBJ lpObj = NULL;
; 1046 : 	lpObj = g_CashShop.SearchUser(aRecv->dwUserGuid);

  00004	8b 5d 08	 mov	 ebx, DWORD PTR _aRecv$[ebp]
  00007	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  0000a	56		 push	 esi
  0000b	50		 push	 eax
  0000c	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CashShop@@3VCCashShop@@A ; g_CashShop
  00011	e8 00 00 00 00	 call	 ?SearchUser@CCashShop@@QAEPAUOBJECTSTRUCT@@H@Z ; CCashShop::SearchUser
  00016	8b f0		 mov	 esi, eax

; 1047 : 
; 1048 : 	int iResult = TRUE;

  00018	c7 45 08 01 00
	00 00		 mov	 DWORD PTR _iResult$[ebp], 1

; 1049 : 	int iItemCode = 0;
; 1050 : 	int iItemUsePeriod = 0;
; 1051 : 
; 1052 : 	//protocol::MSG_GTOS_BUY_ITEM_NTF pMsg;
; 1053 : 
; 1054 : 	if ( lpObj == NULL )

  0001f	85 f6		 test	 esi, esi
  00021	0f 84 3c 01 00
	00		 je	 $LN22@SGAnsUseCa

; 1055 : 		return;
; 1056 : 
; 1057 : 	if( aRecv->dwResult != 0 )

  00027	83 7b 0c 00	 cmp	 DWORD PTR [ebx+12], 0
  0002b	74 14		 je	 SHORT $LN20@SGAnsUseCa

; 1058 : 	{
; 1059 : 		g_CashShop.GCCashItemUseResult(lpObj,(BYTE)aRecv->dwResult);

  0002d	0f b6 4b 0c	 movzx	 ecx, BYTE PTR [ebx+12]
  00031	51		 push	 ecx
  00032	56		 push	 esi
  00033	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CashShop@@3VCCashShop@@A ; g_CashShop
  00038	e8 00 00 00 00	 call	 ?GCCashItemUseResult@CCashShop@@QAEXPAUOBJECTSTRUCT@@E@Z ; CCashShop::GCCashItemUseResult
  0003d	5e		 pop	 esi
  0003e	5b		 pop	 ebx

; 1115 : }

  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
$LN20@SGAnsUseCa:
  00041	57		 push	 edi

; 1060 : 		return;
; 1061 : 	}
; 1062 : 
; 1063 : 	iItemCode = aRecv->itemInfo.dwItemId;

  00042	8b 7b 14	 mov	 edi, DWORD PTR [ebx+20]

; 1064 : 
; 1065 : 	if ( g_CashShop.CheckPeriodItem(iItemCode) == TRUE )

  00045	57		 push	 edi
  00046	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CashShop@@3VCCashShop@@A ; g_CashShop
  0004b	e8 00 00 00 00	 call	 ?CheckPeriodItem@CCashShop@@QAEHH@Z ; CCashShop::CheckPeriodItem
  00050	83 f8 01	 cmp	 eax, 1
  00053	75 15		 jne	 SHORT $LN19@SGAnsUseCa

; 1066 : 	{
; 1067 : 		g_CashItemPeriodSystem.GDReqPeriodItemInsert(lpObj, iItemCode, aRecv->itemInfo.dwUseTime);

  00055	8b 53 1c	 mov	 edx, DWORD PTR [ebx+28]
  00058	52		 push	 edx
  00059	57		 push	 edi
  0005a	56		 push	 esi
  0005b	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CashItemPeriodSystem@@3VCCashItemPeriodSystem@@A ; g_CashItemPeriodSystem
  00060	e8 00 00 00 00	 call	 ?GDReqPeriodItemInsert@CCashItemPeriodSystem@@QAEXPAUOBJECTSTRUCT@@HH@Z ; CCashItemPeriodSystem::GDReqPeriodItemInsert

; 1068 : 	}
; 1069 : 	else if(iItemCode == ITEMGET(14,78)

  00065	e9 a5 00 00 00	 jmp	 $LN24@SGAnsUseCa
$LN19@SGAnsUseCa:

; 1070 : 		|| iItemCode == ITEMGET(14,79) 
; 1071 : 		|| iItemCode == ITEMGET(14,80)
; 1072 : 		|| iItemCode == ITEMGET(14,81)
; 1073 : 		|| iItemCode == ITEMGET(14,82))

  0006a	81 ff 4e 1c 00
	00		 cmp	 edi, 7246		; 00001c4eH
  00070	74 70		 je	 SHORT $LN16@SGAnsUseCa
  00072	81 ff 4f 1c 00
	00		 cmp	 edi, 7247		; 00001c4fH
  00078	74 68		 je	 SHORT $LN16@SGAnsUseCa
  0007a	81 ff 50 1c 00
	00		 cmp	 edi, 7248		; 00001c50H
  00080	74 60		 je	 SHORT $LN16@SGAnsUseCa
  00082	81 ff 51 1c 00
	00		 cmp	 edi, 7249		; 00001c51H
  00088	74 58		 je	 SHORT $LN16@SGAnsUseCa
  0008a	81 ff 52 1c 00
	00		 cmp	 edi, 7250		; 00001c52H
  00090	74 50		 je	 SHORT $LN16@SGAnsUseCa

; 1080 : 			}
; 1081 : 		}
; 1082 : 	}
; 1083 : 	else if(iItemCode == ITEMGET(14,70)
; 1084 : 			|| iItemCode == ITEMGET(14,71)
; 1085 : 			|| iItemCode == ITEMGET(14,94) )

  00092	81 ff 46 1c 00
	00		 cmp	 edi, 7238		; 00001c46H
  00098	74 2c		 je	 SHORT $LN11@SGAnsUseCa
  0009a	81 ff 47 1c 00
	00		 cmp	 edi, 7239		; 00001c47H
  000a0	74 24		 je	 SHORT $LN11@SGAnsUseCa
  000a2	81 ff 5e 1c 00
	00		 cmp	 edi, 7262		; 00001c5eH
  000a8	74 1c		 je	 SHORT $LN11@SGAnsUseCa

; 1095 : 	else if(iItemCode == ITEMGET(14,91) )

  000aa	81 ff 5b 1c 00
	00		 cmp	 edi, 7259		; 00001c5bH
  000b0	75 0e		 jne	 SHORT $LN7@SGAnsUseCa

; 1096 : 	{
; 1097 : 		DGSetSummonerCreate(lpObj,lpObj->m_Index);

  000b2	8b 06		 mov	 eax, DWORD PTR [esi]
  000b4	50		 push	 eax
  000b5	56		 push	 esi
  000b6	e8 00 00 00 00	 call	 ?DGSetSummonerCreate@@YAXPAUOBJECTSTRUCT@@H@Z ; DGSetSummonerCreate
  000bb	83 c4 08	 add	 esp, 8
  000be	eb 4f		 jmp	 SHORT $LN24@SGAnsUseCa
$LN7@SGAnsUseCa:

; 1098 : 	}
; 1099 : 	else if ( g_CashShop.GiveBuyItemToInventory(lpObj, iItemCode,&aRecv->itemInfo) == FALSE )

  000c0	8d 4b 10	 lea	 ecx, DWORD PTR [ebx+16]
  000c3	51		 push	 ecx

; 1100 : 	{
; 1101 : 		iResult = 0;

  000c4	eb 36		 jmp	 SHORT $LN28@SGAnsUseCa
$LN11@SGAnsUseCa:

; 1086 : 	{
; 1087 : 		if(gObjSearchItemPlus(lpObj,iItemCode,0,aRecv->itemInfo.dwDurability,50) == FALSE)

  000c6	8b 53 18	 mov	 edx, DWORD PTR [ebx+24]
  000c9	6a 32		 push	 50			; 00000032H
  000cb	52		 push	 edx
  000cc	6a 00		 push	 0
  000ce	57		 push	 edi
  000cf	56		 push	 esi
  000d0	e8 00 00 00 00	 call	 ?gObjSearchItemPlus@@YAHPAUOBJECTSTRUCT@@HHHH@Z ; gObjSearchItemPlus
  000d5	83 c4 14	 add	 esp, 20			; 00000014H
  000d8	85 c0		 test	 eax, eax
  000da	75 33		 jne	 SHORT $LN24@SGAnsUseCa

; 1088 : 		{
; 1089 : 			if(g_CashShop.GiveBuyItemToInventory(lpObj,iItemCode,&aRecv->itemInfo) == FALSE)

  000dc	8d 43 10	 lea	 eax, DWORD PTR [ebx+16]
  000df	50		 push	 eax

; 1090 : 			{
; 1091 : 				iResult = 0;
; 1092 : 			}
; 1093 : 		}
; 1094 : 	}

  000e0	eb 1a		 jmp	 SHORT $LN28@SGAnsUseCa
$LN16@SGAnsUseCa:

; 1074 : 	{
; 1075 : 		if(gObjSearchItemPlus(lpObj,iItemCode,0,aRecv->itemInfo.dwDurability,3) == FALSE)

  000e2	8b 4b 18	 mov	 ecx, DWORD PTR [ebx+24]
  000e5	6a 03		 push	 3
  000e7	51		 push	 ecx
  000e8	6a 00		 push	 0
  000ea	57		 push	 edi
  000eb	56		 push	 esi
  000ec	e8 00 00 00 00	 call	 ?gObjSearchItemPlus@@YAHPAUOBJECTSTRUCT@@HHHH@Z ; gObjSearchItemPlus
  000f1	83 c4 14	 add	 esp, 20			; 00000014H
  000f4	85 c0		 test	 eax, eax
  000f6	75 17		 jne	 SHORT $LN24@SGAnsUseCa

; 1076 : 		{
; 1077 : 			if(g_CashShop.GiveBuyItemToInventory(lpObj,iItemCode,&aRecv->itemInfo)== FALSE)

  000f8	8d 53 10	 lea	 edx, DWORD PTR [ebx+16]
  000fb	52		 push	 edx
$LN28@SGAnsUseCa:
  000fc	57		 push	 edi
  000fd	56		 push	 esi
  000fe	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CashShop@@3VCCashShop@@A ; g_CashShop
  00103	e8 00 00 00 00	 call	 ?GiveBuyItemToInventory@CCashShop@@QAEHPAUOBJECTSTRUCT@@HPAUuseInfoEx@protocol@@@Z ; CCashShop::GiveBuyItemToInventory
  00108	85 c0		 test	 eax, eax
  0010a	75 03		 jne	 SHORT $LN24@SGAnsUseCa

; 1078 : 			{
; 1079 : 				iResult = 0;

  0010c	89 45 08	 mov	 DWORD PTR _iResult$[ebp], eax
$LN24@SGAnsUseCa:

; 1102 : 	}
; 1103 : 
; 1104 : 
; 1105 : 	switch( iResult )

  0010f	8b 45 08	 mov	 eax, DWORD PTR _iResult$[ebp]
  00112	83 e8 00	 sub	 eax, 0
  00115	74 1e		 je	 SHORT $LN2@SGAnsUseCa
  00117	48		 dec	 eax
  00118	75 22		 jne	 SHORT $LN3@SGAnsUseCa

; 1108 : 	case 1: g_CashShop.GSNtfUseItem(lpObj->DBNumber,aRecv->itemInfo.dwItemGuid); iResult = 0; break;

  0011a	8b 43 10	 mov	 eax, DWORD PTR [ebx+16]
  0011d	8b 4e 30	 mov	 ecx, DWORD PTR [esi+48]
  00120	50		 push	 eax
  00121	51		 push	 ecx
  00122	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CashShop@@3VCCashShop@@A ; g_CashShop
  00127	e8 00 00 00 00	 call	 ?GSNtfUseItem@CCashShop@@QAEXKK@Z ; CCashShop::GSNtfUseItem
  0012c	c7 45 08 00 00
	00 00		 mov	 DWORD PTR _iResult$[ebp], 0
  00133	eb 07		 jmp	 SHORT $LN3@SGAnsUseCa
$LN2@SGAnsUseCa:

; 1106 : 	{
; 1107 : 	case 0: iResult = 15;	break;

  00135	c7 45 08 0f 00
	00 00		 mov	 DWORD PTR _iResult$[ebp], 15 ; 0000000fH
$LN3@SGAnsUseCa:

; 1109 : 	}
; 1110 : 
; 1111 : 	LogAddTD("[CashShop][Use Answer] User(ID:%s, Name:%s) Result:%d",
; 1112 : 		lpObj->AccountID, lpObj->Name, iResult);

  0013c	8b 7d 08	 mov	 edi, DWORD PTR _iResult$[ebp]
  0013f	57		 push	 edi
  00140	8d 56 5d	 lea	 edx, DWORD PTR [esi+93]
  00143	52		 push	 edx
  00144	8d 46 52	 lea	 eax, DWORD PTR [esi+82]
  00147	50		 push	 eax
  00148	68 00 00 00 00	 push	 OFFSET ??_C@_0DG@CEAMHAIN@?$FLCashShop?$FN?$FLUse?5Answer?$FN?5User?$CIID?3?$CF@
  0014d	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00153	83 c4 10	 add	 esp, 16			; 00000010H

; 1113 : 
; 1114 : 	g_CashShop.GCCashItemUseResult(lpObj,iResult);

  00156	57		 push	 edi
  00157	56		 push	 esi
  00158	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CashShop@@3VCCashShop@@A ; g_CashShop
  0015d	e8 00 00 00 00	 call	 ?GCCashItemUseResult@CCashShop@@QAEXPAUOBJECTSTRUCT@@E@Z ; CCashShop::GCCashItemUseResult
  00162	5f		 pop	 edi
$LN22@SGAnsUseCa:
  00163	5e		 pop	 esi
  00164	5b		 pop	 ebx

; 1115 : }

  00165	5d		 pop	 ebp
  00166	c3		 ret	 0
?SGAnsUseCashItem@@YAXPAVMSG_STOG_ITEM_USE_ANS_EX@protocol@@@Z ENDP ; SGAnsUseCashItem
_TEXT	ENDS
PUBLIC	?SGAnsBuyCashItem@@YAXPAVMSG_STOG_BUY_ITEM_ANS_EX@protocol@@@Z ; SGAnsBuyCashItem
; Function compile flags: /Ogtp
;	COMDAT ?SGAnsBuyCashItem@@YAXPAVMSG_STOG_BUY_ITEM_ANS_EX@protocol@@@Z
_TEXT	SEGMENT
_aRecv$ = 8						; size = 4
?SGAnsBuyCashItem@@YAXPAVMSG_STOG_BUY_ITEM_ANS_EX@protocol@@@Z PROC ; SGAnsBuyCashItem, COMDAT

; 1120 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1121 : 	LPOBJ lpObj;
; 1122 : 
; 1123 : 	lpObj = g_CashShop.SearchUser(aRecv->dwUserGuid);

  00004	8b 75 08	 mov	 esi, DWORD PTR _aRecv$[ebp]
  00007	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  0000a	50		 push	 eax
  0000b	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CashShop@@3VCCashShop@@A ; g_CashShop
  00010	e8 00 00 00 00	 call	 ?SearchUser@CCashShop@@QAEPAUOBJECTSTRUCT@@H@Z ; CCashShop::SearchUser

; 1124 : 
; 1125 : 	if ( lpObj == NULL )

  00015	85 c0		 test	 eax, eax
  00017	74 31		 je	 SHORT $LN3@SGAnsBuyCa

; 1126 : 		return;
; 1127 : 
; 1128 : 	if ( aRecv->dwResult == 0 )

  00019	83 7e 20 00	 cmp	 DWORD PTR [esi+32], 0
  0001d	75 1b		 jne	 SHORT $LN1@SGAnsBuyCa

; 1129 : 	{
; 1130 : 		lpObj->m_wcCashPoint = aRecv->dwUserCash[0];

  0001f	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00022	89 88 68 24 00
	00		 mov	 DWORD PTR [eax+9320], ecx

; 1131 : 		lpObj->m_wpCashPoint = aRecv->dwUserCash[1];

  00028	8b 56 18	 mov	 edx, DWORD PTR [esi+24]
  0002b	89 90 6c 24 00
	00		 mov	 DWORD PTR [eax+9324], edx

; 1132 : 		lpObj->m_wgCashPoint = aRecv->dwUserCash[2];

  00031	8b 4e 1c	 mov	 ecx, DWORD PTR [esi+28]
  00034	89 88 70 24 00
	00		 mov	 DWORD PTR [eax+9328], ecx
$LN1@SGAnsBuyCa:

; 1133 : 	}
; 1134 : 
; 1135 : 	g_CashShop.GCCashItemBuyResult(lpObj,(BYTE)aRecv->dwResult);

  0003a	0f b6 56 20	 movzx	 edx, BYTE PTR [esi+32]
  0003e	52		 push	 edx
  0003f	50		 push	 eax
  00040	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CashShop@@3VCCashShop@@A ; g_CashShop
  00045	e8 00 00 00 00	 call	 ?GCCashItemBuyResult@CCashShop@@QAEXPAUOBJECTSTRUCT@@E@Z ; CCashShop::GCCashItemBuyResult
$LN3@SGAnsBuyCa:
  0004a	5e		 pop	 esi

; 1136 : }

  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
?SGAnsBuyCashItem@@YAXPAVMSG_STOG_BUY_ITEM_ANS_EX@protocol@@@Z ENDP ; SGAnsBuyCashItem
_TEXT	ENDS
PUBLIC	?SGAnsGiftCashItem@@YAXPAVMSG_STOG_GIFT_ITEM_ANS_EX@protocol@@@Z ; SGAnsGiftCashItem
; Function compile flags: /Ogtp
;	COMDAT ?SGAnsGiftCashItem@@YAXPAVMSG_STOG_GIFT_ITEM_ANS_EX@protocol@@@Z
_TEXT	SEGMENT
_aRecv$ = 8						; size = 4
?SGAnsGiftCashItem@@YAXPAVMSG_STOG_GIFT_ITEM_ANS_EX@protocol@@@Z PROC ; SGAnsGiftCashItem, COMDAT

; 1139 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1140 : 	LPOBJ lpObj;
; 1141 : 
; 1142 : 	lpObj = g_CashShop.SearchUser(aRecv->dwUserGuid);

  00004	8b 75 08	 mov	 esi, DWORD PTR _aRecv$[ebp]
  00007	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  0000a	50		 push	 eax
  0000b	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CashShop@@3VCCashShop@@A ; g_CashShop
  00010	e8 00 00 00 00	 call	 ?SearchUser@CCashShop@@QAEPAUOBJECTSTRUCT@@H@Z ; CCashShop::SearchUser

; 1143 : 
; 1144 : 	if ( lpObj == NULL )

  00015	85 c0		 test	 eax, eax
  00017	74 31		 je	 SHORT $LN3@SGAnsGiftC

; 1145 : 		return;
; 1146 : 
; 1147 : 	if ( aRecv->dwResult == 0 )

  00019	83 7e 20 00	 cmp	 DWORD PTR [esi+32], 0
  0001d	75 1b		 jne	 SHORT $LN1@SGAnsGiftC

; 1148 : 	{
; 1149 : 		lpObj->m_wcCashPoint = aRecv->dwUserCash[0];

  0001f	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00022	89 88 68 24 00
	00		 mov	 DWORD PTR [eax+9320], ecx

; 1150 : 		lpObj->m_wpCashPoint = aRecv->dwUserCash[1];

  00028	8b 56 18	 mov	 edx, DWORD PTR [esi+24]
  0002b	89 90 6c 24 00
	00		 mov	 DWORD PTR [eax+9324], edx

; 1151 : 		lpObj->m_wgCashPoint = aRecv->dwUserCash[2];

  00031	8b 4e 1c	 mov	 ecx, DWORD PTR [esi+28]
  00034	89 88 70 24 00
	00		 mov	 DWORD PTR [eax+9328], ecx
$LN1@SGAnsGiftC:

; 1152 : 	}
; 1153 : 
; 1154 : 	g_CashShop.GCCashGiftSendResult(lpObj,(BYTE)aRecv->dwResult);

  0003a	0f b6 56 20	 movzx	 edx, BYTE PTR [esi+32]
  0003e	52		 push	 edx
  0003f	50		 push	 eax
  00040	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CashShop@@3VCCashShop@@A ; g_CashShop
  00045	e8 00 00 00 00	 call	 ?GCCashGiftSendResult@CCashShop@@QAEXPAUOBJECTSTRUCT@@E@Z ; CCashShop::GCCashGiftSendResult
$LN3@SGAnsGiftC:
  0004a	5e		 pop	 esi

; 1155 : }

  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
?SGAnsGiftCashItem@@YAXPAVMSG_STOG_GIFT_ITEM_ANS_EX@protocol@@@Z ENDP ; SGAnsGiftCashItem
_TEXT	ENDS
PUBLIC	?SGAnsCashGiftList@@YAXPAVMSG_STOG_GIFT_LIST_ANS_EX@protocol@@@Z ; SGAnsCashGiftList
; Function compile flags: /Ogtp
;	COMDAT ?SGAnsCashGiftList@@YAXPAVMSG_STOG_GIFT_LIST_ANS_EX@protocol@@@Z
_TEXT	SEGMENT
_aRecv$ = 8						; size = 4
?SGAnsCashGiftList@@YAXPAVMSG_STOG_GIFT_LIST_ANS_EX@protocol@@@Z PROC ; SGAnsCashGiftList, COMDAT

; 1158 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1159 : 	LPOBJ lpObj = NULL;
; 1160 : 
; 1161 : 	lpObj = g_CashShop.SearchUser(aRecv->dwUserGuid);

  00004	8b 75 08	 mov	 esi, DWORD PTR _aRecv$[ebp]
  00007	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0000a	50		 push	 eax
  0000b	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CashShop@@3VCCashShop@@A ; g_CashShop
  00010	e8 00 00 00 00	 call	 ?SearchUser@CCashShop@@QAEPAUOBJECTSTRUCT@@H@Z ; CCashShop::SearchUser

; 1162 : 
; 1163 : 	if ( lpObj == NULL )

  00015	85 c0		 test	 eax, eax
  00017	74 0c		 je	 SHORT $LN2@SGAnsCashG

; 1164 : 		return;
; 1165 : 
; 1166 : 	g_CashShop.GCAnsGiftInfo(lpObj,aRecv);

  00019	56		 push	 esi
  0001a	50		 push	 eax
  0001b	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CashShop@@3VCCashShop@@A ; g_CashShop
  00020	e8 00 00 00 00	 call	 ?GCAnsGiftInfo@CCashShop@@QAEXPAUOBJECTSTRUCT@@PAVMSG_STOG_GIFT_LIST_ANS_EX@protocol@@@Z ; CCashShop::GCAnsGiftInfo
$LN2@SGAnsCashG:
  00025	5e		 pop	 esi

; 1167 : }

  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
?SGAnsCashGiftList@@YAXPAVMSG_STOG_GIFT_LIST_ANS_EX@protocol@@@Z ENDP ; SGAnsCashGiftList
_TEXT	ENDS
PUBLIC	?_Tidy@?$_Tree@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::_Tidy
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
;	COMDAT ?_Tidy@?$_Tree@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
$T195476 = -4						; size = 4
?_Tidy@?$_Tree@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::_Tidy, COMDAT
; _this$ = ecx

; 1865 : 		{	// free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1866 : 		erase(begin(), end());

  00004	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00007	8b 10		 mov	 edx, DWORD PTR [eax]
  00009	50		 push	 eax
  0000a	52		 push	 edx
  0000b	8d 45 fc	 lea	 eax, DWORD PTR $T195476[ebp]
  0000e	50		 push	 eax
  0000f	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::erase

; 1867 : 		}

  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
?_Tidy@?$_Tree@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::_Tidy
_TEXT	ENDS
PUBLIC	?ShopServerProtocolCore@@YAXKPAEH@Z		; ShopServerProtocolCore
; Function compile flags: /Ogtp
; File c:\muserver_dev\development\mu-s8ep2-repack\gameserver\source\cashshop.cpp
;	COMDAT ?ShopServerProtocolCore@@YAXKPAEH@Z
_TEXT	SEGMENT
_protoNum$ = 8						; size = 4
_aRecv$ = 12						; size = 4
_aLen$ = 16						; size = 4
?ShopServerProtocolCore@@YAXKPAEH@Z PROC		; ShopServerProtocolCore, COMDAT

; 28   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 29   : 	switch ( protoNum )

  00003	8b 45 08	 mov	 eax, DWORD PTR _protoNum$[ebp]
  00006	3d 00 08 00 00	 cmp	 eax, 2048		; 00000800H
  0000b	77 4f		 ja	 SHORT $LN11@ShopServer
  0000d	74 3f		 je	 SHORT $LN3@ShopServer
  0000f	3d 00 02 00 00	 cmp	 eax, 512		; 00000200H
  00014	74 2a		 je	 SHORT $LN6@ShopServer
  00016	3d 00 04 00 00	 cmp	 eax, 1024		; 00000400H
  0001b	74 15		 je	 SHORT $LN5@ShopServer
  0001d	3d 00 06 00 00	 cmp	 eax, 1536		; 00000600H
  00022	75 60		 jne	 SHORT $LN7@ShopServer

; 33   : 		case 0x600:SGAnsUseCashItem((protocol::MSG_STOG_ITEM_USE_ANS_EX *)aRecv);break;

  00024	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00027	50		 push	 eax
  00028	e8 00 00 00 00	 call	 ?SGAnsUseCashItem@@YAXPAVMSG_STOG_ITEM_USE_ANS_EX@protocol@@@Z ; SGAnsUseCashItem

; 35   : 		case 0xA00:SGAnsBuyCashItem((protocol::MSG_STOG_BUY_ITEM_ANS_EX *)aRecv);break;

  0002d	83 c4 04	 add	 esp, 4

; 37   : 
; 38   : 		/*case 0x400:SGAnsCashItemList((protocol::MSG_STOG_ITEM_LIST_ANS *)aRecv);break;
; 39   : 		case 0x600:SGAnsPackageItemList((protocol::MSG_STOG_PACKAGE_LIST_ANS *)aRecv);break;
; 40   : 		case 0x800:SGAnsBranchItemList((protocol::MSG_STOG_BRANCH_ITEM_LIST_ANS *)aRecv);break;
; 41   : 		case 0xE00:g_CashShop.CashShopOptioNReload();break;
; 42   : 		case 0xA00:SGAnsBuyCashItem((protocol::MSG_STOG_BUY_ITEM_ANS *)aRecv);break;*/
; 43   : 	}
; 44   : }

  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
$LN5@ShopServer:

; 32   : 		case 0x400:SGAnsCashItemList((protocol::MSG_STOG_ITEM_LIST_ANS_EX *)aRecv);break;

  00032	8b 4d 0c	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  00035	51		 push	 ecx
  00036	e8 00 00 00 00	 call	 ?SGAnsCashItemList@@YAXPAVMSG_STOG_ITEM_LIST_ANS_EX@protocol@@@Z ; SGAnsCashItemList

; 35   : 		case 0xA00:SGAnsBuyCashItem((protocol::MSG_STOG_BUY_ITEM_ANS_EX *)aRecv);break;

  0003b	83 c4 04	 add	 esp, 4

; 37   : 
; 38   : 		/*case 0x400:SGAnsCashItemList((protocol::MSG_STOG_ITEM_LIST_ANS *)aRecv);break;
; 39   : 		case 0x600:SGAnsPackageItemList((protocol::MSG_STOG_PACKAGE_LIST_ANS *)aRecv);break;
; 40   : 		case 0x800:SGAnsBranchItemList((protocol::MSG_STOG_BRANCH_ITEM_LIST_ANS *)aRecv);break;
; 41   : 		case 0xE00:g_CashShop.CashShopOptioNReload();break;
; 42   : 		case 0xA00:SGAnsBuyCashItem((protocol::MSG_STOG_BUY_ITEM_ANS *)aRecv);break;*/
; 43   : 	}
; 44   : }

  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
$LN6@ShopServer:

; 30   : 	{
; 31   : 		case 0x200:SGAnsCashPoint((protocol::MSG_STOG_USER_CASH_ANS_EX *)aRecv);break;

  00040	8b 55 0c	 mov	 edx, DWORD PTR _aRecv$[ebp]
  00043	52		 push	 edx
  00044	e8 00 00 00 00	 call	 ?SGAnsCashPoint@@YAXPAVMSG_STOG_USER_CASH_ANS_EX@protocol@@@Z ; SGAnsCashPoint

; 35   : 		case 0xA00:SGAnsBuyCashItem((protocol::MSG_STOG_BUY_ITEM_ANS_EX *)aRecv);break;

  00049	83 c4 04	 add	 esp, 4

; 37   : 
; 38   : 		/*case 0x400:SGAnsCashItemList((protocol::MSG_STOG_ITEM_LIST_ANS *)aRecv);break;
; 39   : 		case 0x600:SGAnsPackageItemList((protocol::MSG_STOG_PACKAGE_LIST_ANS *)aRecv);break;
; 40   : 		case 0x800:SGAnsBranchItemList((protocol::MSG_STOG_BRANCH_ITEM_LIST_ANS *)aRecv);break;
; 41   : 		case 0xE00:g_CashShop.CashShopOptioNReload();break;
; 42   : 		case 0xA00:SGAnsBuyCashItem((protocol::MSG_STOG_BUY_ITEM_ANS *)aRecv);break;*/
; 43   : 	}
; 44   : }

  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
$LN3@ShopServer:

; 34   : 		case 0x800:SGAnsCashGiftList((protocol::MSG_STOG_GIFT_LIST_ANS_EX *) aRecv); break;

  0004e	8b 45 0c	 mov	 eax, DWORD PTR _aRecv$[ebp]
  00051	50		 push	 eax
  00052	e8 00 00 00 00	 call	 ?SGAnsCashGiftList@@YAXPAVMSG_STOG_GIFT_LIST_ANS_EX@protocol@@@Z ; SGAnsCashGiftList

; 35   : 		case 0xA00:SGAnsBuyCashItem((protocol::MSG_STOG_BUY_ITEM_ANS_EX *)aRecv);break;

  00057	83 c4 04	 add	 esp, 4

; 37   : 
; 38   : 		/*case 0x400:SGAnsCashItemList((protocol::MSG_STOG_ITEM_LIST_ANS *)aRecv);break;
; 39   : 		case 0x600:SGAnsPackageItemList((protocol::MSG_STOG_PACKAGE_LIST_ANS *)aRecv);break;
; 40   : 		case 0x800:SGAnsBranchItemList((protocol::MSG_STOG_BRANCH_ITEM_LIST_ANS *)aRecv);break;
; 41   : 		case 0xE00:g_CashShop.CashShopOptioNReload();break;
; 42   : 		case 0xA00:SGAnsBuyCashItem((protocol::MSG_STOG_BUY_ITEM_ANS *)aRecv);break;*/
; 43   : 	}
; 44   : }

  0005a	5d		 pop	 ebp
  0005b	c3		 ret	 0
$LN11@ShopServer:

; 29   : 	switch ( protoNum )

  0005c	3d 00 0a 00 00	 cmp	 eax, 2560		; 00000a00H
  00061	74 15		 je	 SHORT $LN2@ShopServer
  00063	3d 00 0e 00 00	 cmp	 eax, 3584		; 00000e00H
  00068	75 1a		 jne	 SHORT $LN7@ShopServer

; 36   : 		case 0xE00:SGAnsGiftCashItem((protocol::MSG_STOG_GIFT_ITEM_ANS_EX *)aRecv);break;

  0006a	8b 4d 0c	 mov	 ecx, DWORD PTR _aRecv$[ebp]
  0006d	51		 push	 ecx
  0006e	e8 00 00 00 00	 call	 ?SGAnsGiftCashItem@@YAXPAVMSG_STOG_GIFT_ITEM_ANS_EX@protocol@@@Z ; SGAnsGiftCashItem
  00073	83 c4 04	 add	 esp, 4

; 37   : 
; 38   : 		/*case 0x400:SGAnsCashItemList((protocol::MSG_STOG_ITEM_LIST_ANS *)aRecv);break;
; 39   : 		case 0x600:SGAnsPackageItemList((protocol::MSG_STOG_PACKAGE_LIST_ANS *)aRecv);break;
; 40   : 		case 0x800:SGAnsBranchItemList((protocol::MSG_STOG_BRANCH_ITEM_LIST_ANS *)aRecv);break;
; 41   : 		case 0xE00:g_CashShop.CashShopOptioNReload();break;
; 42   : 		case 0xA00:SGAnsBuyCashItem((protocol::MSG_STOG_BUY_ITEM_ANS *)aRecv);break;*/
; 43   : 	}
; 44   : }

  00076	5d		 pop	 ebp
  00077	c3		 ret	 0
$LN2@ShopServer:

; 35   : 		case 0xA00:SGAnsBuyCashItem((protocol::MSG_STOG_BUY_ITEM_ANS_EX *)aRecv);break;

  00078	8b 55 0c	 mov	 edx, DWORD PTR _aRecv$[ebp]
  0007b	52		 push	 edx
  0007c	e8 00 00 00 00	 call	 ?SGAnsBuyCashItem@@YAXPAVMSG_STOG_BUY_ITEM_ANS_EX@protocol@@@Z ; SGAnsBuyCashItem
  00081	83 c4 04	 add	 esp, 4
$LN7@ShopServer:

; 37   : 
; 38   : 		/*case 0x400:SGAnsCashItemList((protocol::MSG_STOG_ITEM_LIST_ANS *)aRecv);break;
; 39   : 		case 0x600:SGAnsPackageItemList((protocol::MSG_STOG_PACKAGE_LIST_ANS *)aRecv);break;
; 40   : 		case 0x800:SGAnsBranchItemList((protocol::MSG_STOG_BRANCH_ITEM_LIST_ANS *)aRecv);break;
; 41   : 		case 0xE00:g_CashShop.CashShopOptioNReload();break;
; 42   : 		case 0xA00:SGAnsBuyCashItem((protocol::MSG_STOG_BUY_ITEM_ANS *)aRecv);break;*/
; 43   : 	}
; 44   : }

  00084	5d		 pop	 ebp
  00085	c3		 ret	 0
?ShopServerProtocolCore@@YAXKPAEH@Z ENDP		; ShopServerProtocolCore
_TEXT	ENDS
PUBLIC	?ConnectShopServer@CCashShop@@QAEHPADH@Z	; CCashShop::ConnectShopServer
EXTRN	?Connect@wsShopServerCli@@QAEHPADGK@Z:PROC	; wsShopServerCli::Connect
EXTRN	__imp__SetWindowLongA@12:PROC
EXTRN	?SetProtocolCore@wsShopServerCli@@QAEHP6AXKPAEH@Z@Z:PROC ; wsShopServerCli::SetProtocolCore
EXTRN	?CreateSocket@MyWinsockBase@@QAEHPAUHWND__@@@Z:PROC ; MyWinsockBase::CreateSocket
EXTRN	?ghWnd@@3PAUHWND__@@A:DWORD			; ghWnd
; Function compile flags: /Ogtp
;	COMDAT ?ConnectShopServer@CCashShop@@QAEHPADH@Z
_TEXT	SEGMENT
_pchIpAddress$ = 8					; size = 4
_iPortNumber$ = 12					; size = 4
?ConnectShopServer@CCashShop@@QAEHPADH@Z PROC		; CCashShop::ConnectShopServer, COMDAT
; _this$ = ecx

; 126  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 127  : 	if ( g_ShopServerClient.CreateSocket(ghWnd) == FALSE )

  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ghWnd@@3PAUHWND__@@A ; ghWnd
  00008	50		 push	 eax
  00009	b9 04 00 00 00	 mov	 ecx, OFFSET ?g_ShopServerClient@@3VwsShopServerCli@@A+4
  0000e	e8 00 00 00 00	 call	 ?CreateSocket@MyWinsockBase@@QAEHPAUHWND__@@@Z ; MyWinsockBase::CreateSocket
  00013	85 c0		 test	 eax, eax
  00015	75 06		 jne	 SHORT $LN3@ConnectSho
$LN6@ConnectSho:

; 128  : 		return FALSE;

  00017	33 c0		 xor	 eax, eax

; 136  : 		return FALSE;
; 137  : 
; 138  : 	return TRUE;
; 139  : }

  00019	5d		 pop	 ebp
  0001a	c2 08 00	 ret	 8
$LN3@ConnectSho:

; 129  : 
; 130  : 	if ( !g_ShopServerClient.SetProtocolCore(ShopServerProtocolCore) )

  0001d	68 00 00 00 00	 push	 OFFSET ?ShopServerProtocolCore@@YAXKPAEH@Z ; ShopServerProtocolCore
  00022	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ShopServerClient@@3VwsShopServerCli@@A ; g_ShopServerClient
  00027	e8 00 00 00 00	 call	 ?SetProtocolCore@wsShopServerCli@@QAEHP6AXKPAEH@Z@Z ; wsShopServerCli::SetProtocolCore
  0002c	85 c0		 test	 eax, eax

; 131  : 		return FALSE;

  0002e	74 e7		 je	 SHORT $LN6@ConnectSho

; 132  : 
; 133  : 	CCashShop::m_lpOldProc = (WNDPROC)SetWindowLong(ghWnd, GWL_WNDPROC, (LONG)CCashShop::ParentWndProc);

  00030	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ghWnd@@3PAUHWND__@@A ; ghWnd
  00036	68 00 00 00 00	 push	 OFFSET ?ParentWndProc@CCashShop@@SAJPAUHWND__@@IIJ@Z ; CCashShop::ParentWndProc
  0003b	6a fc		 push	 -4			; fffffffcH
  0003d	51		 push	 ecx
  0003e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetWindowLongA@12

; 134  : 
; 135  : 	if ( !g_ShopServerClient.Connect(pchIpAddress, iPortNumber, 0x41E) )

  00044	8b 55 0c	 mov	 edx, DWORD PTR _iPortNumber$[ebp]
  00047	68 1e 04 00 00	 push	 1054			; 0000041eH
  0004c	a3 00 00 00 00	 mov	 DWORD PTR ?m_lpOldProc@CCashShop@@2P6GJPAUHWND__@@IIJ@ZA, eax ; CCashShop::m_lpOldProc
  00051	8b 45 08	 mov	 eax, DWORD PTR _pchIpAddress$[ebp]
  00054	52		 push	 edx
  00055	50		 push	 eax
  00056	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ShopServerClient@@3VwsShopServerCli@@A ; g_ShopServerClient
  0005b	e8 00 00 00 00	 call	 ?Connect@wsShopServerCli@@QAEHPADGK@Z ; wsShopServerCli::Connect
  00060	f7 d8		 neg	 eax
  00062	1b c0		 sbb	 eax, eax
  00064	f7 d8		 neg	 eax

; 136  : 		return FALSE;
; 137  : 
; 138  : 	return TRUE;
; 139  : }

  00066	5d		 pop	 ebp
  00067	c2 08 00	 ret	 8
?ConnectShopServer@CCashShop@@QAEHPADH@Z ENDP		; CCashShop::ConnectShopServer
_TEXT	ENDS
PUBLIC	?ReConnectShopServer@CCashShop@@QAEHXZ		; CCashShop::ReConnectShopServer
EXTRN	?GetConnect@MyWinsockBase@@QAEHXZ:PROC		; MyWinsockBase::GetConnect
; Function compile flags: /Ogtp
;	COMDAT ?ReConnectShopServer@CCashShop@@QAEHXZ
_TEXT	SEGMENT
?ReConnectShopServer@CCashShop@@QAEHXZ PROC		; CCashShop::ReConnectShopServer, COMDAT
; _this$ = ecx

; 143  : 	if ( g_ShopServerClient.GetConnect() == TRUE )

  00000	b9 04 00 00 00	 mov	 ecx, OFFSET ?g_ShopServerClient@@3VwsShopServerCli@@A+4
  00005	e8 00 00 00 00	 call	 ?GetConnect@MyWinsockBase@@QAEHXZ ; MyWinsockBase::GetConnect
  0000a	83 f8 01	 cmp	 eax, 1
  0000d	75 01		 jne	 SHORT $LN4@ReConnectS

; 155  : 		return FALSE;
; 156  : 
; 157  : 	return TRUE;
; 158  : }

  0000f	c3		 ret	 0
$LN4@ReConnectS:

; 144  : 		return TRUE;
; 145  : 
; 146  : 	g_ShopServerClient.Close();

  00010	b9 04 00 00 00	 mov	 ecx, OFFSET ?g_ShopServerClient@@3VwsShopServerCli@@A+4
  00015	e8 00 00 00 00	 call	 ?Close@MyWinsockBase@@QAEHXZ ; MyWinsockBase::Close

; 147  : 
; 148  : 	if ( g_ShopServerClient.CreateSocket(ghWnd) == FALSE )

  0001a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ghWnd@@3PAUHWND__@@A ; ghWnd
  0001f	50		 push	 eax
  00020	b9 04 00 00 00	 mov	 ecx, OFFSET ?g_ShopServerClient@@3VwsShopServerCli@@A+4
  00025	e8 00 00 00 00	 call	 ?CreateSocket@MyWinsockBase@@QAEHPAUHWND__@@@Z ; MyWinsockBase::CreateSocket
  0002a	85 c0		 test	 eax, eax
  0002c	75 03		 jne	 SHORT $LN3@ReConnectS
$LN7@ReConnectS:

; 149  : 		return FALSE;

  0002e	33 c0		 xor	 eax, eax

; 155  : 		return FALSE;
; 156  : 
; 157  : 	return TRUE;
; 158  : }

  00030	c3		 ret	 0
$LN3@ReConnectS:

; 150  : 
; 151  : 	if ( !g_ShopServerClient.SetProtocolCore(ShopServerProtocolCore) )

  00031	68 00 00 00 00	 push	 OFFSET ?ShopServerProtocolCore@@YAXKPAEH@Z ; ShopServerProtocolCore
  00036	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ShopServerClient@@3VwsShopServerCli@@A ; g_ShopServerClient
  0003b	e8 00 00 00 00	 call	 ?SetProtocolCore@wsShopServerCli@@QAEHP6AXKPAEH@Z@Z ; wsShopServerCli::SetProtocolCore
  00040	85 c0		 test	 eax, eax

; 152  : 		return FALSE;

  00042	74 ea		 je	 SHORT $LN7@ReConnectS

; 153  : 
; 154  : 	if ( !g_ShopServerClient.Connect(g_ShopServerIP, g_ShopserverPort, 0x41E) )

  00044	0f b7 0d 00 00
	00 00		 movzx	 ecx, WORD PTR ?g_ShopserverPort@@3HA
  0004b	68 1e 04 00 00	 push	 1054			; 0000041eH
  00050	51		 push	 ecx
  00051	68 00 00 00 00	 push	 OFFSET ?g_ShopServerIP@@3PADA ; g_ShopServerIP
  00056	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ShopServerClient@@3VwsShopServerCli@@A ; g_ShopServerClient
  0005b	e8 00 00 00 00	 call	 ?Connect@wsShopServerCli@@QAEHPADGK@Z ; wsShopServerCli::Connect
  00060	f7 d8		 neg	 eax
  00062	1b c0		 sbb	 eax, eax
  00064	f7 d8		 neg	 eax

; 155  : 		return FALSE;
; 156  : 
; 157  : 	return TRUE;
; 158  : }

  00066	c3		 ret	 0
?ReConnectShopServer@CCashShop@@QAEHXZ ENDP		; CCashShop::ReConnectShopServer
_TEXT	ENDS
PUBLIC	??_C@_0DH@PKGJKMBJ@?$FLCashShop?$FN?$FLShopServer?$FN?5?9?5Disconn@ ; `string'
PUBLIC	?CheckShopServerConnectState@CCashShop@@QAEXXZ	; CCashShop::CheckShopServerConnectState
EXTRN	__imp__GetTickCount@0:PROC
;	COMDAT ??_C@_0DH@PKGJKMBJ@?$FLCashShop?$FN?$FLShopServer?$FN?5?9?5Disconn@
CONST	SEGMENT
??_C@_0DH@PKGJKMBJ@?$FLCashShop?$FN?$FLShopServer?$FN?5?9?5Disconn@ DB '['
	DB	'CashShop][ShopServer] - Disconnect From Shop Server!!', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?CheckShopServerConnectState@CCashShop@@QAEXXZ
_TEXT	SEGMENT
?CheckShopServerConnectState@CCashShop@@QAEXXZ PROC	; CCashShop::CheckShopServerConnectState, COMDAT
; _this$ = ecx

; 192  : 	if ( g_bConnectShopServer == FALSE )

  00000	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_bConnectShopServer@@3HA, 0 ; g_bConnectShopServer
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	74 42		 je	 SHORT $LN1@CheckShopS

; 193  : 		return;
; 194  : 
; 195  : 	if ( (GetTickCount()-this->dwCheckShopServerConnectStatePeriod) > 10000 )

  0000c	57		 push	 edi
  0000d	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__GetTickCount@0
  00013	ff d7		 call	 edi
  00015	2b 46 24	 sub	 eax, DWORD PTR [esi+36]
  00018	3d 10 27 00 00	 cmp	 eax, 10000		; 00002710H
  0001d	76 2e		 jbe	 SHORT $LN7@CheckShopS

; 196  : 	{
; 197  : 		this->dwCheckShopServerConnectStatePeriod = GetTickCount();

  0001f	ff d7		 call	 edi
  00021	89 46 24	 mov	 DWORD PTR [esi+36], eax

; 198  : 
; 199  : 		if ( g_bShopServerConnectState == FALSE )

  00024	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_bShopServerConnectState@@3HA, 0 ; g_bShopServerConnectState
  0002b	75 20		 jne	 SHORT $LN7@CheckShopS

; 200  : 		{
; 201  : 			g_bShopServerConnectState = this->ReConnectShopServer();

  0002d	8b ce		 mov	 ecx, esi
  0002f	e8 00 00 00 00	 call	 ?ReConnectShopServer@CCashShop@@QAEHXZ ; CCashShop::ReConnectShopServer
  00034	a3 00 00 00 00	 mov	 DWORD PTR ?g_bShopServerConnectState@@3HA, eax ; g_bShopServerConnectState

; 202  : 
; 203  : 			if ( g_bShopServerConnectState == FALSE )

  00039	85 c0		 test	 eax, eax
  0003b	75 10		 jne	 SHORT $LN7@CheckShopS

; 204  : 			{
; 205  : 				LogAddC(2, "[CashShop][ShopServer] - Disconnect From Shop Server!!");

  0003d	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@PKGJKMBJ@?$FLCashShop?$FN?$FLShopServer?$FN?5?9?5Disconn@
  00042	6a 02		 push	 2
  00044	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddC@@3P6AXEPADZZA ; LogAddC
  0004a	83 c4 08	 add	 esp, 8
$LN7@CheckShopS:
  0004d	5f		 pop	 edi
$LN1@CheckShopS:
  0004e	5e		 pop	 esi

; 206  : 			}
; 207  : 		}
; 208  : 	}
; 209  : }

  0004f	c3		 ret	 0
?CheckShopServerConnectState@CCashShop@@QAEXXZ ENDP	; CCashShop::CheckShopServerConnectState
_TEXT	ENDS
PUBLIC	?AddUser@CCashShop@@QAEHPAUOBJECTSTRUCT@@@Z	; CCashShop::AddUser
; Function compile flags: /Ogtp
;	COMDAT ?AddUser@CCashShop@@QAEHPAUOBJECTSTRUCT@@@Z
_TEXT	SEGMENT
$T195580 = -8						; size = 8
$T195579 = -8						; size = 8
_lpObj$ = 8						; size = 4
?AddUser@CCashShop@@QAEHPAUOBJECTSTRUCT@@@Z PROC	; CCashShop::AddUser, COMDAT
; _this$ = ecx

; 212  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi

; 213  : 	if ( this->SearchUser(lpObj->DBNumber) )

  00007	8b 75 08	 mov	 esi, DWORD PTR _lpObj$[ebp]
  0000a	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  0000d	57		 push	 edi
  0000e	50		 push	 eax
  0000f	8b f9		 mov	 edi, ecx
  00011	e8 00 00 00 00	 call	 ?SearchUser@CCashShop@@QAEPAUOBJECTSTRUCT@@H@Z ; CCashShop::SearchUser
  00016	85 c0		 test	 eax, eax
  00018	74 0a		 je	 SHORT $LN1@AddUser

; 214  : 		return FALSE;

  0001a	5f		 pop	 edi
  0001b	33 c0		 xor	 eax, eax
  0001d	5e		 pop	 esi

; 227  : }

  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
$LN1@AddUser:

; 215  : 
; 216  : 	lpObj->m_wcCashPoint = 0;

  00024	33 c0		 xor	 eax, eax
  00026	53		 push	 ebx
  00027	89 86 68 24 00
	00		 mov	 DWORD PTR [esi+9320], eax

; 217  : 	lpObj->m_wpCashPoint = 0;

  0002d	89 86 6c 24 00
	00		 mov	 DWORD PTR [esi+9324], eax

; 218  : 	lpObj->m_wgCashPoint = 0;

  00033	89 86 70 24 00
	00		 mov	 DWORD PTR [esi+9328], eax

; 219  : 
; 220  : 	lpObj->GoblinPointTick = GetTickCount();

  00039	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  0003f	89 86 74 24 00
	00		 mov	 DWORD PTR [esi+9332], eax

; 221  : 
; 222  : 	MapUserObject.insert(std::pair<int, LPOBJ>(lpObj->DBNumber, lpObj));

  00045	8b 4e 30	 mov	 ecx, DWORD PTR [esi+48]
  00048	6a 00		 push	 0
  0004a	8d 55 f8	 lea	 edx, DWORD PTR $T195579[ebp]
  0004d	89 4d f8	 mov	 DWORD PTR $T195579[ebp], ecx
  00050	52		 push	 edx
  00051	8d 4f 14	 lea	 ecx, DWORD PTR [edi+20]
  00054	89 75 fc	 mov	 DWORD PTR $T195579[ebp+4], esi
  00057	e8 00 00 00 00	 call	 ??$_Buynode@U?$pair@HPAUOBJECTSTRUCT@@@std@@@?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@1@$$QAU?$pair@HPAUOBJECTSTRUCT@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::_Buynode<std::pair<int,OBJECTSTRUCT *> >
  0005c	50		 push	 eax
  0005d	8d 45 f8	 lea	 eax, DWORD PTR $T195580[ebp]
  00060	50		 push	 eax
  00061	8d 4f 14	 lea	 ecx, DWORD PTR [edi+20]
  00064	e8 00 00 00 00	 call	 ?_Linsert@?$_Tree@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@std@@_N@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@2@_N@Z ; std::_Tree<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::_Linsert

; 223  : 
; 224  : 	GCScriptVersionSend(lpObj->m_Index);

  00069	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0006b	51		 push	 ecx
  0006c	8b cf		 mov	 ecx, edi
  0006e	e8 00 00 00 00	 call	 ?GCScriptVersionSend@CCashShop@@QAEXH@Z ; CCashShop::GCScriptVersionSend

; 225  : 	GCBannerVersionSend(lpObj->m_Index);

  00073	8b 16		 mov	 edx, DWORD PTR [esi]
  00075	52		 push	 edx
  00076	8b cf		 mov	 ecx, edi
  00078	e8 00 00 00 00	 call	 ?GCBannerVersionSend@CCashShop@@QAEXH@Z ; CCashShop::GCBannerVersionSend
  0007d	5b		 pop	 ebx
  0007e	5f		 pop	 edi

; 226  : 	return TRUE;

  0007f	b8 01 00 00 00	 mov	 eax, 1
  00084	5e		 pop	 esi

; 227  : }

  00085	8b e5		 mov	 esp, ebp
  00087	5d		 pop	 ebp
  00088	c2 04 00	 ret	 4
?AddUser@CCashShop@@QAEHPAUOBJECTSTRUCT@@@Z ENDP	; CCashShop::AddUser
_TEXT	ENDS
PUBLIC	??1?$_Tree@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::~_Tree<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$??1?$_Tree@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Tree@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Tree@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Tree@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xtree
xdata$x	ENDS
;	COMDAT ??1?$_Tree@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T195722 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Tree@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::~_Tree<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >, COMDAT
; _this$ = ecx

; 790  : 		{	// destroy tree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$_Tree@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	56		 push	 esi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00026	8b f1		 mov	 esi, ecx
  00028	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi

; 791  : 		_Tidy();

  0002b	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0002e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00030	50		 push	 eax
  00031	51		 push	 ecx
  00032	8d 45 ec	 lea	 eax, DWORD PTR $T195722[ebp]
  00035	50		 push	 eax
  00036	8b ce		 mov	 ecx, esi
  00038	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0003f	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::erase

; 792  : 		}

  00044	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00047	51		 push	 ecx
  00048	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0004d	83 c4 04	 add	 esp, 4
  00050	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00053	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005a	59		 pop	 ecx
  0005b	5e		 pop	 esi
  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Tree@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::~_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >
__ehhandler$??1?$_Tree@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@QAE@XZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$_Tree@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@QAE@XZ
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$_Tree@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::~_Tree<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >
PUBLIC	??1?$map@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@@std@@QAE@XZ ; std::map<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> > >::~map<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> > >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$map@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$map@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@@std@@QAE@XZ$1
__ehfuncinfo$??1?$map@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$map@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
xdata$x	ENDS
;	COMDAT ??1?$map@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@@std@@QAE@XZ
_TEXT	SEGMENT
$T195905 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$map@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@@std@@QAE@XZ PROC ; std::map<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> > >::~map<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$map@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	56		 push	 esi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00026	8b f1		 mov	 esi, ecx
  00028	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  0002b	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0002e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00030	50		 push	 eax
  00031	51		 push	 ecx
  00032	8d 45 ec	 lea	 eax, DWORD PTR $T195905[ebp]
  00035	50		 push	 eax
  00036	8b ce		 mov	 ecx, esi
  00038	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0003f	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::erase
  00044	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00047	51		 push	 ecx
  00048	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0004d	83 c4 04	 add	 esp, 4
  00050	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00053	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005a	59		 pop	 ecx
  0005b	5e		 pop	 esi
  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$map@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@@std@@QAE@XZ$1:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::~_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >
__ehhandler$??1?$map@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@@std@@QAE@XZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$map@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@@std@@QAE@XZ
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$map@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@@std@@QAE@XZ ENDP ; std::map<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> > >::~map<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> > >
PUBLIC	??_7CCashShop@@6B@				; CCashShop::`vftable'
PUBLIC	??1CCashShop@@UAE@XZ				; CCashShop::~CCashShop
PUBLIC	??_R4CCashShop@@6B@				; CCashShop::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCCashShop@@@8				; CCashShop `RTTI Type Descriptor'
PUBLIC	??_R3CCashShop@@8				; CCashShop::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CCashShop@@8				; CCashShop::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CCashShop@@8			; CCashShop::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_ECCashShop@@UAEPAXI@Z:PROC			; CCashShop::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@CCashShop@@8
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\xmemory
rdata$r	SEGMENT
??_R1A@?0A@EA@CCashShop@@8 DD FLAT:??_R0?AVCCashShop@@@8 ; CCashShop::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CCashShop@@8
rdata$r	ENDS
;	COMDAT ??_R2CCashShop@@8
rdata$r	SEGMENT
??_R2CCashShop@@8 DD FLAT:??_R1A@?0A@EA@CCashShop@@8	; CCashShop::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CCashShop@@8
rdata$r	SEGMENT
??_R3CCashShop@@8 DD 00H				; CCashShop::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CCashShop@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCCashShop@@@8
_DATA	SEGMENT
??_R0?AVCCashShop@@@8 DD FLAT:??_7type_info@@6B@	; CCashShop `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCCashShop@@', 00H
_DATA	ENDS
;	COMDAT ??_R4CCashShop@@6B@
rdata$r	SEGMENT
??_R4CCashShop@@6B@ DD 00H				; CCashShop::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCCashShop@@@8
	DD	FLAT:??_R3CCashShop@@8
rdata$r	ENDS
;	COMDAT ??_7CCashShop@@6B@
CONST	SEGMENT
??_7CCashShop@@6B@ DD FLAT:??_R4CCashShop@@6B@		; CCashShop::`vftable'
	DD	FLAT:??_ECCashShop@@UAEPAXI@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1CCashShop@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1CCashShop@@UAE@XZ$2
__ehfuncinfo$??1CCashShop@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1CCashShop@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtp
; File c:\muserver_dev\development\mu-s8ep2-repack\gameserver\source\cashshop.cpp
xdata$x	ENDS
;	COMDAT ??1CCashShop@@UAE@XZ
_TEXT	SEGMENT
$T196124 = -20						; size = 4
$T196156 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CCashShop@@UAE@XZ PROC				; CCashShop::~CCashShop, COMDAT
; _this$ = ecx

; 56   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1CCashShop@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	56		 push	 esi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 57   : 
; 58   : }

  00026	8d 71 14	 lea	 esi, DWORD PTR [ecx+20]
  00029	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7CCashShop@@6B@
  0002f	89 75 f0	 mov	 DWORD PTR $T196156[ebp], esi
  00032	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00035	8b 08		 mov	 ecx, DWORD PTR [eax]
  00037	50		 push	 eax
  00038	51		 push	 ecx
  00039	8d 45 ec	 lea	 eax, DWORD PTR $T196124[ebp]
  0003c	50		 push	 eax
  0003d	8b ce		 mov	 ecx, esi
  0003f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00046	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::erase
  0004b	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0004e	51		 push	 ecx
  0004f	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00054	83 c4 04	 add	 esp, 4
  00057	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0005a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00061	59		 pop	 ecx
  00062	5e		 pop	 esi
  00063	8b e5		 mov	 esp, ebp
  00065	5d		 pop	 ebp
  00066	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1CCashShop@@UAE@XZ$2:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR $T196156[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Tree_val@V?$_Tmap_traits@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >::~_Tree_val<std::_Tmap_traits<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> >,0> >
__ehhandler$??1CCashShop@@UAE@XZ:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00012	33 c8		 xor	 ecx, eax
  00014	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00019	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1CCashShop@@UAE@XZ
  0001e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1CCashShop@@UAE@XZ ENDP				; CCashShop::~CCashShop
PUBLIC	??_C@_0CI@ONKBLOFD@?$FLCashShop?$FN?5Shop?5Server?5Connect?5F@ ; `string'
PUBLIC	??_C@_0O@DLCIENJL@BannerVersion?$AA@		; `string'
PUBLIC	??_C@_01LFCBOECM@?4?$AA@			; `string'
PUBLIC	??_C@_0O@DCHNKDBC@ScriptVersion?$AA@		; `string'
PUBLIC	??_C@_0N@OIDHJBNO@000?40000?4000?$AA@		; `string'
PUBLIC	??_C@_0BC@PCDBANNO@MapMoveBoundCheck?$AA@	; `string'
PUBLIC	??_C@_0P@LPGJINFM@ShopServerPort?$AA@		; `string'
PUBLIC	??_C@_0N@HPLMJINB@ShopServerIP?$AA@		; `string'
PUBLIC	??_C@_01GBGANLPD@0?$AA@				; `string'
PUBLIC	??_C@_0BC@IPLMCBFJ@ConnectShopServer?$AA@	; `string'
PUBLIC	??_C@_0P@IMBGJFFI@CashShopOption?$AA@		; `string'
PUBLIC	??_C@_0M@FPBAKIDA@UseCashShop?$AA@		; `string'
PUBLIC	??_C@_0DB@KNFHJJFO@?$FLCashShop?$FN?$FLShopOption?$FN?5?9?5Shop?5Op@ ; `string'
PUBLIC	__$ArrayPad$
PUBLIC	?LoadShopOption@CCashShop@@QAEXPAD@Z		; CCashShop::LoadShopOption
EXTRN	?MsgBox@@YAXPADZZ:PROC				; MsgBox
EXTRN	_atoi:PROC
EXTRN	_strtok:PROC
EXTRN	__imp__GetPrivateProfileStringA@24:PROC
EXTRN	__imp__GetPrivateProfileIntA@16:PROC
;	COMDAT ??_C@_0CI@ONKBLOFD@?$FLCashShop?$FN?5Shop?5Server?5Connect?5F@
CONST	SEGMENT
??_C@_0CI@ONKBLOFD@?$FLCashShop?$FN?5Shop?5Server?5Connect?5F@ DB '[CashS'
	DB	'hop] Shop Server Connect Failed!!', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@DLCIENJL@BannerVersion?$AA@
CONST	SEGMENT
??_C@_0O@DLCIENJL@BannerVersion?$AA@ DB 'BannerVersion', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01LFCBOECM@?4?$AA@
CONST	SEGMENT
??_C@_01LFCBOECM@?4?$AA@ DB '.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@DCHNKDBC@ScriptVersion?$AA@
CONST	SEGMENT
??_C@_0O@DCHNKDBC@ScriptVersion?$AA@ DB 'ScriptVersion', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@OIDHJBNO@000?40000?4000?$AA@
CONST	SEGMENT
??_C@_0N@OIDHJBNO@000?40000?4000?$AA@ DB '000.0000.000', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@PCDBANNO@MapMoveBoundCheck?$AA@
CONST	SEGMENT
??_C@_0BC@PCDBANNO@MapMoveBoundCheck?$AA@ DB 'MapMoveBoundCheck', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@LPGJINFM@ShopServerPort?$AA@
CONST	SEGMENT
??_C@_0P@LPGJINFM@ShopServerPort?$AA@ DB 'ShopServerPort', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@HPLMJINB@ShopServerIP?$AA@
CONST	SEGMENT
??_C@_0N@HPLMJINB@ShopServerIP?$AA@ DB 'ShopServerIP', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01GBGANLPD@0?$AA@
CONST	SEGMENT
??_C@_01GBGANLPD@0?$AA@ DB '0', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@IPLMCBFJ@ConnectShopServer?$AA@
CONST	SEGMENT
??_C@_0BC@IPLMCBFJ@ConnectShopServer?$AA@ DB 'ConnectShopServer', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@IMBGJFFI@CashShopOption?$AA@
CONST	SEGMENT
??_C@_0P@IMBGJFFI@CashShopOption?$AA@ DB 'CashShopOption', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@FPBAKIDA@UseCashShop?$AA@
CONST	SEGMENT
??_C@_0M@FPBAKIDA@UseCashShop?$AA@ DB 'UseCashShop', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@KNFHJJFO@?$FLCashShop?$FN?$FLShopOption?$FN?5?9?5Shop?5Op@
CONST	SEGMENT
??_C@_0DB@KNFHJJFO@?$FLCashShop?$FN?$FLShopOption?$FN?5?9?5Shop?5Op@ DB '['
	DB	'CashShop][ShopOption] - Shop Option Reload ''%s''', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?LoadShopOption@CCashShop@@QAEXPAD@Z
_TEXT	SEGMENT
_szTemp$ = -36						; size = 32
__$ArrayPad$ = -4					; size = 4
_pchFilename$ = 8					; size = 4
?LoadShopOption@CCashShop@@QAEXPAD@Z PROC		; CCashShop::LoadShopOption, COMDAT
; _this$ = ecx

; 67   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	56		 push	 esi
  00012	8b 75 08	 mov	 esi, DWORD PTR _pchFilename$[ebp]
  00015	57		 push	 edi

; 68   : 	LogAddTD("[CashShop][ShopOption] - Shop Option Reload '%s'", pchFilename);

  00016	56		 push	 esi
  00017	68 00 00 00 00	 push	 OFFSET ??_C@_0DB@KNFHJJFO@?$FLCashShop?$FN?$FLShopOption?$FN?5?9?5Shop?5Op@
  0001c	8b f9		 mov	 edi, ecx
  0001e	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD

; 69   : 
; 70   : 	g_bUseCashShop = GetPrivateProfileInt("CashShopOption", "UseCashShop", 0, pchFilename);

  00024	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__GetPrivateProfileIntA@16
  0002a	83 c4 08	 add	 esp, 8
  0002d	56		 push	 esi
  0002e	6a 00		 push	 0
  00030	68 00 00 00 00	 push	 OFFSET ??_C@_0M@FPBAKIDA@UseCashShop?$AA@
  00035	68 00 00 00 00	 push	 OFFSET ??_C@_0P@IMBGJFFI@CashShopOption?$AA@
  0003a	ff d3		 call	 ebx

; 71   : 	g_bConnectShopServer = GetPrivateProfileInt("CashShopOption", "ConnectShopServer", 0, pchFilename);

  0003c	56		 push	 esi
  0003d	6a 00		 push	 0
  0003f	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@IPLMCBFJ@ConnectShopServer?$AA@
  00044	68 00 00 00 00	 push	 OFFSET ??_C@_0P@IMBGJFFI@CashShopOption?$AA@
  00049	a3 00 00 00 00	 mov	 DWORD PTR ?g_bUseCashShop@@3HA, eax ; g_bUseCashShop
  0004e	ff d3		 call	 ebx

; 72   : 	GetPrivateProfileString("CashShopOption", "ShopServerIP", "0", g_ShopServerIP, 16, pchFilename);

  00050	56		 push	 esi
  00051	6a 10		 push	 16			; 00000010H
  00053	68 00 00 00 00	 push	 OFFSET ?g_ShopServerIP@@3PADA ; g_ShopServerIP
  00058	68 00 00 00 00	 push	 OFFSET ??_C@_01GBGANLPD@0?$AA@
  0005d	68 00 00 00 00	 push	 OFFSET ??_C@_0N@HPLMJINB@ShopServerIP?$AA@
  00062	68 00 00 00 00	 push	 OFFSET ??_C@_0P@IMBGJFFI@CashShopOption?$AA@
  00067	a3 00 00 00 00	 mov	 DWORD PTR ?g_bConnectShopServer@@3HA, eax ; g_bConnectShopServer
  0006c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetPrivateProfileStringA@24

; 73   : 	g_ShopserverPort = GetPrivateProfileInt("CashShopOption", "ShopServerPort", 0, pchFilename);

  00072	56		 push	 esi
  00073	6a 00		 push	 0
  00075	68 00 00 00 00	 push	 OFFSET ??_C@_0P@LPGJINFM@ShopServerPort?$AA@
  0007a	68 00 00 00 00	 push	 OFFSET ??_C@_0P@IMBGJFFI@CashShopOption?$AA@
  0007f	ff d3		 call	 ebx

; 74   : 	g_bUseMoveMapBound = GetPrivateProfileInt("CashShopOption", "MapMoveBoundCheck", 0, pchFilename);

  00081	56		 push	 esi
  00082	6a 00		 push	 0
  00084	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@PCDBANNO@MapMoveBoundCheck?$AA@
  00089	68 00 00 00 00	 push	 OFFSET ??_C@_0P@IMBGJFFI@CashShopOption?$AA@
  0008e	a3 00 00 00 00	 mov	 DWORD PTR ?g_ShopserverPort@@3HA, eax ; g_ShopserverPort
  00093	ff d3		 call	 ebx

; 75   : 
; 76   : 	char szTemp[32];
; 77   : 	char* cvstr;
; 78   : 	GetPrivateProfileString("CashShopOption","ScriptVersion","000.0000.000",szTemp,sizeof(szTemp),pchFilename);

  00095	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__GetPrivateProfileStringA@24
  0009b	56		 push	 esi
  0009c	6a 20		 push	 32			; 00000020H
  0009e	a3 00 00 00 00	 mov	 DWORD PTR ?g_bUseMoveMapBound@@3HA, eax ; g_bUseMoveMapBound
  000a3	8d 45 dc	 lea	 eax, DWORD PTR _szTemp$[ebp]
  000a6	50		 push	 eax
  000a7	68 00 00 00 00	 push	 OFFSET ??_C@_0N@OIDHJBNO@000?40000?4000?$AA@
  000ac	68 00 00 00 00	 push	 OFFSET ??_C@_0O@DCHNKDBC@ScriptVersion?$AA@
  000b1	68 00 00 00 00	 push	 OFFSET ??_C@_0P@IMBGJFFI@CashShopOption?$AA@
  000b6	ff d3		 call	 ebx

; 79   : 
; 80   : 	cvstr = strtok(szTemp, ".");

  000b8	8d 4d dc	 lea	 ecx, DWORD PTR _szTemp$[ebp]
  000bb	68 00 00 00 00	 push	 OFFSET ??_C@_01LFCBOECM@?4?$AA@
  000c0	51		 push	 ecx
  000c1	e8 00 00 00 00	 call	 _strtok

; 81   : 
; 82   : 	m_ScriptVer.Ver1 = atoi(cvstr);

  000c6	50		 push	 eax
  000c7	e8 00 00 00 00	 call	 _atoi

; 83   : 	cvstr = strtok(NULL, ".");

  000cc	68 00 00 00 00	 push	 OFFSET ??_C@_01LFCBOECM@?4?$AA@
  000d1	6a 00		 push	 0
  000d3	66 89 47 08	 mov	 WORD PTR [edi+8], ax
  000d7	e8 00 00 00 00	 call	 _strtok

; 84   : 	m_ScriptVer.Ver2 = atoi(cvstr);

  000dc	50		 push	 eax
  000dd	e8 00 00 00 00	 call	 _atoi

; 85   : 	cvstr = strtok(NULL, ".");

  000e2	68 00 00 00 00	 push	 OFFSET ??_C@_01LFCBOECM@?4?$AA@
  000e7	6a 00		 push	 0
  000e9	66 89 47 0a	 mov	 WORD PTR [edi+10], ax
  000ed	e8 00 00 00 00	 call	 _strtok

; 86   : 	m_ScriptVer.Ver3 = atoi(cvstr);

  000f2	50		 push	 eax
  000f3	e8 00 00 00 00	 call	 _atoi
  000f8	83 c4 24	 add	 esp, 36			; 00000024H

; 87   : 
; 88   : 	GetPrivateProfileString("CashShopOption","BannerVersion","000.0000.000",szTemp,sizeof(szTemp),pchFilename);

  000fb	56		 push	 esi
  000fc	6a 20		 push	 32			; 00000020H
  000fe	8d 55 dc	 lea	 edx, DWORD PTR _szTemp$[ebp]
  00101	52		 push	 edx
  00102	68 00 00 00 00	 push	 OFFSET ??_C@_0N@OIDHJBNO@000?40000?4000?$AA@
  00107	68 00 00 00 00	 push	 OFFSET ??_C@_0O@DLCIENJL@BannerVersion?$AA@
  0010c	68 00 00 00 00	 push	 OFFSET ??_C@_0P@IMBGJFFI@CashShopOption?$AA@
  00111	66 89 47 0c	 mov	 WORD PTR [edi+12], ax
  00115	ff d3		 call	 ebx

; 89   : 
; 90   : 	cvstr = strtok(szTemp, ".");

  00117	68 00 00 00 00	 push	 OFFSET ??_C@_01LFCBOECM@?4?$AA@
  0011c	8d 45 dc	 lea	 eax, DWORD PTR _szTemp$[ebp]
  0011f	50		 push	 eax
  00120	e8 00 00 00 00	 call	 _strtok

; 91   : 
; 92   : 	m_BannerVer.Ver1 = atoi(cvstr);

  00125	50		 push	 eax
  00126	e8 00 00 00 00	 call	 _atoi

; 93   : 	cvstr = strtok(NULL, ".");

  0012b	68 00 00 00 00	 push	 OFFSET ??_C@_01LFCBOECM@?4?$AA@
  00130	6a 00		 push	 0
  00132	66 89 47 0e	 mov	 WORD PTR [edi+14], ax
  00136	e8 00 00 00 00	 call	 _strtok

; 94   : 	m_BannerVer.Ver2 = atoi(cvstr);

  0013b	50		 push	 eax
  0013c	e8 00 00 00 00	 call	 _atoi

; 95   : 	cvstr = strtok(NULL, ".");

  00141	68 00 00 00 00	 push	 OFFSET ??_C@_01LFCBOECM@?4?$AA@
  00146	6a 00		 push	 0
  00148	66 89 47 10	 mov	 WORD PTR [edi+16], ax
  0014c	e8 00 00 00 00	 call	 _strtok

; 96   : 	m_BannerVer.Ver3 = atoi(cvstr);

  00151	50		 push	 eax
  00152	e8 00 00 00 00	 call	 _atoi
  00157	83 c4 24	 add	 esp, 36			; 00000024H

; 97   : 	
; 98   : 	this->Initialize();

  0015a	8b cf		 mov	 ecx, edi
  0015c	66 89 47 12	 mov	 WORD PTR [edi+18], ax
  00160	e8 00 00 00 00	 call	 ?Initialize@CCashShop@@QAEXXZ ; CCashShop::Initialize

; 99   : 
; 100  : 	if ( g_bConnectShopServer == TRUE && g_bShopServerConnectState == FALSE)

  00165	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR ?g_bConnectShopServer@@3HA, 1 ; g_bConnectShopServer
  0016c	75 32		 jne	 SHORT $LN1@LoadShopOp
  0016e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_bShopServerConnectState@@3HA, 0 ; g_bShopServerConnectState
  00175	75 29		 jne	 SHORT $LN1@LoadShopOp

; 101  : 	{
; 102  : 		g_bShopServerConnectState = this->ConnectShopServer(g_ShopServerIP, g_ShopserverPort);

  00177	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?g_ShopserverPort@@3HA ; g_ShopserverPort
  0017d	51		 push	 ecx
  0017e	68 00 00 00 00	 push	 OFFSET ?g_ShopServerIP@@3PADA ; g_ShopServerIP
  00183	8b cf		 mov	 ecx, edi
  00185	e8 00 00 00 00	 call	 ?ConnectShopServer@CCashShop@@QAEHPADH@Z ; CCashShop::ConnectShopServer
  0018a	a3 00 00 00 00	 mov	 DWORD PTR ?g_bShopServerConnectState@@3HA, eax ; g_bShopServerConnectState

; 103  : 
; 104  : 		if ( g_bShopServerConnectState == FALSE )

  0018f	85 c0		 test	 eax, eax
  00191	75 0d		 jne	 SHORT $LN1@LoadShopOp

; 105  : 		{
; 106  : 			MsgBox("[CashShop] Shop Server Connect Failed!!");

  00193	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@ONKBLOFD@?$FLCashShop?$FN?5Shop?5Server?5Connect?5F@
  00198	e8 00 00 00 00	 call	 ?MsgBox@@YAXPADZZ	; MsgBox
  0019d	83 c4 04	 add	 esp, 4
$LN1@LoadShopOp:

; 107  : 		}
; 108  : 	}
; 109  : }

  001a0	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001a3	5f		 pop	 edi
  001a4	5e		 pop	 esi
  001a5	33 cd		 xor	 ecx, ebp
  001a7	5b		 pop	 ebx
  001a8	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001ad	8b e5		 mov	 esp, ebp
  001af	5d		 pop	 ebp
  001b0	c2 04 00	 ret	 4
?LoadShopOption@CCashShop@@QAEXPAD@Z ENDP		; CCashShop::LoadShopOption
_TEXT	ENDS
PUBLIC	??_C@_0DF@FDNPPIPB@?$FLCashShop?$FN?$FLOptionLoad?$FN?5?9?5CashSho@ ; `string'
PUBLIC	??_C@_0BM@CKIGLLG@CashShop?2CashShopOption?4dat?$AA@ ; `string'
PUBLIC	??_C@_0DE@PEKLKBCP@?$FLCashShop?$FN?$FLOptionLoad?$FN?5?9?5CashSho@ ; `string'
PUBLIC	?CashShopOptioNReload@CCashShop@@QAEXXZ		; CCashShop::CashShopOptioNReload
EXTRN	?GetNewPath@CDirPath@@QAEPADPAD@Z:PROC		; CDirPath::GetNewPath
EXTRN	?gDirPath@@3VCDirPath@@A:BYTE			; gDirPath
;	COMDAT ??_C@_0DF@FDNPPIPB@?$FLCashShop?$FN?$FLOptionLoad?$FN?5?9?5CashSho@
CONST	SEGMENT
??_C@_0DF@FDNPPIPB@?$FLCashShop?$FN?$FLOptionLoad?$FN?5?9?5CashSho@ DB '['
	DB	'CashShop][OptionLoad] - CashShop Option Load finish', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@CKIGLLG@CashShop?2CashShopOption?4dat?$AA@
CONST	SEGMENT
??_C@_0BM@CKIGLLG@CashShop?2CashShopOption?4dat?$AA@ DB 'CashShop\CashSho'
	DB	'pOption.dat', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@PEKLKBCP@?$FLCashShop?$FN?$FLOptionLoad?$FN?5?9?5CashSho@
CONST	SEGMENT
??_C@_0DE@PEKLKBCP@?$FLCashShop?$FN?$FLOptionLoad?$FN?5?9?5CashSho@ DB '['
	DB	'CashShop][OptionLoad] - CashShop Option Load Begin', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?CashShopOptioNReload@CCashShop@@QAEXXZ
_TEXT	SEGMENT
?CashShopOptioNReload@CCashShop@@QAEXXZ PROC		; CCashShop::CashShopOptioNReload, COMDAT
; _this$ = ecx

; 113  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 114  : 	bCashItemListReload = TRUE;
; 115  : 	LogAddTD("[CashShop][OptionLoad] - CashShop Option Load Begin");

  00003	68 00 00 00 00	 push	 OFFSET ??_C@_0DE@PEKLKBCP@?$FLCashShop?$FN?$FLOptionLoad?$FN?5?9?5CashSho@
  00008	c7 46 04 01 00
	00 00		 mov	 DWORD PTR [esi+4], 1
  0000f	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00015	83 c4 04	 add	 esp, 4

; 116  : 
; 117  : 	this->LoadShopOption(gDirPath.GetNewPath(FILE_CASHSHOP_OPTION));

  00018	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@CKIGLLG@CashShop?2CashShopOption?4dat?$AA@
  0001d	b9 00 00 00 00	 mov	 ecx, OFFSET ?gDirPath@@3VCDirPath@@A ; gDirPath
  00022	e8 00 00 00 00	 call	 ?GetNewPath@CDirPath@@QAEPADPAD@Z ; CDirPath::GetNewPath
  00027	50		 push	 eax
  00028	8b ce		 mov	 ecx, esi
  0002a	e8 00 00 00 00	 call	 ?LoadShopOption@CCashShop@@QAEXPAD@Z ; CCashShop::LoadShopOption

; 118  : 	this->ReConnectShopServer();

  0002f	8b ce		 mov	 ecx, esi
  00031	e8 00 00 00 00	 call	 ?ReConnectShopServer@CCashShop@@QAEHXZ ; CCashShop::ReConnectShopServer

; 119  : 
; 120  : 	LogAddTD("[CashShop][OptionLoad] - CashShop Option Load finish");

  00036	68 00 00 00 00	 push	 OFFSET ??_C@_0DF@FDNPPIPB@?$FLCashShop?$FN?$FLOptionLoad?$FN?5?9?5CashSho@
  0003b	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAddTD@@3P6AXPADZZA ; LogAddTD
  00041	83 c4 04	 add	 esp, 4

; 121  : 
; 122  : 	bCashItemListReload = FALSE;

  00044	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0004b	5e		 pop	 esi

; 123  : }

  0004c	c3		 ret	 0
?CashShopOptioNReload@CCashShop@@QAEXXZ ENDP		; CCashShop::CashShopOptioNReload
_TEXT	ENDS
PUBLIC	??0?$map@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@@std@@QAE@XZ ; std::map<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> > >::map<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\map
;	COMDAT ??0?$map@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@@std@@QAE@XZ
_TEXT	SEGMENT
$T196324 = -16						; size = 12
$T196217 = -4						; size = 4
??0?$map@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@@std@@QAE@XZ PROC ; std::map<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> > >::map<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> > >, COMDAT
; _this$ = ecx

; 106  : 		{	// construct empty map from defaults

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	6a 18		 push	 24			; 00000018H
  0000b	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00012	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00017	83 c4 04	 add	 esp, 4
  0001a	85 c0		 test	 eax, eax
  0001c	74 26		 je	 SHORT $LN25@map
  0001e	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00021	89 00		 mov	 DWORD PTR [eax], eax
  00023	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00026	89 40 04	 mov	 DWORD PTR [eax+4], eax
  00029	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0002c	89 40 08	 mov	 DWORD PTR [eax+8], eax
  0002f	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00032	b0 01		 mov	 al, 1
  00034	88 41 14	 mov	 BYTE PTR [ecx+20], al
  00037	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0003a	88 42 15	 mov	 BYTE PTR [edx+21], al

; 107  : 		}

  0003d	8b c6		 mov	 eax, esi
  0003f	5e		 pop	 esi
  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c3		 ret	 0

; 106  : 		{	// construct empty map from defaults

$LN25@map:
  00044	8d 45 fc	 lea	 eax, DWORD PTR $T196217[ebp]
  00047	50		 push	 eax
  00048	8d 4d f0	 lea	 ecx, DWORD PTR $T196324[ebp]
  0004b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T196217[ebp], 0
  00052	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  00057	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  0005c	8d 4d f0	 lea	 ecx, DWORD PTR $T196324[ebp]
  0005f	51		 push	 ecx
  00060	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T196324[ebp], OFFSET ??_7bad_alloc@std@@6B@
  00067	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN49@map:
$LN48@map:
  0006c	cc		 int	 3
??0?$map@HPAUOBJECTSTRUCT@@U?$less@H@std@@V?$allocator@U?$pair@$$CBHPAUOBJECTSTRUCT@@@std@@@3@@std@@QAE@XZ ENDP ; std::map<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> > >::map<int,OBJECTSTRUCT *,std::less<int>,std::allocator<std::pair<int const ,OBJECTSTRUCT *> > >
_TEXT	ENDS
PUBLIC	??0CCashShop@@QAE@XZ				; CCashShop::CCashShop
; Function compile flags: /Ogtp
; File c:\muserver_dev\development\mu-s8ep2-repack\gameserver\source\cashshop.cpp
;	COMDAT ??0CCashShop@@QAE@XZ
_TEXT	SEGMENT
$T196545 = -16						; size = 12
$T196390 = -4						; size = 4
??0CCashShop@@QAE@XZ PROC				; CCashShop::CCashShop, COMDAT
; _this$ = ecx

; 51   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7CCashShop@@6B@
  0000f	6a 18		 push	 24			; 00000018H
  00011	c7 46 1c 00 00
	00 00		 mov	 DWORD PTR [esi+28], 0
  00018	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0001d	83 c4 04	 add	 esp, 4
  00020	85 c0		 test	 eax, eax
  00022	74 26		 je	 SHORT $LN28@CCashShop
  00024	89 46 18	 mov	 DWORD PTR [esi+24], eax
  00027	89 00		 mov	 DWORD PTR [eax], eax
  00029	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  0002c	89 40 04	 mov	 DWORD PTR [eax+4], eax
  0002f	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  00032	89 40 08	 mov	 DWORD PTR [eax+8], eax
  00035	8b 4e 18	 mov	 ecx, DWORD PTR [esi+24]
  00038	b0 01		 mov	 al, 1
  0003a	88 41 14	 mov	 BYTE PTR [ecx+20], al
  0003d	8b 56 18	 mov	 edx, DWORD PTR [esi+24]
  00040	88 42 15	 mov	 BYTE PTR [edx+21], al

; 52   : 
; 53   : }

  00043	8b c6		 mov	 eax, esi
  00045	5e		 pop	 esi
  00046	8b e5		 mov	 esp, ebp
  00048	5d		 pop	 ebp
  00049	c3		 ret	 0

; 51   : {

$LN28@CCashShop:
  0004a	8d 45 fc	 lea	 eax, DWORD PTR $T196390[ebp]
  0004d	50		 push	 eax
  0004e	8d 4d f0	 lea	 ecx, DWORD PTR $T196545[ebp]
  00051	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T196390[ebp], 0
  00058	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception
  0005d	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_alloc@std@@
  00062	8d 4d f0	 lea	 ecx, DWORD PTR $T196545[ebp]
  00065	51		 push	 ecx
  00066	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T196545[ebp], OFFSET ??_7bad_alloc@std@@6B@
  0006d	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN53@CCashShop:
$LN52@CCashShop:
  00072	cc		 int	 3
??0CCashShop@@QAE@XZ ENDP				; CCashShop::CCashShop
; Function compile flags: /Ogtp
_TEXT	ENDS
;	COMDAT ??_GCCashShop@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCCashShop@@UAEPAXI@Z PROC				; CCashShop::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1CCashShop@@UAE@XZ	; CCashShop::~CCashShop
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 09		 je	 SHORT $LN4@scalar@2
  00011	56		 push	 esi
  00012	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00017	83 c4 04	 add	 esp, 4
$LN4@scalar@2:
  0001a	8b c6		 mov	 eax, esi
  0001c	5e		 pop	 esi
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
??_GCCashShop@@UAEPAXI@Z ENDP				; CCashShop::`scalar deleting destructor'
_TEXT	ENDS
EXTRN	_atexit:PROC
; Function compile flags: /Ogtp
;	COMDAT ??__Eg_CashShop@@YAXXZ
text$yc	SEGMENT
??__Eg_CashShop@@YAXXZ PROC				; `dynamic initializer for 'g_CashShop'', COMDAT

; 22   : CCashShop g_CashShop;

  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CashShop@@3VCCashShop@@A ; g_CashShop
  00005	e8 00 00 00 00	 call	 ??0CCashShop@@QAE@XZ	; CCashShop::CCashShop
  0000a	68 00 00 00 00	 push	 OFFSET ??__Fg_CashShop@@YAXXZ ; `dynamic atexit destructor for 'g_CashShop''
  0000f	e8 00 00 00 00	 call	 _atexit
  00014	59		 pop	 ecx
  00015	c3		 ret	 0
??__Eg_CashShop@@YAXXZ ENDP				; `dynamic initializer for 'g_CashShop''
text$yc	ENDS
EXTRN	??0wsShopServerCli@@QAE@XZ:PROC			; wsShopServerCli::wsShopServerCli
; Function compile flags: /Ogtp
;	COMDAT ??__Eg_ShopServerClient@@YAXXZ
text$yc	SEGMENT
??__Eg_ShopServerClient@@YAXXZ PROC			; `dynamic initializer for 'g_ShopServerClient'', COMDAT

; 23   : wsShopServerCli g_ShopServerClient;

  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ShopServerClient@@3VwsShopServerCli@@A ; g_ShopServerClient
  00005	e8 00 00 00 00	 call	 ??0wsShopServerCli@@QAE@XZ ; wsShopServerCli::wsShopServerCli
  0000a	68 00 00 00 00	 push	 OFFSET ??__Fg_ShopServerClient@@YAXXZ ; `dynamic atexit destructor for 'g_ShopServerClient''
  0000f	e8 00 00 00 00	 call	 _atexit
  00014	59		 pop	 ecx
  00015	c3		 ret	 0
??__Eg_ShopServerClient@@YAXXZ ENDP			; `dynamic initializer for 'g_ShopServerClient''
text$yc	ENDS
EXTRN	??1wsShopServerCli@@UAE@XZ:PROC			; wsShopServerCli::~wsShopServerCli
; Function compile flags: /Ogtp
;	COMDAT ??__Fg_ShopServerClient@@YAXXZ
text$yd	SEGMENT
??__Fg_ShopServerClient@@YAXXZ PROC			; `dynamic atexit destructor for 'g_ShopServerClient'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_ShopServerClient@@3VwsShopServerCli@@A ; g_ShopServerClient
  00005	e9 00 00 00 00	 jmp	 ??1wsShopServerCli@@UAE@XZ ; wsShopServerCli::~wsShopServerCli
??__Fg_ShopServerClient@@YAXXZ ENDP			; `dynamic atexit destructor for 'g_ShopServerClient''
; Function compile flags: /Ogtp
text$yd	ENDS
;	COMDAT ??__Fg_CashShop@@YAXXZ
text$yd	SEGMENT
??__Fg_CashShop@@YAXXZ PROC				; `dynamic atexit destructor for 'g_CashShop'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_CashShop@@3VCCashShop@@A ; g_CashShop
  00005	e9 00 00 00 00	 jmp	 ??1CCashShop@@UAE@XZ	; CCashShop::~CCashShop
??__Fg_CashShop@@YAXXZ ENDP				; `dynamic atexit destructor for 'g_CashShop''
text$yd	ENDS
PUBLIC	?g_ShopServerClient@@3VwsShopServerCli@@A	; g_ShopServerClient
PUBLIC	?g_CashShop@@3VCCashShop@@A			; g_CashShop
_BSS	SEGMENT
?g_ShopServerClient@@3VwsShopServerCli@@A DB 0190028H DUP (?) ; g_ShopServerClient
?g_CashShop@@3VCCashShop@@A DB 028H DUP (?)		; g_CashShop
_BSS	ENDS
CRT$XCU	SEGMENT
_g_CashShop$initializer$ DD FLAT:??__Eg_CashShop@@YAXXZ
_g_ShopServerClient$initializer$ DD FLAT:??__Eg_ShopServerClient@@YAXXZ
CRT$XCU	ENDS
END
