; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	C:\muserver_dev\development\MU-S8EP2-Repack\GameServer\Source\LuaFun.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

; Function compile flags: /Ogtp
; File c:\muserver_dev\development\mu-s8ep2-repack\gameserver\source\luafun.cpp
;	COMDAT ?Debug_Print@@YAHPAUlua_State@@@Z
_TEXT	SEGMENT
_L$ = 8							; size = 4
?Debug_Print@@YAHPAUlua_State@@@Z PROC			; Debug_Print, COMDAT

; 13   : #ifdef _DEBUG
; 14   : 	// here must be some code
; 15   : 	// no code in executable, since it was build without _DEBUG
; 16   : #endif
; 17   : 
; 18   : 	return 0;

  00000	33 c0		 xor	 eax, eax

; 19   : }

  00002	c3		 ret	 0
?Debug_Print@@YAHPAUlua_State@@@Z ENDP			; Debug_Print
_TEXT	ENDS
PUBLIC	??_C@_0L@NNLLPGPO@DebugPrint?$AA@		; `string'
PUBLIC	?Debug_AddDebugPrintTemp@@YAXPAUlua_State@@@Z	; Debug_AddDebugPrintTemp
EXTRN	_lua_setfield:PROC
EXTRN	_lua_pushcclosure:PROC
;	COMDAT ??_C@_0L@NNLLPGPO@DebugPrint?$AA@
CONST	SEGMENT
??_C@_0L@NNLLPGPO@DebugPrint?$AA@ DB 'DebugPrint', 00H	; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?Debug_AddDebugPrintTemp@@YAXPAUlua_State@@@Z
_TEXT	SEGMENT
_DebugGlue$ = -16					; size = 16
_L$ = 8							; size = 4
?Debug_AddDebugPrintTemp@@YAXPAUlua_State@@@Z PROC	; Debug_AddDebugPrintTemp, COMDAT

; 22   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	53		 push	 ebx

; 23   : 	luaL_reg DebugGlue[] =
; 24   : 	{
; 25   : 		{"DebugPrint", Debug_Print},
; 26   : 		{NULL, NULL}
; 27   : 	};
; 28   : 
; 29   : 
; 30   : 	for (int i = 0; DebugGlue[i].name; ++i )

  00007	8b 5d 08	 mov	 ebx, DWORD PTR _L$[ebp]
  0000a	56		 push	 esi
  0000b	33 c0		 xor	 eax, eax
  0000d	be 00 00 00 00	 mov	 esi, OFFSET ??_C@_0L@NNLLPGPO@DebugPrint?$AA@
  00012	57		 push	 edi
  00013	89 75 f0	 mov	 DWORD PTR _DebugGlue$[ebp], esi
  00016	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _DebugGlue$[ebp+4], OFFSET ?Debug_Print@@YAHPAUlua_State@@@Z ; Debug_Print
  0001d	89 45 f8	 mov	 DWORD PTR _DebugGlue$[ebp+8], eax
  00020	89 45 fc	 mov	 DWORD PTR _DebugGlue$[ebp+12], eax
  00023	33 ff		 xor	 edi, edi
$LL8@Debug_AddD:

; 31   : 	{
; 32   : 		lua_pushcclosure(L, DebugGlue[i].func, 0);

  00025	8b 44 05 f4	 mov	 eax, DWORD PTR _DebugGlue$[ebp+eax+4]
  00029	6a 00		 push	 0
  0002b	50		 push	 eax
  0002c	53		 push	 ebx
  0002d	e8 00 00 00 00	 call	 _lua_pushcclosure

; 33   : 		lua_setfield(L, LUA_GLOBALSINDEX, DebugGlue[i].name);

  00032	56		 push	 esi
  00033	68 ee d8 ff ff	 push	 -10002			; ffffd8eeH
  00038	53		 push	 ebx
  00039	e8 00 00 00 00	 call	 _lua_setfield
  0003e	47		 inc	 edi
  0003f	8d 04 fd 00 00
	00 00		 lea	 eax, DWORD PTR [edi*8]
  00046	8b 74 05 f0	 mov	 esi, DWORD PTR _DebugGlue$[ebp+eax]
  0004a	83 c4 18	 add	 esp, 24			; 00000018H
  0004d	85 f6		 test	 esi, esi
  0004f	75 d4		 jne	 SHORT $LL8@Debug_AddD
  00051	5f		 pop	 edi
  00052	5e		 pop	 esi
  00053	5b		 pop	 ebx

; 34   : 	}
; 35   : }

  00054	8b e5		 mov	 esp, ebp
  00056	5d		 pop	 ebp
  00057	c3		 ret	 0
?Debug_AddDebugPrintTemp@@YAXPAUlua_State@@@Z ENDP	; Debug_AddDebugPrintTemp
_TEXT	ENDS
PUBLIC	??_C@_0DA@PIFINKPE@luacall_Generic_Call?5wrong?5resul@ ; `string'
PUBLIC	??_C@_0CJ@EGCCEPHO@luacall_Generic_Call?5invalid?5opt@ ; `string'
PUBLIC	??_C@_0DF@HDBMEAKM@luacall_Generic_Call?5error?5runni@ ; `string'
PUBLIC	??_C@_0BD@IOJAAODF@too?5many?5arguments?$AA@	; `string'
PUBLIC	?g_Generic_Call@@YA_NPAUlua_State@@PBD1ZZ	; g_Generic_Call
EXTRN	_lua_settop:PROC
EXTRN	_lua_tonumber:PROC
EXTRN	_lua_isnumber:PROC
EXTRN	_lua_isstring:PROC
EXTRN	?LogAdd@@3P6AXPADZZA:DWORD			; LogAdd
EXTRN	_lua_tolstring:PROC
EXTRN	_lua_pcall:PROC
EXTRN	_luaL_checkstack:PROC
EXTRN	_lua_pushlstring:PROC
EXTRN	_lua_pushnumber:PROC
EXTRN	_lua_getfield:PROC
EXTRN	__fltused:DWORD
EXTRN	__ftol2_sse:PROC
;	COMDAT ??_C@_0DA@PIFINKPE@luacall_Generic_Call?5wrong?5resul@
CONST	SEGMENT
??_C@_0DA@PIFINKPE@luacall_Generic_Call?5wrong?5resul@ DB 'luacall_Generi'
	DB	'c_Call wrong result type [%c][%d]', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@EGCCEPHO@luacall_Generic_Call?5invalid?5opt@
CONST	SEGMENT
??_C@_0CJ@EGCCEPHO@luacall_Generic_Call?5invalid?5opt@ DB 'luacall_Generi'
	DB	'c_Call invalid option (%c)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@HDBMEAKM@luacall_Generic_Call?5error?5runni@
CONST	SEGMENT
??_C@_0DF@HDBMEAKM@luacall_Generic_Call?5error?5runni@ DB 'luacall_Generi'
	DB	'c_Call error running function `%s'': %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@IOJAAODF@too?5many?5arguments?$AA@
CONST	SEGMENT
??_C@_0BD@IOJAAODF@too?5many?5arguments?$AA@ DB 'too many arguments', 00H ; `string'
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?g_Generic_Call@@YA_NPAUlua_State@@PBD1ZZ
_TEXT	SEGMENT
tv361 = -8						; size = 4
_nRetValCnt$ = -8					; size = 4
_narg$ = -4						; size = 4
_L$ = 8							; size = 4
_func$ = 12						; size = 4
_sig$ = 16						; size = 4
?g_Generic_Call@@YA_NPAUlua_State@@PBD1ZZ PROC		; g_Generic_Call, COMDAT

; 39   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 40   : 	va_list vl;
; 41   : 	int narg, nres;  /* number of arguments and results */
; 42   :     
; 43   : 	va_start(vl, sig);
; 44   : 	// lua_setfield(L, LUA_GLOBALSINDEX, func); -- webzen error ? ... 
; 45   : 	lua_getglobal(L,func);

  00006	8b 45 0c	 mov	 eax, DWORD PTR _func$[ebp]
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	8b 75 08	 mov	 esi, DWORD PTR _L$[ebp]
  0000e	57		 push	 edi
  0000f	50		 push	 eax
  00010	68 ee d8 ff ff	 push	 -10002			; ffffd8eeH
  00015	56		 push	 esi
  00016	8d 5d 14	 lea	 ebx, DWORD PTR _sig$[ebp+4]
  00019	e8 00 00 00 00	 call	 _lua_getfield

; 46   :     
; 47   : 	/* push arguments */
; 48   : 	narg = 0;
; 49   : 	while (*sig) 

  0001e	8b 4d 10	 mov	 ecx, DWORD PTR _sig$[ebp]
  00021	8a 01		 mov	 al, BYTE PTR [ecx]
  00023	83 c4 0c	 add	 esp, 12			; 0000000cH
  00026	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _narg$[ebp], 0
  0002d	84 c0		 test	 al, al
  0002f	0f 84 9f 00 00
	00		 je	 $endwhile$155153
$LL24@g_Generic_:

; 50   : 	{  
; 51   : 		/* push arguments */
; 52   : 		switch (*sig++) 

  00035	ff 45 10	 inc	 DWORD PTR _sig$[ebp]
  00038	0f be c0	 movsx	 eax, al
  0003b	83 e8 3e	 sub	 eax, 62			; 0000003eH
  0003e	83 f8 39	 cmp	 eax, 57			; 00000039H
  00041	0f 87 dc 00 00
	00		 ja	 $LN14@g_Generic_
  00047	0f b6 90 00 00
	00 00		 movzx	 edx, BYTE PTR $LN35@g_Generic_[eax]
  0004e	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN41@g_Generic_[edx*4]
$LN20@g_Generic_:

; 53   : 		{
; 54   : 			case 'w':  /* word argument */
; 55   : 				lua_pushnumber(L, va_arg(vl, short));

  00055	0f bf 03	 movsx	 eax, WORD PTR [ebx]
  00058	83 c3 04	 add	 ebx, 4
  0005b	89 45 f8	 mov	 DWORD PTR tv361[ebp], eax
  0005e	83 ec 08	 sub	 esp, 8
  00061	db 45 f8	 fild	 DWORD PTR tv361[ebp]
  00064	dd 1c 24	 fstp	 QWORD PTR [esp]
  00067	56		 push	 esi
  00068	e8 00 00 00 00	 call	 _lua_pushnumber

; 56   : 			break;

  0006d	eb 42		 jmp	 SHORT $LN39@g_Generic_
$LN19@g_Generic_:

; 57   : 
; 58   : 			case 'd':  /* double argument */
; 59   : 				lua_pushnumber(L, va_arg(vl, double));

  0006f	dd 03		 fld	 QWORD PTR [ebx]
  00071	83 c3 08	 add	 ebx, 8
  00074	83 ec 08	 sub	 esp, 8
  00077	dd 1c 24	 fstp	 QWORD PTR [esp]
  0007a	56		 push	 esi
  0007b	e8 00 00 00 00	 call	 _lua_pushnumber

; 60   :             break;

  00080	eb 2f		 jmp	 SHORT $LN39@g_Generic_
$LN18@g_Generic_:

; 61   :     
; 62   : 			case 'i':  /* int argument */
; 63   : 				lua_pushnumber(L, va_arg(vl, int));

  00082	db 03		 fild	 DWORD PTR [ebx]
  00084	83 c3 04	 add	 ebx, 4
  00087	83 ec 08	 sub	 esp, 8
  0008a	dd 1c 24	 fstp	 QWORD PTR [esp]
  0008d	56		 push	 esi
  0008e	e8 00 00 00 00	 call	 _lua_pushnumber

; 64   :             break;

  00093	eb 1c		 jmp	 SHORT $LN39@g_Generic_
$LN17@g_Generic_:

; 65   :     
; 66   : 			case 's':  /* string argument */
; 67   : 			{
; 68   : 				char* pszString = va_arg(vl, char *);

  00095	8b 13		 mov	 edx, DWORD PTR [ebx]
  00097	83 c3 04	 add	 ebx, 4

; 69   : 				lua_pushlstring(L, pszString, strlen(pszString));

  0009a	8b c2		 mov	 eax, edx
  0009c	8d 78 01	 lea	 edi, DWORD PTR [eax+1]
  0009f	90		 npad	 1
$LL36@g_Generic_:
  000a0	8a 08		 mov	 cl, BYTE PTR [eax]
  000a2	40		 inc	 eax
  000a3	84 c9		 test	 cl, cl
  000a5	75 f9		 jne	 SHORT $LL36@g_Generic_
  000a7	2b c7		 sub	 eax, edi
  000a9	50		 push	 eax
  000aa	52		 push	 edx
  000ab	56		 push	 esi
  000ac	e8 00 00 00 00	 call	 _lua_pushlstring
$LN39@g_Generic_:

; 79   :         }
; 80   :         narg++;

  000b1	ff 45 fc	 inc	 DWORD PTR _narg$[ebp]
  000b4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 81   :         luaL_checkstack(L, 1, "too many arguments");

  000b7	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@IOJAAODF@too?5many?5arguments?$AA@
  000bc	6a 01		 push	 1
  000be	56		 push	 esi
  000bf	e8 00 00 00 00	 call	 _luaL_checkstack
  000c4	8b 4d 10	 mov	 ecx, DWORD PTR _sig$[ebp]
  000c7	8a 01		 mov	 al, BYTE PTR [ecx]
  000c9	83 c4 0c	 add	 esp, 12			; 0000000cH
  000cc	84 c0		 test	 al, al
  000ce	0f 85 61 ff ff
	ff		 jne	 $LL24@g_Generic_
$endwhile$155153:

; 82   : 	} 
; 83   : endwhile:
; 84   :     
; 85   : 	/* do the call */
; 86   : 	nres = strlen(sig);  /* number of expected results */

  000d4	8b 7d 10	 mov	 edi, DWORD PTR _sig$[ebp]
  000d7	8d 4f 01	 lea	 ecx, DWORD PTR [edi+1]
  000da	8d 9b 00 00 00
	00		 npad	 6
$LL37@g_Generic_:
  000e0	8a 07		 mov	 al, BYTE PTR [edi]
  000e2	47		 inc	 edi
  000e3	84 c0		 test	 al, al
  000e5	75 f9		 jne	 SHORT $LL37@g_Generic_
  000e7	2b f9		 sub	 edi, ecx

; 87   : 
; 88   : 	if (lua_pcall(L, narg, nres, 0) != 0)  /* do the call */

  000e9	8b 4d fc	 mov	 ecx, DWORD PTR _narg$[ebp]
  000ec	6a 00		 push	 0
  000ee	57		 push	 edi
  000ef	51		 push	 ecx
  000f0	56		 push	 esi
  000f1	e8 00 00 00 00	 call	 _lua_pcall
  000f6	83 c4 10	 add	 esp, 16			; 00000010H
  000f9	85 c0		 test	 eax, eax
  000fb	74 45		 je	 SHORT $LN13@g_Generic_

; 89   : 	{
; 90   : 		LogAdd("luacall_Generic_Call error running function `%s': %s", func, lua_tolstring(L, -1, NULL));

  000fd	6a 00		 push	 0
  000ff	6a ff		 push	 -1
  00101	56		 push	 esi
  00102	e8 00 00 00 00	 call	 _lua_tolstring
  00107	8b 55 0c	 mov	 edx, DWORD PTR _func$[ebp]
  0010a	50		 push	 eax
  0010b	52		 push	 edx
  0010c	68 00 00 00 00	 push	 OFFSET ??_C@_0DF@HDBMEAKM@luacall_Generic_Call?5error?5runni@
  00111	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00117	83 c4 18	 add	 esp, 24			; 00000018H
  0011a	5f		 pop	 edi
  0011b	5e		 pop	 esi

; 91   : 		return false;

  0011c	32 c0		 xor	 al, al
  0011e	5b		 pop	 ebx

; 143  : }

  0011f	8b e5		 mov	 esp, ebp
  00121	5d		 pop	 ebp
  00122	c3		 ret	 0
$LN14@g_Generic_:

; 70   : 			}
; 71   :             break;
; 72   :     
; 73   : 			case '>':
; 74   : 				goto endwhile;
; 75   :     
; 76   : 			default:
; 77   : 				LogAdd("luacall_Generic_Call invalid option (%c)", *(sig - 1));

  00123	8b 55 10	 mov	 edx, DWORD PTR _sig$[ebp]
  00126	0f be 42 ff	 movsx	 eax, BYTE PTR [edx-1]
  0012a	50		 push	 eax
  0012b	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@EGCCEPHO@luacall_Generic_Call?5invalid?5opt@
  00130	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00136	83 c4 08	 add	 esp, 8
  00139	5f		 pop	 edi
  0013a	5e		 pop	 esi

; 78   : 			return false;

  0013b	32 c0		 xor	 al, al
  0013d	5b		 pop	 ebx

; 143  : }

  0013e	8b e5		 mov	 esp, ebp
  00140	5d		 pop	 ebp
  00141	c3		 ret	 0
$LN13@g_Generic_:

; 96   : 	nres = -nres;  /* stack index of first result */
; 97   : 	while (*sig) 

  00142	8b 45 10	 mov	 eax, DWORD PTR _sig$[ebp]
  00145	8a 00		 mov	 al, BYTE PTR [eax]
  00147	8b cf		 mov	 ecx, edi
  00149	f7 df		 neg	 edi
  0014b	89 4d f8	 mov	 DWORD PTR _nRetValCnt$[ebp], ecx
  0014e	84 c0		 test	 al, al
  00150	0f 84 9c 00 00
	00		 je	 $LN11@g_Generic_

; 92   : 	}
; 93   :     
; 94   : 	/* retrieve results */
; 95   : 	int nRetValCnt = nres;

  00156	83 c3 fc	 add	 ebx, -4			; fffffffcH
  00159	8d a4 24 00 00
	00 00		 npad	 7
$LL12@g_Generic_:

; 98   : 	{  
; 99   : 		/* get results */
; 100  : 		switch (*sig++) 

  00160	ff 45 10	 inc	 DWORD PTR _sig$[ebp]
  00163	0f be c0	 movsx	 eax, al
  00166	83 f8 64	 cmp	 eax, 100		; 00000064H
  00169	74 57		 je	 SHORT $LN8@g_Generic_
  0016b	83 f8 69	 cmp	 eax, 105		; 00000069H
  0016e	74 2c		 je	 SHORT $LN6@g_Generic_
  00170	83 f8 73	 cmp	 eax, 115		; 00000073H
  00173	75 ae		 jne	 SHORT $LN14@g_Generic_

; 120  :     
; 121  : 			case 's':  /* string result */
; 122  : 				if (!lua_isstring(L, nres))

  00175	57		 push	 edi
  00176	56		 push	 esi
  00177	e8 00 00 00 00	 call	 _lua_isstring
  0017c	83 c4 08	 add	 esp, 8
  0017f	85 c0		 test	 eax, eax
  00181	0f 84 87 00 00
	00		 je	 $LN30@g_Generic_

; 126  : 				}
; 127  : 				*va_arg(vl, const char **) = lua_tolstring(L, nres, NULL);

  00187	6a 00		 push	 0
  00189	57		 push	 edi
  0018a	56		 push	 esi
  0018b	83 c3 04	 add	 ebx, 4
  0018e	e8 00 00 00 00	 call	 _lua_tolstring
  00193	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  00195	83 c4 0c	 add	 esp, 12			; 0000000cH
  00198	89 01		 mov	 DWORD PTR [ecx], eax

; 128  :             break;

  0019a	eb 45		 jmp	 SHORT $LN9@g_Generic_
$LN6@g_Generic_:

; 110  :             break;
; 111  :     
; 112  : 			case 'i':  /* int result */
; 113  : 				if (!lua_isnumber(L, nres))

  0019c	57		 push	 edi
  0019d	56		 push	 esi
  0019e	e8 00 00 00 00	 call	 _lua_isnumber
  001a3	83 c4 08	 add	 esp, 8

; 117  : 				}
; 118  : 				*va_arg(vl, int *) = (int)lua_tonumber(L, nres);

  001a6	57		 push	 edi
  001a7	85 c0		 test	 eax, eax
  001a9	74 6e		 je	 SHORT $LN31@g_Generic_
  001ab	56		 push	 esi
  001ac	83 c3 04	 add	 ebx, 4
  001af	e8 00 00 00 00	 call	 _lua_tonumber
  001b4	83 c4 08	 add	 esp, 8
  001b7	e8 00 00 00 00	 call	 __ftol2_sse
  001bc	8b 13		 mov	 edx, DWORD PTR [ebx]
  001be	89 02		 mov	 DWORD PTR [edx], eax

; 119  :             break;

  001c0	eb 1f		 jmp	 SHORT $LN9@g_Generic_
$LN8@g_Generic_:

; 101  : 		{
; 102  :     
; 103  : 			case 'd':  /* double result */
; 104  : 				if (!lua_isnumber(L, nres))

  001c2	57		 push	 edi
  001c3	56		 push	 esi
  001c4	e8 00 00 00 00	 call	 _lua_isnumber
  001c9	83 c4 08	 add	 esp, 8

; 108  : 				}
; 109  : 				*va_arg(vl, double *) = lua_tonumber(L, nres);

  001cc	57		 push	 edi
  001cd	85 c0		 test	 eax, eax
  001cf	74 52		 je	 SHORT $LN32@g_Generic_
  001d1	56		 push	 esi
  001d2	83 c3 04	 add	 ebx, 4
  001d5	e8 00 00 00 00	 call	 _lua_tonumber
  001da	8b 03		 mov	 eax, DWORD PTR [ebx]
  001dc	dd 18		 fstp	 QWORD PTR [eax]
  001de	83 c4 08	 add	 esp, 8
$LN9@g_Generic_:

; 96   : 	nres = -nres;  /* stack index of first result */
; 97   : 	while (*sig) 

  001e1	8b 4d 10	 mov	 ecx, DWORD PTR _sig$[ebp]
  001e4	8a 01		 mov	 al, BYTE PTR [ecx]

; 129  :     
; 130  : 			default:
; 131  : 				LogAdd("luacall_Generic_Call invalid option (%c)", *(sig - 1));
; 132  : 			return false;
; 133  : 		}
; 134  :         nres++;

  001e6	47		 inc	 edi
  001e7	84 c0		 test	 al, al
  001e9	0f 85 71 ff ff
	ff		 jne	 $LL12@g_Generic_

; 101  : 		{
; 102  :     
; 103  : 			case 'd':  /* double result */
; 104  : 				if (!lua_isnumber(L, nres))

  001ef	8b 4d f8	 mov	 ecx, DWORD PTR _nRetValCnt$[ebp]
$LN11@g_Generic_:

; 135  : 	}
; 136  : 
; 137  : 	if(nRetValCnt)

  001f2	85 c9		 test	 ecx, ecx
  001f4	74 0f		 je	 SHORT $LN1@g_Generic_

; 138  : 		lua_settop(L, -nRetValCnt-1);

  001f6	83 ca ff	 or	 edx, -1
  001f9	2b d1		 sub	 edx, ecx
  001fb	52		 push	 edx
  001fc	56		 push	 esi
  001fd	e8 00 00 00 00	 call	 _lua_settop
  00202	83 c4 08	 add	 esp, 8
$LN1@g_Generic_:

; 139  : 
; 140  : //	va_end(vl);
; 141  : 
; 142  : 	return true;

  00205	5f		 pop	 edi
  00206	5e		 pop	 esi
  00207	b0 01		 mov	 al, 1
  00209	5b		 pop	 ebx

; 143  : }

  0020a	8b e5		 mov	 esp, ebp
  0020c	5d		 pop	 ebp
  0020d	c3		 ret	 0
$LN30@g_Generic_:

; 123  : 				{
; 124  : 					LogAdd("luacall_Generic_Call wrong result type [%c][%d]", *(sig-1), nres);

  0020e	8b 4d 10	 mov	 ecx, DWORD PTR _sig$[ebp]
  00211	0f be 51 ff	 movsx	 edx, BYTE PTR [ecx-1]
  00215	57		 push	 edi
  00216	52		 push	 edx

; 125  : 					return false;

  00217	eb 12		 jmp	 SHORT $LN40@g_Generic_
$LN31@g_Generic_:

; 114  : 				{
; 115  : 					LogAdd("luacall_Generic_Call wrong result type [%c][%d]", *(sig-1), nres);

  00219	8b 45 10	 mov	 eax, DWORD PTR _sig$[ebp]
  0021c	0f be 48 ff	 movsx	 ecx, BYTE PTR [eax-1]
  00220	51		 push	 ecx

; 116  : 					return false;

  00221	eb 08		 jmp	 SHORT $LN40@g_Generic_
$LN32@g_Generic_:

; 105  : 				{
; 106  : 					LogAdd("luacall_Generic_Call wrong result type [%c][%d]", *(sig-1), nres);

  00223	8b 55 10	 mov	 edx, DWORD PTR _sig$[ebp]
  00226	0f be 42 ff	 movsx	 eax, BYTE PTR [edx-1]
  0022a	50		 push	 eax
$LN40@g_Generic_:
  0022b	68 00 00 00 00	 push	 OFFSET ??_C@_0DA@PIFINKPE@luacall_Generic_Call?5wrong?5resul@
  00230	ff 15 00 00 00
	00		 call	 DWORD PTR ?LogAdd@@3P6AXPADZZA ; LogAdd
  00236	83 c4 0c	 add	 esp, 12			; 0000000cH
  00239	5f		 pop	 edi
  0023a	5e		 pop	 esi

; 107  : 					return false;

  0023b	32 c0		 xor	 al, al
  0023d	5b		 pop	 ebx

; 143  : }

  0023e	8b e5		 mov	 esp, ebp
  00240	5d		 pop	 ebp
  00241	c3		 ret	 0
  00242	8b ff		 npad	 2
$LN41@g_Generic_:
  00244	00 00 00 00	 DD	 $endwhile$155153
  00248	00 00 00 00	 DD	 $LN19@g_Generic_
  0024c	00 00 00 00	 DD	 $LN18@g_Generic_
  00250	00 00 00 00	 DD	 $LN17@g_Generic_
  00254	00 00 00 00	 DD	 $LN20@g_Generic_
  00258	00 00 00 00	 DD	 $LN14@g_Generic_
$LN35@g_Generic_:
  0025c	00		 DB	 0
  0025d	05		 DB	 5
  0025e	05		 DB	 5
  0025f	05		 DB	 5
  00260	05		 DB	 5
  00261	05		 DB	 5
  00262	05		 DB	 5
  00263	05		 DB	 5
  00264	05		 DB	 5
  00265	05		 DB	 5
  00266	05		 DB	 5
  00267	05		 DB	 5
  00268	05		 DB	 5
  00269	05		 DB	 5
  0026a	05		 DB	 5
  0026b	05		 DB	 5
  0026c	05		 DB	 5
  0026d	05		 DB	 5
  0026e	05		 DB	 5
  0026f	05		 DB	 5
  00270	05		 DB	 5
  00271	05		 DB	 5
  00272	05		 DB	 5
  00273	05		 DB	 5
  00274	05		 DB	 5
  00275	05		 DB	 5
  00276	05		 DB	 5
  00277	05		 DB	 5
  00278	05		 DB	 5
  00279	05		 DB	 5
  0027a	05		 DB	 5
  0027b	05		 DB	 5
  0027c	05		 DB	 5
  0027d	05		 DB	 5
  0027e	05		 DB	 5
  0027f	05		 DB	 5
  00280	05		 DB	 5
  00281	05		 DB	 5
  00282	01		 DB	 1
  00283	05		 DB	 5
  00284	05		 DB	 5
  00285	05		 DB	 5
  00286	05		 DB	 5
  00287	02		 DB	 2
  00288	05		 DB	 5
  00289	05		 DB	 5
  0028a	05		 DB	 5
  0028b	05		 DB	 5
  0028c	05		 DB	 5
  0028d	05		 DB	 5
  0028e	05		 DB	 5
  0028f	05		 DB	 5
  00290	05		 DB	 5
  00291	03		 DB	 3
  00292	05		 DB	 5
  00293	05		 DB	 5
  00294	05		 DB	 5
  00295	04		 DB	 4
?g_Generic_Call@@YA_NPAUlua_State@@PBD1ZZ ENDP		; g_Generic_Call
_TEXT	ENDS
END
