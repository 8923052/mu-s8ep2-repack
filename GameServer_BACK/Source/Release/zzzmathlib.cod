; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	C:\muserver_dev\development\MU-S8EP2-Repack\GameServer\Source\zzzmathlib.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?VectorMA@@YAXQAMM00@Z				; VectorMA
EXTRN	__fltused:DWORD
; Function compile flags: /Ogtp
; File c:\muserver_dev\development\mu-s8ep2-repack\gameserver\source\zzzmathlib.cpp
;	COMDAT ?VectorMA@@YAXQAMM00@Z
_TEXT	SEGMENT
_va$ = 8						; size = 4
_scale$ = 12						; size = 4
_vb$ = 16						; size = 4
_vc$ = 20						; size = 4
?VectorMA@@YAXQAMM00@Z PROC				; VectorMA, COMDAT

; 34   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 35   : 	vc[0] = va[0] + scale*vb[0];

  00003	8b 45 10	 mov	 eax, DWORD PTR _vb$[ebp]
  00006	d9 00		 fld	 DWORD PTR [eax]
  00008	8b 4d 08	 mov	 ecx, DWORD PTR _va$[ebp]
  0000b	d9 45 0c	 fld	 DWORD PTR _scale$[ebp]
  0000e	8b 55 14	 mov	 edx, DWORD PTR _vc$[ebp]
  00011	d9 c0		 fld	 ST(0)
  00013	de ca		 fmulp	 ST(2), ST(0)
  00015	d9 01		 fld	 DWORD PTR [ecx]
  00017	de c2		 faddp	 ST(2), ST(0)
  00019	d9 c9		 fxch	 ST(1)
  0001b	d9 1a		 fstp	 DWORD PTR [edx]

; 36   : 	vc[1] = va[1] + scale*vb[1];

  0001d	d9 40 04	 fld	 DWORD PTR [eax+4]
  00020	d8 c9		 fmul	 ST(0), ST(1)
  00022	d8 41 04	 fadd	 DWORD PTR [ecx+4]
  00025	d9 5a 04	 fstp	 DWORD PTR [edx+4]

; 37   : 	vc[2] = va[2] + scale*vb[2];

  00028	d8 48 08	 fmul	 DWORD PTR [eax+8]
  0002b	d8 41 08	 fadd	 DWORD PTR [ecx+8]
  0002e	d9 5a 08	 fstp	 DWORD PTR [edx+8]

; 38   : }

  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
?VectorMA@@YAXQAMM00@Z ENDP				; VectorMA
_TEXT	ENDS
PUBLIC	?CrossProduct@@YAXQAM00@Z			; CrossProduct
; Function compile flags: /Ogtp
;	COMDAT ?CrossProduct@@YAXQAM00@Z
_TEXT	SEGMENT
_v1$ = 8						; size = 4
_v2$ = 12						; size = 4
_cross$ = 16						; size = 4
?CrossProduct@@YAXQAM00@Z PROC				; CrossProduct, COMDAT

; 41   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 42   : 	cross[0] = v1[1]*v2[2] - v1[2]*v2[1];

  00003	8b 45 08	 mov	 eax, DWORD PTR _v1$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR _v2$[ebp]
  00009	d9 40 04	 fld	 DWORD PTR [eax+4]
  0000c	d8 49 08	 fmul	 DWORD PTR [ecx+8]
  0000f	8b 55 10	 mov	 edx, DWORD PTR _cross$[ebp]
  00012	d9 40 08	 fld	 DWORD PTR [eax+8]
  00015	d8 49 04	 fmul	 DWORD PTR [ecx+4]
  00018	de e9		 fsubp	 ST(1), ST(0)
  0001a	d9 1a		 fstp	 DWORD PTR [edx]

; 43   : 	cross[1] = v1[2]*v2[0] - v1[0]*v2[2];

  0001c	d9 40 08	 fld	 DWORD PTR [eax+8]
  0001f	d8 09		 fmul	 DWORD PTR [ecx]
  00021	d9 00		 fld	 DWORD PTR [eax]
  00023	d8 49 08	 fmul	 DWORD PTR [ecx+8]
  00026	de e9		 fsubp	 ST(1), ST(0)
  00028	d9 5a 04	 fstp	 DWORD PTR [edx+4]

; 44   : 	cross[2] = v1[0]*v2[1] - v1[1]*v2[0];

  0002b	d9 00		 fld	 DWORD PTR [eax]
  0002d	d8 49 04	 fmul	 DWORD PTR [ecx+4]
  00030	d9 01		 fld	 DWORD PTR [ecx]
  00032	d8 48 04	 fmul	 DWORD PTR [eax+4]
  00035	de e9		 fsubp	 ST(1), ST(0)
  00037	d9 5a 08	 fstp	 DWORD PTR [edx+8]

; 45   : }

  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
?CrossProduct@@YAXQAM00@Z ENDP				; CrossProduct
_TEXT	ENDS
PUBLIC	?_DotProduct@@YAMQAM0@Z				; _DotProduct
; Function compile flags: /Ogtp
;	COMDAT ?_DotProduct@@YAMQAM0@Z
_TEXT	SEGMENT
tv156 = 8						; size = 4
_v1$ = 8						; size = 4
_v2$ = 12						; size = 4
?_DotProduct@@YAMQAM0@Z PROC				; _DotProduct, COMDAT

; 48   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 49   : 	return v1[0]*v2[0] + v1[1]*v2[1] + v1[2]*v2[2];

  00003	8b 45 08	 mov	 eax, DWORD PTR _v1$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR _v2$[ebp]
  00009	d9 40 04	 fld	 DWORD PTR [eax+4]
  0000c	d8 49 04	 fmul	 DWORD PTR [ecx+4]
  0000f	d9 00		 fld	 DWORD PTR [eax]
  00011	d8 09		 fmul	 DWORD PTR [ecx]
  00013	de c1		 faddp	 ST(1), ST(0)
  00015	d9 40 08	 fld	 DWORD PTR [eax+8]
  00018	d8 49 08	 fmul	 DWORD PTR [ecx+8]
  0001b	de c1		 faddp	 ST(1), ST(0)
  0001d	d9 5d 08	 fstp	 DWORD PTR tv156[ebp]
  00020	d9 45 08	 fld	 DWORD PTR tv156[ebp]

; 50   : }

  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
?_DotProduct@@YAMQAM0@Z ENDP				; _DotProduct
_TEXT	ENDS
PUBLIC	?_VectorSubtract@@YAXQAM00@Z			; _VectorSubtract
; Function compile flags: /Ogtp
;	COMDAT ?_VectorSubtract@@YAXQAM00@Z
_TEXT	SEGMENT
_va$ = 8						; size = 4
_vb$ = 12						; size = 4
_out$ = 16						; size = 4
?_VectorSubtract@@YAXQAM00@Z PROC			; _VectorSubtract, COMDAT

; 53   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 54   : 	out[0] = va[0]-vb[0];

  00003	8b 45 08	 mov	 eax, DWORD PTR _va$[ebp]
  00006	d9 00		 fld	 DWORD PTR [eax]
  00008	8b 4d 0c	 mov	 ecx, DWORD PTR _vb$[ebp]
  0000b	d8 21		 fsub	 DWORD PTR [ecx]
  0000d	8b 55 10	 mov	 edx, DWORD PTR _out$[ebp]
  00010	d9 1a		 fstp	 DWORD PTR [edx]

; 55   : 	out[1] = va[1]-vb[1];

  00012	d9 40 04	 fld	 DWORD PTR [eax+4]
  00015	d8 61 04	 fsub	 DWORD PTR [ecx+4]
  00018	d9 5a 04	 fstp	 DWORD PTR [edx+4]

; 56   : 	out[2] = va[2]-vb[2];

  0001b	d9 40 08	 fld	 DWORD PTR [eax+8]
  0001e	d8 61 08	 fsub	 DWORD PTR [ecx+8]
  00021	d9 5a 08	 fstp	 DWORD PTR [edx+8]

; 57   : }

  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
?_VectorSubtract@@YAXQAM00@Z ENDP			; _VectorSubtract
_TEXT	ENDS
PUBLIC	?_VectorAdd@@YAXQAM00@Z				; _VectorAdd
; Function compile flags: /Ogtp
;	COMDAT ?_VectorAdd@@YAXQAM00@Z
_TEXT	SEGMENT
_va$ = 8						; size = 4
_vb$ = 12						; size = 4
_out$ = 16						; size = 4
?_VectorAdd@@YAXQAM00@Z PROC				; _VectorAdd, COMDAT

; 60   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 61   : 	out[0] = va[0]+vb[0];

  00003	8b 45 08	 mov	 eax, DWORD PTR _va$[ebp]
  00006	d9 00		 fld	 DWORD PTR [eax]
  00008	8b 4d 0c	 mov	 ecx, DWORD PTR _vb$[ebp]
  0000b	d8 01		 fadd	 DWORD PTR [ecx]
  0000d	8b 55 10	 mov	 edx, DWORD PTR _out$[ebp]
  00010	d9 1a		 fstp	 DWORD PTR [edx]

; 62   : 	out[1] = va[1]+vb[1];

  00012	d9 40 04	 fld	 DWORD PTR [eax+4]
  00015	d8 41 04	 fadd	 DWORD PTR [ecx+4]
  00018	d9 5a 04	 fstp	 DWORD PTR [edx+4]

; 63   : 	out[2] = va[2]+vb[2];

  0001b	d9 40 08	 fld	 DWORD PTR [eax+8]
  0001e	d8 41 08	 fadd	 DWORD PTR [ecx+8]
  00021	d9 5a 08	 fstp	 DWORD PTR [edx+8]

; 64   : }

  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
?_VectorAdd@@YAXQAM00@Z ENDP				; _VectorAdd
_TEXT	ENDS
PUBLIC	?_VectorCopy@@YAXQAM0@Z				; _VectorCopy
; Function compile flags: /Ogtp
;	COMDAT ?_VectorCopy@@YAXQAM0@Z
_TEXT	SEGMENT
_in$ = 8						; size = 4
_out$ = 12						; size = 4
?_VectorCopy@@YAXQAM0@Z PROC				; _VectorCopy, COMDAT

; 67   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 68   : 	out[0] = in[0];

  00003	8b 45 08	 mov	 eax, DWORD PTR _in$[ebp]
  00006	d9 00		 fld	 DWORD PTR [eax]
  00008	8b 4d 0c	 mov	 ecx, DWORD PTR _out$[ebp]
  0000b	d9 19		 fstp	 DWORD PTR [ecx]

; 69   : 	out[1] = in[1];

  0000d	d9 40 04	 fld	 DWORD PTR [eax+4]
  00010	d9 59 04	 fstp	 DWORD PTR [ecx+4]

; 70   : 	out[2] = in[2];

  00013	d9 40 08	 fld	 DWORD PTR [eax+8]
  00016	d9 59 08	 fstp	 DWORD PTR [ecx+8]

; 71   : }

  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
?_VectorCopy@@YAXQAM0@Z ENDP				; _VectorCopy
_TEXT	ENDS
PUBLIC	?VectorScale@@YAXQAMM0@Z			; VectorScale
; Function compile flags: /Ogtp
;	COMDAT ?VectorScale@@YAXQAMM0@Z
_TEXT	SEGMENT
_v$ = 8							; size = 4
_scale$ = 12						; size = 4
_out$ = 16						; size = 4
?VectorScale@@YAXQAMM0@Z PROC				; VectorScale, COMDAT

; 75   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 76   : 	out[0] = v[0] * scale;

  00003	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  00006	d9 00		 fld	 DWORD PTR [eax]
  00008	8b 4d 10	 mov	 ecx, DWORD PTR _out$[ebp]
  0000b	d9 45 0c	 fld	 DWORD PTR _scale$[ebp]
  0000e	d9 c0		 fld	 ST(0)
  00010	de ca		 fmulp	 ST(2), ST(0)
  00012	d9 c9		 fxch	 ST(1)
  00014	d9 19		 fstp	 DWORD PTR [ecx]

; 77   : 	out[1] = v[1] * scale;

  00016	d9 40 04	 fld	 DWORD PTR [eax+4]
  00019	d8 c9		 fmul	 ST(0), ST(1)
  0001b	d9 59 04	 fstp	 DWORD PTR [ecx+4]

; 78   : 	out[2] = v[2] * scale;

  0001e	d8 48 08	 fmul	 DWORD PTR [eax+8]
  00021	d9 59 08	 fstp	 DWORD PTR [ecx+8]

; 79   : }

  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
?VectorScale@@YAXQAMM0@Z ENDP				; VectorScale
_TEXT	ENDS
PUBLIC	?VectorInverse@@YAXQAM@Z			; VectorInverse
; Function compile flags: /Ogtp
;	COMDAT ?VectorInverse@@YAXQAM@Z
_TEXT	SEGMENT
_v$ = 8							; size = 4
?VectorInverse@@YAXQAM@Z PROC				; VectorInverse, COMDAT

; 105  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 106  : 	v[0] = -v[0];

  00003	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  00006	d9 00		 fld	 DWORD PTR [eax]
  00008	d9 e0		 fchs
  0000a	d9 18		 fstp	 DWORD PTR [eax]

; 107  : 	v[1] = -v[1];

  0000c	d9 40 04	 fld	 DWORD PTR [eax+4]
  0000f	d9 e0		 fchs
  00011	d9 58 04	 fstp	 DWORD PTR [eax+4]

; 108  : 	v[2] = -v[2];

  00014	d9 40 08	 fld	 DWORD PTR [eax+8]
  00017	d9 e0		 fchs
  00019	d9 58 08	 fstp	 DWORD PTR [eax+8]

; 109  : }

  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
?VectorInverse@@YAXQAM@Z ENDP				; VectorInverse
_TEXT	ENDS
PUBLIC	__real@c7c34f80
PUBLIC	__real@47c34f80
PUBLIC	?ClearBounds@@YAXQAM0@Z				; ClearBounds
;	COMDAT __real@c7c34f80
CONST	SEGMENT
__real@c7c34f80 DD 0c7c34f80r			; -99999
CONST	ENDS
;	COMDAT __real@47c34f80
CONST	SEGMENT
__real@47c34f80 DD 047c34f80r			; 99999
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?ClearBounds@@YAXQAM0@Z
_TEXT	SEGMENT
_mins$ = 8						; size = 4
_maxs$ = 12						; size = 4
?ClearBounds@@YAXQAM0@Z PROC				; ClearBounds, COMDAT

; 112  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 113  : 	mins[0] = mins[1] = mins[2] = 99999;

  00003	8b 45 08	 mov	 eax, DWORD PTR _mins$[ebp]
  00006	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@47c34f80
  0000c	d9 50 08	 fst	 DWORD PTR [eax+8]
  0000f	d9 50 04	 fst	 DWORD PTR [eax+4]
  00012	d9 18		 fstp	 DWORD PTR [eax]

; 114  : 	maxs[0] = maxs[1] = maxs[2] = -99999;

  00014	8b 45 0c	 mov	 eax, DWORD PTR _maxs$[ebp]
  00017	d9 05 00 00 00
	00		 fld	 DWORD PTR __real@c7c34f80
  0001d	d9 50 08	 fst	 DWORD PTR [eax+8]
  00020	d9 50 04	 fst	 DWORD PTR [eax+4]
  00023	d9 18		 fstp	 DWORD PTR [eax]

; 115  : }

  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
?ClearBounds@@YAXQAM0@Z ENDP				; ClearBounds
_TEXT	ENDS
PUBLIC	?AddPointToBounds@@YAXQAM00@Z			; AddPointToBounds
; Function compile flags: /Ogtp
;	COMDAT ?AddPointToBounds@@YAXQAM00@Z
_TEXT	SEGMENT
_val$ = -4						; size = 4
_v$ = 8							; size = 4
_mins$ = 12						; size = 4
_maxs$ = 16						; size = 4
?AddPointToBounds@@YAXQAM00@Z PROC			; AddPointToBounds, COMDAT

; 120  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 127  : 		if (val < mins[i])

  00004	8b 4d 0c	 mov	 ecx, DWORD PTR _mins$[ebp]
  00007	56		 push	 esi
  00008	8b 75 08	 mov	 esi, DWORD PTR _v$[ebp]
  0000b	d9 06		 fld	 DWORD PTR [esi]
  0000d	d9 5d fc	 fstp	 DWORD PTR _val$[ebp]
  00010	d9 45 fc	 fld	 DWORD PTR _val$[ebp]
  00013	d9 01		 fld	 DWORD PTR [ecx]
  00015	d8 d9		 fcomp	 ST(1)
  00017	df e0		 fnstsw	 ax
  00019	f6 c4 41	 test	 ah, 65			; 00000041H
  0001c	75 02		 jne	 SHORT $LN2@AddPointTo

; 128  : 			mins[i] = val;

  0001e	d9 11		 fst	 DWORD PTR [ecx]
$LN2@AddPointTo:

; 129  : 		if (val > maxs[i])

  00020	8b 55 10	 mov	 edx, DWORD PTR _maxs$[ebp]
  00023	d9 02		 fld	 DWORD PTR [edx]
  00025	d8 d9		 fcomp	 ST(1)
  00027	df e0		 fnstsw	 ax
  00029	f6 c4 05	 test	 ah, 5
  0002c	7a 04		 jp	 SHORT $LN24@AddPointTo

; 130  : 			maxs[i] = val;

  0002e	d9 1a		 fstp	 DWORD PTR [edx]
  00030	eb 02		 jmp	 SHORT $LN4@AddPointTo
$LN24@AddPointTo:
  00032	dd d8		 fstp	 ST(0)
$LN4@AddPointTo:

; 121  : 	int		i;
; 122  : 	vec_t	val;
; 123  : 
; 124  : 	for (i=0 ; i<3 ; i++)
; 125  : 	{
; 126  : 		val = v[i];

  00034	d9 46 04	 fld	 DWORD PTR [esi+4]
  00037	d9 5d fc	 fstp	 DWORD PTR _val$[ebp]

; 127  : 		if (val < mins[i])

  0003a	d9 45 fc	 fld	 DWORD PTR _val$[ebp]
  0003d	d9 41 04	 fld	 DWORD PTR [ecx+4]
  00040	d8 d9		 fcomp	 ST(1)
  00042	df e0		 fnstsw	 ax
  00044	f6 c4 41	 test	 ah, 65			; 00000041H
  00047	75 03		 jne	 SHORT $LN15@AddPointTo

; 128  : 			mins[i] = val;

  00049	d9 51 04	 fst	 DWORD PTR [ecx+4]
$LN15@AddPointTo:

; 129  : 		if (val > maxs[i])

  0004c	d9 42 04	 fld	 DWORD PTR [edx+4]
  0004f	d8 d9		 fcomp	 ST(1)
  00051	df e0		 fnstsw	 ax
  00053	f6 c4 05	 test	 ah, 5
  00056	7a 05		 jp	 SHORT $LN30@AddPointTo

; 130  : 			maxs[i] = val;

  00058	d9 5a 04	 fstp	 DWORD PTR [edx+4]
  0005b	eb 02		 jmp	 SHORT $LN16@AddPointTo
$LN30@AddPointTo:
  0005d	dd d8		 fstp	 ST(0)
$LN16@AddPointTo:

; 121  : 	int		i;
; 122  : 	vec_t	val;
; 123  : 
; 124  : 	for (i=0 ; i<3 ; i++)
; 125  : 	{
; 126  : 		val = v[i];

  0005f	d9 46 08	 fld	 DWORD PTR [esi+8]
  00062	5e		 pop	 esi
  00063	d9 5d fc	 fstp	 DWORD PTR _val$[ebp]

; 127  : 		if (val < mins[i])

  00066	d9 45 fc	 fld	 DWORD PTR _val$[ebp]
  00069	d9 41 08	 fld	 DWORD PTR [ecx+8]
  0006c	d8 d9		 fcomp	 ST(1)
  0006e	df e0		 fnstsw	 ax
  00070	f6 c4 41	 test	 ah, 65			; 00000041H
  00073	75 03		 jne	 SHORT $LN18@AddPointTo

; 128  : 			mins[i] = val;

  00075	d9 51 08	 fst	 DWORD PTR [ecx+8]
$LN18@AddPointTo:

; 129  : 		if (val > maxs[i])

  00078	d9 42 08	 fld	 DWORD PTR [edx+8]
  0007b	d8 d9		 fcomp	 ST(1)
  0007d	df e0		 fnstsw	 ax
  0007f	f6 c4 05	 test	 ah, 5
  00082	7a 07		 jp	 SHORT $LN36@AddPointTo

; 130  : 			maxs[i] = val;

  00084	d9 5a 08	 fstp	 DWORD PTR [edx+8]

; 131  : 	}
; 132  : }

  00087	8b e5		 mov	 esp, ebp
  00089	5d		 pop	 ebp
  0008a	c3		 ret	 0
$LN36@AddPointTo:

; 129  : 		if (val > maxs[i])

  0008b	dd d8		 fstp	 ST(0)

; 131  : 	}
; 132  : }

  0008d	8b e5		 mov	 esp, ebp
  0008f	5d		 pop	 ebp
  00090	c3		 ret	 0
?AddPointToBounds@@YAXQAM00@Z ENDP			; AddPointToBounds
_TEXT	ENDS
PUBLIC	?R_ConcatTransforms@@YAXQBM0QAM@Z		; R_ConcatTransforms
; Function compile flags: /Ogtp
;	COMDAT ?R_ConcatTransforms@@YAXQBM0QAM@Z
_TEXT	SEGMENT
_in1$ = 8						; size = 4
_in2$ = 12						; size = 4
_out$ = 16						; size = 4
?R_ConcatTransforms@@YAXQBM0QAM@Z PROC			; R_ConcatTransforms, COMDAT

; 202  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 203  : 	out[0*4+0] = in1[0*4+0] * in2[0*4+0] + in1[0*4+1] * in2[1*4+0] + in1[0*4+2] * in2[2*4+0];

  00003	8b 45 08	 mov	 eax, DWORD PTR _in1$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR _in2$[ebp]
  00009	d9 00		 fld	 DWORD PTR [eax]
  0000b	d8 09		 fmul	 DWORD PTR [ecx]
  0000d	8b 55 10	 mov	 edx, DWORD PTR _out$[ebp]
  00010	d9 40 04	 fld	 DWORD PTR [eax+4]
  00013	d8 49 10	 fmul	 DWORD PTR [ecx+16]
  00016	de c1		 faddp	 ST(1), ST(0)
  00018	d9 41 20	 fld	 DWORD PTR [ecx+32]
  0001b	d8 48 08	 fmul	 DWORD PTR [eax+8]
  0001e	de c1		 faddp	 ST(1), ST(0)
  00020	d9 1a		 fstp	 DWORD PTR [edx]

; 204  : 	out[0*4+1] = in1[0*4+0] * in2[0*4+1] + in1[0*4+1] * in2[1*4+1] + in1[0*4+2] * in2[2*4+1];

  00022	d9 41 14	 fld	 DWORD PTR [ecx+20]
  00025	d8 48 04	 fmul	 DWORD PTR [eax+4]
  00028	d9 41 04	 fld	 DWORD PTR [ecx+4]
  0002b	d8 08		 fmul	 DWORD PTR [eax]
  0002d	de c1		 faddp	 ST(1), ST(0)
  0002f	d9 40 08	 fld	 DWORD PTR [eax+8]
  00032	d8 49 24	 fmul	 DWORD PTR [ecx+36]
  00035	de c1		 faddp	 ST(1), ST(0)
  00037	d9 5a 04	 fstp	 DWORD PTR [edx+4]

; 205  : 	out[0*4+2] = in1[0*4+0] * in2[0*4+2] + in1[0*4+1] * in2[1*4+2] + in1[0*4+2] * in2[2*4+2];

  0003a	d9 41 18	 fld	 DWORD PTR [ecx+24]
  0003d	d8 48 04	 fmul	 DWORD PTR [eax+4]
  00040	d9 41 08	 fld	 DWORD PTR [ecx+8]
  00043	d8 08		 fmul	 DWORD PTR [eax]
  00045	de c1		 faddp	 ST(1), ST(0)
  00047	d9 40 08	 fld	 DWORD PTR [eax+8]
  0004a	d8 49 28	 fmul	 DWORD PTR [ecx+40]
  0004d	de c1		 faddp	 ST(1), ST(0)
  0004f	d9 5a 08	 fstp	 DWORD PTR [edx+8]

; 206  : 	out[0*4+3] = in1[0*4+0] * in2[0*4+3] + in1[0*4+1] * in2[1*4+3] + in1[0*4+2] * in2[2*4+3] + in1[0*4+3];

  00052	d9 41 1c	 fld	 DWORD PTR [ecx+28]
  00055	d8 48 04	 fmul	 DWORD PTR [eax+4]
  00058	d9 41 0c	 fld	 DWORD PTR [ecx+12]
  0005b	d8 08		 fmul	 DWORD PTR [eax]
  0005d	de c1		 faddp	 ST(1), ST(0)
  0005f	d9 40 08	 fld	 DWORD PTR [eax+8]
  00062	d8 49 2c	 fmul	 DWORD PTR [ecx+44]
  00065	de c1		 faddp	 ST(1), ST(0)
  00067	d8 40 0c	 fadd	 DWORD PTR [eax+12]
  0006a	d9 5a 0c	 fstp	 DWORD PTR [edx+12]

; 207  : 	out[1*4+0] = in1[1*4+0] * in2[0*4+0] + in1[1*4+1] * in2[1*4+0] + in1[1*4+2] * in2[2*4+0];

  0006d	d9 40 14	 fld	 DWORD PTR [eax+20]
  00070	d8 49 10	 fmul	 DWORD PTR [ecx+16]
  00073	d9 40 10	 fld	 DWORD PTR [eax+16]
  00076	d8 09		 fmul	 DWORD PTR [ecx]
  00078	de c1		 faddp	 ST(1), ST(0)
  0007a	d9 40 18	 fld	 DWORD PTR [eax+24]
  0007d	d8 49 20	 fmul	 DWORD PTR [ecx+32]
  00080	de c1		 faddp	 ST(1), ST(0)
  00082	d9 5a 10	 fstp	 DWORD PTR [edx+16]

; 208  : 	out[1*4+1] = in1[1*4+0] * in2[0*4+1] + in1[1*4+1] * in2[1*4+1] + in1[1*4+2] * in2[2*4+1];

  00085	d9 40 10	 fld	 DWORD PTR [eax+16]
  00088	d8 49 04	 fmul	 DWORD PTR [ecx+4]
  0008b	d9 40 14	 fld	 DWORD PTR [eax+20]
  0008e	d8 49 14	 fmul	 DWORD PTR [ecx+20]
  00091	de c1		 faddp	 ST(1), ST(0)
  00093	d9 40 18	 fld	 DWORD PTR [eax+24]
  00096	d8 49 24	 fmul	 DWORD PTR [ecx+36]
  00099	de c1		 faddp	 ST(1), ST(0)
  0009b	d9 5a 14	 fstp	 DWORD PTR [edx+20]

; 209  : 	out[1*4+2] = in1[1*4+0] * in2[0*4+2] + in1[1*4+1] * in2[1*4+2] + in1[1*4+2] * in2[2*4+2];

  0009e	d9 40 10	 fld	 DWORD PTR [eax+16]
  000a1	d8 49 08	 fmul	 DWORD PTR [ecx+8]
  000a4	d9 40 14	 fld	 DWORD PTR [eax+20]
  000a7	d8 49 18	 fmul	 DWORD PTR [ecx+24]
  000aa	de c1		 faddp	 ST(1), ST(0)
  000ac	d9 40 18	 fld	 DWORD PTR [eax+24]
  000af	d8 49 28	 fmul	 DWORD PTR [ecx+40]
  000b2	de c1		 faddp	 ST(1), ST(0)
  000b4	d9 5a 18	 fstp	 DWORD PTR [edx+24]

; 210  : 	out[1*4+3] = in1[1*4+0] * in2[0*4+3] + in1[1*4+1] * in2[1*4+3] + in1[1*4+2] * in2[2*4+3] + in1[1*4+3];

  000b7	d9 40 10	 fld	 DWORD PTR [eax+16]
  000ba	d8 49 0c	 fmul	 DWORD PTR [ecx+12]
  000bd	d9 40 14	 fld	 DWORD PTR [eax+20]
  000c0	d8 49 1c	 fmul	 DWORD PTR [ecx+28]
  000c3	de c1		 faddp	 ST(1), ST(0)
  000c5	d9 40 18	 fld	 DWORD PTR [eax+24]
  000c8	d8 49 2c	 fmul	 DWORD PTR [ecx+44]
  000cb	de c1		 faddp	 ST(1), ST(0)
  000cd	d8 40 1c	 fadd	 DWORD PTR [eax+28]
  000d0	d9 5a 1c	 fstp	 DWORD PTR [edx+28]

; 211  : 	out[2*4+0] = in1[2*4+0] * in2[0*4+0] + in1[2*4+1] * in2[1*4+0] + in1[2*4+2] * in2[2*4+0];

  000d3	d9 40 24	 fld	 DWORD PTR [eax+36]
  000d6	d8 49 10	 fmul	 DWORD PTR [ecx+16]
  000d9	d9 01		 fld	 DWORD PTR [ecx]
  000db	d8 48 20	 fmul	 DWORD PTR [eax+32]
  000de	de c1		 faddp	 ST(1), ST(0)
  000e0	d9 40 28	 fld	 DWORD PTR [eax+40]
  000e3	d8 49 20	 fmul	 DWORD PTR [ecx+32]
  000e6	de c1		 faddp	 ST(1), ST(0)
  000e8	d9 5a 20	 fstp	 DWORD PTR [edx+32]

; 212  : 	out[2*4+1] = in1[2*4+0] * in2[0*4+1] + in1[2*4+1] * in2[1*4+1] + in1[2*4+2] * in2[2*4+1];

  000eb	d9 41 04	 fld	 DWORD PTR [ecx+4]
  000ee	d8 48 20	 fmul	 DWORD PTR [eax+32]
  000f1	d9 40 24	 fld	 DWORD PTR [eax+36]
  000f4	d8 49 14	 fmul	 DWORD PTR [ecx+20]
  000f7	de c1		 faddp	 ST(1), ST(0)
  000f9	d9 40 28	 fld	 DWORD PTR [eax+40]
  000fc	d8 49 24	 fmul	 DWORD PTR [ecx+36]
  000ff	de c1		 faddp	 ST(1), ST(0)
  00101	d9 5a 24	 fstp	 DWORD PTR [edx+36]

; 213  : 	out[2*4+2] = in1[2*4+0] * in2[0*4+2] + in1[2*4+1] * in2[1*4+2] + in1[2*4+2] * in2[2*4+2];

  00104	d9 41 08	 fld	 DWORD PTR [ecx+8]
  00107	d8 48 20	 fmul	 DWORD PTR [eax+32]
  0010a	d9 40 24	 fld	 DWORD PTR [eax+36]
  0010d	d8 49 18	 fmul	 DWORD PTR [ecx+24]
  00110	de c1		 faddp	 ST(1), ST(0)
  00112	d9 40 28	 fld	 DWORD PTR [eax+40]
  00115	d8 49 28	 fmul	 DWORD PTR [ecx+40]
  00118	de c1		 faddp	 ST(1), ST(0)
  0011a	d9 5a 28	 fstp	 DWORD PTR [edx+40]

; 214  : 	out[2*4+3] = in1[2*4+0] * in2[0*4+3] + in1[2*4+1] * in2[1*4+3] + in1[2*4+2] * in2[2*4+3] + in1[2*4+3];

  0011d	d9 41 0c	 fld	 DWORD PTR [ecx+12]
  00120	d8 48 20	 fmul	 DWORD PTR [eax+32]
  00123	d9 40 24	 fld	 DWORD PTR [eax+36]
  00126	d8 49 1c	 fmul	 DWORD PTR [ecx+28]
  00129	de c1		 faddp	 ST(1), ST(0)
  0012b	d9 40 28	 fld	 DWORD PTR [eax+40]
  0012e	d8 49 2c	 fmul	 DWORD PTR [ecx+44]
  00131	de c1		 faddp	 ST(1), ST(0)
  00133	d8 40 2c	 fadd	 DWORD PTR [eax+44]
  00136	d9 5a 2c	 fstp	 DWORD PTR [edx+44]

; 215  : }

  00139	5d		 pop	 ebp
  0013a	c3		 ret	 0
?R_ConcatTransforms@@YAXQBM0QAM@Z ENDP			; R_ConcatTransforms
_TEXT	ENDS
PUBLIC	?VectorRotate@@YAXQBM0QAM@Z			; VectorRotate
; Function compile flags: /Ogtp
;	COMDAT ?VectorRotate@@YAXQBM0QAM@Z
_TEXT	SEGMENT
_in1$ = 8						; size = 4
_in2$ = 12						; size = 4
_out$ = 16						; size = 4
?VectorRotate@@YAXQBM0QAM@Z PROC			; VectorRotate, COMDAT

; 218  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 219  : 	out[0*4+0] = in1[0*4+0] * in2[0*4+0] + in1[0*4+1] * in2[0*4+1] + in1[0*4+2] * in2[0*4+2];

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR _in2$[ebp]
  00006	8b 45 08	 mov	 eax, DWORD PTR _in1$[ebp]
  00009	d9 41 04	 fld	 DWORD PTR [ecx+4]
  0000c	d8 48 04	 fmul	 DWORD PTR [eax+4]
  0000f	8b 55 10	 mov	 edx, DWORD PTR _out$[ebp]
  00012	d9 00		 fld	 DWORD PTR [eax]
  00014	d8 09		 fmul	 DWORD PTR [ecx]
  00016	de c1		 faddp	 ST(1), ST(0)
  00018	d9 41 08	 fld	 DWORD PTR [ecx+8]
  0001b	d8 48 08	 fmul	 DWORD PTR [eax+8]
  0001e	de c1		 faddp	 ST(1), ST(0)
  00020	d9 1a		 fstp	 DWORD PTR [edx]

; 220  : 	out[0*4+1] = in1[0*4+0] * in2[0*4+4] + in1[0*4+1] * in2[0*4+5] + in1[0*4+2] * in2[0*4+6];

  00022	d9 41 10	 fld	 DWORD PTR [ecx+16]
  00025	d8 08		 fmul	 DWORD PTR [eax]
  00027	d9 41 14	 fld	 DWORD PTR [ecx+20]
  0002a	d8 48 04	 fmul	 DWORD PTR [eax+4]
  0002d	de c1		 faddp	 ST(1), ST(0)
  0002f	d9 41 18	 fld	 DWORD PTR [ecx+24]
  00032	d8 48 08	 fmul	 DWORD PTR [eax+8]
  00035	de c1		 faddp	 ST(1), ST(0)
  00037	d9 5a 04	 fstp	 DWORD PTR [edx+4]

; 221  : 	out[0*4+2] = in1[0*4+0] * in2[0*4+8] + in1[0*4+1] * in2[0*4+9] + in1[0*4+2] * in2[0*4+10];

  0003a	d9 41 20	 fld	 DWORD PTR [ecx+32]
  0003d	d8 08		 fmul	 DWORD PTR [eax]
  0003f	d9 41 24	 fld	 DWORD PTR [ecx+36]
  00042	d8 48 04	 fmul	 DWORD PTR [eax+4]
  00045	de c1		 faddp	 ST(1), ST(0)
  00047	d9 41 28	 fld	 DWORD PTR [ecx+40]
  0004a	d8 48 08	 fmul	 DWORD PTR [eax+8]
  0004d	de c1		 faddp	 ST(1), ST(0)
  0004f	d9 5a 08	 fstp	 DWORD PTR [edx+8]

; 222  : }

  00052	5d		 pop	 ebp
  00053	c3		 ret	 0
?VectorRotate@@YAXQBM0QAM@Z ENDP			; VectorRotate
_TEXT	ENDS
PUBLIC	?VectorIRotate@@YAXQBM0QAM@Z			; VectorIRotate
; Function compile flags: /Ogtp
;	COMDAT ?VectorIRotate@@YAXQBM0QAM@Z
_TEXT	SEGMENT
_in1$ = 8						; size = 4
_in2$ = 12						; size = 4
_out$ = 16						; size = 4
?VectorIRotate@@YAXQBM0QAM@Z PROC			; VectorIRotate, COMDAT

; 226  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 227  : 	out[0*4+0] = in1[0*4+0] * in2[0*4+0] + in1[0*4+1] * in2[0*4+4] + in1[0*4+2] * in2[0*4+8];

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR _in2$[ebp]
  00006	8b 45 08	 mov	 eax, DWORD PTR _in1$[ebp]
  00009	d9 41 10	 fld	 DWORD PTR [ecx+16]
  0000c	d8 48 04	 fmul	 DWORD PTR [eax+4]
  0000f	8b 55 10	 mov	 edx, DWORD PTR _out$[ebp]
  00012	d9 00		 fld	 DWORD PTR [eax]
  00014	d8 09		 fmul	 DWORD PTR [ecx]
  00016	de c1		 faddp	 ST(1), ST(0)
  00018	d9 41 20	 fld	 DWORD PTR [ecx+32]
  0001b	d8 48 08	 fmul	 DWORD PTR [eax+8]
  0001e	de c1		 faddp	 ST(1), ST(0)
  00020	d9 1a		 fstp	 DWORD PTR [edx]

; 228  : 	out[0*4+1] = in1[0*4+0] * in2[0*4+1] + in1[0*4+1] * in2[0*4+5] + in1[0*4+2] * in2[0*4+9];

  00022	d9 41 04	 fld	 DWORD PTR [ecx+4]
  00025	d8 08		 fmul	 DWORD PTR [eax]
  00027	d9 41 14	 fld	 DWORD PTR [ecx+20]
  0002a	d8 48 04	 fmul	 DWORD PTR [eax+4]
  0002d	de c1		 faddp	 ST(1), ST(0)
  0002f	d9 41 24	 fld	 DWORD PTR [ecx+36]
  00032	d8 48 08	 fmul	 DWORD PTR [eax+8]
  00035	de c1		 faddp	 ST(1), ST(0)
  00037	d9 5a 04	 fstp	 DWORD PTR [edx+4]

; 229  : 	out[0*4+2] = in1[0*4+0] * in2[0*4+2] + in1[0*4+1] * in2[0*4+6] + in1[0*4+2] * in2[0*4+10];

  0003a	d9 41 08	 fld	 DWORD PTR [ecx+8]
  0003d	d8 08		 fmul	 DWORD PTR [eax]
  0003f	d9 41 18	 fld	 DWORD PTR [ecx+24]
  00042	d8 48 04	 fmul	 DWORD PTR [eax+4]
  00045	de c1		 faddp	 ST(1), ST(0)
  00047	d9 41 28	 fld	 DWORD PTR [ecx+40]
  0004a	d8 48 08	 fmul	 DWORD PTR [eax+8]
  0004d	de c1		 faddp	 ST(1), ST(0)
  0004f	d9 5a 08	 fstp	 DWORD PTR [edx+8]

; 230  : }

  00052	5d		 pop	 ebp
  00053	c3		 ret	 0
?VectorIRotate@@YAXQBM0QAM@Z ENDP			; VectorIRotate
_TEXT	ENDS
PUBLIC	?VectorTranslate@@YAXQBM0QAM@Z			; VectorTranslate
; Function compile flags: /Ogtp
;	COMDAT ?VectorTranslate@@YAXQBM0QAM@Z
_TEXT	SEGMENT
_in1$ = 8						; size = 4
_in2$ = 12						; size = 4
_out$ = 16						; size = 4
?VectorTranslate@@YAXQBM0QAM@Z PROC			; VectorTranslate, COMDAT

; 235  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 236  : 	out[0*4+0] = in1[0*4+0] + in2[0*4+3];

  00003	8b 45 0c	 mov	 eax, DWORD PTR _in2$[ebp]
  00006	d9 40 0c	 fld	 DWORD PTR [eax+12]
  00009	8b 4d 08	 mov	 ecx, DWORD PTR _in1$[ebp]
  0000c	d8 01		 fadd	 DWORD PTR [ecx]
  0000e	8b 55 10	 mov	 edx, DWORD PTR _out$[ebp]
  00011	d9 1a		 fstp	 DWORD PTR [edx]

; 237  : 	out[0*4+1] = in1[0*4+1] + in2[1*4+3];

  00013	d9 40 1c	 fld	 DWORD PTR [eax+28]
  00016	d8 41 04	 fadd	 DWORD PTR [ecx+4]
  00019	d9 5a 04	 fstp	 DWORD PTR [edx+4]

; 238  : 	out[0*4+2] = in1[0*4+2] + in2[2*4+3];

  0001c	d9 40 2c	 fld	 DWORD PTR [eax+44]
  0001f	d8 41 08	 fadd	 DWORD PTR [ecx+8]
  00022	d9 5a 08	 fstp	 DWORD PTR [edx+8]

; 239  : }

  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
?VectorTranslate@@YAXQBM0QAM@Z ENDP			; VectorTranslate
_TEXT	ENDS
PUBLIC	?VectorTransform@@YAXQBM0QAM@Z			; VectorTransform
; Function compile flags: /Ogtp
;	COMDAT ?VectorTransform@@YAXQBM0QAM@Z
_TEXT	SEGMENT
_in1$ = 8						; size = 4
_in2$ = 12						; size = 4
_out$ = 16						; size = 4
?VectorTransform@@YAXQBM0QAM@Z PROC			; VectorTransform, COMDAT

; 244  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 245  : 	out[0*4+0] = in1[0*4+0] * in2[0*4+0] + in1[0*4+1] * in2[0*4+1] + in1[0*4+2] * in2[0*4+2] + in2[0*4+3];

  00003	8b 45 0c	 mov	 eax, DWORD PTR _in2$[ebp]
  00006	8b 4d 08	 mov	 ecx, DWORD PTR _in1$[ebp]
  00009	d9 40 04	 fld	 DWORD PTR [eax+4]
  0000c	d8 49 04	 fmul	 DWORD PTR [ecx+4]
  0000f	8b 55 10	 mov	 edx, DWORD PTR _out$[ebp]
  00012	d9 01		 fld	 DWORD PTR [ecx]
  00014	d8 08		 fmul	 DWORD PTR [eax]
  00016	de c1		 faddp	 ST(1), ST(0)
  00018	d9 40 08	 fld	 DWORD PTR [eax+8]
  0001b	d8 49 08	 fmul	 DWORD PTR [ecx+8]
  0001e	de c1		 faddp	 ST(1), ST(0)
  00020	d8 40 0c	 fadd	 DWORD PTR [eax+12]
  00023	d9 1a		 fstp	 DWORD PTR [edx]

; 246  : 	out[0*4+1] = in1[0*4+0] * in2[1*4+0] + in1[0*4+1] * in2[1*4+1] + in1[0*4+2] * in2[1*4+2] + in2[1*4+3];

  00025	d9 40 10	 fld	 DWORD PTR [eax+16]
  00028	d8 09		 fmul	 DWORD PTR [ecx]
  0002a	d9 40 14	 fld	 DWORD PTR [eax+20]
  0002d	d8 49 04	 fmul	 DWORD PTR [ecx+4]
  00030	de c1		 faddp	 ST(1), ST(0)
  00032	d9 40 18	 fld	 DWORD PTR [eax+24]
  00035	d8 49 08	 fmul	 DWORD PTR [ecx+8]
  00038	de c1		 faddp	 ST(1), ST(0)
  0003a	d8 40 1c	 fadd	 DWORD PTR [eax+28]
  0003d	d9 5a 04	 fstp	 DWORD PTR [edx+4]

; 247  : 	out[0*4+2] = in1[0*4+0] * in2[2*4+0] + in1[0*4+1] * in2[2*4+1] + in1[0*4+2] * in2[2*4+2] + in2[2*4+3];

  00040	d9 40 20	 fld	 DWORD PTR [eax+32]
  00043	d8 09		 fmul	 DWORD PTR [ecx]
  00045	d9 40 24	 fld	 DWORD PTR [eax+36]
  00048	d8 49 04	 fmul	 DWORD PTR [ecx+4]
  0004b	de c1		 faddp	 ST(1), ST(0)
  0004d	d9 40 28	 fld	 DWORD PTR [eax+40]
  00050	d8 49 08	 fmul	 DWORD PTR [ecx+8]
  00053	de c1		 faddp	 ST(1), ST(0)
  00055	d8 40 2c	 fadd	 DWORD PTR [eax+44]
  00058	d9 5a 08	 fstp	 DWORD PTR [edx+8]

; 248  : }

  0005b	5d		 pop	 ebp
  0005c	c3		 ret	 0
?VectorTransform@@YAXQBM0QAM@Z ENDP			; VectorTransform
_TEXT	ENDS
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@4000000000000000
PUBLIC	?QuaternionMatrix@@YAXPBMPAY03M@Z		; QuaternionMatrix
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@4000000000000000
CONST	SEGMENT
__real@4000000000000000 DQ 04000000000000000r	; 2
; Function compile flags: /Ogtp
CONST	ENDS
;	COMDAT ?QuaternionMatrix@@YAXPBMPAY03M@Z
_TEXT	SEGMENT
_quaternion$ = 8					; size = 4
_matrix$ = 12						; size = 4
?QuaternionMatrix@@YAXPBMPAY03M@Z PROC			; QuaternionMatrix, COMDAT

; 281  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 282  : 	matrix[0][0]	= 1.0f - ( quaternion[1] * 2 * quaternion[1] ) - ( quaternion[2] * 2 * quaternion[2] );

  00003	8b 45 08	 mov	 eax, DWORD PTR _quaternion$[ebp]
  00006	d9 40 04	 fld	 DWORD PTR [eax+4]
  00009	8b 4d 0c	 mov	 ecx, DWORD PTR _matrix$[ebp]
  0000c	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@4000000000000000
  00012	dc c9		 fmul	 ST(1), ST(0)
  00014	d9 40 04	 fld	 DWORD PTR [eax+4]
  00017	de ca		 fmulp	 ST(2), ST(0)
  00019	d9 e8		 fld1
  0001b	d9 c0		 fld	 ST(0)
  0001d	de e3		 fsubrp	 ST(3), ST(0)
  0001f	d9 40 08	 fld	 DWORD PTR [eax+8]
  00022	d8 ca		 fmul	 ST(0), ST(2)
  00024	d8 48 08	 fmul	 DWORD PTR [eax+8]
  00027	de eb		 fsubp	 ST(3), ST(0)
  00029	d9 ca		 fxch	 ST(2)
  0002b	d9 19		 fstp	 DWORD PTR [ecx]

; 283  : 	matrix[1][0]	=       ( quaternion[0] * 2 * quaternion[1] ) + ( quaternion[3] * 2 * quaternion[2] );

  0002d	d9 40 0c	 fld	 DWORD PTR [eax+12]
  00030	d8 c9		 fmul	 ST(0), ST(1)
  00032	d8 48 08	 fmul	 DWORD PTR [eax+8]
  00035	d9 00		 fld	 DWORD PTR [eax]
  00037	d8 ca		 fmul	 ST(0), ST(2)
  00039	d8 48 04	 fmul	 DWORD PTR [eax+4]
  0003c	de c1		 faddp	 ST(1), ST(0)
  0003e	d9 59 10	 fstp	 DWORD PTR [ecx+16]

; 284  : 	matrix[2][0]	=       ( quaternion[0] * 2 * quaternion[2] ) - ( quaternion[3] * 2 * quaternion[1] );

  00041	d9 00		 fld	 DWORD PTR [eax]
  00043	d8 c9		 fmul	 ST(0), ST(1)
  00045	d8 48 08	 fmul	 DWORD PTR [eax+8]
  00048	d9 40 0c	 fld	 DWORD PTR [eax+12]
  0004b	d8 ca		 fmul	 ST(0), ST(2)
  0004d	d8 48 04	 fmul	 DWORD PTR [eax+4]
  00050	de e9		 fsubp	 ST(1), ST(0)
  00052	d9 59 20	 fstp	 DWORD PTR [ecx+32]

; 285  : 
; 286  : 	matrix[0][1]	=       ( quaternion[0] * 2 * quaternion[1] ) - ( quaternion[3] * 2 * quaternion[2] );

  00055	d9 00		 fld	 DWORD PTR [eax]
  00057	d8 c9		 fmul	 ST(0), ST(1)
  00059	d8 48 04	 fmul	 DWORD PTR [eax+4]
  0005c	d9 40 0c	 fld	 DWORD PTR [eax+12]
  0005f	d8 ca		 fmul	 ST(0), ST(2)
  00061	d8 48 08	 fmul	 DWORD PTR [eax+8]
  00064	de e9		 fsubp	 ST(1), ST(0)
  00066	d9 59 04	 fstp	 DWORD PTR [ecx+4]

; 287  : 	matrix[1][1]	= 1.0f - ( quaternion[0] * 2 * quaternion[0] ) - ( quaternion[2] * 2 * quaternion[2] );

  00069	d9 00		 fld	 DWORD PTR [eax]
  0006b	d8 c9		 fmul	 ST(0), ST(1)
  0006d	d8 08		 fmul	 DWORD PTR [eax]
  0006f	d8 ea		 fsubr	 ST(0), ST(2)
  00071	d9 40 08	 fld	 DWORD PTR [eax+8]
  00074	d8 ca		 fmul	 ST(0), ST(2)
  00076	d8 48 08	 fmul	 DWORD PTR [eax+8]
  00079	de e9		 fsubp	 ST(1), ST(0)
  0007b	d9 59 14	 fstp	 DWORD PTR [ecx+20]

; 288  : 	matrix[2][1]	=       ( quaternion[1] * 2 * quaternion[2] ) + ( quaternion[3] * 2 * quaternion[0] );

  0007e	d9 40 04	 fld	 DWORD PTR [eax+4]
  00081	d8 c9		 fmul	 ST(0), ST(1)
  00083	d8 48 08	 fmul	 DWORD PTR [eax+8]
  00086	d9 40 0c	 fld	 DWORD PTR [eax+12]
  00089	d8 ca		 fmul	 ST(0), ST(2)
  0008b	d8 08		 fmul	 DWORD PTR [eax]
  0008d	de c1		 faddp	 ST(1), ST(0)
  0008f	d9 59 24	 fstp	 DWORD PTR [ecx+36]

; 289  : 
; 290  : 	matrix[0][2]	=       ( quaternion[0] * 2 * quaternion[2] ) + ( quaternion[3] * 2 * quaternion[1] );

  00092	d9 40 0c	 fld	 DWORD PTR [eax+12]
  00095	d8 c9		 fmul	 ST(0), ST(1)
  00097	d8 48 04	 fmul	 DWORD PTR [eax+4]
  0009a	d9 00		 fld	 DWORD PTR [eax]
  0009c	d8 ca		 fmul	 ST(0), ST(2)
  0009e	d8 48 08	 fmul	 DWORD PTR [eax+8]
  000a1	de c1		 faddp	 ST(1), ST(0)
  000a3	d9 59 08	 fstp	 DWORD PTR [ecx+8]

; 291  : 	matrix[1][2]	=       ( quaternion[1] * 2 * quaternion[2] ) - ( quaternion[3] * 2 * quaternion[0] );

  000a6	d9 40 04	 fld	 DWORD PTR [eax+4]
  000a9	d8 c9		 fmul	 ST(0), ST(1)
  000ab	d8 48 08	 fmul	 DWORD PTR [eax+8]
  000ae	d9 40 0c	 fld	 DWORD PTR [eax+12]
  000b1	d8 ca		 fmul	 ST(0), ST(2)
  000b3	d8 08		 fmul	 DWORD PTR [eax]
  000b5	de e9		 fsubp	 ST(1), ST(0)
  000b7	d9 59 18	 fstp	 DWORD PTR [ecx+24]

; 292  : 	matrix[2][2]	= 1.0f - ( quaternion[0] * 2 * quaternion[0] ) - ( quaternion[1] * 2 * quaternion[1] );

  000ba	d9 00		 fld	 DWORD PTR [eax]
  000bc	d8 c9		 fmul	 ST(0), ST(1)
  000be	d8 08		 fmul	 DWORD PTR [eax]
  000c0	de ea		 fsubp	 ST(2), ST(0)
  000c2	d8 48 04	 fmul	 DWORD PTR [eax+4]
  000c5	d8 48 04	 fmul	 DWORD PTR [eax+4]
  000c8	de e9		 fsubp	 ST(1), ST(0)
  000ca	d9 59 28	 fstp	 DWORD PTR [ecx+40]

; 293  : }

  000cd	5d		 pop	 ebp
  000ce	c3		 ret	 0
?QuaternionMatrix@@YAXPBMPAY03M@Z ENDP			; QuaternionMatrix
_TEXT	ENDS
PUBLIC	_fabsf
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\math.h
;	COMDAT _fabsf
_TEXT	SEGMENT
tv129 = 8						; size = 4
__X$ = 8						; size = 4
_fabsf	PROC						; COMDAT

; 395  :         {return ((float)fabs((double)_X)); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	d9 45 08	 fld	 DWORD PTR __X$[ebp]
  00006	d9 e1		 fabs
  00008	d9 5d 08	 fstp	 DWORD PTR tv129[ebp]
  0000b	d9 45 08	 fld	 DWORD PTR tv129[ebp]
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
_fabsf	ENDP
_TEXT	ENDS
PUBLIC	_acosf
EXTRN	__CIacos:PROC
; Function compile flags: /Ogtp
;	COMDAT _acosf
_TEXT	SEGMENT
tv69 = 8						; size = 4
__X$ = 8						; size = 4
_acosf	PROC						; COMDAT

; 400  :         {return ((float)acos((double)_X)); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	d9 45 08	 fld	 DWORD PTR __X$[ebp]
  00006	e8 00 00 00 00	 call	 __CIacos
  0000b	d9 5d 08	 fstp	 DWORD PTR tv69[ebp]
  0000e	d9 45 08	 fld	 DWORD PTR tv69[ebp]
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
_acosf	ENDP
_TEXT	ENDS
PUBLIC	_cosf
EXTRN	__CIcos:PROC
; Function compile flags: /Ogtp
;	COMDAT _cosf
_TEXT	SEGMENT
tv69 = 8						; size = 4
__X$ = 8						; size = 4
_cosf	PROC						; COMDAT

; 410  :         {return ((float)cos((double)_X)); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	d9 45 08	 fld	 DWORD PTR __X$[ebp]
  00006	e8 00 00 00 00	 call	 __CIcos
  0000b	d9 5d 08	 fstp	 DWORD PTR tv69[ebp]
  0000e	d9 45 08	 fld	 DWORD PTR tv69[ebp]
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
_cosf	ENDP
_TEXT	ENDS
PUBLIC	_floorf
EXTRN	_floor:PROC
; Function compile flags: /Ogtp
;	COMDAT _floorf
_TEXT	SEGMENT
tv69 = 8						; size = 4
__X$ = 8						; size = 4
_floorf	PROC						; COMDAT

; 416  :         {return ((float)floor((double)_X)); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	d9 45 08	 fld	 DWORD PTR __X$[ebp]
  00006	83 ec 08	 sub	 esp, 8
  00009	dd 1c 24	 fstp	 QWORD PTR [esp]
  0000c	e8 00 00 00 00	 call	 _floor
  00011	d9 5d 08	 fstp	 DWORD PTR tv69[ebp]
  00014	83 c4 08	 add	 esp, 8
  00017	d9 45 08	 fld	 DWORD PTR tv69[ebp]
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
_floorf	ENDP
_TEXT	ENDS
PUBLIC	_sinf
EXTRN	__CIsin:PROC
; Function compile flags: /Ogtp
;	COMDAT _sinf
_TEXT	SEGMENT
tv69 = 8						; size = 4
__X$ = 8						; size = 4
_sinf	PROC						; COMDAT

; 430  :         {return ((float)sin((double)_X)); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	d9 45 08	 fld	 DWORD PTR __X$[ebp]
  00006	e8 00 00 00 00	 call	 __CIsin
  0000b	d9 5d 08	 fstp	 DWORD PTR tv69[ebp]
  0000e	d9 45 08	 fld	 DWORD PTR tv69[ebp]
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
_sinf	ENDP
_TEXT	ENDS
PUBLIC	_sqrtf
EXTRN	__CIsqrt:PROC
; Function compile flags: /Ogtp
;	COMDAT _sqrtf
_TEXT	SEGMENT
tv69 = 8						; size = 4
__X$ = 8						; size = 4
_sqrtf	PROC						; COMDAT

; 434  :         {return ((float)sqrt((double)_X)); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	d9 45 08	 fld	 DWORD PTR __X$[ebp]
  00006	e8 00 00 00 00	 call	 __CIsqrt
  0000b	d9 5d 08	 fstp	 DWORD PTR tv69[ebp]
  0000e	d9 45 08	 fld	 DWORD PTR tv69[ebp]
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
_sqrtf	ENDP
_TEXT	ENDS
PUBLIC	?acos@@YAMM@Z					; acos
; Function compile flags: /Ogtp
;	COMDAT ?acos@@YAMM@Z
_TEXT	SEGMENT
tv73 = 8						; size = 4
__X$ = 8						; size = 4
?acos@@YAMM@Z PROC					; acos, COMDAT

; 502  :         {return (acosf(_X)); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	d9 45 08	 fld	 DWORD PTR __X$[ebp]
  00006	e8 00 00 00 00	 call	 __CIacos
  0000b	d9 5d 08	 fstp	 DWORD PTR tv73[ebp]
  0000e	d9 45 08	 fld	 DWORD PTR tv73[ebp]
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?acos@@YAMM@Z ENDP					; acos
_TEXT	ENDS
PUBLIC	?cos@@YAMM@Z					; cos
; Function compile flags: /Ogtp
;	COMDAT ?cos@@YAMM@Z
_TEXT	SEGMENT
tv73 = 8						; size = 4
__X$ = 8						; size = 4
?cos@@YAMM@Z PROC					; cos, COMDAT

; 512  :         {return (cosf(_X)); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	d9 45 08	 fld	 DWORD PTR __X$[ebp]
  00006	e8 00 00 00 00	 call	 __CIcos
  0000b	d9 5d 08	 fstp	 DWORD PTR tv73[ebp]
  0000e	d9 45 08	 fld	 DWORD PTR tv73[ebp]
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?cos@@YAMM@Z ENDP					; cos
_TEXT	ENDS
PUBLIC	?fabs@@YAMM@Z					; fabs
; Function compile flags: /Ogtp
;	COMDAT ?fabs@@YAMM@Z
_TEXT	SEGMENT
tv131 = 8						; size = 4
__X$ = 8						; size = 4
?fabs@@YAMM@Z PROC					; fabs, COMDAT

; 518  :         {return (fabsf(_X)); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	d9 45 08	 fld	 DWORD PTR __X$[ebp]
  00006	d9 e1		 fabs
  00008	d9 5d 08	 fstp	 DWORD PTR tv131[ebp]
  0000b	d9 45 08	 fld	 DWORD PTR tv131[ebp]
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?fabs@@YAMM@Z ENDP					; fabs
_TEXT	ENDS
PUBLIC	?floor@@YAMM@Z					; floor
; Function compile flags: /Ogtp
;	COMDAT ?floor@@YAMM@Z
_TEXT	SEGMENT
tv73 = 8						; size = 4
__X$ = 8						; size = 4
?floor@@YAMM@Z PROC					; floor, COMDAT

; 520  :         {return (floorf(_X)); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	d9 45 08	 fld	 DWORD PTR __X$[ebp]
  00006	83 ec 08	 sub	 esp, 8
  00009	dd 1c 24	 fstp	 QWORD PTR [esp]
  0000c	e8 00 00 00 00	 call	 _floor
  00011	d9 5d 08	 fstp	 DWORD PTR tv73[ebp]
  00014	83 c4 08	 add	 esp, 8
  00017	d9 45 08	 fld	 DWORD PTR tv73[ebp]
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
?floor@@YAMM@Z ENDP					; floor
_TEXT	ENDS
PUBLIC	?sin@@YAMM@Z					; sin
; Function compile flags: /Ogtp
;	COMDAT ?sin@@YAMM@Z
_TEXT	SEGMENT
tv73 = 8						; size = 4
__X$ = 8						; size = 4
?sin@@YAMM@Z PROC					; sin, COMDAT

; 538  :         {return (sinf(_X)); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	d9 45 08	 fld	 DWORD PTR __X$[ebp]
  00006	e8 00 00 00 00	 call	 __CIsin
  0000b	d9 5d 08	 fstp	 DWORD PTR tv73[ebp]
  0000e	d9 45 08	 fld	 DWORD PTR tv73[ebp]
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?sin@@YAMM@Z ENDP					; sin
_TEXT	ENDS
PUBLIC	?sqrt@@YAMM@Z					; sqrt
; Function compile flags: /Ogtp
;	COMDAT ?sqrt@@YAMM@Z
_TEXT	SEGMENT
tv73 = 8						; size = 4
__X$ = 8						; size = 4
?sqrt@@YAMM@Z PROC					; sqrt, COMDAT

; 542  :         {return (sqrtf(_X)); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	d9 45 08	 fld	 DWORD PTR __X$[ebp]
  00006	e8 00 00 00 00	 call	 __CIsqrt
  0000b	d9 5d 08	 fstp	 DWORD PTR tv73[ebp]
  0000e	d9 45 08	 fld	 DWORD PTR tv73[ebp]
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?sqrt@@YAMM@Z ENDP					; sqrt
_TEXT	ENDS
PUBLIC	__real@0000000000000000
PUBLIC	?VectorLength@@YAMQAM@Z				; VectorLength
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
; Function compile flags: /Ogtp
; File c:\muserver_dev\development\mu-s8ep2-repack\gameserver\source\zzzmathlib.cpp
CONST	ENDS
;	COMDAT ?VectorLength@@YAMQAM@Z
_TEXT	SEGMENT
tv330 = -4						; size = 4
tv326 = -4						; size = 4
tv316 = -4						; size = 4
_length$ = -4						; size = 4
_v$ = 8							; size = 4
?VectorLength@@YAMQAM@Z PROC				; VectorLength, COMDAT

; 5    : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]
  00007	d9 00		 fld	 DWORD PTR [eax]

; 6    : 	int		i;
; 7    : 	float	length;
; 8    : 	
; 9    : 	length = 0.0f;
; 10   : 	for (i=0 ; i< 3 ; i++)
; 11   : 		length += v[i]*v[i];

  00009	d9 40 04	 fld	 DWORD PTR [eax+4]
  0000c	d9 40 08	 fld	 DWORD PTR [eax+8]
  0000f	d9 c2		 fld	 ST(2)
  00011	de cb		 fmulp	 ST(3), ST(0)
  00013	d9 ca		 fxch	 ST(2)
  00015	dc 05 00 00 00
	00		 fadd	 QWORD PTR __real@0000000000000000
  0001b	d9 5d fc	 fstp	 DWORD PTR tv330[ebp]
  0001e	d9 c0		 fld	 ST(0)
  00020	de c9		 fmulp	 ST(1), ST(0)
  00022	d8 45 fc	 fadd	 DWORD PTR tv330[ebp]
  00025	d9 5d fc	 fstp	 DWORD PTR tv326[ebp]
  00028	d9 c0		 fld	 ST(0)
  0002a	de c9		 fmulp	 ST(1), ST(0)
  0002c	d8 45 fc	 fadd	 DWORD PTR tv326[ebp]
  0002f	d9 5d fc	 fstp	 DWORD PTR _length$[ebp]

; 12   : 	length = sqrtf (length);
; 13   : 
; 14   : 	return length;

  00032	d9 45 fc	 fld	 DWORD PTR _length$[ebp]
  00035	e8 00 00 00 00	 call	 __CIsqrt
  0003a	d9 5d fc	 fstp	 DWORD PTR tv316[ebp]
  0003d	d9 45 fc	 fld	 DWORD PTR tv316[ebp]

; 15   : }

  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c3		 ret	 0
?VectorLength@@YAMQAM@Z ENDP				; VectorLength
_TEXT	ENDS
PUBLIC	__real@3f50624dd2f1a9fc
PUBLIC	?VectorCompare@@YAHQAM0@Z			; VectorCompare
;	COMDAT __real@3f50624dd2f1a9fc
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\math.h
CONST	SEGMENT
__real@3f50624dd2f1a9fc DQ 03f50624dd2f1a9fcr	; 0.001
; Function compile flags: /Ogtp
; File c:\muserver_dev\development\mu-s8ep2-repack\gameserver\source\zzzmathlib.cpp
CONST	ENDS
;	COMDAT ?VectorCompare@@YAHQAM0@Z
_TEXT	SEGMENT
tv281 = -4						; size = 4
tv274 = -4						; size = 4
_v1$ = 8						; size = 4
_v2$ = 12						; size = 4
?VectorCompare@@YAHQAM0@Z PROC				; VectorCompare, COMDAT

; 18   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 19   : 	int		i;
; 20   : 	
; 21   : 	for (i=0 ; i<3 ; i++)

  00004	8b 55 0c	 mov	 edx, DWORD PTR _v2$[ebp]
  00007	dd 05 00 00 00
	00		 fld	 QWORD PTR __real@3f50624dd2f1a9fc
  0000d	56		 push	 esi
  0000e	8b 75 08	 mov	 esi, DWORD PTR _v1$[ebp]
  00011	33 c9		 xor	 ecx, ecx
  00013	2b f2		 sub	 esi, edx
$LN4@VectorComp:

; 22   : 		if (fabs(v1[i]-v2[i]) > EQUAL_EPSILON)

  00015	d9 04 16	 fld	 DWORD PTR [esi+edx]
  00018	d8 22		 fsub	 DWORD PTR [edx]
  0001a	d9 5d fc	 fstp	 DWORD PTR tv281[ebp]
  0001d	d9 45 fc	 fld	 DWORD PTR tv281[ebp]
  00020	d9 e1		 fabs
  00022	d9 5d fc	 fstp	 DWORD PTR tv274[ebp]
  00025	d9 45 fc	 fld	 DWORD PTR tv274[ebp]
  00028	d8 d9		 fcomp	 ST(1)
  0002a	df e0		 fnstsw	 ax
  0002c	f6 c4 41	 test	 ah, 65			; 00000041H
  0002f	74 15		 je	 SHORT $LN16@VectorComp

; 19   : 	int		i;
; 20   : 	
; 21   : 	for (i=0 ; i<3 ; i++)

  00031	41		 inc	 ecx
  00032	83 c2 04	 add	 edx, 4
  00035	83 f9 03	 cmp	 ecx, 3
  00038	7c db		 jl	 SHORT $LN4@VectorComp
  0003a	dd d8		 fstp	 ST(0)

; 24   : 			
; 25   : 	return true;

  0003c	b8 01 00 00 00	 mov	 eax, 1
  00041	5e		 pop	 esi

; 26   : }

  00042	8b e5		 mov	 esp, ebp
  00044	5d		 pop	 ebp
  00045	c3		 ret	 0
$LN16@VectorComp:

; 22   : 		if (fabs(v1[i]-v2[i]) > EQUAL_EPSILON)

  00046	dd d8		 fstp	 ST(0)

; 23   : 			return false;

  00048	33 c0		 xor	 eax, eax
  0004a	5e		 pop	 esi

; 26   : }

  0004b	8b e5		 mov	 esp, ebp
  0004d	5d		 pop	 ebp
  0004e	c3		 ret	 0
?VectorCompare@@YAHQAM0@Z ENDP				; VectorCompare
_TEXT	ENDS
PUBLIC	__real@3fe0000000000000
PUBLIC	?Q_rint@@YAMM@Z					; Q_rint
;	COMDAT __real@3fe0000000000000
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\math.h
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
; Function compile flags: /Ogtp
; File c:\muserver_dev\development\mu-s8ep2-repack\gameserver\source\zzzmathlib.cpp
CONST	ENDS
;	COMDAT ?Q_rint@@YAMM@Z
_TEXT	SEGMENT
tv135 = 8						; size = 4
tv79 = 8						; size = 4
_in$ = 8						; size = 4
?Q_rint@@YAMM@Z PROC					; Q_rint, COMDAT

; 29   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 30   : 	return floor(in + 0.5f);

  00003	d9 45 08	 fld	 DWORD PTR _in$[ebp]
  00006	83 ec 08	 sub	 esp, 8
  00009	dc 05 00 00 00
	00		 fadd	 QWORD PTR __real@3fe0000000000000
  0000f	d9 5d 08	 fstp	 DWORD PTR tv135[ebp]
  00012	d9 45 08	 fld	 DWORD PTR tv135[ebp]
  00015	dd 1c 24	 fstp	 QWORD PTR [esp]
  00018	e8 00 00 00 00	 call	 _floor
  0001d	d9 5d 08	 fstp	 DWORD PTR tv79[ebp]
  00020	83 c4 08	 add	 esp, 8
  00023	d9 45 08	 fld	 DWORD PTR tv79[ebp]

; 31   : }

  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
?Q_rint@@YAMM@Z ENDP					; Q_rint
_TEXT	ENDS
PUBLIC	__real@00000000
PUBLIC	?VectorNormalize@@YAMQAM@Z			; VectorNormalize
;	COMDAT __real@00000000
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\math.h
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
; Function compile flags: /Ogtp
; File c:\muserver_dev\development\mu-s8ep2-repack\gameserver\source\zzzmathlib.cpp
CONST	ENDS
;	COMDAT ?VectorNormalize@@YAMQAM@Z
_TEXT	SEGMENT
tv470 = 8						; size = 4
tv466 = 8						; size = 4
tv457 = 8						; size = 4
_length$ = 8						; size = 4
_v$ = 8							; size = 4
?VectorNormalize@@YAMQAM@Z PROC				; VectorNormalize, COMDAT

; 83   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b 75 08	 mov	 esi, DWORD PTR _v$[ebp]
  00007	d9 06		 fld	 DWORD PTR [esi]

; 84   : 	int		i;
; 85   : 	float	length;
; 86   : 	
; 87   : 	if ( fabs(v[1]-0.0002159560000) < 0.0001 )
; 88   : 	{
; 89   : 		i=1;
; 90   : 	}
; 91   : 	length=0;
; 92   : 	for (i=0 ; i< 3 ; i++)
; 93   : 		length += v[i]*v[i];

  00009	d9 46 04	 fld	 DWORD PTR [esi+4]
  0000c	d9 46 08	 fld	 DWORD PTR [esi+8]
  0000f	d9 c2		 fld	 ST(2)
  00011	de cb		 fmulp	 ST(3), ST(0)
  00013	d9 ca		 fxch	 ST(2)
  00015	dc 05 00 00 00
	00		 fadd	 QWORD PTR __real@0000000000000000
  0001b	d9 5d 08	 fstp	 DWORD PTR tv470[ebp]
  0001e	d9 c0		 fld	 ST(0)
  00020	de c9		 fmulp	 ST(1), ST(0)
  00022	d8 45 08	 fadd	 DWORD PTR tv470[ebp]
  00025	d9 5d 08	 fstp	 DWORD PTR tv466[ebp]
  00028	d9 c0		 fld	 ST(0)
  0002a	de c9		 fmulp	 ST(1), ST(0)
  0002c	d8 45 08	 fadd	 DWORD PTR tv466[ebp]
  0002f	d9 5d 08	 fstp	 DWORD PTR _length$[ebp]

; 94   : 	length = sqrtf (length);

  00032	d9 45 08	 fld	 DWORD PTR _length$[ebp]
  00035	e8 00 00 00 00	 call	 __CIsqrt
  0003a	d9 5d 08	 fstp	 DWORD PTR tv457[ebp]
  0003d	d9 45 08	 fld	 DWORD PTR tv457[ebp]
  00040	d9 5d 08	 fstp	 DWORD PTR _length$[ebp]

; 95   : 	if (length == 0)

  00043	d9 45 08	 fld	 DWORD PTR _length$[ebp]
  00046	d9 c0		 fld	 ST(0)
  00048	d9 ee		 fldz
  0004a	d9 c0		 fld	 ST(0)
  0004c	dd ea		 fucomp	 ST(2)
  0004e	df e0		 fnstsw	 ax
  00050	dd d9		 fstp	 ST(1)
  00052	f6 c4 44	 test	 ah, 68			; 00000044H
  00055	7a 05		 jp	 SHORT $LN26@VectorNorm
  00057	dd d9		 fstp	 ST(1)
  00059	5e		 pop	 esi

; 100  : 
; 101  : 	return length;
; 102  : }

  0005a	5d		 pop	 ebp
  0005b	c3		 ret	 0
$LN26@VectorNorm:

; 95   : 	if (length == 0)

  0005c	dd d8		 fstp	 ST(0)

; 96   : 		return (vec_t)0;
; 97   : 		
; 98   : 	for (i=0 ; i< 3 ; i++)
; 99   : 		v[i] /= length;	

  0005e	d9 06		 fld	 DWORD PTR [esi]
  00060	d8 f1		 fdiv	 ST(0), ST(1)
  00062	d9 1e		 fstp	 DWORD PTR [esi]
  00064	d9 46 04	 fld	 DWORD PTR [esi+4]
  00067	d8 f1		 fdiv	 ST(0), ST(1)
  00069	d9 5e 04	 fstp	 DWORD PTR [esi+4]
  0006c	d9 46 08	 fld	 DWORD PTR [esi+8]
  0006f	d8 f1		 fdiv	 ST(0), ST(1)
  00071	d9 5e 08	 fstp	 DWORD PTR [esi+8]
  00074	5e		 pop	 esi

; 100  : 
; 101  : 	return length;
; 102  : }

  00075	5d		 pop	 ebp
  00076	c3		 ret	 0
?VectorNormalize@@YAMQAM@Z ENDP				; VectorNormalize
_TEXT	ENDS
PUBLIC	__real@3f91df46a0000000
PUBLIC	?AngleMatrix@@YAXPBMPAY03M@Z			; AngleMatrix
;	COMDAT __real@3f91df46a0000000
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\math.h
CONST	SEGMENT
__real@3f91df46a0000000 DQ 03f91df46a0000000r	; 0.0174533
; Function compile flags: /Ogtp
; File c:\muserver_dev\development\mu-s8ep2-repack\gameserver\source\zzzmathlib.cpp
CONST	ENDS
;	COMDAT ?AngleMatrix@@YAXPBMPAY03M@Z
_TEXT	SEGMENT
tv347 = -24						; size = 8
tv329 = -24						; size = 8
_sy$ = -20						; size = 4
_cy$ = -16						; size = 4
_cp$ = -12						; size = 4
tv309 = -8						; size = 4
_sr$ = -8						; size = 4
tv340 = -4						; size = 4
tv324 = -4						; size = 4
_sp$ = -4						; size = 4
tv333 = 8						; size = 4
tv317 = 8						; size = 4
tv302 = 8						; size = 4
_cr$ = 8						; size = 4
_angle$ = 8						; size = 4
_angles$ = 8						; size = 4
_matrix$ = 12						; size = 4
?AngleMatrix@@YAXPBMPAY03M@Z PROC			; AngleMatrix, COMDAT

; 142  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	56		 push	 esi

; 143  : 	float		angle;
; 144  : 	float		sr, sp, sy, cr, cp, cy;
; 145  : 	
; 146  : 	angle = angles[ROLL] *	0.0174532925199432955f;		//0.0174532821447436905f;

  00007	8b 75 08	 mov	 esi, DWORD PTR _angles$[ebp]
  0000a	d9 46 08	 fld	 DWORD PTR [esi+8]
  0000d	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@3f91df46a0000000
  00013	d9 5d 08	 fstp	 DWORD PTR _angle$[ebp]

; 147  : 	sy = sin(angle);

  00016	d9 45 08	 fld	 DWORD PTR _angle$[ebp]
  00019	e8 00 00 00 00	 call	 __CIsin
  0001e	d9 5d fc	 fstp	 DWORD PTR tv340[ebp]
  00021	d9 45 fc	 fld	 DWORD PTR tv340[ebp]
  00024	d9 5d ec	 fstp	 DWORD PTR _sy$[ebp]

; 148  : 	cy = cos(angle);

  00027	d9 45 08	 fld	 DWORD PTR _angle$[ebp]
  0002a	e8 00 00 00 00	 call	 __CIcos
  0002f	d9 5d 08	 fstp	 DWORD PTR tv333[ebp]
  00032	d9 45 08	 fld	 DWORD PTR tv333[ebp]
  00035	d9 5d f0	 fstp	 DWORD PTR _cy$[ebp]

; 149  : 	angle = angles[YAW] *   0.0174532925199432955f;

  00038	d9 46 04	 fld	 DWORD PTR [esi+4]
  0003b	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@3f91df46a0000000
  00041	d9 5d 08	 fstp	 DWORD PTR _angle$[ebp]

; 150  : 	sp = sin(angle);   //ST=0.0174532923847436905

  00044	d9 45 08	 fld	 DWORD PTR _angle$[ebp]
  00047	e8 00 00 00 00	 call	 __CIsin
  0004c	d9 5d fc	 fstp	 DWORD PTR tv324[ebp]
  0004f	d9 45 fc	 fld	 DWORD PTR tv324[ebp]
  00052	d9 5d fc	 fstp	 DWORD PTR _sp$[ebp]

; 151  : 	cp = cos(angle);

  00055	d9 45 08	 fld	 DWORD PTR _angle$[ebp]
  00058	e8 00 00 00 00	 call	 __CIcos
  0005d	d9 5d 08	 fstp	 DWORD PTR tv317[ebp]
  00060	d9 45 08	 fld	 DWORD PTR tv317[ebp]
  00063	d9 5d f4	 fstp	 DWORD PTR _cp$[ebp]

; 152  : 	angle = angles[PITCH] * 0.0174532925199432955f;		//0.0174532821247436905f;

  00066	d9 06		 fld	 DWORD PTR [esi]
  00068	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@3f91df46a0000000
  0006e	d9 5d 08	 fstp	 DWORD PTR _angle$[ebp]

; 153  : 	sr = sin(angle);

  00071	d9 45 08	 fld	 DWORD PTR _angle$[ebp]
  00074	e8 00 00 00 00	 call	 __CIsin
  00079	d9 5d f8	 fstp	 DWORD PTR tv309[ebp]
  0007c	d9 45 f8	 fld	 DWORD PTR tv309[ebp]
  0007f	d9 5d f8	 fstp	 DWORD PTR _sr$[ebp]

; 154  : 	cr = cos(angle);

  00082	d9 45 08	 fld	 DWORD PTR _angle$[ebp]
  00085	e8 00 00 00 00	 call	 __CIcos
  0008a	d9 5d 08	 fstp	 DWORD PTR tv302[ebp]
  0008d	d9 45 08	 fld	 DWORD PTR tv302[ebp]

; 155  : 
; 156  : 	// matrix = (YAW * PITCH) * ROLL
; 157  : 	matrix[0][0] = cp*cy;

  00090	8b 45 0c	 mov	 eax, DWORD PTR _matrix$[ebp]
  00093	d9 5d 08	 fstp	 DWORD PTR _cr$[ebp]
  00096	d9 45 f4	 fld	 DWORD PTR _cp$[ebp]
  00099	d9 c0		 fld	 ST(0)
  0009b	d9 45 f0	 fld	 DWORD PTR _cy$[ebp]
  0009e	d9 c0		 fld	 ST(0)
  000a0	de ca		 fmulp	 ST(2), ST(0)
  000a2	d9 c9		 fxch	 ST(1)
  000a4	d9 18		 fstp	 DWORD PTR [eax]

; 158  : 	matrix[1][0] = cp*sy;

  000a6	d9 c1		 fld	 ST(1)
  000a8	d9 45 ec	 fld	 DWORD PTR _sy$[ebp]
  000ab	d9 c0		 fld	 ST(0)
  000ad	de ca		 fmulp	 ST(2), ST(0)
  000af	d9 c9		 fxch	 ST(1)
  000b1	d9 58 10	 fstp	 DWORD PTR [eax+16]

; 159  : 	matrix[2][0] = -sp;

  000b4	d9 45 fc	 fld	 DWORD PTR _sp$[ebp]
  000b7	d9 c0		 fld	 ST(0)
  000b9	d9 e0		 fchs
  000bb	d9 58 20	 fstp	 DWORD PTR [eax+32]

; 160  : 	matrix[0][1] = sr*sp*cy+cr*-sy;

  000be	d9 45 f8	 fld	 DWORD PTR _sr$[ebp]
  000c1	d9 c0		 fld	 ST(0)
  000c3	de ca		 fmulp	 ST(2), ST(0)
  000c5	d9 c9		 fxch	 ST(1)
  000c7	dd 55 e8	 fst	 QWORD PTR tv329[ebp]
  000ca	d8 cb		 fmul	 ST(0), ST(3)
  000cc	d9 45 08	 fld	 DWORD PTR _cr$[ebp]
  000cf	d9 c0		 fld	 ST(0)
  000d1	d8 cc		 fmul	 ST(0), ST(4)
  000d3	de ea		 fsubp	 ST(2), ST(0)
  000d5	d9 c9		 fxch	 ST(1)
  000d7	d9 58 04	 fstp	 DWORD PTR [eax+4]

; 161  : 	matrix[1][1] = sr*sp*sy+cr*cy;

  000da	d9 c0		 fld	 ST(0)
  000dc	d8 cc		 fmul	 ST(0), ST(4)
  000de	d9 c3		 fld	 ST(3)
  000e0	dc 4d e8	 fmul	 QWORD PTR tv329[ebp]
  000e3	de c1		 faddp	 ST(1), ST(0)
  000e5	d9 58 14	 fstp	 DWORD PTR [eax+20]

; 162  : 	matrix[2][1] = sr*cp;

  000e8	d9 c1		 fld	 ST(1)
  000ea	d8 cd		 fmul	 ST(0), ST(5)
  000ec	d9 58 24	 fstp	 DWORD PTR [eax+36]

; 163  : 	matrix[0][2] = (cr*sp*cy+-sr*-sy);

  000ef	d9 c0		 fld	 ST(0)
  000f1	d8 4d fc	 fmul	 DWORD PTR _sp$[ebp]
  000f4	5e		 pop	 esi
  000f5	dd 55 e8	 fst	 QWORD PTR tv347[ebp]
  000f8	d8 cc		 fmul	 ST(0), ST(4)
  000fa	d9 c3		 fld	 ST(3)
  000fc	d9 e0		 fchs
  000fe	d8 cb		 fmul	 ST(0), ST(3)
  00100	de e9		 fsubp	 ST(1), ST(0)
  00102	d9 58 08	 fstp	 DWORD PTR [eax+8]

; 164  : 	matrix[1][2] = (cr*sp*sy+-sr*cy);

  00105	d9 ca		 fxch	 ST(2)
  00107	dc 4d e8	 fmul	 QWORD PTR tv347[ebp]
  0010a	d9 c9		 fxch	 ST(1)
  0010c	de cb		 fmulp	 ST(3), ST(0)
  0010e	de e2		 fsubrp	 ST(2), ST(0)
  00110	d9 c9		 fxch	 ST(1)
  00112	d9 58 18	 fstp	 DWORD PTR [eax+24]

; 165  : 	matrix[2][2] = cr*cp;

  00115	de c9		 fmulp	 ST(1), ST(0)
  00117	d9 58 28	 fstp	 DWORD PTR [eax+40]

; 166  : 	matrix[0][3] = 0.0;

  0011a	d9 ee		 fldz
  0011c	d9 50 0c	 fst	 DWORD PTR [eax+12]

; 167  : 	matrix[1][3] = 0.0;

  0011f	d9 50 1c	 fst	 DWORD PTR [eax+28]

; 168  : 	matrix[2][3] = 0.0;

  00122	d9 58 2c	 fstp	 DWORD PTR [eax+44]

; 169  : }

  00125	8b e5		 mov	 esp, ebp
  00127	5d		 pop	 ebp
  00128	c3		 ret	 0
?AngleMatrix@@YAXPBMPAY03M@Z ENDP			; AngleMatrix
_TEXT	ENDS
PUBLIC	?AngleIMatrix@@YAXQBMQAY03M@Z			; AngleIMatrix
; Function compile flags: /Ogtp
;	COMDAT ?AngleIMatrix@@YAXQBMQAY03M@Z
_TEXT	SEGMENT
tv347 = -24						; size = 8
tv329 = -24						; size = 8
_sy$ = -20						; size = 4
_cy$ = -16						; size = 4
_cp$ = -12						; size = 4
tv309 = -8						; size = 4
_sr$ = -8						; size = 4
tv340 = -4						; size = 4
tv324 = -4						; size = 4
_sp$ = -4						; size = 4
tv333 = 8						; size = 4
tv317 = 8						; size = 4
tv302 = 8						; size = 4
_cr$ = 8						; size = 4
_angle$ = 8						; size = 4
_angles$ = 8						; size = 4
_matrix$ = 12						; size = 4
?AngleIMatrix@@YAXQBMQAY03M@Z PROC			; AngleIMatrix, COMDAT

; 172  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	56		 push	 esi

; 173  : 	float angle;
; 174  : 	float sr, sp, sy, cr, cp, cy;
; 175  : 	
; 176  : 	angle = angles[ROLL] * (float)(0.0174532925199432955f);

  00007	8b 75 08	 mov	 esi, DWORD PTR _angles$[ebp]
  0000a	d9 46 08	 fld	 DWORD PTR [esi+8]
  0000d	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@3f91df46a0000000
  00013	d9 5d 08	 fstp	 DWORD PTR _angle$[ebp]

; 177  : 	sy = sin(angle);

  00016	d9 45 08	 fld	 DWORD PTR _angle$[ebp]
  00019	e8 00 00 00 00	 call	 __CIsin
  0001e	d9 5d fc	 fstp	 DWORD PTR tv340[ebp]
  00021	d9 45 fc	 fld	 DWORD PTR tv340[ebp]
  00024	d9 5d ec	 fstp	 DWORD PTR _sy$[ebp]

; 178  : 	cy = cos(angle);

  00027	d9 45 08	 fld	 DWORD PTR _angle$[ebp]
  0002a	e8 00 00 00 00	 call	 __CIcos
  0002f	d9 5d 08	 fstp	 DWORD PTR tv333[ebp]
  00032	d9 45 08	 fld	 DWORD PTR tv333[ebp]
  00035	d9 5d f0	 fstp	 DWORD PTR _cy$[ebp]

; 179  : 	angle = angles[YAW] * (float)(0.0174532925199432955f);

  00038	d9 46 04	 fld	 DWORD PTR [esi+4]
  0003b	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@3f91df46a0000000
  00041	d9 5d 08	 fstp	 DWORD PTR _angle$[ebp]

; 180  : 	sp = sin(angle);

  00044	d9 45 08	 fld	 DWORD PTR _angle$[ebp]
  00047	e8 00 00 00 00	 call	 __CIsin
  0004c	d9 5d fc	 fstp	 DWORD PTR tv324[ebp]
  0004f	d9 45 fc	 fld	 DWORD PTR tv324[ebp]
  00052	d9 5d fc	 fstp	 DWORD PTR _sp$[ebp]

; 181  : 	cp = cos(angle);

  00055	d9 45 08	 fld	 DWORD PTR _angle$[ebp]
  00058	e8 00 00 00 00	 call	 __CIcos
  0005d	d9 5d 08	 fstp	 DWORD PTR tv317[ebp]
  00060	d9 45 08	 fld	 DWORD PTR tv317[ebp]
  00063	d9 5d f4	 fstp	 DWORD PTR _cp$[ebp]

; 182  : 	angle = angles[PITCH] * (float)(0.0174532925199432955f);	// M_PI*2 /360

  00066	d9 06		 fld	 DWORD PTR [esi]
  00068	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@3f91df46a0000000
  0006e	d9 5d 08	 fstp	 DWORD PTR _angle$[ebp]

; 183  : 	sr = sin(angle);

  00071	d9 45 08	 fld	 DWORD PTR _angle$[ebp]
  00074	e8 00 00 00 00	 call	 __CIsin
  00079	d9 5d f8	 fstp	 DWORD PTR tv309[ebp]
  0007c	d9 45 f8	 fld	 DWORD PTR tv309[ebp]
  0007f	d9 5d f8	 fstp	 DWORD PTR _sr$[ebp]

; 184  : 	cr = cos(angle);

  00082	d9 45 08	 fld	 DWORD PTR _angle$[ebp]
  00085	e8 00 00 00 00	 call	 __CIcos
  0008a	d9 5d 08	 fstp	 DWORD PTR tv302[ebp]
  0008d	d9 45 08	 fld	 DWORD PTR tv302[ebp]

; 185  : 
; 186  : 	// matrix = (YAW * PITCH) * ROLL
; 187  : 	matrix[0][0] = cp*cy;

  00090	8b 45 0c	 mov	 eax, DWORD PTR _matrix$[ebp]
  00093	d9 5d 08	 fstp	 DWORD PTR _cr$[ebp]
  00096	d9 45 f4	 fld	 DWORD PTR _cp$[ebp]
  00099	d9 c0		 fld	 ST(0)
  0009b	d9 45 f0	 fld	 DWORD PTR _cy$[ebp]
  0009e	d9 c0		 fld	 ST(0)
  000a0	de ca		 fmulp	 ST(2), ST(0)
  000a2	d9 c9		 fxch	 ST(1)
  000a4	d9 18		 fstp	 DWORD PTR [eax]

; 188  : 	matrix[0][1] = cp*sy;

  000a6	d9 c1		 fld	 ST(1)
  000a8	d9 45 ec	 fld	 DWORD PTR _sy$[ebp]
  000ab	d9 c0		 fld	 ST(0)
  000ad	de ca		 fmulp	 ST(2), ST(0)
  000af	d9 c9		 fxch	 ST(1)
  000b1	d9 58 04	 fstp	 DWORD PTR [eax+4]

; 189  : 	matrix[0][2] = -sp;

  000b4	d9 45 fc	 fld	 DWORD PTR _sp$[ebp]
  000b7	d9 c0		 fld	 ST(0)
  000b9	d9 e0		 fchs
  000bb	d9 58 08	 fstp	 DWORD PTR [eax+8]

; 190  : 	matrix[1][0] = sr*sp*cy+cr*-sy;

  000be	d9 45 f8	 fld	 DWORD PTR _sr$[ebp]
  000c1	d9 c0		 fld	 ST(0)
  000c3	de ca		 fmulp	 ST(2), ST(0)
  000c5	d9 c9		 fxch	 ST(1)
  000c7	dd 55 e8	 fst	 QWORD PTR tv329[ebp]
  000ca	d8 cb		 fmul	 ST(0), ST(3)
  000cc	d9 45 08	 fld	 DWORD PTR _cr$[ebp]
  000cf	d9 c0		 fld	 ST(0)
  000d1	d8 cc		 fmul	 ST(0), ST(4)
  000d3	de ea		 fsubp	 ST(2), ST(0)
  000d5	d9 c9		 fxch	 ST(1)
  000d7	d9 58 10	 fstp	 DWORD PTR [eax+16]

; 191  : 	matrix[1][1] = sr*sp*sy+cr*cy;

  000da	d9 c0		 fld	 ST(0)
  000dc	d8 cc		 fmul	 ST(0), ST(4)
  000de	d9 c3		 fld	 ST(3)
  000e0	dc 4d e8	 fmul	 QWORD PTR tv329[ebp]
  000e3	de c1		 faddp	 ST(1), ST(0)
  000e5	d9 58 14	 fstp	 DWORD PTR [eax+20]

; 192  : 	matrix[1][2] = sr*cp;

  000e8	d9 c1		 fld	 ST(1)
  000ea	d8 cd		 fmul	 ST(0), ST(5)
  000ec	d9 58 18	 fstp	 DWORD PTR [eax+24]

; 193  : 	matrix[2][0] = (cr*sp*cy+-sr*-sy);

  000ef	d9 c0		 fld	 ST(0)
  000f1	d8 4d fc	 fmul	 DWORD PTR _sp$[ebp]
  000f4	5e		 pop	 esi
  000f5	dd 55 e8	 fst	 QWORD PTR tv347[ebp]
  000f8	d8 cc		 fmul	 ST(0), ST(4)
  000fa	d9 c3		 fld	 ST(3)
  000fc	d9 e0		 fchs
  000fe	d8 cb		 fmul	 ST(0), ST(3)
  00100	de e9		 fsubp	 ST(1), ST(0)
  00102	d9 58 20	 fstp	 DWORD PTR [eax+32]

; 194  : 	matrix[2][1] = (cr*sp*sy+-sr*cy);

  00105	d9 ca		 fxch	 ST(2)
  00107	dc 4d e8	 fmul	 QWORD PTR tv347[ebp]
  0010a	d9 c9		 fxch	 ST(1)
  0010c	de cb		 fmulp	 ST(3), ST(0)
  0010e	de e2		 fsubrp	 ST(2), ST(0)
  00110	d9 c9		 fxch	 ST(1)
  00112	d9 58 24	 fstp	 DWORD PTR [eax+36]

; 195  : 	matrix[2][2] = cr*cp;

  00115	de c9		 fmulp	 ST(1), ST(0)
  00117	d9 58 28	 fstp	 DWORD PTR [eax+40]

; 196  : 	matrix[0][3] = 0.0;

  0011a	d9 ee		 fldz
  0011c	d9 50 0c	 fst	 DWORD PTR [eax+12]

; 197  : 	matrix[1][3] = 0.0;

  0011f	d9 50 1c	 fst	 DWORD PTR [eax+28]

; 198  : 	matrix[2][3] = 0.0;

  00122	d9 58 2c	 fstp	 DWORD PTR [eax+44]

; 199  : }

  00125	8b e5		 mov	 esp, ebp
  00127	5d		 pop	 ebp
  00128	c3		 ret	 0
?AngleIMatrix@@YAXQBMQAY03M@Z ENDP			; AngleIMatrix
_TEXT	ENDS
PUBLIC	?AngleQuaternion@@YAXQBMPAM@Z			; AngleQuaternion
; Function compile flags: /Ogtp
;	COMDAT ?AngleQuaternion@@YAXQBMPAM@Z
_TEXT	SEGMENT
_sy$ = -20						; size = 4
_cy$ = -16						; size = 4
_cp$ = -12						; size = 4
tv72 = -8						; size = 4
_sr$ = -8						; size = 4
tv282 = -4						; size = 4
tv267 = -4						; size = 4
_sp$ = -4						; size = 4
tv275 = 8						; size = 4
tv260 = 8						; size = 4
tv177 = 8						; size = 4
_cr$ = 8						; size = 4
_angle$ = 8						; size = 4
_angles$ = 8						; size = 4
_quaternion$ = 12					; size = 4
?AngleQuaternion@@YAXQBMPAM@Z PROC			; AngleQuaternion, COMDAT

; 256  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	56		 push	 esi

; 257  : 	float angle;
; 258  : 	float sr, sp, sy, cr, cp, cy;
; 259  : 
; 260  : 	angle	= angles[2] * 0.5f;

  00007	8b 75 08	 mov	 esi, DWORD PTR _angles$[ebp]
  0000a	d9 46 08	 fld	 DWORD PTR [esi+8]
  0000d	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@3fe0000000000000
  00013	d9 5d 08	 fstp	 DWORD PTR _angle$[ebp]

; 261  : 	sy	= (float)sin(angle);

  00016	d9 45 08	 fld	 DWORD PTR _angle$[ebp]
  00019	e8 00 00 00 00	 call	 __CIsin
  0001e	d9 5d fc	 fstp	 DWORD PTR tv282[ebp]
  00021	d9 45 fc	 fld	 DWORD PTR tv282[ebp]
  00024	d9 5d ec	 fstp	 DWORD PTR _sy$[ebp]

; 262  : 	cy	= (float)cos(angle);

  00027	d9 45 08	 fld	 DWORD PTR _angle$[ebp]
  0002a	e8 00 00 00 00	 call	 __CIcos
  0002f	d9 5d 08	 fstp	 DWORD PTR tv275[ebp]
  00032	d9 45 08	 fld	 DWORD PTR tv275[ebp]
  00035	d9 5d f0	 fstp	 DWORD PTR _cy$[ebp]

; 263  : 
; 264  : 	angle			= angles[1] * 0.5f;

  00038	d9 46 04	 fld	 DWORD PTR [esi+4]
  0003b	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@3fe0000000000000
  00041	d9 5d 08	 fstp	 DWORD PTR _angle$[ebp]

; 265  : 	sp	= (float)sin(angle);

  00044	d9 45 08	 fld	 DWORD PTR _angle$[ebp]
  00047	e8 00 00 00 00	 call	 __CIsin
  0004c	d9 5d fc	 fstp	 DWORD PTR tv267[ebp]
  0004f	d9 45 fc	 fld	 DWORD PTR tv267[ebp]
  00052	d9 5d fc	 fstp	 DWORD PTR _sp$[ebp]

; 266  : 	cp	= (float)cos(angle);

  00055	d9 45 08	 fld	 DWORD PTR _angle$[ebp]
  00058	e8 00 00 00 00	 call	 __CIcos
  0005d	d9 5d 08	 fstp	 DWORD PTR tv260[ebp]
  00060	d9 45 08	 fld	 DWORD PTR tv260[ebp]
  00063	d9 5d f4	 fstp	 DWORD PTR _cp$[ebp]

; 267  : 
; 268  : 	angle			= angles[0] * 0.5f;

  00066	d9 06		 fld	 DWORD PTR [esi]
  00068	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@3fe0000000000000
  0006e	d9 5d 08	 fstp	 DWORD PTR _angle$[ebp]

; 269  : 	sr	= (float)sin(angle);

  00071	d9 45 08	 fld	 DWORD PTR _angle$[ebp]
  00074	e8 00 00 00 00	 call	 __CIsin
  00079	d9 5d f8	 fstp	 DWORD PTR tv72[ebp]
  0007c	d9 45 f8	 fld	 DWORD PTR tv72[ebp]
  0007f	d9 5d f8	 fstp	 DWORD PTR _sr$[ebp]

; 270  : 	cr	= (float)cos(angle);

  00082	d9 45 08	 fld	 DWORD PTR _angle$[ebp]
  00085	e8 00 00 00 00	 call	 __CIcos
  0008a	d9 5d 08	 fstp	 DWORD PTR tv177[ebp]
  0008d	d9 45 08	 fld	 DWORD PTR tv177[ebp]

; 271  : 
; 272  : 	quaternion[0]	= sr * cp * cy - cr * sp * sy;

  00090	8b 45 0c	 mov	 eax, DWORD PTR _quaternion$[ebp]
  00093	d9 5d 08	 fstp	 DWORD PTR _cr$[ebp]
  00096	5e		 pop	 esi
  00097	d9 45 f8	 fld	 DWORD PTR _sr$[ebp]
  0009a	d9 c0		 fld	 ST(0)
  0009c	d9 45 f4	 fld	 DWORD PTR _cp$[ebp]
  0009f	d9 c0		 fld	 ST(0)
  000a1	de ca		 fmulp	 ST(2), ST(0)
  000a3	d9 45 08	 fld	 DWORD PTR _cr$[ebp]
  000a6	d8 4d fc	 fmul	 DWORD PTR _sp$[ebp]
  000a9	d9 45 f0	 fld	 DWORD PTR _cy$[ebp]
  000ac	d9 c0		 fld	 ST(0)
  000ae	d8 cc		 fmul	 ST(0), ST(4)
  000b0	d9 45 ec	 fld	 DWORD PTR _sy$[ebp]
  000b3	d9 c0		 fld	 ST(0)
  000b5	d8 cc		 fmul	 ST(0), ST(4)
  000b7	de ea		 fsubp	 ST(2), ST(0)
  000b9	d9 c9		 fxch	 ST(1)
  000bb	d9 18		 fstp	 DWORD PTR [eax]

; 273  : 	quaternion[1]	= cr * sp * cy + sr * cp * sy;

  000bd	d9 c1		 fld	 ST(1)
  000bf	de cb		 fmulp	 ST(3), ST(0)
  000c1	d9 c0		 fld	 ST(0)
  000c3	de cd		 fmulp	 ST(5), ST(0)
  000c5	d9 ca		 fxch	 ST(2)
  000c7	de c4		 faddp	 ST(4), ST(0)
  000c9	d9 cb		 fxch	 ST(3)
  000cb	d9 58 04	 fstp	 DWORD PTR [eax+4]

; 274  : 	quaternion[2]	= cr * cp * sy - sr * sp * cy;

  000ce	d9 45 08	 fld	 DWORD PTR _cr$[ebp]
  000d1	de ca		 fmulp	 ST(2), ST(0)
  000d3	d9 45 fc	 fld	 DWORD PTR _sp$[ebp]
  000d6	de cc		 fmulp	 ST(4), ST(0)
  000d8	d9 c0		 fld	 ST(0)
  000da	d8 ca		 fmul	 ST(0), ST(2)
  000dc	d9 c3		 fld	 ST(3)
  000de	d8 cd		 fmul	 ST(0), ST(5)
  000e0	de e9		 fsubp	 ST(1), ST(0)
  000e2	d9 58 08	 fstp	 DWORD PTR [eax+8]

; 275  : 	quaternion[3]	= cr * cp * cy + sr * sp * sy;

  000e5	de cb		 fmulp	 ST(3), ST(0)
  000e7	de c9		 fmulp	 ST(1), ST(0)
  000e9	de c1		 faddp	 ST(1), ST(0)
  000eb	d9 58 0c	 fstp	 DWORD PTR [eax+12]

; 276  : }

  000ee	8b e5		 mov	 esp, ebp
  000f0	5d		 pop	 ebp
  000f1	c3		 ret	 0
?AngleQuaternion@@YAXQBMPAM@Z ENDP			; AngleQuaternion
_TEXT	ENDS
PUBLIC	__real@400921fb60000000
PUBLIC	__real@bff0000000000000
PUBLIC	?QuaternionSlerp@@YAXPBMPAMM1@Z			; QuaternionSlerp
;	COMDAT __real@400921fb60000000
; File c:\program files (x86)\microsoft visual studio 10.0\vc\include\math.h
CONST	SEGMENT
__real@400921fb60000000 DQ 0400921fb60000000r	; 3.14159
CONST	ENDS
;	COMDAT __real@bff0000000000000
CONST	SEGMENT
__real@bff0000000000000 DQ 0bff0000000000000r	; -1
; Function compile flags: /Ogtp
; File c:\muserver_dev\development\mu-s8ep2-repack\gameserver\source\zzzmathlib.cpp
CONST	ENDS
;	COMDAT ?QuaternionSlerp@@YAXPBMPAMM1@Z
_TEXT	SEGMENT
_sinom$ = -4						; size = 4
tv1734 = 8						; size = 4
tv1729 = 8						; size = 4
tv1725 = 8						; size = 4
tv1710 = 8						; size = 4
tv1706 = 8						; size = 4
tv1701 = 8						; size = 4
tv1673 = 8						; size = 4
tv1666 = 8						; size = 4
tv1661 = 8						; size = 4
tv1655 = 8						; size = 4
tv1625 = 8						; size = 4
tv1618 = 8						; size = 4
_sclp$ = 8						; size = 4
_cosom$ = 8						; size = 4
_b$ = 8							; size = 4
_p$ = 8							; size = 4
tv1649 = 12						; size = 4
tv1643 = 12						; size = 4
tv1615 = 12						; size = 4
tv1609 = 12						; size = 4
_sclq$ = 12						; size = 4
_omega$ = 12						; size = 4
_a$ = 12						; size = 4
_q$ = 12						; size = 4
_t$ = 16						; size = 4
_qt$ = 20						; size = 4
?QuaternionSlerp@@YAXPBMPAMM1@Z PROC			; QuaternionSlerp, COMDAT

; 301  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	8b 75 08	 mov	 esi, DWORD PTR _p$[ebp]
  00008	d9 06		 fld	 DWORD PTR [esi]
  0000a	57		 push	 edi
  0000b	8b 7d 0c	 mov	 edi, DWORD PTR _q$[ebp]
  0000e	d8 27		 fsub	 DWORD PTR [edi]
  00010	d9 46 04	 fld	 DWORD PTR [esi+4]
  00013	d8 67 04	 fsub	 DWORD PTR [edi+4]
  00016	d9 46 08	 fld	 DWORD PTR [esi+8]
  00019	d8 67 08	 fsub	 DWORD PTR [edi+8]
  0001c	d9 46 0c	 fld	 DWORD PTR [esi+12]
  0001f	d8 67 0c	 fsub	 DWORD PTR [edi+12]

; 302  : 	int i;
; 303  : 	float omega;
; 304  : 	float cosom;
; 305  : 	float sinom;
; 306  : 	float sclp;
; 307  : 	float sclq;
; 308  : 	float a=0;
; 309  : 	float b=0;
; 310  : 
; 311  : 	for ( i=0;i<4;i++)
; 312  : 	{
; 313  : 		a += ( p[i] - q[i] ) * ( p[i] - q[i] );

  00022	d9 c3		 fld	 ST(3)
  00024	de cc		 fmulp	 ST(4), ST(0)
  00026	d9 ee		 fldz
  00028	dc c4		 fadd	 ST(4), ST(0)
  0002a	d9 cc		 fxch	 ST(4)
  0002c	d9 5d 08	 fstp	 DWORD PTR tv1734[ebp]
  0002f	d9 45 08	 fld	 DWORD PTR tv1734[ebp]
  00032	d9 c3		 fld	 ST(3)
  00034	de cc		 fmulp	 ST(4), ST(0)
  00036	de c3		 faddp	 ST(3), ST(0)
  00038	d9 ca		 fxch	 ST(2)
  0003a	d9 5d 08	 fstp	 DWORD PTR tv1729[ebp]
  0003d	d9 c0		 fld	 ST(0)
  0003f	de c9		 fmulp	 ST(1), ST(0)
  00041	d8 45 08	 fadd	 DWORD PTR tv1729[ebp]
  00044	d9 5d 08	 fstp	 DWORD PTR tv1725[ebp]
  00047	d9 c0		 fld	 ST(0)
  00049	de c9		 fmulp	 ST(1), ST(0)
  0004b	d8 45 08	 fadd	 DWORD PTR tv1725[ebp]
  0004e	d9 5d 0c	 fstp	 DWORD PTR _a$[ebp]
  00051	d9 06		 fld	 DWORD PTR [esi]
  00053	d8 07		 fadd	 DWORD PTR [edi]
  00055	d9 46 04	 fld	 DWORD PTR [esi+4]
  00058	d8 47 04	 fadd	 DWORD PTR [edi+4]
  0005b	d9 46 08	 fld	 DWORD PTR [esi+8]
  0005e	d8 47 08	 fadd	 DWORD PTR [edi+8]
  00061	d9 46 0c	 fld	 DWORD PTR [esi+12]
  00064	d8 47 0c	 fadd	 DWORD PTR [edi+12]

; 314  : 		b += ( p[i] + q[i] ) * ( p[i] + q[i] );

  00067	d9 c3		 fld	 ST(3)
  00069	de cc		 fmulp	 ST(4), ST(0)
  0006b	d9 cb		 fxch	 ST(3)
  0006d	de c4		 faddp	 ST(4), ST(0)
  0006f	d9 cb		 fxch	 ST(3)
  00071	d9 5d 08	 fstp	 DWORD PTR tv1710[ebp]
  00074	d9 c0		 fld	 ST(0)
  00076	de c9		 fmulp	 ST(1), ST(0)
  00078	d8 45 08	 fadd	 DWORD PTR tv1710[ebp]
  0007b	d9 5d 08	 fstp	 DWORD PTR tv1706[ebp]
  0007e	d9 45 08	 fld	 DWORD PTR tv1706[ebp]
  00081	d9 c2		 fld	 ST(2)
  00083	de cb		 fmulp	 ST(3), ST(0)
  00085	de c2		 faddp	 ST(2), ST(0)
  00087	d9 c9		 fxch	 ST(1)
  00089	d9 5d 08	 fstp	 DWORD PTR tv1701[ebp]
  0008c	d9 c0		 fld	 ST(0)
  0008e	de c9		 fmulp	 ST(1), ST(0)
  00090	d8 45 08	 fadd	 DWORD PTR tv1701[ebp]
  00093	d9 5d 08	 fstp	 DWORD PTR _b$[ebp]

; 315  : 	}
; 316  : 
; 317  : 	if ( a > b )

  00096	d9 45 0c	 fld	 DWORD PTR _a$[ebp]
  00099	d9 45 08	 fld	 DWORD PTR _b$[ebp]
  0009c	de d9		 fcompp
  0009e	df e0		 fnstsw	 ax
  000a0	f6 c4 05	 test	 ah, 5
  000a3	7a 1e		 jp	 SHORT $LN57@Quaternion

; 318  : 	{
; 319  : 		for ( i=0;i<4;i++)
; 320  : 		{
; 321  : 			q[i] = -q[i];

  000a5	d9 07		 fld	 DWORD PTR [edi]
  000a7	d9 e0		 fchs
  000a9	d9 1f		 fstp	 DWORD PTR [edi]
  000ab	d9 47 04	 fld	 DWORD PTR [edi+4]
  000ae	d9 e0		 fchs
  000b0	d9 5f 04	 fstp	 DWORD PTR [edi+4]
  000b3	d9 47 08	 fld	 DWORD PTR [edi+8]
  000b6	d9 e0		 fchs
  000b8	d9 5f 08	 fstp	 DWORD PTR [edi+8]
  000bb	d9 47 0c	 fld	 DWORD PTR [edi+12]
  000be	d9 e0		 fchs
  000c0	d9 5f 0c	 fstp	 DWORD PTR [edi+12]
$LN57@Quaternion:

; 322  : 		}
; 323  : 	}
; 324  : 
; 325  : 	cosom = p[0] * q[0] + p[1] * q[1] + p[2] * q[2] + p[3] * q[3];

  000c3	d9 46 04	 fld	 DWORD PTR [esi+4]
  000c6	d8 4f 04	 fmul	 DWORD PTR [edi+4]
  000c9	d9 06		 fld	 DWORD PTR [esi]
  000cb	d8 0f		 fmul	 DWORD PTR [edi]
  000cd	de c1		 faddp	 ST(1), ST(0)
  000cf	d9 46 08	 fld	 DWORD PTR [esi+8]
  000d2	d8 4f 08	 fmul	 DWORD PTR [edi+8]
  000d5	de c1		 faddp	 ST(1), ST(0)
  000d7	d9 46 0c	 fld	 DWORD PTR [esi+12]
  000da	d8 4f 0c	 fmul	 DWORD PTR [edi+12]
  000dd	de c1		 faddp	 ST(1), ST(0)
  000df	d9 5d 08	 fstp	 DWORD PTR _cosom$[ebp]

; 326  : 
; 327  : 	if ( ( (double)1 + cosom) > 1 )

  000e2	d9 45 08	 fld	 DWORD PTR _cosom$[ebp]
  000e5	d9 c0		 fld	 ST(0)
  000e7	d9 e8		 fld1
  000e9	dc c1		 fadd	 ST(1), ST(0)
  000eb	d8 d1		 fcom	 ST(1)
  000ed	df e0		 fnstsw	 ax
  000ef	dd d9		 fstp	 ST(1)
  000f1	f6 c4 05	 test	 ah, 5
  000f4	0f 8a cc 00 00
	00		 jp	 $LN72@Quaternion

; 328  : 	{
; 329  : 		if ( (1 - cosom ) > -1 )

  000fa	d9 c1		 fld	 ST(1)
  000fc	d8 e9		 fsubr	 ST(0), ST(1)
  000fe	dc 1d 00 00 00
	00		 fcomp	 QWORD PTR __real@bff0000000000000
  00104	df e0		 fnstsw	 ax
  00106	f6 c4 41	 test	 ah, 65			; 00000041H
  00109	75 5e		 jne	 SHORT $LN75@Quaternion
  0010b	dd d8		 fstp	 ST(0)

; 330  : 		{
; 331  : 			omega = acos(cosom);

  0010d	e8 00 00 00 00	 call	 __CIacos
  00112	d9 5d 08	 fstp	 DWORD PTR tv1673[ebp]
  00115	d9 45 08	 fld	 DWORD PTR tv1673[ebp]
  00118	d9 5d 0c	 fstp	 DWORD PTR _omega$[ebp]

; 332  : 			sinom = sin(omega);

  0011b	d9 45 0c	 fld	 DWORD PTR _omega$[ebp]
  0011e	e8 00 00 00 00	 call	 __CIsin
  00123	d9 5d 08	 fstp	 DWORD PTR tv1666[ebp]
  00126	d9 45 08	 fld	 DWORD PTR tv1666[ebp]
  00129	d9 5d fc	 fstp	 DWORD PTR _sinom$[ebp]

; 333  : 			sclp = sin((1 - t) * omega) / sinom;

  0012c	d9 45 10	 fld	 DWORD PTR _t$[ebp]
  0012f	d9 e8		 fld1
  00131	de e1		 fsubrp	 ST(1), ST(0)
  00133	d8 4d 0c	 fmul	 DWORD PTR _omega$[ebp]
  00136	d9 5d 08	 fstp	 DWORD PTR tv1661[ebp]
  00139	d9 45 08	 fld	 DWORD PTR tv1661[ebp]
  0013c	e8 00 00 00 00	 call	 __CIsin
  00141	d9 5d 08	 fstp	 DWORD PTR tv1655[ebp]
  00144	d9 45 08	 fld	 DWORD PTR tv1655[ebp]
  00147	d8 75 fc	 fdiv	 DWORD PTR _sinom$[ebp]
  0014a	d9 5d 08	 fstp	 DWORD PTR _sclp$[ebp]

; 334  : 			sclq = sin(t * omega) / sinom;

  0014d	d9 45 0c	 fld	 DWORD PTR _omega$[ebp]
  00150	d8 4d 10	 fmul	 DWORD PTR _t$[ebp]
  00153	d9 5d 0c	 fstp	 DWORD PTR tv1649[ebp]
  00156	d9 45 0c	 fld	 DWORD PTR tv1649[ebp]
  00159	e8 00 00 00 00	 call	 __CIsin
  0015e	d9 5d 0c	 fstp	 DWORD PTR tv1643[ebp]
  00161	d9 45 0c	 fld	 DWORD PTR tv1643[ebp]
  00164	d8 75 fc	 fdiv	 DWORD PTR _sinom$[ebp]

; 335  : 		}
; 336  : 		else

  00167	eb 0e		 jmp	 SHORT $LN77@Quaternion
$LN75@Quaternion:

; 328  : 	{
; 329  : 		if ( (1 - cosom ) > -1 )

  00169	dd d9		 fstp	 ST(1)

; 337  : 		{
; 338  : 			sclp = 1 - t;

  0016b	d9 45 10	 fld	 DWORD PTR _t$[ebp]
  0016e	d9 c0		 fld	 ST(0)
  00170	de ea		 fsubp	 ST(2), ST(0)
  00172	d9 c9		 fxch	 ST(1)
  00174	d9 5d 08	 fstp	 DWORD PTR _sclp$[ebp]
$LN77@Quaternion:

; 339  : 			sclq = t;

  00177	d9 5d 0c	 fstp	 DWORD PTR _sclq$[ebp]

; 340  : 		}
; 341  : 
; 342  : 		for ( i=0;i<4;i++)
; 343  : 		{
; 344  : 			qt[i] = sclp * p[i] + sclq * q[i];

  0017a	8b 45 14	 mov	 eax, DWORD PTR _qt$[ebp]
  0017d	d9 06		 fld	 DWORD PTR [esi]
  0017f	d9 45 08	 fld	 DWORD PTR _sclp$[ebp]
  00182	d9 c0		 fld	 ST(0)
  00184	de ca		 fmulp	 ST(2), ST(0)
  00186	d9 07		 fld	 DWORD PTR [edi]
  00188	d9 45 0c	 fld	 DWORD PTR _sclq$[ebp]
  0018b	d9 c0		 fld	 ST(0)
  0018d	de ca		 fmulp	 ST(2), ST(0)
  0018f	d9 cb		 fxch	 ST(3)
  00191	de c1		 faddp	 ST(1), ST(0)
  00193	d9 18		 fstp	 DWORD PTR [eax]
  00195	d9 47 04	 fld	 DWORD PTR [edi+4]
  00198	d8 ca		 fmul	 ST(0), ST(2)
  0019a	d9 46 04	 fld	 DWORD PTR [esi+4]
  0019d	d8 ca		 fmul	 ST(0), ST(2)
  0019f	de c1		 faddp	 ST(1), ST(0)
  001a1	d9 58 04	 fstp	 DWORD PTR [eax+4]
  001a4	d9 47 08	 fld	 DWORD PTR [edi+8]
  001a7	d8 ca		 fmul	 ST(0), ST(2)
  001a9	d9 46 08	 fld	 DWORD PTR [esi+8]
  001ac	d8 ca		 fmul	 ST(0), ST(2)
  001ae	de c1		 faddp	 ST(1), ST(0)
  001b0	d9 58 08	 fstp	 DWORD PTR [eax+8]
  001b3	d9 47 0c	 fld	 DWORD PTR [edi+12]
  001b6	5f		 pop	 edi
  001b7	de ca		 fmulp	 ST(2), ST(0)
  001b9	d8 4e 0c	 fmul	 DWORD PTR [esi+12]
  001bc	5e		 pop	 esi
  001bd	de c1		 faddp	 ST(1), ST(0)
  001bf	d9 58 0c	 fstp	 DWORD PTR [eax+12]

; 359  : 		}
; 360  : 	}
; 361  : }

  001c2	8b e5		 mov	 esp, ebp
  001c4	5d		 pop	 ebp
  001c5	c3		 ret	 0
$LN72@Quaternion:

; 326  : 
; 327  : 	if ( ( (double)1 + cosom) > 1 )

  001c6	dd d9		 fstp	 ST(1)
  001c8	53		 push	 ebx

; 345  : 		}
; 346  : 	}
; 347  : 	else
; 348  : 	{
; 349  : 		qt[0] = -p[1];

  001c9	d9 46 04	 fld	 DWORD PTR [esi+4]
  001cc	8b 5d 14	 mov	 ebx, DWORD PTR _qt$[ebp]
  001cf	d9 e0		 fchs
  001d1	d9 1b		 fstp	 DWORD PTR [ebx]

; 350  : 		qt[1] = p[0];

  001d3	d9 06		 fld	 DWORD PTR [esi]
  001d5	d9 5b 04	 fstp	 DWORD PTR [ebx+4]

; 351  : 		qt[2] = -p[3];

  001d8	d9 46 0c	 fld	 DWORD PTR [esi+12]
  001db	d9 e0		 fchs
  001dd	d9 5b 08	 fstp	 DWORD PTR [ebx+8]

; 352  : 		qt[3] = p[2];

  001e0	d9 46 08	 fld	 DWORD PTR [esi+8]
  001e3	d9 5b 0c	 fstp	 DWORD PTR [ebx+12]

; 353  : 		sclp = sin(( 1.0f - t ) * 0.5f * M_PI);

  001e6	d8 65 10	 fsub	 DWORD PTR _t$[ebp]
  001e9	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@3fe0000000000000
  001ef	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@400921fb60000000
  001f5	d9 5d 08	 fstp	 DWORD PTR tv1625[ebp]
  001f8	d9 45 08	 fld	 DWORD PTR tv1625[ebp]
  001fb	e8 00 00 00 00	 call	 __CIsin
  00200	d9 5d 08	 fstp	 DWORD PTR tv1618[ebp]
  00203	d9 45 08	 fld	 DWORD PTR tv1618[ebp]
  00206	d9 5d 08	 fstp	 DWORD PTR _sclp$[ebp]

; 354  : 		sclq = sin( t * 0.5f * M_PI );

  00209	d9 45 10	 fld	 DWORD PTR _t$[ebp]
  0020c	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@3fe0000000000000
  00212	dc 0d 00 00 00
	00		 fmul	 QWORD PTR __real@400921fb60000000
  00218	d9 5d 0c	 fstp	 DWORD PTR tv1615[ebp]
  0021b	d9 45 0c	 fld	 DWORD PTR tv1615[ebp]
  0021e	e8 00 00 00 00	 call	 __CIsin
  00223	d9 5d 0c	 fstp	 DWORD PTR tv1609[ebp]
  00226	d9 45 0c	 fld	 DWORD PTR tv1609[ebp]
  00229	d9 5d 0c	 fstp	 DWORD PTR _sclq$[ebp]

; 355  : 
; 356  : 		for ( i=0;i<3;i++)
; 357  : 		{
; 358  : 			qt[i] = sclp * p[i] + sclq * q[i];

  0022c	d9 06		 fld	 DWORD PTR [esi]
  0022e	d9 45 08	 fld	 DWORD PTR _sclp$[ebp]
  00231	d9 c0		 fld	 ST(0)
  00233	de ca		 fmulp	 ST(2), ST(0)
  00235	d9 07		 fld	 DWORD PTR [edi]
  00237	d9 45 0c	 fld	 DWORD PTR _sclq$[ebp]
  0023a	d9 c0		 fld	 ST(0)
  0023c	de ca		 fmulp	 ST(2), ST(0)
  0023e	d9 cb		 fxch	 ST(3)
  00240	de c1		 faddp	 ST(1), ST(0)
  00242	d9 1b		 fstp	 DWORD PTR [ebx]
  00244	d9 47 04	 fld	 DWORD PTR [edi+4]
  00247	d8 ca		 fmul	 ST(0), ST(2)
  00249	d9 46 04	 fld	 DWORD PTR [esi+4]
  0024c	d8 ca		 fmul	 ST(0), ST(2)
  0024e	de c1		 faddp	 ST(1), ST(0)
  00250	d9 5b 04	 fstp	 DWORD PTR [ebx+4]
  00253	d9 47 08	 fld	 DWORD PTR [edi+8]
  00256	de ca		 fmulp	 ST(2), ST(0)
  00258	d8 4e 08	 fmul	 DWORD PTR [esi+8]
  0025b	de c1		 faddp	 ST(1), ST(0)
  0025d	d9 5b 08	 fstp	 DWORD PTR [ebx+8]
  00260	5b		 pop	 ebx
  00261	5f		 pop	 edi
  00262	5e		 pop	 esi

; 359  : 		}
; 360  : 	}
; 361  : }

  00263	8b e5		 mov	 esp, ebp
  00265	5d		 pop	 ebp
  00266	c3		 ret	 0
?QuaternionSlerp@@YAXPBMPAMM1@Z ENDP			; QuaternionSlerp
_TEXT	ENDS
PUBLIC	?FaceNormalize@@YAXPAM000@Z			; FaceNormalize
; Function compile flags: /Ogtp
;	COMDAT ?FaceNormalize@@YAXPAM000@Z
_TEXT	SEGMENT
_v1$ = 8						; size = 4
_v2$ = 12						; size = 4
_v3$ = 16						; size = 4
_Normal$ = 20						; size = 4
?FaceNormalize@@YAXPAM000@Z PROC			; FaceNormalize, COMDAT

; 367  : 	float nx = ( v2[1] - v1[1] ) * ( v3[2] - v1[2] ) - ( v3[1] - v1[1] ) * ( v2[2] - v1[2] );
; 368  : 	float ny = ( v2[1] - v1[1] ) * ( v3[2] - v1[2] ) - ( v3[1] - v1[1] ) * ( v2[2] - v1[2] );
; 369  : 	float nz = ( v2[1] - v1[1] ) * ( v3[2] - v1[2] ) - ( v3[1] - v1[1] ) * ( v2[2] - v1[2] );
; 370  : 	double dot = sqrt( nx * nx + ny * ny + nz * nz );
; 371  : }

  00000	c3		 ret	 0
?FaceNormalize@@YAXPAM000@Z ENDP			; FaceNormalize
_TEXT	ENDS
END
